//
// Copyright (c) 2017, 2021 Contributors to the Eclipse Foundation
//

== Container and Provider Contracts for Deployment and Bootstrapping

This chapter defines requirements on the Jakarta EE container and on
the persistence provider for deployment and bootstrapping.

=== Jakarta EE Deployment [[a12802]]

Each persistence unit deployed into a Jakarta EE
container consists of a single `persistence.xml` file, any number of
mapping files, and any number of class files.

At deployment time the container is
responsible for scanning the locations specified in <<a12236>> and
discovering the `persistence.xml` files and processing them.

When the container finds a `persistence.xml`
file, it must process the persistence unit definitions that it contains.
The container must validate the `persistence.xml` file against the
`persistence_3_0.xsd` or `persistence_2_2.xsd` schema in accordance with
the version specified by the `persistence.xml` file and report any validation errors.
Provider or data source information not specified in the `persistence.xml` file
must be provided at deployment time or defaulted by the container. The
container may optionally add any container-specific properties to be
passed to the provider when creating the entity manager factory for the
persistence unit.

Once the container has read the persistence
metadata, it determines the `jakarta.persistence.spi.PersistenceProvider`
implementation class for each deployed named persistence unit. The
container then creates an instance of the `PersistenceProvider`
implementation class for each deployed named persistence unit and
invokes the `createContainerEntityManagerFactory` method on that
instance.

* The container must implement the
`PersistenceUnitInfo` interface described in <<a13160>> and pass the
metadata—in the form of a `PersistenceUnitInfo` instance—to the
persistence provider as part of this call.
* If a Bean Validation provider exists in the
container environment and the `validation-mode` `NONE` is not specified,
a `ValidatorFactory` instance must be made available by the container.
The container is responsible for passing this `ValidatorFactory`
instance via the map that is passed as an argument to the
`createContainerEntityManagerFactory` call. The map key used must be the
standard property name `jakarta.persistence.validation.factory`.
* If CDI is enabled, a `BeanManager` instance
must be made available by the container. The container is responsible
for passing this `BeanManager` instance via the map that is passed as an
argument to the `createContainerEntityManagerFactory` call. The map key
used must be the standard property name `jakarta.persistence.bean.manager`.

The `EntityManagerFactory` instance obtained
as a result will be used by the container to create container-managed
entity managers. Only one EntityManagerFactory is permitted to be
created for each deployed persistence unit configuration. Any number of
EntityManager instances may be created from a given factory.

In a Jakarta EE environment, the classes of the
persistence unit should not be loaded by the application class loader or
any of its parent class loaders until after the entity manager factory
for the persistence unit has been created.

When a persistence unit is redeployed, the
container should call the `close` method on the previous
`EntityManagerFactory` instance and call the
`createContainerEntityManagerFactory` method again, with the required
`PersistenceUnitInfo` metadata, to achieve the redeployment.

=== Bootstrapping in Java SE Environments

In Java SE environments, the
`Persistence.createEntityManagerFactory` method is used by the
application to create an entity manager factoryfootnote:[Use of these Java SE
bootstrapping APIs may be supported in Jakarta EE containers; however,
support for such use is not required.].

A persistence provider implementation running
in a Java SE environment should also act as a service provider by
supplying a service provider configuration file as defined by the Java
SE platform.

The provider configuration file serves to
export the provider implementation class to the `Persistence` bootstrap
class, positioning the provider as a candidate for backing named
persistence units. The provider supplies the provider configuration file
by creating a text file named
`jakarta.persistence.spi.PersistenceProvider` and placing it in the
`META-INF/services` directory of one of its JAR files. The contents of
the file should be the name of the provider implementation class of the
`jakarta.persistence.spi.PersistenceProvider` interface.

*Example:*

A persistence vendor called ACME persistence
products ships a JAR called `acme.jar` that contains its persistence
provider implementation. The JAR includes the provider configuration
file.

----
acme.jar
    META-INF/services/jakarta.persistence.spi.PersistenceProvider
    com.acme.PersistenceProvider
    ...
----

The contents of the
`META-INF/services/jakarta.persistence.spi.PersistenceProvider` file is
nothing more than the name of the implementation class:
`com.acme.PersistenceProvider`.

Persistence provider jars may be installed or
made available in the same ways as other service providers, e.g. as
extensions or added to the application classpath.

The `Persistence` bootstrap class must locate
all of the persistence providers using the `PersistenceProviderResolver`
mechanism described in <<a12837>> and call
`createEntityManagerFactory` on them in turn until an appropriate
backing provider returns an `EntityManagerFactory` instance. A provider
may deem itself as appropriate for the persistence unit if any of the
following are true:

* Its implementation class has been specified
in the `provider` element for that persistence unit in the
`persistence.xml` file and has not been overridden by a different
`jakarta.persistence.provider` property value included in the Map passed
to the `createEntityManagerFactory` method.
* The `jakarta.persistence.provider` property was
included in the Map passed to `createEntityManagerFactory` and the value
of the property is the provider's implementation class.
* No provider was specified for the persistence
unit in either the `persistence.xml` or the property map.

If a provider does not qualify as the
provider for the named persistence unit, it must return `null` when
`createEntityManagerFactory` is invoked on it.

==== Schema Generation [[a12803]]

In Java SE environments, the
`Persistence.generateSchema` method may be used by the application to
cause schema generation to occur as a separate phase from entity manager
factory creation.

In this case, the `Persistence` bootstrap
class must locate all of the persistence providers using the
`PersistenceProviderResolver` mechanism described in <<a12837>>
and call `generateSchema` on them in turn until an
appropriate backing provider returns `true`. A provider may deem itself
as appropriate for the persistence unit if any of the following are
true:

* Its implementation class has been specified
in the `provider` element for that persistence unit in the
`persistence.xml` file and has not been overridden by a different
`jakarta.persistence.provider` property value included in the Map passed
to the `generateSchema` method.
* The `jakarta.persistence.provider` property was
included in the Map passed to `generateSchema` and the value of the
property is the provider's implementation class.
* No provider was specified for the persistence
unit in either the `persistence.xml` or the property map.

If a provider does not qualify as the
provider for the named persistence unit, it must return `false` when
`generateSchema` is invoked on it.

=== Determining the Available Persistence Providers [[a12837]]

The `PersistenceProviderResolver` and
`PersistenceProviderResolverHolder` mechanism supports the dynamic
discovery of persistence providers.footnote:[In dynamic
environments (e.g., OSGi-based environments, containers based on dynamic
kernels, etc.), the list of persistence providers may change.]

The `PersistenceProviderResolver` instance is
responsible for returning the list of providers available in the
environment.

The `PersistenceProviderResolverHolder` class
holds the `PersistenceProviderResolver` instance that is in use. The
implementation of `PersistenceProviderResolverHolder` must be
threadsafe, but no guarantee is made against multiple threads setting
the resolver.

The container is allowed to implement
and set a specific `PersistenceProviderResolver` provided that it
respects the `PersistenceProviderResolver` contract. The
`PersistenceProviderResolver` instance to be used is set by the
container using the
`PersistenceProviderResolverHolder.setPersistenceProviderResolver`
method.footnote:[If a custom
PersistenceProviderResolver is needed in a JavaSE environment, it must
be set before Persistence.createEntityManagerFactory is called. Note,
however, that the setPersistenceProviderResolver method is not intended
for general use, but rather is aimed at containers maintaining a dynamic
environment.]

If no `PersistenceProviderResolver` is set,
the `PersistenceProviderResolverHolder` must return a
`PersistenceProviderResolver` that returns the providers whose
persistence provider jars have been installed or made available as
service providers or extensions. This default
`PersistenceProviderResolver` instance does not guarantee the order in
which persistence providers are returned.

A `PersistenceProviderResolver` must be threadsafe.

The
`PersistenceProviderResolver.getPersistenceProviders()` method must be
used to determine the list of available persistence providers.

The results of calling the
`PersistenceProviderResolverHolder.getPersistenceProviderResolver` and
the `PersistenceProviderResolver.getPersistenceProviders` methods must
not be cached. In particular, the following methods must use the
`PersistenceProviderResolver` instance returned by the
`PersistenceProviderResolverHolder.getPersistenceProviderResolver`
method to determine the list of available providers:


* `Persistence.createEntityManagerFactory(String)`
* `Persistence.createEntityManagerFactory(String, Map)`
* `PersistenceUtil.isLoaded(Object)`
* `PersistenceUtil.isLoaded(Object, String)`

These methods must not cache the list of
providers and must not cache the `PersistenceProviderResolver` instance.

[NOTE]
====
Note that the
`PersistenceProviderResolver.getPersistenceProviders()` method can
potentially be called many times. It is therefore recommended that the
implementation of this method make use of caching.
====

Note that only a single
`PersistenceProviderResolver` instance can be defined in a given
classloader hierarchy at a given time.

==== PersistenceProviderResolver interface

[source,java]
----
package jakarta.persistence.spi;

import java.util.List;

/**
 * Determine the list of persistence providers available in the
 * runtime environment.
 *
 * <p> Implementations must be thread-safe.
 *
 * <p> Note that the <code>getPersistenceProviders</code> method can potentially
 * be called many times: it is recommended that the implementation
 * of this method make use of caching.
 *
 * @see PersistenceProvider
 * @since 2.0
 */
public interface PersistenceProviderResolver {

    /**
     * Returns a list of the <code>PersistenceProvider</code> implementations
     * available in the runtime environment.
     *
     * @return list of the persistence providers available
     *         in the environment
     */
    List<PersistenceProvider> getPersistenceProviders();

    /**
     * Clear cache of providers.
     *
     */
    void clearCachedProviders();
}
----

==== PersistenceProviderResolverHolder class

[source,java]
----
package jakarta.persistence.spi;

import java.util.List;

/**
 * Holds the global {@link PersistenceProviderResolver}
 * instance. If no <code>PersistenceProviderResolver</code> is set by the
 * environment, the default <code>PersistenceProviderResolver</code> is used.
 * Enable "jakarta.persistence.spi" logger to show diagnostic information.
 *
 * Implementations must be thread-safe.
 *
 * @since 2.0
 */
public class PersistenceProviderResolverHolder {

    private static PersistenceProviderResolver singleton = new DefaultPersistenceProviderResolver();

    /**
     * Returns the current persistence provider resolver.
     *
     * @return the current persistence provider resolver
     */
    public static PersistenceProviderResolver getPersistenceProviderResolver() {
        return singleton;
    }

    /**
     * Defines the persistence provider resolver used.
     *
     * @param resolver persistence provider resolver to be used.
     */
    public static void setPersistenceProviderResolver(PersistenceProviderResolver resolver) {
        if (resolver == null) {
            singleton = new DefaultPersistenceProviderResolver();
        } else {
            singleton = resolver;
        }
    }

}
----

=== Schema Generation [[a12917]]

In cases where a preconfigured database (or a
“legacy” database) is not used or is not available, the Jakarta Persistence
schema generation facility may be used to generate the tables and other
database artifacts required by the persistence application. Whether
schema generation entails the creation of schemas proper in the database
is determined by the environment and the configuration of the schema
generation process, as described below.

Schema generation may happen either prior to
application deployment or when the entity manager factory is created as
part of the application deployment and initialization process.

* In Jakarta EE environments, the container may
call the `PersistenceProvider` `generateSchema` method separately from
and/or prior to the creation of the entity manager factory for the
persistence unit, or the container may pass additional information to
the `createContainerEntityManagerFactory` call to cause schema
generation to happen as part of the entity manager factory creation and
application initialization process. The information passed to these
methods controls whether the generation occurs directly in the target
database, whether DDL scripts for schema generation are created, or
both.
* In Java SE environments, the application may
call the `Persistence` `generateSchema` method separately from and/or
prior to the creation of the entity manager factory or may pass
information to the `createEntityManagerFactory` method to cause schema
generation to occur as part of the entity manager factory creation.

The application may provide DDL scripts to be
used for schema generation as described in <<a12384>>. The application developer
may package these scripts as part of the persistence unit or may specify
strings corresponding to file URLs for the location of such scripts. In
Jakarta EE environments, such scripts may be executed by the container, or
the container may direct the persistence provider to execute the
scripts. In Java SE environments, the execution of the scripts is the
responsibility of the persistence provider. In the absence of the
specification of scripts, schema generation, if requested, will be
determined by the object/relational metadata of the persistence unit.

The following standard properties are defined
for configuring the schema generation process. In Jakarta EE environments
these properties are passed by the container in the `Map` argument to
either the `PersistenceProvider` `generateSchema` method or the
`createContainerEntityManagerFactory` method. In Java SE environments,
they are passed in the `Map` argument to either the `Persistence`
`generateSchema` method or `createEntityManagerFactory` method.

In Jakarta EE environments, any strings
corresponding to file URLs for script sources or targets must specify
absolute paths (not relative). In Jakarta EE environments, all source and
target file locations must be accessible to the application server
deploying the persistence unit

`jakarta.persistence.schema-generation.database.action` ::
The `jakarta.persistence.schema-generation.database.action` property specifies
the action to be taken by the persistence provider with regard to the
database artifacts. The values for this property are _"none"_,
_"create"_, _"drop-and-create"_, _"drop"_, _"validate"_. If the
`jakarta.persistence.schema-generation.database.action` property is not
specified, no schema generation actions must be taken on the database.
`jakarta.persistence.schema-generation.scripts.action` ::
The `jakarta.persistence.schema-generation.scripts.action` property specifies
which scripts are to be generated by the persistence provider. The
values for this property are _"none"_, _"create"_, _"drop-and-create"_
, _"drop"_. A script will only be generated if the script target is
specified. If this property is not specified, no scripts will be
generated.
`jakarta.persistence.schema-generation.create-source` ::
The `jakarta.persistence.schema-generation.create-source` property specifies
whether the creation of database artifacts is to occur on the basis of
the object/relational mapping metadata, DDL script, or a combination of
the two. The values for this property are _"metadata"_, _"script"_,
_"metadata-then-script"_, _"script-then-metadata"_. If this property
is not specified, and a script is specified by the
`jakarta.persistence.schema-generation.create-script-source` property, the
script (only) will be used for schema generation; otherwise if this
property is not specified, schema generation will occur on the basis of
the object/relational mapping metadata (only). The
_"metadata-then-script"_ and _"script-then-metadata"_ values specify
that a combination of metadata and script is to be used and the order in
which this use is to occur. If either of these values is specified and
the resulting database actions are not disjoint, the results are
undefined and schema generation may fail.
`jakarta.persistence.schema-generation.drop-source` ::
The `jakarta.persistence.schema-generation.drop-source` property specifies
whether the dropping of database artifacts is to occur on the basis of
the object/relational mapping metadata, DDL script, or a combination of
the two. The values for this property are _"metadata"_, _"script"_,
_"metadata-then-script"_, _"script-then-metadata"_. If this property
is not specified, and a script is specified by the
`jakarta.persistence.schema-generation.drop-script-source` property, the
script (only) will be used for the dropping of database artifacts;
otherwise if this property is not specified, the dropping of database
artifacts will occur on the basis of the object/relational mapping
metadata (only). The _"metadata-then-script"_ and
_"script-then-metadata"_ values specify that a combination of metadata
and script is to be used and the order in which this use is to occur. If
either of these values is specified and the resulting database actions
are not disjoint, the results are undefined and the dropping of database
artifacts may fail.
`jakarta.persistence.schema-generation.create-database-schemas` ::
In Jakarta EE environments, it is anticipated
that the Jakarta EE platform provider may wish to control the creation of
database schemas rather than delegate this task to the persistence
provider. The
`jakarta.persistence.schema-generation.create-database-schemas` property
specifies whether the persistence provider is to create the database
schema(s) in addition to creating database objects such as tables,
sequences, constraints, etc. The value of this boolean property should
be set to true if the persistence provider is to create schemas in the
database or to generate DDL that contains “CREATE SCHEMA” commands. If
this property is not supplied, the provider should not attempt to create
database schemas. This property may also be specified in Java SE
environments.
`jakarta.persistence.schema-generation.scripts.create-target`, +
`jakarta.persistence.schema-generation.scripts.drop-target` ::
If scripts are to be generated, the target
locations for the writing of these scripts must be specified. +
The `jakarta.persistence.schema-generation.scripts.create-target` property
specifies a `java.io.Writer` configured for use by the persistence
provider for output of the DDL script or a string specifying the file
URL for the DDL script. This property should only be specified if
scripts are to be generated. +
The `jakarta.persistence.schema-generation.scripts.drop-target` property
specifies a `java.io.Writer` configured for use by the persistence
provider for output of the DDL script or a string specifying the file
URL for the DDL script. This property should only be specified if
scripts are to be generated.
`jakarta.persistence.database-product-name`, ::
`jakarta.persistence.database-major-version`, ::
`jakarta.persistence.database-minor-version` ::
If scripts are to be generated by the
persistence provider and a connection to the target database is not
supplied, the `jakarta.persistence.database-product-name` property must be
specified. The value of this property should be the value returned for
the target database by the JDBC `DatabaseMetaData` method
`getDatabaseProductName`. If sufficient database version information is
not included in the result of this method, the
`jakarta.persistence.database-major-version` and
`jakarta.persistence.database-minor-version` properties should be
specified as needed. These should contain the values returned by the
JDBC `getDatabaseMajorVersion` and `getDatabaseMinorVersion` methods
respectively.
`jakarta.persistence.schema-generation.create-script-source`, +
`jakarta.persistence.schema-generation.drop-script-source` ::
The `jakarta.persistence.schema-generation.create-script-source` and
`jakarta.persistence.schema-generation.drop-script-source` properties are
used for script execution. In Jakarta EE container environments, it is
generally expected that the container will be responsible for executing
DDL scripts, although the container is permitted to delegate this task
to the persistence provider. If DDL scripts are to be used in Java SE
environments or if the Jakarta EE container delegates the execution of
scripts to the persistence provider, these properties must be specified. +
The
`jakarta.persistence.schema-generation.create-script-source` property
specifies a `java.io.Reader` configured for reading of the DDL script or
a string designating a file URL for the DDL script. +
The
`jakarta.persistence.schema-generation.drop-script-source` property
specifies a `java.io.Reader` configured for reading of the DDL script or
a string designating a file URL for the DDL script.
`jakarta.persistence.schema-generation.connection` ::
The `jakarta.persistence.schema-generation.connection` property specifies the
JDBC connection to be used for schema generation. This is intended for
use in Jakarta EE environments, where the platform provider may want to
control the database privileges that are available to the persistence
provider. This connection is provided by the container, and should be
closed by the container when the schema generation request or entity
manager factory creation completes. The connection provided must have
credentials sufficient for the persistence provider to carry out the
requested actions. If this property is not specified, the persistence
provider should use the DataSource that has otherwise been provided.

==== Data Loading

Data loading, by means of the use of SQL
scripts, may occur as part of the schema generation process after the
creation of the database artifacts or independently of schema
generation. The specification of the
`jakarta.persistence.sql-load-script-source` controls whether data loading
will occur.

`jakarta.persistence.sql-load-script-source` ::
In Jakarta EE container environments, it is
generally expected that the container will be responsible for executing
data load scripts, although the container is permitted to delegate this
task to the persistence provider. If a load script is to be used in Java
SE environments or if the Jakarta EE container delegates the execution of
the load script to the persistence provider, this property must be
specified. + The
`jakarta.persistence.sql-load-script-source` property specifies a
`java.io.Reader` configured for reading of the SQL load script for
database initialization or a string designating a file URL for the
script.

=== Responsibilities of the Persistence Provider

The persistence provider must implement the
`PersistenceProvider` SPI.

In Jakarta EE environments, the persistence
provider must process the metadata that is passed to it at the time
`createContainerEntityManagerFactory` method is called and create an
instance of `EntityManagerFactory` using the `PersistenceUnitInfo`
metadata for the factory. The factory is then returned to the container.

In Java SE environments, the persistence
provider must validate the `persistence.xml` file against the
`persistence` schema that corresponds to the version specified by the
`persistence.xml` file and report any validation errors.

The persistence provider processes the
metadata annotations on the managed classes of the persistence unit.

When the entity manager factory for a
persistence unit is created, it is the responsibility of the persistence
provider to initialize the state of the metamodel classes of the
persistence unit.

When the persistence provider obtains an
object/relational mapping file, it processes the definitions that it
contains. The persistence provider must validate any object/relational
mapping files against the object/relational mapping schema version
specified by the object/relational mapping file and report any
validation errors. The object relational mapping file must specify the
object/relational mapping schema that it is written against by
indicating the `version` element.

In Java SE environments, the application can
pass the `ValidatorFactory` instance via the map that is passed as an
argument to the `Persistence.createEntityManagerFactory` call. The map
key used must be the standard property name
`jakarta.persistence.validation.factory`. If no `ValidatorFactory`
instance is provided by the application, and if a Bean Validation
provider is present in the classpath, the persistence provider must
instantiate the `ValidatorFactory` using the default bootstrapping
approach as defined by the Bean Validation specification
<<a19498>>, namely
`Validation.buildDefaultValidatorFactory()`.

==== jakarta.persistence.spi.PersistenceProvider

The interface
`jakarta.persistence.spi.PersistenceProvider` must be implemented by the
persistence provider.

It is invoked by the container in Jakarta EE
environments and by the `jakarta.persistence.Persistence` class in Java SE
environments. The `jakarta.persistence.spi.PersistenceProvider`
implementation is not intended to be used by the application.

The `PersistenceProvider` implementation
class must have a public no-arg constructor.

[source,java]
----
package jakarta.persistence.spi;

import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;
import jakarta.persistence.PersistenceException;
import java.util.Map;

/**
 * Interface implemented by the persistence provider.
 *
 * <p> It is invoked by the container in Jakarta EE environments and
 * by the {@link Persistence} class in Java SE environments to
 * create an {@link EntityManagerFactory} and/or to cause
 * schema generation to occur.
 *
 * @since 1.0
 */
public interface PersistenceProvider {

    /**
     * Called by <code>Persistence</code> class when an
     * <code>EntityManagerFactory</code> is to be created.
     *
     * @param emName  the name of the persistence unit
     * @param map  a Map of properties for use by the
     * persistence provider. These properties may be used to
     * override the values of the corresponding elements in
     * the <code>persistence.xml</code> file or specify values for
     * properties not specified in the <code>persistence.xml</code>
     * (and may be null if no properties are specified).
     * @return EntityManagerFactory for the persistence unit,
     * or null if the provider is not the right provider
     */
    public EntityManagerFactory createEntityManagerFactory(String emName, Map map);

    /**
     * Called by <code>Persistence</code> class when an
     * <code>EntityManagerFactory</code> is to be created.
     *
     * @param configuration  the configuration of the persistence unit
     * @return EntityManagerFactory for the persistence unit,
     * or null if the provider is not the right provider
     * @throws IllegalStateException if required configuration is missing
     *
     * @see Persistence#createEntityManagerFactory(PersistenceConfiguration)
     *
     * @since 3.2
     */
    public EntityManagerFactory createEntityManagerFactory(PersistenceConfiguration configuration);

    /**
     * Called by the container when an <code>EntityManagerFactory</code>
     * is to be created.
     *
     * @param info  metadata for use by the persistence provider
     * @param map  a Map of integration-level properties for use
     * by the persistence provider (may be null if no properties
     * are specified).  These properties may include properties to
     * control schema generation.
     * If a Bean Validation provider is present in the classpath,
     * the container must pass the <code>ValidatorFactory</code> instance in
     * the map with the key <code>"jakarta.persistence.validation.factory"</code>.
     * If the containing archive is a bean archive, the container
     * must pass the BeanManager instance in the map with the key
     * <code>"jakarta.persistence.bean.manager"</code>.
     * @return EntityManagerFactory for the persistence unit
     * specified by the metadata
     */
    public EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map map);


    /**
     * Create database schemas and/or tables and/or create DDL
     * scripts as determined by the supplied properties.
     * <p>
     * Called by the container when schema generation is to
     * occur as a separate phase from creation of the entity
     * manager factory.
     * <p>
     * @param info metadata for use by the persistence provider
     * @param map properties for schema generation;  these may
     *             also include provider-specific properties
     * @throws PersistenceException if insufficient or inconsistent
     *         configuration information is provided of if schema
     *         generation otherwise fails
     *
     * @since 2.1
     */
    public void generateSchema(PersistenceUnitInfo info, Map map);

    /**
     * Create database schemas and/or tables and/or create DDL
     * scripts as determined by the supplied properties.
     * <p>
     * Called by the Persistence class when schema generation is to
     * occur as a separate phase from creation of the entity
     * manager factory.
     * <p>
     * @param persistenceUnitName the name of the persistence unit
     * @param map properties for schema generation;  these may
     *             also contain provider-specific properties.  The
     *             value of these properties override any values that
     *             may have been configured elsewhere.
     * @return true  if schema was generated, otherwise false
     * @throws PersistenceException if insufficient or inconsistent
     *         configuration information is provided or if schema
     *         generation otherwise fails
     *
     * @since 2.1
     */
    public boolean generateSchema(String persistenceUnitName, Map map);

    /**
     * Return the utility interface implemented by the persistence
     * provider.
     * @return ProviderUtil interface
     *
     * @since 2.0
     */
    public ProviderUtil getProviderUtil();
}
----

The properties used in the
`createEntityManagerFactory` method in Java SE environments are
described further in <<a13443>> below.

==== jakarta.persistence.spi.ProviderUtil

The `ProviderUtil` interface is invoked by
the `PersistenceUtil` implementation to determine the load status of an
entity or entity attribute. It is not intended to be invoked by the
application.

[source,java]
----
package jakarta.persistence.spi;

import jakarta.persistence.PersistenceUtil;

/**
 * Utility interface implemented by the persistence provider.  This
 * interface is invoked by the {@link
 * PersistenceUtil} implementation to determine
 * the load status of an entity or entity attribute.
 *
 * @since 2.0
 */
public interface ProviderUtil {

    /**
     * If the provider determines that the entity has been provided
     * by itself and that the state of the specified attribute has
     * been loaded, this method returns <code>LoadState.LOADED</code>.
     * <p> If the provider determines that the entity has been provided
     * by itself and that either entity attributes with <code>FetchType.EAGER</code>
     * have not been loaded or that the state of the specified
     * attribute has not been loaded, this methods returns
     * <code>LoadState.NOT_LOADED</code>.
     * <p> If a provider cannot determine the load state, this method
     * returns <code>LoadState.UNKNOWN</code>.
     * <p> The provider's implementation of this method must not obtain
     * a reference to an attribute value, as this could trigger the
     * loading of entity state if the entity has been provided by a
     * different provider.
     * @param entity  entity instance
     * @param attributeName  name of attribute whose load status is
     *        to be determined
     * @return load status of the attribute
     */
    public LoadState isLoadedWithoutReference(Object entity, String attributeName);

    /**
     * If the provider determines that the entity has been provided
     * by itself and that the state of the specified attribute has
     * been loaded, this method returns <code>LoadState.LOADED</code>.
     * <p> If a provider determines that the entity has been provided
     * by itself and that either the entity attributes with <code>FetchType.EAGER</code>
     * have not been loaded or that the state of the specified
     * attribute has not been loaded, this method returns
     * return <code>LoadState.NOT_LOADED</code>.
     * <p> If the provider cannot determine the load state, this method
     * returns <code>LoadState.UNKNOWN</code>.
     * <p> The provider's implementation of this method is permitted to
     * obtain a reference to the attribute value.  (This access is
     * safe because providers which might trigger the loading of the
     * attribute state will have already been determined by
     * <code>isLoadedWithoutReference</code>. )
     *
     * @param entity  entity instance
     * @param attributeName  name of attribute whose load status is
     *        to be determined
     * @return load status of the attribute
     */
    public LoadState isLoadedWithReference(Object entity, String attributeName);

    /**
     * If the provider determines that the entity has been provided
     * by itself and that the state of all attributes for which
     * <code>FetchType.EAGER</code> has been specified have been loaded, this
     * method returns <code>LoadState.LOADED</code>.
     * <p> If the provider determines that the entity has been provided
     * by itself and that not all attributes with <code>FetchType.EAGER</code>
     * have been loaded, this method returns <code>LoadState.NOT_LOADED</code>.
     * <p> If the provider cannot determine if the entity has been
     * provided by itself, this method returns <code>LoadState.UNKNOWN</code>.
     * <p> The provider's implementation of this method must not obtain
     * a reference to any attribute value, as this could trigger the
     * loading of entity state if the entity has been provided by a
     * different provider.
     * @param entity whose loaded status is to be determined
     * @return load status of the entity
     */
    public LoadState isLoaded(Object entity);
}
----

[source,java]
----
package jakarta.persistence.spi;

/**
 * Load states returned by the {@link ProviderUtil} SPI methods.
 * @since 2.0
 *
 */
public enum LoadState {
    /** The state of the element is known to have been loaded. */
    LOADED,
    /** The state of the element is known not to have been loaded. */
    NOT_LOADED,
    /** The load state of the element cannot be determined. */
    UNKNOWN
}
----

=== jakarta.persistence.spi.PersistenceUnitInfo Interface [[a13160]]

[source,java]
----
package jakarta.persistence.spi;

import javax.sql.DataSource;
import java.util.List;
import java.util.Properties;
import java.net.URL;
import jakarta.persistence.SharedCacheMode;
import jakarta.persistence.ValidationMode;
import jakarta.persistence.EntityManagerFactory;

/**
 * Interface implemented by the container and used by the
 * persistence provider when creating an {@link EntityManagerFactory}.
 *
 * @since 1.0
 */
public interface PersistenceUnitInfo {

    /**
     * Returns the name of the persistence unit. Corresponds to the
     * <code>name</code> attribute in the <code>persistence.xml</code> file.
     * @return  the name of the persistence unit
     */
    public String getPersistenceUnitName();

    /**
     * Returns the fully qualified name of the persistence provider
     * implementation class. Corresponds to the <code>provider</code> element in
     * the <code>persistence.xml</code> file.
     * @return  the fully qualified name of the persistence provider
     * implementation class
     */
    public String getPersistenceProviderClassName();

    /**
     * Returns the transaction type of the entity managers created by
     * the <code>EntityManagerFactory</code>. The transaction type corresponds to
     * the <code>transaction-type</code> attribute in the <code>persistence.xml</code> file.
     * @return  transaction type of the entity managers created
     * by the EntityManagerFactory
     */
    public PersistenceUnitTransactionType getTransactionType();

    /**
     * Returns the JTA-enabled data source to be used by the
     * persistence provider. The data source corresponds to the
     * <code>jta-data-source</code> element in the <code>persistence.xml</code> file or is
     * provided at deployment or by the container.
     * @return the JTA-enabled data source to be used by the
     * persistence provider
     */
    public DataSource getJtaDataSource();

    /**
     * Returns the non-JTA-enabled data source to be used by the
     * persistence provider for accessing data outside a JTA
     * transaction. The data source corresponds to the named
     * <code>non-jta-data-source</code> element in the <code>persistence.xml</code> file or
     * provided at deployment or by the container.
     * @return the non-JTA-enabled data source to be used by the
     * persistence provider for accessing data outside a JTA
     * transaction
     */
    public DataSource getNonJtaDataSource();

    /**
     * Returns the list of the names of the mapping files that the
     * persistence provider must load to determine the mappings for
     * the entity classes. The mapping files must be in the standard
     * XML mapping format, be uniquely named and be resource-loadable
     * from the application classpath.  Each mapping file name
     * corresponds to a <code>mapping-file</code> element in the
     * <code>persistence.xml</code> file.
     * @return the list of mapping file names that the persistence
     * provider must load to determine the mappings for the entity
     * classes
     */
    public List<String> getMappingFileNames();

    /**
     * Returns a list of URLs for the jar files or exploded jar
     * file directories that the persistence provider must examine
     * for managed classes of the persistence unit. Each URL
     * corresponds to a <code>jar-file</code> element in the
     * <code>persistence.xml</code> file. A URL will either be a
     * file: URL referring to a jar file or referring to a directory
     * that contains an exploded jar file, or some other URL from
     * which an InputStream in jar format can be obtained.
     * @return a list of URL objects referring to jar files or
     * directories
     */
    public List<URL> getJarFileUrls();

    /**
     * Returns the URL for the jar file or directory that is the
     * root of the persistence unit. (If the persistence unit is
     * rooted in the WEB-INF/classes directory, this will be the
     * URL of that directory.)
     * The URL will either be a file: URL referring to a jar file
     * or referring to a directory that contains an exploded jar
     * file, or some other URL from which an InputStream in jar
     * format can be obtained.
     * @return a URL referring to a jar file or directory
     */
    public URL getPersistenceUnitRootUrl();

    /**
     * Returns the list of the names of the classes that the
     * persistence provider must add to its set of managed
     * classes. Each name corresponds to a named <code>class</code> element in the
     * <code>persistence.xml</code> file.
     * @return the list of the names of the classes that the
     * persistence provider must add to its set of managed
     * classes
     */
    public List<String> getManagedClassNames();

    /**
     * Returns whether classes in the root of the persistence unit
     * that have not been explicitly listed are to be included in the
     * set of managed classes. This value corresponds to the
     * <code>exclude-unlisted-classes</code> element in the <code>persistence.xml</code> file.
     * @return whether classes in the root of the persistence
     * unit that have not been explicitly listed are to be
     * included in the set of managed classes
     */
    public boolean excludeUnlistedClasses();

    /**
     * Returns the specification of how the provider must use
     * a second-level cache for the persistence unit.
     * The result of this method corresponds to the <code>shared-cache-mode</code>
     * element in the <code>persistence.xml</code> file.
     * @return the second-level cache mode that must be used by the
     * provider for the persistence unit
     *
     * @since 2.0
     */
    public SharedCacheMode getSharedCacheMode();

    /**
     * Returns the validation mode to be used by the persistence
     * provider for the persistence unit.  The validation mode
     * corresponds to the <code>validation-mode</code> element in the
     * <code>persistence.xml</code> file.
     * @return the validation mode to be used by the
     * persistence provider for the persistence unit
     *
     * @since 2.0
     */
    public ValidationMode getValidationMode();

    /**
     * Returns a properties object. Each property corresponds to a
     * <code>property</code> element in the <code>persistence.xml</code> file
     * or to a property set by the container.
     * @return Properties object
     */
    public Properties getProperties();

    /**
     * Returns the schema version of the <code>persistence.xml</code> file.
     * @return persistence.xml schema version
     *
     * @since 2.0
     */
    public String getPersistenceXMLSchemaVersion();

    /**
     * Returns ClassLoader that the provider may use to load any
     * classes, resources, or open URLs.
     * @return ClassLoader that the provider may use to load any
     * classes, resources, or open URLs
     */
    public ClassLoader getClassLoader();

    /**
     * Add a transformer supplied by the provider that will be
     * called for every new class definition or class redefinition
     * that gets loaded by the loader returned by the
     * {@link PersistenceUnitInfo#getClassLoader} method. The transformer
     * has no effect on the result returned by the
     * {@link PersistenceUnitInfo#getNewTempClassLoader} method.
     * Classes are only transformed once within the same classloading
     * scope, regardless of how many persistence units they may be
     * a part of.
     * @param transformer   provider-supplied transformer that the
     * container invokes at class-(re)definition time
     */
    public void addTransformer(Transformer transformer);

    /**
     * Return a new instance of a ClassLoader that the provider may
     * use to temporarily load any classes, resources, or open
     * URLs. The scope and classpath of this loader is exactly the
     * same as that of the loader returned by {@link
     * PersistenceUnitInfo#getClassLoader}. None of the classes loaded
     * by this class loader will be visible to application
     * components. The provider may only use this ClassLoader within
     * the scope of the {@link
     * PersistenceProvider#createContainerEntityManagerFactory} call.
     * @return temporary ClassLoader with same visibility as current
     * loader
     */
    public ClassLoader getNewTempClassLoader();
}
----

The enum
`jakarta.persistence.spi.PersistenceUnitTransactionType` defines whether
the entity managers created by the factory will be JTA or resource-local
entity managers.

[source,java]
----
package jakarta.persistence.spi;

import jakarta.persistence.EntityManagerFactory;

/**
 * Specifies whether entity managers created by the {@link
 * EntityManagerFactory} will be JTA or
 * resource-local entity managers.
 *
 * @since 1.0
 */
public enum PersistenceUnitTransactionType {

    /** JTA entity managers will be created. */
    JTA,

    /** Resource-local entity managers will be created. */
    RESOURCE_LOCAL
}
----

The enum `jakarta.persistence.SharedCacheMode`
defines the use of caching. The `persistence.xml` `shared-cache-mode`
element has no default value. The `getSharedCacheMode` method must
return `UNSPECIFIED` if the `shared-cache-mode` element has not been
specified for the persistence unit.

[source,java]
----
package jakarta.persistence;

import jakarta.persistence.spi.PersistenceUnitInfo;

/**
 * Specifies how the provider must use a second-level cache for the
 * persistence unit.  Corresponds to the value of the <code>persistence.xml</code>
 * <code>shared-cache-mode</code> element, and returned as the result of
 * {@link PersistenceUnitInfo#getSharedCacheMode()}.
 *
 * @since 2.0
 */
public enum SharedCacheMode {

    /**
     * All entities and entity-related state and data are cached.
     */
    ALL,

    /**
     * Caching is disabled for the persistence unit.
     */
    NONE,

    /**
     * Caching is enabled for all entities for <code>Cacheable(true)</code>
     * is specified.  All other entities are not cached.
     */
    ENABLE_SELECTIVE,

    /**
     * Caching is enabled for all entities except those for which
     * <code>Cacheable(false)</code> is specified.  Entities for which
     * <code>Cacheable(false)</code> is specified are not cached.
     */
    DISABLE_SELECTIVE,

    /**
     *
     * Caching behavior is undefined: provider-specific defaults may apply.
     */
    UNSPECIFIED
}
----

The enum `jakarta.persistence.ValidationMode`
defines the validation mode.

[source,java]
----
package jakarta.persistence;

/**
 * The validation mode to be used by the provider for the persistence
 * unit.
 *
 * @since 2.0
 */
public enum ValidationMode {

    /**
     * If a Bean Validation provider is present in the environment,
     * the persistence provider must perform the automatic validation
     * of entities.  If no Bean Validation provider is present in the
     * environment, no lifecycle event validation takes place.
     * This is the default behavior.
     */
    AUTO,

    /**
     * The persistence provider must perform the lifecycle event
     * validation.  It is an error if there is no Bean Validation
     * provider present in the environment.
     */
    CALLBACK,

    /**
     * The persistence provider must not perform lifecycle event validation.
     */
    NONE
}
----

==== jakarta.persistence.spi.ClassTransformer Interface

The `jakarta.persistence.spi.ClassTransformer`
interface is implemented by a persistence provider that wants to
transform entities and managed classes at class load time or at class
redefinition time. Implementation of this interface by a persistence
provider is optional.

[source,java]
----
package jakarta.persistence.spi;

import java.security.ProtectionDomain;

/**
 * A persistence provider supplies an instance of this 
 * interface to the {@link PersistenceUnitInfo#addTransformer 
 * PersistenceUnitInfo.addTransformer}
 * method. The supplied transformer instance will get 
 * called to transform entity class files when they are 
 * loaded or redefined. The transformation occurs before  
 * the class is defined by the JVM.
 *
 * @since 1.0
 */
public interface ClassTransformer {

    /**
     * Invoked when a class is being loaded or redefined.
     * The implementation of this method may transform the 
     * supplied class file and return a new replacement class 
     * file.
     *
     * @param loader  the defining loader of the class to be 
     *        transformed, may be null if the bootstrap loader
     * @param className  the name of the class in the internal form 
     *        of fully qualified class and interface names 
     * @param classBeingRedefined  if this is a redefine, the 
     *        class being redefined, otherwise null
     * @param protectionDomain  the protection domain of the 
     *        class being defined or redefined
     * @param classfileBuffer  the input byte buffer in class 
     *        file format - must not be modified 
     * @return a well-formed class file buffer (the result of 
     *         the transform), or null if no transform is performed
     * @throws TransformerException  if the input does
     *         not represent a well-formed class file
     */
    byte[] transform(ClassLoader loader,
                     String className,
                     Class<?> classBeingRedefined,
                     ProtectionDomain protectionDomain, 
                     byte[] classfileBuffer) 
        throws TransformerException;
}
----

=== jakarta.persistence.Persistence Class [[a13443]]

The `Persistence` class is used to obtain an `EntityManagerFactory` instance
in Java SE environments. It may also be used for schema generation—i.e., to
create database schemas and/or tables and/or to create DDL scripts.

The `Persistence` class is also available in a Jakarta EE container environment;
however, support for the Java SE bootstrapping APIs is not required in container
environments.

The `Persistence` class is used to obtain a `PersistenceUtil` instance in both
Jakarta EE and Java SE environments.

[source,java]
----
package jakarta.persistence;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import jakarta.persistence.spi.PersistenceProvider;
import jakarta.persistence.spi.PersistenceProviderResolver;
import jakarta.persistence.spi.PersistenceProviderResolverHolder;
import jakarta.persistence.spi.LoadState;

/**
 * Bootstrap class that is used to obtain an {@link EntityManagerFactory}
 * in Java SE environments.  It may also be used to cause schema
 * generation to occur.
 *
 * <p> The <code>Persistence</code> class is available in a Jakarta EE
 * container environment as well; however, support for the Java SE
 * bootstrapping APIs is not required in container environments.
 *
 * <p> The <code>Persistence</code> class is used to obtain a {@link
 * PersistenceUtil PersistenceUtil} instance in both
 * Jakarta EE and Java SE environments.
 *
 * @since 1.0
 */
public class Persistence {

    /**
     * Create and return an EntityManagerFactory for the named
     * persistence unit.
     *
     * @param persistenceUnitName
     *            the name of the persistence unit
     * @return the factory that creates EntityManagers configured according to
     *         the specified persistence unit
     */
    public static EntityManagerFactory createEntityManagerFactory(String persistenceUnitName) {
        return createEntityManagerFactory(persistenceUnitName, null);
    }

    /**
     * Create and return an EntityManagerFactory for the named persistence unit
     * using the given properties.
     *
     * @param persistenceUnitName
     *            the name of the persistence unit
     * @param properties
     *            Additional properties to use when creating the factory.
     *            These properties may include properties to control
     *            schema generation.  The values of these properties override
     *            any values that may have been configured elsewhere.
     * @return the factory that creates EntityManagers configured according to
     *         the specified persistence unit.
     */
    public static EntityManagerFactory createEntityManagerFactory(String persistenceUnitName, Map properties) {

        EntityManagerFactory emf = null;
        PersistenceProviderResolver resolver = PersistenceProviderResolverHolder.getPersistenceProviderResolver();

        List<PersistenceProvider> providers = resolver.getPersistenceProviders();

        for (PersistenceProvider provider : providers) {
            emf = provider.createEntityManagerFactory(persistenceUnitName, properties);
            if (emf != null) {
                break;
            }
        }
        if (emf == null) {
            throw new PersistenceException("No Persistence provider for EntityManager named " + persistenceUnitName);
        }
        return emf;
    }

    /**
     * Create and return an EntityManagerFactory for the named persistence unit
     * using the given properties.
     *
     * @param configuration
     *            configuration of the persistence unit
     * @return the factory that creates EntityManagers configured according to
     *         the specified persistence unit.
     *
     * @since 3.2
     */
    public static EntityManagerFactory createEntityManagerFactory(PersistenceConfiguration configuration) {

        EntityManagerFactory emf = null;
        PersistenceProviderResolver resolver = PersistenceProviderResolverHolder.getPersistenceProviderResolver();

        List<PersistenceProvider> providers = resolver.getPersistenceProviders();

        for (PersistenceProvider provider : providers) {
            emf = provider.createEntityManagerFactory(configuration);
            if (emf != null) {
                break;
            }
        }
        if (emf == null) {
            throw new PersistenceException("No Persistence provider for EntityManager named " + configuration.name());
        }
        return emf;
    }


    /**
     * Create database schemas and/or tables and/or create DDL
     * scripts as determined by the supplied properties.
     * <p>
     * Called when schema generation is to occur as a separate phase
     * from creation of the entity manager factory.
     * <p>
     * @param persistenceUnitName the name of the persistence unit
     * @param map properties for schema generation;  these may
     *             also contain provider-specific properties.  The
     *             value of these properties override any values that
     *             may have been configured elsewhere..
     * @throws PersistenceException if insufficient or inconsistent
     *         configuration information is provided or if schema
     *         generation otherwise fails.
     *
     * @since 2.1
     */
    public static void generateSchema(String persistenceUnitName, Map map) {
        PersistenceProviderResolver resolver = PersistenceProviderResolverHolder.getPersistenceProviderResolver();
        List<PersistenceProvider> providers = resolver.getPersistenceProviders();

        for (PersistenceProvider provider : providers) {
            if (provider.generateSchema(persistenceUnitName, map)) {
                return;
            }
        }

        throw new PersistenceException("No Persistence provider to generate schema named " + persistenceUnitName);
    }


    /**
     * Return the PersistenceUtil instance
     * @return PersistenceUtil instance
     * @since 2.0
     */
    public static PersistenceUtil getPersistenceUtil() {
       // ...
    }

    // ...
}
----

The `properties` argument passed to the
`createEntityManagerFactory` method is used to specify both standard and
vendor-specific properties and hints intended for use in creating the
entity manager factory.

The following properties correspond to the
elements and properties in the `persistence.xml` file. When any of these
properties are specified in the Map parameter passed to the
`createEntityManagerFactory` method, their values override the values of
the corresponding elements and properties in the `persistence.xml` file
for the named persistence unit. They also override any defaults that the
persistence provider might have applied.

* `jakarta.persistence.lock.timeout` — integer
value in milliseconds for pessimistic lock timeout or string
corresponding to integer value. This corresponds to the property of the
same name in the `persistence.xml`, and is a hint only. See <<a2132>>.
* `jakarta.persistence.query.timeout` — integer
value in milliseconds for query timeout or string corresponding to
integer value. This corresponds to the property of the same name in the
`persistence.xml`, and is a hint only. See <<a4391>>.
* `jakarta.persistence.provider` — string
corresponding to the `provider` element in the pe `rsistence.xml`. See
<<a12300>>.
* `jakarta.persistence.transactionType` — string
corresponding to the `transaction-type` attribute in the
`persistence.xml`. See <<a12296>>.
* `jakarta.persistence.jtaDataSource` — string
corresponding to the `jta-data-source` element in the `persistence.xml`.
See <<a12302>>.
* `jakarta.persistence.nonJtaDataSource` —
string corresponding to the `non-jta-data-source` element in the
`persistence.xml`. See <<a12302>>.
* `jakarta.persistence.sharedCache.mode`
— string corresponding to the `shared-cache-mode` element in the
`persistence.xml`. See <<a12380>>.
* `jakarta.persistence.validation.mode` — string
corresponding to the `validation-mode` element in the `persistence.xml`
. The value is " `auto` ", " `callback` ", or " `none` ". See
<<a12382>> and <<a2374>>.
* `jakarta.persistence.validation.group.pre-persist` — string corresponding
to the `jakarta.persistence.validation.group.pre-persist` property in the
`persistence.xml`. See <<a12384>> and <<a2380>>.
* `jakarta.persistence.validation.group.pre-update` — string corresponding
to the `jakarta.persistence.validation.group.pre-update` property in the
`persistence.xml`. See <<a12384>> and <<a2380>>.
* `jakarta.persistence.validation.group.pre-remove` — string corresponding
to the `jakarta.persistence.validation.group.pre-remove` property in the
`persistence.xml`. See <<a12384>> and <<a2380>>.
* `jakarta.persistence.schema-generation.create-script-source` — string
corresponding to the
`jakarta.persistence.schema-generation.create-script-source` property in
the `persistence.xml`. See <<a12384>>.
* `jakarta.persistence.schema-generation.drop-script-source` — string
corresponding to the
`jakarta.persistence.schema-generation.drop-script-source` property in
the `persistence.xml`. See <<a12384>>.
* `jakarta.persistence.sql-load-script-source` —
string corresponding to the `jakarta.persistence.sql-load-script-source`
property in the `persistence.xml`. See <<a12384>>.
* `jakarta.persistence.schema-generation.database.action` — string
corresponding to the
`jakarta.persistence.schema-generation.database.action` property in the
`persistence.xml`. See <<a12384>>.
* `jakarta.persistence.schema-generation.scripts.action` — string
corresponding to the
`jakarta.persistence.schema-generation.scripts.action` property in the
`persistence.xml`. See <<a12384>>.
* `jakarta.persistence.schema-generation.create-source` — string
corresponding to the `jakarta.persistence.schema-generation.create-source`
property in the `persistence.xml`. See <<a12384>>.
* `jakarta.persistence.schema-generation.drop-source` — string corresponding
to the `jakarta.persistence.schema-generation.drop-source` property in
the `persistence.xml`. See <<a12384>>.
* `jakarta.persistence.schema-generation.scripts.create-target` —string
corresponding to the
`jakarta.persistence.schema-generation.scripts.create-target` property in
the `persistence.xml`. See <<a12384>>.
* `jakarta.persistence.schema-generation.scripts.drop-target` — string
corresponding to the
`jakarta.persistence.schema-generation.scripts.drop-target` property in
the `persistence.xml`. See <<a12384>>.

The following additional standard properties
are defined by this specification for the configuration of the entity
manager factory:

* `jakarta.persistence.jdbc.driver` — value is
the fully qualified name of the driver class.
* `jakarta.persistence.jdbc.url` — string
corresponding to the driver-specific URL.
* `jakarta.persistence.jdbc.user` — value is the
username used by database connection.
* `jakarta.persistence.jdbc.password` — value is
the password for database connection validation.
* `jakarta.persistence.dataSource` — value is
instance of `javax.sql.DataSource` to be used for the specified
persistence unit.
* `jakarta.persistence.validation.factory` —
value is instance of `jakarta.validation.ValidatorFactory`.

Any number of vendor-specific properties may
also be included in the map. If a persistence provider does not
recognize a property (other than a property defined by this
specification), the provider must ignore it.

Vendors should use vendor namespaces for
properties (e.g., `com.acme.persistence.logging`). Entries that make
use of the namespace `jakarta.persistence` and its subnamespaces must not
be used for vendor-specific information. The namespace
`jakarta.persistence` is reserved for use by this specification.

=== jakarta.persistence.PersistenceConfiguration Class [[a13444]]

The `PersistenceConfiguration` class is used to programmatically define and
configure a persistence unit and create an `EntityManagerFactory` instance
directly. Thus, `PersistenceConfiguration` is an alternative to XML-based
configuration using `persistence.xml`, and so the configuration options
available via this API reflect the similarly-named elements of
`persistence.xml`. See <<a12237>>.

A programmatically-configured persistence unit is considered a Java SE
persistence unit, even when this API is used within the Jakarta EE
environment.footnote:[Persistence units defined programmatically using the
`PersistenceConfiguration` class do not support JNDI lookup or injection via
the `PersistenceContext` or `PersistenceUnit` annotations.]

A persistence provider may define a subclass of `PersistenceConfiguration`
with vendor-specific configuration options. A provider must support
configuration via any instance of `PersistenceConfiguration` or of any
subclass of `PersistenceConfiguration`. If a subclass defines configuration
options the provider does not recognize, it should ignore those options.

=== PersistenceUtil Interface

This interface is used to determine load
state. The semantics of the methods of this interface are defined in
<<a13592>> below.

[source,java]
----
package jakarta.persistence;

/**
 * Utility interface between the application and the persistence
 * provider(s).
 *
 * <p> The <code>PersistenceUtil</code> interface instance obtained from the
 * {@link Persistence} class is used to determine the load state of an
 * entity or entity attribute regardless of which persistence
 * provider in the environment created the entity.
 *
 * @since 2.0
 */
public interface PersistenceUtil {

    /**
     * Determine the load state of a given persistent attribute.
     * @param entity  entity containing the attribute
     * @param attributeName name of attribute whose load state is
     *        to be determined
     * @return false if entity's state has not been loaded or
     *  if the attribute state has not been loaded, else true
     */
    public boolean isLoaded(Object entity, String attributeName);

    /**
     * Determine the load state of an entity.
     * This method can be used to determine the load state
     * of an entity passed as a reference.  An entity is
     * considered loaded if all attributes for which
     * <code>FetchType.EAGER</code> has been specified have been loaded.
     * <p> The <code>isLoaded(Object, String)</code> method should be used to
     * determine the load state of an attribute.
     * Not doing so might lead to unintended loading of state.
     * @param entity whose load state is to be determined
     * @return false if the entity has not been loaded, else true
     */
    public boolean isLoaded(Object entity);
}
----

==== Contracts for Determining the Load State of an Entity or Entity Attribute [[a13592]]

The implementation of the
`PersistenceUtil.isLoaded(Object)` method must determine the list of
persistence providers available in the runtime
environmentfootnote:[The determining of
the persistence providers that are available is discussed in <<a12837>>.] and call the
`ProviderUtil.isLoaded(Object)` method on each of them until either:

* one provider returns `LoadState.LOADED`. In
this case `PersistenceUtil.isLoaded` returns `true`.
* one provider returns `LoadState.NOT_LOADED`.
In this case `PersistenceUtil.isLoaded` returns `false`.
* all providers return `LoadState.UNKNOWN`. In
this case `PersistenceUtil.isLoaded` returns `true`.

If the `PersistenceUtil` implementation
determines that only a single provider is available in the environment,
it is permitted to use provider-specific methods to determine the result
of `isLoaded(Object)` as long as the semantics defined in <<a2019>> are observed.

The implementation of the
_PersistenceUtil.isLoaded(Object,String)_ method must determine the list
of persistence providers available in the environment and call the
`ProviderUtil.isLoadedWithoutReference` method on each of them until
either:

* one provider returns `LoadState.LOADED`. In
this case `PersistenceUtil.isLoaded` returns `true`.
* one provider returns `LoadState.NOT_LOADED`.
In this case `PersistenceUtil.isLoaded` returns `false`.
* all providers return `LoadState.UNKNOWN`. In
this case, the `PersistenceUtil.isLoaded` method then calls
`ProviderUtil.isLoadedWithReference` on each of the providers until:
** one provider returns `LoadState.LOADED`. In
this case `PersistenceUtil.isLoaded` return `true`.
** one provider returns `LoadState.NOT_LOADED`.
In this case, `PersistenceUtil.isLoaded` returns `false`.
** all providers return `LoadState.UNKNOWN`. In
this case, `PersistenceUtil.isLoaded` returns `true`.

If the `PersistenceUtil` implementation
determines that only a single provider is available in the environment,
it is permitted to use provider specific methods to determine the result
of _isLoaded(Object, String)_ as long as the semantics defined in
<<a2019>> are observed.

NOTE: The rationale for splitting the
determination of load state between the methods isLoadedWithoutReference
and isLoadedWithReference is the following.

* _It is assumed that the provider that loaded
the entity is present in the environment._
* _Providers that use bytecode enhancement
don't need to access an attribute reference to determine its load state,
and can determine if the entity has been provided by them._
* _By first querying all providers using
bytecode enhancement, it is insured that no attribute will be loaded by
side effect._
* _Proxy-based providers do need to access an
attribute reference to determine load state, but will not trigger
attribute loading as a side effect._
* _If no provider recognizes an entity as
provided by it, it is assumed to be an object that is not instrumented
and is considered loaded._