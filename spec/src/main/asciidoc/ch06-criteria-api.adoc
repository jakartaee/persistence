//
// Copyright (c) 2017, 2023 Contributors to the Eclipse Foundation
//

== Criteria API [[a6925]]

The Jakarta Persistence Criteria API is used to
define queries through the construction of object-based query definition
objects, rather than use of the string-based approach of the Jakarta
Persistence query language described in <<a4665>>.

This chapter provides the full definition of the Criteria API.

=== Overview

The Jakarta Persistence Criteria API, like the
Jakarta Persistence query language is based on the abstract persistence
schema of entities, their embedded objects, and their relationships as
its data model. This abstract persistence schema is materialized in the
form of metamodel objects over which the Criteria API operates. The
semantics of criteria queries are designed to reflect those of Jakarta
Persistence query language queries.

The complete criteria query API may be found in <<Criteria API Interfaces>>.

The syntax of the Criteria API is designed to
allow the construction of an object-based query “graph”, whose nodes
correspond to the semantic query elements.

Java language variables can be used to
reference individual nodes in a criteria query object as it is
constructed and/or modified. Such variables, when used to refer to the
entities and embeddable types that constitute the query domain, play a
role analogous to that of the identification variables of the Jakarta
Persistence query language.

These concepts are further described in the sections that follow.
Sections <<a10608>> through <<a11413>> describe the construction and
modification of criteria query objects. Additional requirements on the
persistence provider are described in <<a11427>>.

The metamodel on which criteria queries are based was already presented
in <<a6072>>. The static metamodel classes which are used to construct
strongly-typed criteria queries are described in <<a6933>>.

=== Criteria Query API Usage [[a10608]]

The `jakarta.persistence.criteria` API
interfaces are designed both to allow criteria queries to be constructed
in a strongly-typed manner, using metamodel objects to provide type
safety, and to allow for string-based use as an alternative:

Metamodel objects are used to specify
navigation through joins and through path
expressionsfootnote:[The attributes of
these metamodel objects play a role analogous to that which would be
played by member literals.]. Typesafe navigation is achieved by
specification of the source and target types of the navigation.

Strings may be used as an alternative to
metamodel objects, whereby joins and navigation are specified by use of
strings that correspond to attribute names.

Using either the approach based on metamodel
objects or the string-based approach, queries can be constructed both
statically and dynamically. Both approaches are equivalent in terms of
the range of queries that can be expressed and operational semantics.

<<a10614>> provides a description of the use of the
criteria API interfaces. This section is illustrated on the basis of the
construction of strongly-typed queries using static metamodel classes.
<<a11305>> describes how
the `jakarta.persistence.metamodel` API can be used to construct
strongly-typed queries in the absence of such classes. String-based use
of the criteria API is described in <<a11349>>.

=== Constructing Criteria Queries [[a10614]]

A criteria query is constructed through the
creation and modification of a
`jakarta.persistence.criteria.CriteriaQuery` object.

The `CriteriaBuilder` interface is used to
construct `CriteriaQuery`, `CriteriaUpdate`, and `CriteriaDelete`
objects. The `CriteriaBuilder` implementation is accessed through the
`getCriteriaBuilder` method of the `EntityManager` or
`EntityManagerFactory` interface.

For example:

[source,java]
----
@PersistenceUnit
EntityManagerFactory emf;

CriteriaBuilder cb = emf.getCriteriaBuilder();
----

==== CriteriaQuery Creation [[a10621]]

A `CriteriaQuery` object is created by means
of one of the `createQuery` methods or the `createTupleQuery` method of
the `CriteriaBuilder` interface. A `CriteriaQuery` object is typed
according to its expected result type when the `CriteriaQuery` object is
created. A `TypedQuery` instance created from the `CriteriaQuery` object
by means of the `EntityManager` `createQuery` method will result in
instances of this type when the resulting query is executed.

The following methods are provided for the
creation of `CriteriaQuery` objects:

[source,java]
----
<T> CriteriaQuery<T> createQuery(Class<T> resultClass);

CriteriaQuery<Tuple> createTupleQuery();

CriteriaQuery<Object> createQuery();
----

Methods for the creation of update and delete
queries are described in <<a11239>>.

The methods `<T> CriteriaQuery<T>
createQuery(Class<T> resultClass)` and `createTupleQuery` provide for
typing of criteria query results and for typesafe query execution using
the `TypedQuery` API.

The effect of the `createTupleQuery` method
is semantically equivalent to invoking the `createQuery` method with the
`Tuple.class` argument. The `Tuple` interface supports the extraction of
multiple selection items in a strongly typed manner. See <<a3868>> and
<<a3949>>.

The `CriteriaQuery<Object> createQuery()`
method supports both the case where the `select` or `multiselect` method
specifies only a single selection item and where the `multiselect`
method specifies multiple selection items. If only a single item is
specified, an instance of type `Object` will be returned for each result
of the query execution. If multiple selection items are specified, an
instance of type `Object[]` will be instantiated and returned for each
result of the execution.

See <<a10945>> for further discussion of the specification
of selection items.

==== Query Roots

A `CriteriaQuery` object defines a query over
one or more entity, embeddable, or basic abstract schema types. The root
objects of the query are entities, from which the other types are
reached by navigation. A query root plays a role analogous to that of a
range variable in the Jakarta Persistence query language and forms the
basis for defining the domain of the query.

A query root is created and added to the
query by use of the `from` method of the `AbstractQuery` interface (from
which both the `CriteriaQuery` and `Subquery` interfaces inherit). The
argument to the `from` method is the entity class or `EntityType`
instance for the entity. The result of the `from` method is a `Root`
object. The `Root` interface extends the `From` interface, which
represents objects that may occur in the from clause of a query.

A `CriteriaQuery` object may have more than
one root. The addition of a query root has the semantic effect of
creating a cartesian product between the entity type referenced by the
added root and those of the other roots.

The following query illustrates the
definition of a query root. When executed, this query causes all
instances of the `Customer` entity to be returned.

[source,java]
----
CriteriaBuilder cb = ...
CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
Root<Customer> customer = q.from(Customer.class);
q.select(customer);
----

==== Joins [[a10643]]

The `join` methods of the `From` interface
extend the query domain by creating a join with a related class that can
be navigated to or that is an element of the given class of the query
domain.

The target of the join is specified by
the corresponding `SingularAttribute` or collection-valued attribute (
`CollectionAttribute`, `SetAttribute`, `ListAttribute`, or
`MapAttribute`) of the corresponding metamodel
class.footnote:[Metamodel objects are
used to specify typesafe nagivation through joins and through path
expressions. These metamodel objects capture both the source and target
types of the attribute through which navigation occurs, and are thus the
mechanism by which typesafe navigation is achieved.] footnote:[Attribute names serve
this role for string-based queries. See <<a11349>>.]

The `join` methods may be applied to
instances of the `Root` and `Join` types.

The result of a `join` method is a `Join`
object (instance of the `Join`, `CollectionJoin`, `SetJoin`,
`ListJoin`, or `MapJoin` types) that captures the source and target
types of the join.

For example, given the `Order` entity and
corresponding `Order_` metamodel class shown in <<a6961>>, a join to the lineItems of the
order would be expressed as follows:

[source,java]
----
CriteriaQuery<Order> q = cb.createQuery(Order.class);
Root<Order> order = q.from(Order.class);
Join<Order, Item> item = order.join(Order_.lineItems);
q.select(order);
----

The argument to the `join` method,
`Order.lineItems`, is of type
`jakarta.persistence.metamodel.SetAttribute<Order, Item>`.

The `join` methods have the same semantics as
the corresponding Jakarta Persistence query language operations, as
described in <<a4957>>.

*Example:*

[source,java]
----
CriteriaBuilder cb = ...
CriteriaQuery<String> q = cb.createQuery(String.class);
Root<Customer> customer = q.from(Customer.class);
Join<Customer, Order> order = customer.join(Customer_.orders);
Join<Order, Item> item = order.join(Order_.lineItems);
q.select(customer.get(Customer_.name))
    .where(cb.equal(item.get(Item_.product).get(Product_.productType), "printer"));
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT c.name
FROM Customer c JOIN c.orders o JOIN o.lineItems i
WHERE i.product.productType = 'printer'
----

Joins can be chained, thus allowing this
query to be written more concisely:

[source,java]
----
CriteriaQuery<String> q = cb.createQuery(String.class);
Root<Customer> customer = q.from(Customer.class);
Join<Order, Item> item = customer.join(Customer_.orders).join(Order_.lineItems);
q.select(customer.get(Customer_.name))
    .where(cb.equal(item.get(Item_.product).get(Product_.productType), "printer"));
----

By default, the `join` method defines an inner join. Outer joins are defined
by explicitly specifying a `JoinType` argument.

The following query uses a left outer join:

[source,java]
----
CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
Root<Customer> customer = q.from(Customer.class);
Join<Customer,Order> order = customer.join(Customer_.orders, JoinType.LEFT);
q.where(cb.equal(customer.get(Customer_.status), 1))
    .select(customer);
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT c FROM Customer c LEFT JOIN c.orders o WHERE c.status = 1
----

On-conditions can be specified for joins. The
following query uses an on-condition with a left outer join:

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Supplier> s = q.from(Supplier.class);
Join<Supplier, Product> p = s.join(Supplier_.products, JoinType.LEFT);
p.on(cb.equal(p.get(Product_.status), "inStock"));
q.groupBy(s.get(Supplier_.name));
q.multiselect(s.get(Supplier_.name), cb.count(p));
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT s.name, COUNT(p)
FROM Suppliers s LEFT JOIN s.products p ON p.status = 'inStock'
GROUP BY s.name
----

==== Fetch Joins

Fetch joins are specified by means of the
`fetch` method. The `fetch` method specifies that the referenced
association or attribute is to be fetched as a side effect of the
execution of the query. The `fetch` method can be applied to a `Root` or
`Join` instance.

An association or attribute referenced by the
`fetch` method must be referenced from an entity or embeddable that is
returned as the result of the query. A fetch join has the same join
semantics as the corresponding inner or outer join, except that the
related objects are not top-level objects in the query result and cannot
be referenced elsewhere by the query. See <<a4931>>.

The `fetch` method must not be used in a subquery.

Multiple levels of fetch joins are not
required to be supported by an implementation of this specification.
Applications that use multi-level fetch joins will not be portable.

*Example:*

[source,java]
----
CriteriaQuery<Department> q = cb.createQuery(Department.class);
Root<Department> d = q.from(Department.class);
d.fetch(Department.employees, JoinType.LEFT);
q.where(cb.equal(d.get(Department_.deptno), 1)).select(d);
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT d
FROM Department d LEFT JOIN FETCH d.employees
WHERE d.deptno = 1
----

==== Path Navigation [[a16277]]

A `Path` instance can be a `Root` instance, a
`Join` instance, a `Path` instance that has been derived from another
`Path` instance by means of the `get` navigation method, or a `Path`
instance derived from a map-valued association or element collection by
use of the `key` or `value` method.

When a criteria query is executed, path
navigation—like path navigation using the Jakarta Persistence query
language—is obtained using “inner join” semantics. That is, if the value
of a non-terminal `Path` instance is null, the path is considered to
have no value, and does not participate in the determination of the
query result. See <<a4792>>.

The `get` method is used for path navigation.
The argument to the `get` method is specified by the corresponding
`SingularAttribute` or collection-valued attribute
(`CollectionAttribute`, `SetAttribute`, `ListAttribute`, or
`MapAttribute`) of the corresponding metamodel
classfootnote:[Attribute names serve
this role for string-based queries. See <<a11349>>.].

*Example 1:*

In the following example, `ContactInfo` is an
embeddable class consisting of an address and set of phones. `Phone` is
an entity.

[source,java]
----
CriteriaQuery<Vendor> q = cb.createQuery(Vendor.class);
Root<Employee> emp = q.from(Employee.class);
Join<ContactInfo, Phone> phone =
    emp.join(Employee_.contactInfo).join(ContactInfo_.phones);
q.where(cb.equal(emp.get(Employee_.contactInfo)
        .get(ContactInfo_.address)
        .get(Address_.zipcode), "95054"))
    .select(phone.get(Phone_.vendor));
----

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT p.vendor
FROM Employee e JOIN e.contactInfo.phones p
WHERE e.contactInfo.address.zipcode = '95054'
----

*Example 2:*

In this example, the `photos` attribute
corresponds to a map from photo label to filename. The map key is a
string, the value an object. The result of this query will be returned
as a `Tuple` object whose elements are of types `String` and `Object`.
The `multiselect` method, described further in <<a10945>>, is used to
specify that the query returns multiple selection items.

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Item> item = q.from(Item.class);
MapJoin<Item, String, Object> photo = item.join(Item_.photos);
q.multiselect(item.get(Item_.name), photo)
    .where(cb.like(photo.key(), "%egret%"));
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT i.name, p
FROM Item i JOIN i.photos p
WHERE KEY(p) LIKE '%egret%'
----

==== Restricting the Query Result

The result of a query can be restricted by
specifying one or more predicate conditions. Restriction predicates are
applied to the `CriteriaQuery` object by means of the `where` method.
Invocation of the `where` method results in the modification of the
`CriteriaQuery` object with the specified restriction(s).

The argument to the `where` method can be
either an _Expression<Boolean>_ instance or zero or more `Predicate`
instances. A predicate can be either simple or compound.

A simple predicate is created by invoking one
of the conditional methods of the `CriteriaBuilder` interface, or by the
`isNull`, `isNotNull`, and `in` methods of the `Expression` interface.
The semantics of the conditional methods—e.g., `equal`, `notEqual`,
`gt`, `ge`, `lt`, `le`, `between`, and `like` — mirror those of the
corresponding Jakarta Persistence query language operators as described in
<<a4665>>.

Compound predicates are constructed by means
of the `and`, `or`, and `not` methods of the `CriteriaBuilder`
interface.

The restrictions upon the types to which
conditional operations are permitted to be applied are the same as the
respective operators of the Jakarta Persistence query language as described
in subsections <<a5066>> through <<a5243>>. The same
null value semantics as described in <<a5676>> and the subsections of
<<a4994>> apply.
The equality and comparison semantics described in <<a5735>> likewise apply.

*Example 1:*

[source,java]
----
CriteriaQuery<TransactionHistory> q = cb.createQuery(TransactionHistory.class);
Root<CreditCard> cc = q.from(CreditCard.class);
ListJoin<CreditCard,TransactionHistory> t = cc.join(CreditCard_.transactionHistory);
q.select(t)
    .where(cb.equal(cc.get(CreditCard_.customer)
             .get(Customer_.accountNum), 321987),
           cb.between (t.index(), 0, 9));
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT t
FROM CreditCard c JOIN c.transactionHistory t
WHERE c.customer.accountNum = 321987 AND INDEX(t) BETWEEN 0 AND 9
----

*Example 2:*

[source,java]
----
CriteriaQuery<Order> q = cb.createQuery(Order.class);
Root<Order> order = q.from(Order.class);
q.where(cb.isEmpty(order.get(Order_.lineItems)))
    .select(order);
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT o
FROM Order o
WHERE o.lineItems IS EMPTY
----

==== Downcasting

Downcasting by means of the `treat` method is
supported in joins and in the construction of `where` conditions.

*Example 1:*

[source,java]
----
CriteriaQuery<String> q = cb.createQuery(String.class);
Root<Order> order = q.from(Order.class);
Join<Order,Book> book = cb.treat(order.join(Order_.product), Book.class);
q.select(book.get(Book_.isbn));
----

This query is equivalent to the following
Jakarta Persistence query language query.

[source,sql]
----
SELECT b.ISBN
FROM Order o JOIN TREAT(o.product AS Book) b
----

*Example 2:*

[source,java]
----
CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
Root<Customer> customer = q.from(Customer.class);
Join<Customer, Order> order = customer.join(Customer_.orders);
q.where(
    cb.equal(cb.treat(order.get(Order_.product), Book.class).get(Book_.name), "Iliad"));
q.select(customer);
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT c
FROM Customer c JOIN c.orders o
WHERE TREAT(o.product AS Book).name = 'Iliad'
----

*Example 3:*

[source,java]
----
CriteriaQuery<Employee> q = cb.createQuery(Employee.class);
Root<Employee> e = q.from(Employee.class);
q.where(
    cb.or(cb.gt(cb.treat(e, Exempt.class).get(Exempt_.vacationDays), 10),
    cb.gt(cb.treat(e, Contractor.class).get(Contractor_.hours), 100)));
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT e
FROM Employee e
WHERE TREAT(e AS Exempt).vacationDays > 10
    OR TREAT(e AS Contractor).hours > 100
----

==== Expressions

An `Expression` or one of its subtypes can be
used in the construction of the query's select list or in the
construction of `where` or `having` method conditions.

Paths and boolean predicates are expressions.

Other expressions are created by means of the
methods of the `CriteriaBuilder` interface. The `CriteriaBuilder`
interface provides methods corresponding to the built-in arthmetic,
string, datetime, and case operators and functions of the Jakarta
Persistence query language.

*Example 1:*

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Customer> cust = q.from(Customer.class);
Join<Customer, Order> order = cust.join(Customer_.orders);
Join<Customer, Address> addr = cust.join(Customer_.address);
q.where(cb.equal(addr.get(Address_.state), "CA"),
        cb.equal(addr.get(Address_.county), "Santa Clara"));

q.multiselect(order.get(Order_.quantity),
        cb.prod(order.get(Order_.totalCost), 1.08),
        addr.get(Address_.zipcode));
----

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT o.quantity, o.totalCost*1.08, a.zipcode
FROM Customer c JOIN c.orders o JOIN c.address a
WHERE a.state = 'CA' AND a.county = 'Santa Clara'
----

*Example 2:*

[source,java]
----
CriteriaQuery<Employee> q = cb.createQuery(Employee.class);
Root<Employee> emp = q.from(Employee.class);
q.select(emp)
    .where(cb.notEqual(emp.type(), Exempt.class));
----

The `type` method can only be applied to a
path expression. Its result denotes the type navigated to by the path.

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT e
FROM Employee e
WHERE TYPE(e) <> Exempt
----

*Example 3:*

[source,java]
----
CriteriaQuery<String> q = cb.createQuery(String.class);
Root<Course> c = q.from(Course.class);
ListJoin<Course, Student> w = c.join(Course_.studentWaitlist);
q.where(cb.equal(c.get(Course_.name), "Calculus"),
        cb.equal(w.index(), 0))
 .select(w.get(Student_.name));
----

The `index` method can be applied to a
`ListJoin` object that corresponds to a list for which an order column
has been specified. Its result denotes the position of the item in the
list.

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT w.name
FROM Course c JOIN c.studentWaitlist w
WHERE c.name = 'Calculus' AND INDEX(w) = 0
----

*Example 4:*

[source,java]
----
CriteriaQuery<BigDecimal> q = cb.createQuery(BigDecimal.class);
Root<Order> order = q.from(Order.class);
Join<Order, Item> item = order.join(Order_.lineItems);
Join<Order, Customer> cust = order.join(Order_.customer);

q.where(
    cb.equal(cust.get(Customer_.lastName), "Smith"),
    cb.equal(cust.get(Customer_.firstName), "John"));
q.select(cb.sum(item.get(Item_.price)));
----

The aggregation methods `avg`, `max`, `min`
, `sum`, `count` can only be used in the construction of the select
list or in `having` method conditions.

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT SUM(i.price)
FROM Order o JOIN o.lineItems i JOIN o.customer c
WHERE c.lastName = 'Smith' AND c.firstName = 'John'
----

*Example 5:*

[source,java]
----
CriteriaQuery<Integer> q = cb.createQuery(Integer.class);
Root<Department> d = q.from(Department.class);
q
    .where(cb.equal(d.get(Department_.name), "Sales"))
    .select(cb.size(d.get(Department_.employees)));
----

The `size` method can be applied to a path
expression that corresponds to an association or element collection. Its
result denotes the number of elements in the association or element
collection.

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT SIZE(d.employees)
FROM Department d
WHERE d.name = 'Sales'
----

*Example 6:*

Both simple and general case expressions are
supported. The query below illustrates use of a general case expression.

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Employee> e = q.from(Employee.class);
q.where(
    cb.equal(e.get(Employee_.department).get(Department_.name), "Engineering"));
q.multiselect(
    e.get(Employee_.name),
    cb.selectCase()
        .when(
            cb.equal(e.get(Employee_.rating), 1),
            cb.prod(e.get(Employee_.salary), 1.1))
        .when(
            cb.equal(e.get(Employee_.rating), 2),
            cb.prod(e.get(Employee_.salary), 1.2))
        .otherwise(cb.prod(e.get(Employee_.salary), 1.01)));
----

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT e.name,
    CASE
        WHEN e.rating = 1 THEN e.salary * 1.1
        WHEN e.rating = 2 THEN e.salary * 1.2
        ELSE e.salary * 1.01
    END
FROM EMPLOYEE e
WHERE e.department.name = 'Engineering'
----

===== Result Types of Expressions

The `getJavaType` method, as defined in the
`TupleElement` interface, returns the runtime type of the object on
which it is invoked.

In the case of the `In`, `Case`,
`SimpleCase`, and `Coalesce` builder interfaces, the runtime results of
the `getJavaType` method may differ from the `Expression` type and may
vary as the expression is incrementally constructed. For non-numerical
operands, the implementation must return the most specific common
superclass of the types of the operands used to form the result.

In the case of the two-argument `sum`,
`prod`, `diff`, `quot`, `coalesce`, and `nullif` methods, and the
`In`, `Case`, `SimpleCase`, and `Coalesce` builder methods, the
runtime result types will differ from the `Expression` type when the
latter is `Number`. The following rules must be observed by the
implementation when materializing the results of numeric expressions
involving these methods. These rules correspond to those specified for
the Jakarta Persistence query language as defined in <<a5574>>.

* If there is an operand of type Double, the
result of the operation is of type Double;
* otherwise, if there is an operand of type
Float, the result of the operation is of type Float;
* otherwise, if there is an operand of type
BigDecimal, the result of the operation is of type BigDecimal;
* otherwise, if there is an operand of type
BigInteger, the result of the operation is of type BigInteger, unless
the method is `quot`, in which case the numeric result type is not
further defined;
* otherwise, if there is an operand of type
Long, the result of the operation is of type Long, unless the method is
`quot`, in which case the numeric result type is not further defined;
* otherwise, if there is an operand of integral
type, the result of the operation is of type Integer, unless the method
is `quot`, in which case the numeric result type is not further
defined.

[NOTE]
====
Users should note that the semantics of the
SQL division operation are not standard across databases. In particular,
when both operands are of integral types, the result of the division
operation will be an integral type in some databases, and an
non-integral type in others. Portable applications should not assume a
particular result type.
====

==== Literals

An `Expression` literal instance is obtained
by passing a value to the `literal` method of the `CriteriaBuilder`
interface. An `Expression` instance representing a null is created by
the `nullLiteral` method of the `CriteriaBuilder` interface.

*Example:*

[source,java]
----
CriteriaQuery<String> q = cb.createQuery(String.class);
Root<Employee> emp = q.from(Employee.class);
Join<Employee, FrequentFlierPlan> fp = emp.join(Employee_.frequentFlierPlan);

q.select(
    cb.<String>selectCase()
        .when(
            cb.gt(fp.get(FrequentFlierPlan_.annualMiles), 50000),
            cb.literal("Platinum"))
        .when(
            cb.gt(fp.get(FrequentFlierPlan_.annualMiles), 25000),
            cb.literal("Silver"))
        .otherwise(cb.nullLiteral(String.class)));
----

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT
    CASE
        WHEN fp.annualMiles > 50000 THEN 'Platinum'
        WHEN fp.annualMiles > 25000 THEN 'Gold'
        ELSE NULL
    END
----

==== Parameter Expressions

A `ParameterExpression` instance is an
expression that corresponds to a parameter whose value will be supplied
before the query is executed. Parameter expressions can only be used in
the construction of conditional predicates.

*Example:*

[source,java]
----
CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
Root<Customer> c = q.from(Customer.class);
ParameterExpression<Integer> param = cb.parameter(Integer.class);

q.select(c)
    .where(cb.equal(c.get(Customer_.status), param));
----

If a name is supplied when the
`ParameterExpression` instance is created, the parameter may also be
treated as a named parameter when the query is executed:

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

[source,java]
----
Root<Customer> c = q.from(Customer.class);
ParameterExpression<Integer> param = cb.parameter(Integer.class, "stat");
q.select(c).where(cb.equal(c.get(Customer_.status), param));
----

This is equivalent to the following query in
the Jakarta Persistence query language:

[source,sql]
----
SELECT c FROM Customer c WHERE c.status = :stat
----

==== Specifying the Select List [[a10945]]

The select list of a query is specified by
use of the `select` or `multiselect` methods of the `CriteriaQuery`
interface. The arguments to the `select` and `multiselect` methods are
`Selection` instances.

[NOTE]
====
Portable applications should use the `select`
or `multiselect` method to specify the query's selection list.
Applications that do not use one of these methods will not be portable.
====

The `select` method takes a single
`Selection` argument, which can be either an `Expression` instance or a
`CompoundSelection` instance. The type of the `Selection` item must be
assignable to the defined `CriteriaQuery` result type, as described in
<<a10621>>.

The `construct`, `tuple` and `array` methods
of the `CriteriaBuilder` interface are used to aggregate multiple
selection items into a `CompoundSelection` instance.

The `multiselect` method also supports the
specification and aggregation of multiple selection items. When the
`multiselect` method is used, the aggregation of the selection items is
determined by the result type of the `CriteriaQuery` object as described
in <<a10621>> and <<a8857>>.

A `Selection` instance passed to the
`construct`, `tuple`, `array`, or `multiselect` methods can be one of
the following:

* An `Expression` instance.
* A `Selection` instance obtained as the result
of the invocation of the _CriteriaBuilder construct_ method.

The `distinct` method of the `CriteriaQuery`
interface is used to specify that duplicate values must be eliminated
from the query result. If the `distinct` method is not used or
`distinct(false)` is invoked on the criteria query object, duplicate
values are not eliminated. When `distinct(true)` is used, and the select
items include embeddable objects or map entry results, the elimination
of duplicates is undefined.

The semantics of the `construct` method used
in the selection list is as described in <<a5500>>. The semantics of embeddables returned by the selection list areas described in <<a5511>>.

*Example 1:*

In the following example, `videoInventory` is
a Map from the entity `Movie` to the number of copies in stock.

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<VideoStore> v = q.from(VideoStore.class);
MapJoin<VideoStore, Movie, Integer> inv = v.join(VideoStore_.videoInventory);

q.multiselect(
    v.get(VideoStore_.location).get(Address_.street),
    inv.key().get(Movie_.title),
    inv);
q.where(cb.equal(v.get(VideoStore_.location).get(Address_.zipcode), "94301"),
        cb.gt(inv, 0));
----

This query is equivalent to the following, in
which the `tuple` method is used:

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<VideoStore> v = q.from(VideoStore.class);
MapJoin<VideoStore, Movie, Integer> inv = v.join(VideoStore_.videoInventory);

q.select(cb.tuple(
        v.get(VideoStore_.location).get(Address_.street),
        inv.key().get(Movie_.title),
        inv));
q.where(cb.equal(v.get(VideoStore_.location).get(Address_.zipcode), "94301"),
        cb.gt(inv, 0));
----

Both are equivalent to the following Jakarta
Persistence query language query:

[source,sql]
----
SELECT v.location.street, KEY(i).title, VALUE(i)
FROM VideoStore v JOIN v.videoInventory i
WHERE v.location.zipcode = '94301' AND VALUE(i) > 0
----

Example 2:

The following two queries are equivalent to
the Jakarta Persistence query language query above. Because the result type
is not specified by the `createQuery` method, an `Object[]` is
returned as a result of the query execution:

[source,java]
----
CriteriaQuery<Object> q = cb.createQuery();
Root<VideoStore> v = q.from(VideoStore.class);
MapJoin<VideoStore, Movie, Integer> inv = v.join(VideoStore_.videoInventory);

q.multiselect(
    v.get(VideoStore_.location).get(Address_.street),
    inv.key().get(Movie_.title),
    inv);

q.where(cb.equal(v.get(VideoStore_.location).get(Address_.zipcode), "94301"),
        cb.gt(inv, 0));
----

Equivalently:

[source,java]
----
CriteriaQuery<Object> q = cb.createQuery();
Root<VideoStore> v = q.from(VideoStore.class);
MapJoin<VideoStore, Movie, Integer> inv = v.join(VideoStore_.videoInventory);

q.select(cb.array(
        v.get(VideoStore_.location).get(Address_.street),
        inv.key().get(Movie_.title),
        inv));
q.where(cb.equal(v.get(VideoStore_.location).get(Address_.zipcode), "94301"),
        cb.gt(inv, 0));
----

Example 3:

The following example illustrates the
specification of a constructor.

[source,java]
----
CriteriaQuery<CustomerDetails> q = cb.createQuery(CustomerDetails.class);
Root<Customer> c = q.from(Customer.class);
Join<Customer, Order> o = c.join(Customer_.orders);

q.where(cb.gt(o.get(Order_.quantity), 100));
q.select(cb.construct(
        CustomerDetails.class,
        c.get(Customer_.id),
        c.get(Customer_.status),
        o.get(Order_.quantity)));
----

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT NEW com.acme.example.CustomerDetails(c.id, c.status, o.quantity)
FROM Customer c JOIN c.orders o
WHERE o.quantity > 100
----

===== Assigning Aliases to Selection Items

The `alias` method of the `Selection`
interface can be used to assign an alias to a selection item. The alias
may then later be used to extract the corresponding item from the query
result when the query is executed. The `alias` method assigns the given
alias to the `Selection` item. Once assigned, the alias cannot be
changed.

Example:

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Customer> c = q.from(Customer.class);
Join<Customer, Order> o = c.join(Customer_.orders);
Join<Customer, Address> a = c.join(Customer_.address);

q.where(cb.equal(c.get(Customer_.id), 97510));
q.multiselect(
        o.get(Order_.quantity).alias("quantity"),
        cb.prod(o.get(Order_.totalCost), 1.08).alias("taxedCost"),
        a.get(Address_.zipcode).alias("zipcode"));

TypedQuery<Tuple> typedQuery = em.createQuery(q);
Tuple result = typedQuery.getSingleResult();
Double cost = (Double)result.get("taxedCost");
----

==== Subqueries

Both correlated and non-correlated subqueries
can be used in restriction predicates. A subquery is constructed through
the creation and modification of a `Subquery` object.

A `Subquery` instance can be passed as an
argument to the `all`, `any`, or `some` methods of the
`CriteriaBuilder` interface for use in conditional expressions.

A `Subquery` instance can be passed to the
`CriteriaBuilder` `exists` method to create a conditional predicate.

*Example 1: Non-correlated subquery*

The query below contains a non-correlated
subquery. A non-correlated subquery does not reference objects of the
query of which it is a subquery. In particular, `Root`, `Join`, and
`Path` instances are not shared between the subquery and the criteria
query instance of which it is a subquery.

[source,java]
----
// create criteria query instance, with root Customer
CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
Root<Customer> goodCustomer = q.from(Customer.class);

// create subquery instance, with root Customer
// the Subquery object is typed according to its return type
Subquery<Double> sq = q.subquery(Double.class);
Root<Customer> customer = sq.from(Customer.class);

// the result of the first query depends on the subquery
q.where(cb.lt(
    goodCustomer.get(Customer_.balanceOwed),
    sq.select(cb.avg(customer.get(Customer_.balanceOwed)))));
q.select(goodCustomer);
----

This query corresponds to the following Jakarta
Persistence query language query.

[source,sql]
----
SELECT goodCustomer
FROM Customer goodCustomer
WHERE goodCustomer.balanceOwed < (SELECT AVG(c.balanceOwed) FROM Customer c)
----

*Example 2: Correlated subquery*

[source,java]
----
// create CriteriaQuery instance, with root Employee
CriteriaQuery<Employee> q = cb.createQuery(Employee.class);
Root<Employee> emp = q.from(Employee.class);

// create Subquery instance, with root Employee
Subquery<Employee> sq = q.subquery(Employee.class);
Root<Employee> spouseEmp = sq.from(Employee.class);

// the subquery references the root of the containing query
sq.where(cb.equal(spouseEmp, emp.get(Employee_.spouse)))
    .select(spouseEmp);

// an exists condition is applied to the subquery result:
q.where(cb.exists(sq));
q.select(emp).distinct(true);
----

The above query corresponds to the following
Jakarta Persistence query language query.

[source,sql]
----
SELECT DISTINCT emp
FROM Employee emp
WHERE EXISTS (
    SELECT spouseEmp
    FROM Employee spouseEmp
    WHERE spouseEmp = emp.spouse)
----

*Example 3: Subquery qualified by all()*

[source,java]
----
// create CriteriaQuery instance, with root Employee
CriteriaQuery<Employee> q = cb.createQuery(Employee.class);
Root<Employee> emp = q.from(Employee.class);

// create Subquery instance, with root Manager
Subquery<BigDecimal> sq = q.subquery(BigDecimal.class);
Root<Manager> manager = sq.from(Manager.class);

sq.select(manager.get(Manager_.salary));
sq.where(cb.equal(
    manager.get(Manager_.department),
    emp.get(Employee_.department)));

// an all expression is applied to the subquery result
q.select(emp)
    .where(cb.gt(emp.get(Employee_.salary), cb.all(sq)));
----

This query corresponds to the following Jakarta
Persistence query language query:

[source,sql]
----
SELECT emp
FROM Employee emp
WHERE emp.salary > ALL (
    SELECT m.salary
    FROM Manager m
    WHERE m.department = emp.department)
----

*Example 4: A Special case*

In order to express some correlated
subqueries involving unidirectional relationships, it may be useful to
correlate the domain of the subquery with the domain of the containing
query. This is performed by using the `correlate` method of the
`Subquery` interface.

For example:

[source,java]
----
CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
Root<Customer> customer = q.from(Customer.class);
Subquery<Long> sq = q.subquery(Long.class);
Root<Customer> customerSub = sq.correlate(customer);
Join<Customer,Order> order = customerSub.join(Customer_.orders);

q.where(cb.gt(sq.select(cb.count(order)), 10))
    .select(customer);
----

This query corresponds to the following Jakarta
Persistence query language query:

[source,sql]
----
SELECT c
FROM Customer c
WHERE (SELECT COUNT(o) FROM c.orders o) > 10
----

Note that joins involving the derived
subquery root do not affect the join conditions of the containing query.
The following two query definitions thus differ in semantics:

[source,java]
----
CriteriaQuery<Order> q = cb.createQuery(Order.class);
Root<Order> order = q.from(Order.class);
Subquery<Integer> sq = q.subquery(Integer.class);
Root<Order> orderSub = sq.correlate(order);
Join<Order,Customer> customer = orderSub.join(Order_.customer);
Join<Customer,Account> account = customer.join(Customer_.accounts);

sq.select(account.get(Account_.balance));
q.where(cb.lt(cb.literal(10000), cb.all(sq)));
----

and

[source,java]
----
CriteriaQuery<Order> q = cb.createQuery(Order.class);
Root<Order> order = q.from(Order.class);
Join<Order,Customer> customer = order.join(Order_.customer);
Subquery<Integer> sq = q.subquery(Integer.class);
Join<Order,Customer> customerSub = sq.correlate(customer);
Join<Customer,Account> account = customerSub.join(Customer_.accounts);

sq.select(account.get(Account_.balance));
q.where(cb.lt(cb.literal(10000), cb.all(sq)));
----

The first of these queries will return orders
that are not associated with customers, whereas the second will not. The
corresponding Jakarta Persistence query language queries are the following:

[source,sql]
----
SELECT o
FROM Order o
WHERE 10000 < ALL (
    SELECT a.balance
    FROM o.customer c JOIN c.accounts a)
----

and

[source,sql]
----
SELECT o
FROM Order o JOIN o.customer c
WHERE 10000 < ALL (
    SELECT a.balance
    FROM c.accounts a)
----

==== GroupBy and Having

The `groupBy` method of the `CriteriaQuery`
interface is used to define a partitioning of the query results into
groups. The `having` method of the `CriteriaQuery` interface can be used
to filter over the groups.

The arguments to the `groupBy` method are
`Expression` instances.

When the `groupBy` method is used, each
selection item that is not the result of applying an aggregate method
must correspond to a path expression that is used for defining the
grouping. Requirements on the types that correspond to the elements of
the grouping and having constructs and their relationship to the select
items are as specified in <<a5410>>.

*Example:*

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Customer> customer = q.from(Customer.class);

q.groupBy(customer.get(Customer_.status));
q.having(cb.in(customer.get(Customer_.status)).value(1).value(2));
q.select(cb.tuple(
        customer.get(Customer_.status),
        cb.avg(customer.get(Customer_.filledOrderCount)),
        cb.count(customer)));
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT c.status, AVG(c.filledOrderCount), COUNT(c)
FROM Customer c
GROUP BY c.status
HAVING c.status IN (1, 2)
----

==== Ordering the Query Results

The ordering of the results of a query is
defined by use of the `orderBy` method of the `CriteriaQuery` instance.
The arguments to the `orderBy` method are `Order` instances.

An `Order` instance is created by means of
the `asc` and `desc` methods of the `CriteriaBuilder` interface. An
argument to either of these methods must be one of the following:

* Any `Expression` instance that corresponds to
an orderable state field of an entity or embeddable class abstract
schema type that is specified as an argument to the `select` or
`multiselect` method or that is an argument to a tuple or array
constructor that is passed as an argument to the `select` method.
* Any `Expression` instance that corresponds to
the same state field of the same entity or embeddable abstract schema
type as an `Expression` instance that is specified as an argument to the
`select` or `multiselect` method or that is an argument to a tuple or
array constructor that is passed as an argument to the `select` method.
* An `Expression` instance that is specified as
an argument to the `select` or `multiselect` method or that is an
argument to a tuple or array constructor that is passed as an argument
to the `select` method or that is semantically equivalent to such an
`Expression` instance.

If more than one `Order` instance is
specified, the order in which they appear in the argument list of the
`orderBy` method determines the precedence, whereby the first item has
highest precedence.

SQL rules for the ordering of null values
apply, as described in <<a5587>>.

*Example 1:*

[source,java]
----
CriteriaQuery<Order> q = cb.createQuery(Order.class);
Root<Customer> c = q.from(Customer.class);
Join<Customer,Order> o = c.join(Customer_.orders);
Join<Customer,Address> a = c.join(Customer_.address);

q.where(cb.equal(a.get(Address_.state), "CA"));
q.select(o);
q.orderBy(cb.desc(o.get(Order_.quantity)),
    cb.asc(o.get(Order_.totalCost)));
----

This query corresponds to the following Jakarta
Persistence query language query:

[source,sql]
----
SELECT o
FROM Customer c JOIN c.orders o JOIN c.address a
WHERE a.state = 'CA'
ORDER BY o.quantity DESC, o.totalcost
----

*Example 2:*

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Customer> c = q.from(Customer.class);
Join<Customer, Order> o = c.join(Customer_.orders);
Join<Customer, Address> a = c.join(Customer_.address);

q.where(cb.equal(a.get(Address_.state), "CA"));
q.orderBy(cb.asc(o.get(Order_.quantity)),
    cb.asc(a.get(Address_.zipcode)));
q.multiselect(o.get(Order_.quantity),
    a.get(Address_.zipcode));
----

This query corresponds to the following Jakarta
Persistence query language query:

[source,sql]
----
SELECT o.quantity, a.zipcode
FROM Customer c JOIN c.orders o JOIN c.address a
WHERE a.state = 'CA'
ORDER BY o.quantity, a.zipcode
----

It can be equivalently expressed as follows:

[source,java]
----
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Customer> c = q.from(Customer.class);
Join<Customer, Order> o = c.join(Customer_.orders);
Join<Customer, Address> a = c.join(Customer_.address);

q.where(cb.equal(a.get(Address_.state), "CA"));
q.orderBy(cb.asc(o.get(Order_.quantity)),
    cb.asc(a.get(Address_.zipcode)));
q.select(cb.tuple(o.get(Order_.quantity),
    a.get(Address_.zipcode)));
----

*Example 3:*

[source,java]
----
CriteriaQuery<Object[]> q = cb.createQuery(Object[].class);
Root<Customer> c = q.from(Customer.class);
Join<Customer, Order> o = c.join(Customer_.orders);
Join<Customer, Address> a = c.join(Customer_.address);

q.where(cb.equal(a.get(Address_.state), "CA"),
    cb.equal(a.get(Address_.county), "Santa Clara"));
q.select(cb.array(o.get(Order_.quantity),
    cb.prod(o.get(Order_.totalCost), 1.08),
    a.get(Address_.zipcode)));
q.orderBy(cb.asc(o.get(Order_.quantity)),
    cb.asc(cb.prod(o.get(Order_.totalCost), 1.08)),
    cb.asc(a.get(Address_.zipcode)));
----

This query corresponds to the following Jakarta
Persistence query language query:

[source,sql]
----
SELECT o.quantity, o.totalCost * 1.08 AS taxedCost, a.zipcode
FROM Customer c JOIN c.orders o JOIN c.address a
WHERE a.state = 'CA' AND a.county = 'Santa Clara'
ORDER BY o.quantity, taxedCost, a.zipcode
----

==== Bulk Update and Delete Operations [[a11239]]

A bulk update query is constructed through
the creation and modification of a
`jakarta.persistence.criteria.CriteriaUpdate` object.

A `CriteriaUpdate` object is created by means
of one of the `createCriteriaUpdate` methods of the `CriteriaBuilder`
interface. A `CriteriaUpdate` object is typed according to the entity
type that is the target of the update. A `CriteriaUpdate` object has a
single root, the entity that is being updated.

A bulk delete query is constructed through
the creation and modification of a
`jakarta.persistence.criteria.CriteriaDelete` object.

A `CriteriaDelete` object is created by means
of one of the `createCriteriaDelete` methods of the `CriteriaBuilder`
interface. A `CriteriaDelete` object is typed according to the entity
type that is the target of the delete. A `CriteriaDelete` object has a
single root, the entity that is being deleted.

*Example 1:*

[source,java]
----
CriteriaUpdate<Customer> q = cb.createCriteriaUpdate(Customer.class);
Root<Customer> c = q.from(Customer.class);

q.set(c.get(Customer_.status), "outstanding")
    .where(cb.lt(c.get(Customer_.balance), 10000));
----

The following Jakarta Persistence query language
update statement is equivalent.

[source,sql]
----
UPDATE Customer c
SET c.status = 'outstanding'
WHERE c.balance < 10000
----

*Example 2:*

[source,java]
----
CriteriaUpdate<Employee> q = cb.createCriteriaUpdate(Employee.class);
Root<Employee> e = q.from(Employee.class);

q.set(e.get(Employee_.address).get(Address_.building), 22)
    .where(
        cb.equal(e.get(Employee_.address).get(Address_.building), 14),
        cb.equal(e.get(Employee_.address).get(Address_.city), "Santa Clara"),
        cb.equal(e.get(Employee_.project).get(Project_.name), "Jakarta EE"));
----

`Address` is an embeddable class. Note that
updating across implicit joins is not supported.

The following Jakarta Persistence query language
update statement is equivalent.

[source,sql]
----
UPDATE Employee e
SET e.address.building = 22
WHERE e.address.building = 14
    AND e.address.city = 'Santa Clara'
    AND e.project.name = 'Jakarta EE'
----

*Example 3:*

The following update query causes multiple
attributes to be updated.

[source,java]
----
CriteriaUpdate<Employee> q = cb.createCriteriaUpdate(Employee.class);
Root<Employee> e = q.from(Employee.class);

q.set(e.get(Employee_.salary), cb.prod(e.get(Employee_.salary), 1.1f))
    .set(e.get(Employee_.commission), cb.prod(e.get(Employee_.commission), 1.1f))
    .set(e.get(Employee_.bonus), cb.sum(e.get(Employee_.bonus), 5000))
    .where(cb.equal(e.get(Employee_.dept).get(Department_.name), "Sales"));
----

The following Jakarta Persistence query language
update statement is equivalent.

[source,sql]
----
UPDATE Employee e
SET e.salary = e.salary * 1.1,
    e.commission = e.commission * 1.1,
    e.bonus = e.bonus + 5000
WHERE e.dept.name = 'Sales'
----

*Example 4:*

[source,java]
----
CriteriaDelete<Customer> q = cb.createCriteriaDelete(Customer.class);
Root<Customer> c = q.from(Customer.class);

q.where(
    cb.equal(c.get(Customer_.status), "inactive"),
    cb.isEmpty(c.get(Customer_.orders)));
----

The following Jakarta Persistence query language
delete statement is equivalent.

[source,sql]
----
DELETE
FROM Customer c
WHERE c.status = 'inactive'
    AND c.orders IS EMPTY
----

Like bulk update and delete operations made
through the Jakarta Persistence query language, criteria API bulk update
and delete operations map directly to database operations, bypassing any
optimistic locking checks. Portable applications using bulk update
operations must manually update the value of the version column, if
desired, and/or manually validate the value of the version column.

The persistence context is not synchronized
with the result of the bulk update or delete. See <<a5636>>.

=== Constructing Strongly-typed Queries using the jakarta.persistence.metamodel Interfaces [[a11305]]

Strongly-typed queries can also be
constructed, either statically or dynamically, in the absence of
generated metamodel classes. The `jakarta.persistence.metamodel`
interfaces are used to access the metamodel objects that correspond to
the managed classes.

The following examples illustrate this
approach. These are equivalent to the example queries shown in <<a16277>>.

The `Metamodel` interface is obtained from
the EntityManager or EntityManagerFactory for the persistence unit, and
then used to obtain the corresponding metamodel objects for the managed
types referenced by the queries.

Example 1:

[source,java]
----
EntityManager em = ...;

Metamodel mm = em.getMetamodel();
EntityType<Employee> emp_ =mm.entity(Employee.class);
EmbeddableType<ContactInfo> cinfo_ = mm.embeddable(ContactInfo.class);
EntityType<Phone> phone_ = mm.entity(Phone.class);
EmbeddableType<Address> addr_ = mm.embeddable(Address.class);

CriteriaQuery<Vendor> q = cb.createQuery(Vendor.class);
Root<Employee> emp = q.from(Employee.class);
Join<Employee, ContactInfo> cinfo =
    emp.join(emp_.getSingularAttribute("contactInfo", ContactInfo.class));
Join<ContactInfo, Phone> p =
    cinfo.join(cinfo_.getSingularAttribute("phones", Phone.class));
q.where(
    cb.equal(emp.get(emp_.getSingularAttribute("contactInfo", ContactInfo.class))
        .get(cinfo_.getSingularAttribute("address", Address.class))
        .get(addr_.getSingularAttribute("zipcode", String.class)), "95054"))
    .select(p.get(phone_.getSingularAttribute("vendor",Vendor.class)));
----

Example 2:

[source,java]
----
EntityManager em = ...;
Metamodel mm = em.getMetamodel();

EntityType<Item> item_ = mm.entity(Item.class);
CriteriaQuery<Tuple> q = cb.createTupleQuery();
Root<Item> item = q.from(Item.class);
MapJoin<Item, String, Object> photo =
    item.join(item_.getMap("photos", String.class, Object.class));
q.multiselect(
    item.get(item_.getSingularAttribute("name", String.class)), photo)
        .where(cb.like(photo.key(), "%egret%"));
----

=== Use of the Criteria API with Strings to Reference Attributes [[a11349]]

The Criteria API provides the option of
specifying the attribute references used in joins and navigation by
attribute names used as arguments to the various `join`, `fetch`, and
`get` methods.

The resulting queries have the same semantics
as described in <<a10614>>, but do not provide the same level of type safety.

The examples in this section illustrate this
approach. These examples are derived from among those of sections
<<a10643>> and <<a16277>>.

*Example 1:*

[source,java]
----
CriteriaBuilder cb = ...
CriteriaQuery<String> q = cb.createQuery(String.class);
Root<Customer> cust = q.from(Customer.class);
Join<Order, Item> item = cust.join("orders").join("lineItems");
q.select(cust.<String>get("name"))
    .where(cb.equal(item.get("product").get("productType"), "printer"));
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT c.name
FROM Customer c JOIN c.orders o JOIN o.lineItems i
WHERE i.product.productType = 'printer'
----

It is not required that type parameters be
used. However, their omission may result in compiler warnings, as with
the below version of the same query:

[source,java]
----
CriteriaBuilder cb = ...
CriteriaQuery q = cb.createQuery();
Root cust = q.from(Customer.class);
Join item = cust.join("orders").join("lineItems");
q.select(cust.get("name")).where(
    cb.equal(item.get("product").get("productType"),"printer"));
----

*Example 2:*

The following query uses an outer join:

[source,java]
----
CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
Root<Customer> cust = q.from(Customer.class);
Join<Customer,Order> order = cust.join("orders", JoinType.LEFT);
q.where(cb.equal(cust.get("status"), 1))
    .select(cust);
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT c FROM Customer c LEFT JOIN c.orders o
WHERE c.status = 1
----

*Example 3:*

In the following example, `ContactInfo` is an
embeddable class consisting of an address and set of phones. `Phone` is
an entity.

[source,java]
----
CriteriaQuery<Vendor> q = cb.createQuery(Vendor.class);
Root<Employee> emp = q.from(Employee.class);
Join<ContactInfo, Phone> phone = emp.join("contactInfo").join("phones");
q.where(cb.equal(emp.get("contactInfo")
    .get("address")
    .get("zipcode"), "95054"));
q.select(phone.<Vendor>get("vendor"));
----

The following Jakarta Persistence query language
query is equivalent:

[source,sql]
----
SELECT p.vendor
FROM Employee e JOIN e.contactInfo.phones p
WHERE e.contactInfo.address.zipcode = '95054'
----

*Example 4:*

In this example, the `photos` attribute
corresponds to a map from photo label to filename. The map key is a
string, the value an object.

[source,java]
----
CriteriaQuery<Object> q = cb.createQuery();
Root<Item> item = q.from(Item.class);
MapJoin<Item, String, Object> photo = item.joinMap("photos");
q.multiselect(item.get("name"), photo)
    .where(cb.like(photo.key(), "%egret%"));
----

This query is equivalent to the following
Jakarta Persistence query language query:

[source,sql]
----
SELECT i.name, p
FROM Item i JOIN i.photos p
WHERE KEY(p) LIKE '%egret%'
----

=== Query Modification [[a11413]]

A `CriteriaQuery`, `CriteriaUpdate`, or
`CriteriaDelete` object may be modified, either before or after `Query`
or `TypedQuery` objects have been created and executed from it. For
example, such modification may entail replacement of the `where`
predicate or the `select` list. Modifications may thus result in the
same query object “base” being reused for several query instances.

For example, the user might create and
execute a query from the following `CriteriaQuery` object:

[source,java]
----
CriteriaQuery<Customer> q = cb.createQuery(Customer.class);
Root<Customer> c = q.from(Customer.class);

Predicate pred = cb.equal(c.get(Customer_.address).get(Address_.city),"Chicago");

q.select(c);
q.where(pred);
----

The `CriteriaQuery` object might then be
modified to reflect a different predicate condition, for example:

[source,java]
----
Predicate pred2 = cb.gt(c.get(Customer_.balanceOwed), 1000);
q.where(pred2);
----

Note, however, that query elements—-in this
example, predicate conditions—are dependent on the `CriteriaQuery`,
`CriteriaUpdate`, or `CriteriaDelete` instance, and are thus not
portably reusable with different instances.

=== Query Execution [[a11427]]

A criteria query is executed by passing the
`CriteriaQuery`, `CriteriaUpdate`, or `CriteriaDelete` object to the
`createQuery` method of the `EntityManager` interface to create an
executable `TypedQuery` object (or, in the case of `CriteriaUpdate` and
`CriteriaDelete`, a `Query` object), which can then be passed to one of
the query execution methods of the `TypedQuery` or `Query` interface.

A `CriteriaQuery`, `CriteriaUpdate`, or
`CriteriaDelete` object may be further modified after an executable
query object has been created from it. The modification of the
`CriteriaQuery`, `CriteriaUpdate`, or `CriteriaDelete` object does not
have any impact on the already created executable query object. If the
modified `CriteriaQuery`, `CriteriaUpdate`, or `CriteriaDelete` object
is passed to the `createQuery` method, the persistence provider must
insure that a new executable query object is created and returned that
reflects the semantics of the changed query definition.

`CriteriaQuery`, `CriteriaUpdate`, and
`CriteriaDelete` objects must be serializable. A persistence vendor is
required to support the subsequent deserialization of such an object
into a separate JVM instance of that vendor's runtime, where both
runtime instances have access to any required vendor implementation
classes. `CriteriaQuery`, `CriteriaUpdate`, and `CriteriaDelete`
objects are not required to be interoperable across vendors.