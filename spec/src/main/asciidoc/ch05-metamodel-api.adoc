//
// Copyright (c) 2017, 2020 Contributors to the Eclipse Foundation
//

== Metamodel API [[a6072]]

This specification provides a set of interfaces for dynamically accessing
a metamodel representing the managed classes of a persistence unit.
Instances of metamodel types may be obtained either:

- via programmatic lookup using an instance of the interface `Metamodel`
  (found in <<_metamodel_>>) obtained from the `EntityManagerFactory` or
  `EntityManager` by calling `getMetamodel()`, or
- in a typesafe way, using _static metamodel classes_.

A static metamodel class is a class with static members providing direct
typesafe access to metamodel objects representing the persistent members
of a given managed class.

=== Static Metamodel Classes [[a6933]]

A set of static metamodel classes corresponding to the managed classes of
a persistence unit can be generated using an annotation processor or may
be created by the application developer.

In the typical case, an annotation processor is used to generate static
metamodel classes corresponding to the entities, mapped superclasses,
and embeddable classes in the persistence unit. A static metamodel class
models the persistent state and relationships of the corresponding managed
class. For portability, an annotation processor should generate a _canonical
metamodel_ as specified in the next section.

This canonical metamodel also includes elements for classes and interfaces
with members annotated with the `@StaticQuery` or `@StaticNativeQuery`
annotations found in <<static-query-api>>.

==== Canonical Metamodel

The canonical metamodel classes must be generated by the annotation
processor with the standard structure specified below. The annotation
processor might generate additional program elements, but it must at
minimum generate the program elements specified here. Applications which
require portability between different annotation processors should avoid
the use of generated program elements other than those defined by this
specification.

A class is considered _eligible_ for generation of a metamodel class if
it belongs to the persistence unit and:

- is a managed class (an entity class, embeddable class, or mapped
  superclass), or
- has a method or field annotated with one of the two static query
  annotations, `@StaticQuery` or `@StaticNativeQuery`, as defined in
  <<static-query-api>>.

For every eligible class in the persistence unit, a corresponding metamodel
class is generated as follows:

* For each eligible class `X` in package `p`, a metamodel class `X_` is
  created in the package `p`.footnote:[We might provide the option of a
  different package in a future release of this specification.] The name
  of the metamodel class is derived from the name of the eligible class
  by appending "`_`" to the name of the eligible class.

* The metamodel class `X_` must be annotated with the `StaticMetamodel`
  annotation found in <<_staticmetamodel_>>.footnote:[If the class was
  generated, it should also be annotated with either
  `javax.annotation.processing.Generated` or `jakarta.annotation.Generated`.
  The occurrence of any other annotations on static metamodel classes is
  undefined.]

The metamodel class for a managed class `X` is generated as follows:

* If a managed class `X` extends another class `S`, where `S` is the most
derived managed class extended by `X`, then the metamodel class `X_` must
extend the metamodel  class `S_` created for `S`.

* The metamodel class for a managed class must contain a field declaration
as follows:
+
[source,java]
----
public static volatile jakarta.persistence.metamodel.T<X> class_;
----
+
where `T` is `EntityType`, `EmbeddableType`, or `MappedSuperclassType`
depending on whether `X` is an entity, embeddable, or mapped superclass.

* For every persistent attribute `y` declared by a managed class `X`,
the metamodel class must contain a field declaration as follows:
+
[source,java]
----
public static final String Y = "y";
----
+
where the field name `Y` is obtained by transforming each lowercase
character in the attribute name `y` to uppercase, inserting an
underscore if the character following the transformed character
is uppercase, and then replacing each character which is not
a legal Java identifier character with an underscore.

* For every persistent non-collection-valued attribute `y` declared by
`X`, where the type of `y` is `Y`, the metamodel class must contain a
declaration as follows:
+
[source,java]
----
public static volatile SingularAttribute<X, Y> y;
----

* For every persistent collection-valued attribute `z` declared by class
`X`, where the element type of `z` is `Z`, the metamodel class must contain
a declaration as follows:
** if the collection type of `z` is `java.util.Collection`, then
+
[source,java]
----
public static volatile CollectionAttribute<X, Z> z;
----
+
** if the collection type of `z` is `java.util.Set`, then
+
[source,java]
----
public static volatile SetAttribute<X, Z> z;
----
+
** if the collection type of `z` is `java.util.List`, then
+
[source,java]
----
public static volatile ListAttribute<X, Z> z;
----
+
** if the collection type of `z` is `java.util.Map`, then
+
[source,java]
----
public static volatile MapAttribute<X, K, Z> z;
----
+
where `K` is the type of the key of the map in class `X`

The metamodel class for any eligible class `X` is generated as follows:

* For every method `m` of return type `R` and with parameters `p1`, `p2`,
etc., of types `T1`, `T2`, etc., annotated with a static query annotation,
the metamodel class must contain a declaration as follows:
+
[source,java]
----
public static TypedQueryReference<R> m(T1 p1, T2 p2, ...) {
    return new StaticQueryReference(
            "X.m",
            X.class,
            "m",
            R.class,
            List.of(T1.class, T2.class, ... ),
            List.of("p1", "p2", ... ),
            List.of(p1, p2, ... ),
            Map.of("h1", v1, "h2", v2, ...),
            o1, o2, o3, ...
    );
}
----
+
where (`h1`, `v1`), (`h2`, `v2`), etc., are `hints` and `o1`, `o2`, etc.,
are options specified by any `@ReadQueryOptions` or `@WriteQueryOptions`
annotation of `m`. If the annotated method has more parameters than the
query specified by the annotation `value` member, the annotation processor
is permitted to ignore the method parameters which do not correspond to
parameters of the query, but this behavior is not required and is not
portable between different processors.footnote:[A future version of this
specification might define how an annotation processor treats a method
parameter which does not correspond to a parameter of the query.]

* For every named query, named entity graph, or SQL result set mapping
with name `"n"` declared by annotations of the class `X`, the metamodel
class must contain a declaration as follows:
+
[source,java]
----
public static final String T_N = "n";
----
+
where the prefix `T` is the string `QUERY`, `GRAPH`, or `MAPPING`,
as appropriate, depending on the annotation type, and the suffix
`N` is obtained by transforming each lowercase character in the
name `n` to uppercase, inserting an underscore if the character
following the transformed character is uppercase, and then
replacing each character which is not a legal Java identifier
character with an underscore.

* For every named query with name `"n"` and query result class `R`
declared by annotations of the class `X`, the metamodel class must
contain a declaration as follows:
+
[source,java]
----
public static volatile TypedQueryReference<R> _n_;
----
+
where `n` is the name `"n"` with every character which is not a legal
Java identifier character replaced with an underscore.

* For every named entity graph with name `"n"` declared by annotations
of the class `X`, the metamodel class must contain a declaration as
follows:
+
[source,java]
----
public static volatile EntityGraph<X> _n;
----
+
where `n` is the name `"n"` with every character which is not a legal
Java identifier character replaced with an underscore.

Import statements must be included for the needed `jakarta.persistence`
and `jakarta.persistence.metamodel` types as appropriate and for all
classes `X`, `Y`, `Z`, `R`, and `K`.

[NOTE]
====
Implementations of this specification are not required to resolve naming
collisions resulting from the rules above when generating canonical
metamodel classes.
====

[NOTE]
====
Implementations of this specification are not required to support the
use of metamodel classes which do not adhere to this canonical form. An
application that uses non-canonical metamodel classes is not portable.
====

===== Example Canonical Metamodel [[a6961]]

Assume the `Order` entity below.

[source,java]
----
package com.example;

import java.util.Set;
import java.math.BigDecimal;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;

@Entity
public class Order {
    @Id
    Integer orderId;

    @ManyToOne
    Customer customer;

    @OneToMany
    Set<Item> lineItems;

    Address shippingAddress;

    BigDecimal totalCost;

    // ...
}
----

The corresponding canonical metamodel class, `Order_`, is as follows:

[source,java]
----
package com.example;

import java.math.BigDecimal;
import jakarta.persistence.metamodel.EntityType;
import jakarta.persistence.metamodel.SingularAttribute;
import jakarta.persistence.metamodel.SetAttribute;
import jakarta.persistence.metamodel.StaticMetamodel;

@StaticMetamodel(Order.class)
public class Order_ {
    public static volatile EntityType<Order> class_;

    public static volatile SingularAttribute<Order, Integer> orderId;
    public static volatile SingularAttribute<Order, Customer> customer;
    public static volatile SetAttribute<Order, Item> lineItems;
    public static volatile SingularAttribute<Order, Address> shippingAddress;
    public static volatile SingularAttribute<Order, BigDecimal> totalCost;

    public static final String LINE_ITEMS = "lineItems";
    public static final String ORDER_ID = "orderId";
    public static final String SHIPPING_ADDRESS = "shippingAddress";
    public static final String TOTAL_COST = "totalCost";
    public static final String CUSTOMER = "customer";
}
----

==== Bootstrapping the Static Metamodel

When the entity manager factory for a persistence unit is created, it is
the responsibility of the persistence provider to initialize the state of
the static metamodel classes representing managed classes belonging to the
persistence unit. Any generated metamodel classes must be accessible on the
classpath.

Persistence providers must support the use of canonical metamodel classes.
Persistence providers may, but are not required to, support the use of
non-canonical metamodel classes.


=== Runtime Access to Metamodel

The interfaces defined in `jakarta.persistence.metamodel` provide for
dynamic access to a metamodel of the persistent state and relationships
of the managed classes of a persistence unit.

An instance of `Metamodel` may be obtained by calling the `getMetamodel()`
method of `EntityManagerFactory` or `EntityManager`.

The complete metamodel API may be found in <<metamodel-api>>.