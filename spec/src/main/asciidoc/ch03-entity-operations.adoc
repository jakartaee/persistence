//
// Copyright (c) 2017, 2023 Contributors to the Eclipse Foundation
//

== Entity Operations [[a1060]]

This chapter describes:

- the use of the `EntityManager` and `Query` APIs to retrieve instances of
  entity classes representing persistent state held in the database, and
  of `EntityGraph` to control the limits of the object graph returned by
  such operations,
- the use of the `EntityManager` API to manage the lifecycle of entity
  instances associated with a persistence context, and to control the
  synchronization of state held in the persistence context with the
  database,
- the use of the second-level cache, and
- entity listeners and lifeycle callbacks, attribute converters,
  and integration with Bean Validation.

=== Overview

Every instance of `EntityManager` has an associated _persistence context_.
A persistence context is a set of entity instances in which for any given
persistent entity identity there is a unique entity instance. Within the
persistence context, the entity instances and their lifecycle are managed.
The entity instance lifecycle is defined in <<a1929>>. The relationship
between entity managers and persistence contexts is described in <<a2027>>,
and again in further detail in <<a11431>>.

The `EntityManager` interface defines the methods used to interact with
its persistence context. The `EntityManager` API is used to create and
remove persistent entity instances, to find persistent entities by primary
key, and to query over persistent entity types. <<a1066>> describes the
`EntityManager` interface. <<a2052>> describes mechanisms for concurrency
control and locking. <<a4639>> provides a summary of exceptions.

The `EntityManager` acts as a factory for instances of `Query`, which are
used to control query execution. `Query`, `TypedQuery`, `StoredProcedureQuery`,
and related interfaces are described in <<a3125>>. The Jakarta Persistence
query language is defined in <<a4665>> and APIs for the construction of
Criteria queries in <<a6925>>. <<a2397>> describes the use of entity graphs
to control and limit the data fetched during find and query operations.

Each `EntityManager` belongs to an `EntityManagerFactory` with an associated
_persistence unit_. A persistence unit defines a set of related entities which
map to a single database. Entities belonging to the same persistence unit may
participate in associations. An `EntityManager` may only manage instances of
entities belonging to its persistence unit. The definition of persistence
units is described in <<a12229>>. An `EntityManagerFactory` might have an
associated second-level cache. <<a3061>> describes mechanisms for portable
configuration of the second-level cache.

Jakarta Persistence features several mechanisms allowing user-written code
to react to events occurring within the persistence context. <<a2153>>
describes entity listeners and lifecycle callback methods for entities.
<<a2366>> describes support for automatic use of Bean Validation. <<a2397>>
describes mechanisms for defining conversions between entity and database
representations for attributes of basic types.

=== EntityManager Interface [[a1066]]

The `EntityManager` interface may be found in <<_entitymanager_>>.

The `persist`, `merge`, `remove`, and
`refresh` methods must be invoked within a transaction context when an
entity manager with a transaction-scoped persistence context is used. If
there is no transaction context, the
`jakarta.persistence.TransactionRequiredException` is thrown.

Methods that specify a lock mode other than
`LockModeType.NONE` must be invoked within a transaction. If there is no
transaction or if the entity manager has not been joined to the
transaction, the `jakarta.persistence.TransactionRequiredException` is
thrown.

The `find` method (provided it is invoked
without a lock or invoked with `LockModeType.NONE`) and the
`getReference` method are not required to be invoked within a
transaction. If an entity manager with transaction-scoped persistence
context is in use, the resulting entities will be detached; if an entity
manager with an extended persistence context is used, they will be
managed. See <<a2027>> for entity manager use outside a
transaction.

The `Query`, `TypedQuery`,
`StoredProcedureQuery`, `CriteriaBuilder`, `Metamodel`, and
`EntityTransaction` objects obtained from an entity manager are valid
while that entity manager is open.

If the argument to the `createQuery` method
is not a valid Jakarta Persistence query string or a valid `CriteriaQuery`
object, the `IllegalArgumentException` may be thrown or the query
execution will fail and a `PersistenceException` will be thrown. If the
result class specification of a Jakarta Persistence query language query is
incompatible with the result of the query, the
`IllegalArgumentException` may be thrown when the `createQuery` method
is invoked or the query execution will fail and a `PersistenceException`
will be thrown when the query is executed. If a native query is not a
valid query for the database in use or if the result set specification
is incompatible with the result of the query, the query execution will
fail and a `PersistenceException` will be thrown when the query is
executed. The `PersistenceException` should wrap the underlying database
exception when possible.

Runtime exceptions thrown by the methods of
the `EntityManager` interface other than the `LockTimeoutException` will
cause the current transaction to be marked for rollback if the
persistence context is joined to that transaction.

The methods `close`, `isOpen`,
`joinTransaction`, and `getTransaction` are used to manage
application-managed entity managers and their lifecycle. See <<a11465>>.

The `EntityManager` interface and other
interfaces defined by this specification contain methods that take
properties and/or hints as arguments. This specification distinguishes
between `properties` and `hints` as follows:

* A property defined by this specification must
be observed by the provider unless otherwise explicitly stated.

* A hint specifies a preference on the part of
the application. While a hint defined by this specification should be
observed by the provider if possible, a hint may or may not always be
observed. A portable application must not depend on the observance of a
hint.

For example:

[source,java]
----
@Stateless
public class OrderEntryBean implements OrderEntry {
    @PersistenceContext
    EntityManager em;

    public void enterOrder(int custID, Order newOrder) {
        Customer cust = em.find(Customer.class, custID);
        cust.getOrders().add(newOrder);
        newOrder.setCustomer(cust);
        em.persist(newOrder);
    }
}
----

=== Entity Instance's Life Cycle [[a1929]]

This section describes the `EntityManager`
operations for managing an entity instance's lifecycle. An entity
instance can be characterized as being new, managed, detached, or
removed.

* A new entity instance has no persistent
identity, and is not yet associated with a persistence context.
* A managed entity instance is an instance with
a persistent identity that is currently associated with a persistence
context.
* A detached entity instance is an instance
with a persistent identity that is not (or no longer) associated with a
persistence context.
* A removed entity instance is an instance with
a persistent identity, associated with a persistence context, that will
be removed from the database upon transaction commit.

The following subsections describe the effect
of lifecycle operations upon entities. Use of the `cascade` annotation
element may be used to propagate the effect of an operation to
associated entities. The cascade functionality is most typically used in
parent-child relationships.

==== Entity Instance Creation

Entity instances are created by means of the
`new` operation. An entity instance, when first created by `new` is not
yet persistent. An instance becomes persistent by means of the
`EntityManager` API.

==== Persisting an Entity Instance

A new entity instance becomes both managed
and persistent by invoking the `persist` method on it or by cascading
the persist operation.

The semantics of the persist operation,
applied to an entity X are as follows:

* If X is a new entity, it becomes managed. The
entity X will be entered into the database at or before transaction
commit or as a result of the flush operation.
* If X is a preexisting managed entity, it is
ignored by the persist operation. However, the persist operation is
cascaded to entities referenced by X, if the relationships from X to
these other entities are annotated with the `cascade=PERSIST` or
`cascade=ALL` annotation element value or specified with the equivalent
XML descriptor element.
* If X is a removed entity, it becomes managed.
* If X is a detached object, the
`EntityExistsException` may be thrown when the persist operation is
invoked, or the `EntityExistsException` or another
`PersistenceException` may be thrown at flush or commit time.
* For all entities Y referenced by a
relationship from X, if the relationship to Y has been annotated with
the `cascade` element value `cascade=PERSIST` or `cascade=ALL`, the
persist operation is applied to Y.

==== Removal [[a1946]]

A managed entity instance becomes removed by
invoking the `remove` method on it or by cascading the remove operation.

The semantics of the remove operation,
applied to an entity X are as follows:

* If X is a new entity, it is ignored by the
remove operation. However, the remove operation is cascaded to entities
referenced by X, if the relationship from X to these other entities is
annotated with the `cascade=REMOVE` or `cascade=ALL` annotation element
value.
* If X is a managed entity, the remove
operation causes it to become removed. The remove operation is cascaded
to entities referenced by X, if the relationships from X to these other
entities is annotated with the `cascade=REMOVE` or `cascade=ALL`
annotation element value.
* If X is a detached entity, an
`IllegalArgumentException` will be thrown by the remove operation (or
the transaction commit will fail).
* If X is a removed entity, it is ignored by the remove operation.
* A removed entity X will be removed from the
database at or before transaction commit or as a result of the flush
operation.

After an entity has been removed, its state
(except for generated state) will be that of the entity at the point at
which the remove operation was called.

==== Synchronization to the Database [[a1955]]

In general, a persistence context will be
synchronized to the database as described below. However, a persistence
context of type `SynchronizationType.UNSYNCHRONIZED` or an
application-managed persistence context that has been created outside
the scope of the current transaction will only be synchronized to the
database if it has been joined to the current transaction by the
application's use of the `EntityManager.joinTransaction` method.

The state of persistent entities is
synchronized to the database at transaction commit. This synchronization
involves writing to the database any updates to persistent entities and
their relationships as specified above.

An update to the state of an entity includes
both the assignment of a new value to a persistent property or field of
the entity as well as the modification of a mutable value of a
persistent property or fieldfootnote:[This includes, for
example. modifications to persistent attributes of type char[\] and
byte[\].].

Synchronization to the database does not
involve a refresh of any managed entities unless the `refresh` operation
is explicitly invoked on those entities or cascaded to them as a result
of the specification of the `cascade=REFRESH` or `cascade=ALL`
annotation element value.

Bidirectional relationships between
managed entities will be persisted based on references held by the
owning side of the relationship. It is the developer's responsibility to
keep the in-memory references held on the owning side and those held on
the inverse side consistent with each other when they change. In the
case of unidirectional one-to-one and one-to-many relationships, it is
the developer's responsibility to ensure that the semantics of the
relationships are adhered to.footnote:[This might be an
issue if unique constraints (such as those described for the default
mappings in <<a640>> and <<a764>>) were not applied in the
definition of the object/relational mapping.]

[NOTE]
====
It is particularly important to ensure that
changes to the inverse side of a relationship result in appropriate
updates on the owning side, so as to ensure the changes are not lost
when they are synchronized to the database.
====

The persistence provider runtime is permitted
to perform synchronization to the database at other times as well when a
transaction is active and the persistence context is joined to the
transaction. The `flush` method can be used by the application to force
synchronization. It applies to entities associated with the persistence
context. The `setFlushMode` methods of the `EntityManager`, `Query`,
`TypedQuery`, and `StoredProcedureQuery` interfaces can be used to
control synchronization semantics. The effect of `FlushModeType.AUTO` is
defined in <<a4374>>. If `FlushModeType.COMMIT` is specified, flushing will occur at
transaction commit; the persistence provider is permitted, but not
required, to perform to flush at other times. If there is no transaction
active or if the persistence context has not been joined to the current
transaction, the persistence provider must not flush to the database.

The semantics of the flush operation, applied
to an entity X are as follows:

* If X is a managed entity, it is synchronized
to the database.
** For all entities Y referenced by a
relationship from X, if the relationship to Y has been annotated with
the `cascade` element value `cascade=PERSIST` or `cascade=ALL`, the
persist operation is applied to Y.
** For any entity Y referenced by a relationship
from X, where the relationship to Y has not been annotated with the
`cascade` element value `cascade=PERSIST` or `cascade=ALL`:
*** If Y is new or removed, an
`IllegalStateException` will be thrown by the flush operation (and the
transaction marked for rollback) or the transaction commit will fail.
*** If Y is detached, the semantics depend upon
the ownership of the relationship. If X owns the relationship, any
changes to the relationship are synchronized with the database;
otherwise, if Y owns the relationships, the behavior is undefined.
* If X is a removed entity, it is removed from
the database. No `cascade` options are relevant.

==== Refreshing an Entity Instance

The state of a managed entity instance is
refreshed from the database by invoking the `refresh` method on it or by
cascading the refresh operation.

The semantics of the refresh operation,
applied to an entity X are as follows:

* If X is a managed entity, the state of X is
refreshed from the database, overwriting changes made to the entity, if
any. The refresh operation is cascaded to entities referenced by X if
the relationship from X to these other entities is annotated with the
`cascade=REFRESH` or `cascade=ALL` annotation element value.
* If X is a new, detached, or removed entity,
the `IllegalArgumentException` is thrown.

==== Evicting an Entity Instance from the Persistence Context

An entity instance is removed from the
persistence context by invoking the `detach` method on it or cascading
the detach operation. Changes made to the entity, if any (including
removal of the entity), will not be synchronized to the database after
such eviction has taken place.

Applications must use the `flush` method
prior to the `detach` method to ensure portable semantics if changes
have been made to the entity (including removal of the entity). Because
the persistence provider may write to the database at times other than
the explicit invocation of the `flush` method, portable applications
must not assume that changes have not been written to the database if
the `flush` method has not been called prior to detach.

The semantics of the detach operation,
applied to an entity X are as follows:

* If X is a managed entity, the detach
operation causes it to become detached. The detach operation is cascaded
to entities referenced by X if the relationships from X to these other
entities is annotated with the `cascade=DETACH` or `cascade=ALL`
annotation element value. Entities which previously referenced X will
continue to reference X.
* If X is a new or detached entity, it is
ignored by the detach operation.
* If X is a removed entity, the detach
operation causes it to become detached. The detach operation is cascaded
to entities referenced by X if the relationships from X to these other
entities is annotated with the `cascade=DETACH` or `cascade=ALL`
annotation element value. Entities which previously referenced X will
continue to reference X. Portable applications should not pass removed
entities that have been detached from the persistence context to further
`EntityManager` operations.

==== Detached Entities [[a1982]]

A detached entity results from transaction
commit if a transaction-scoped persistence context is used (see <<a2027>>);
from transaction rollback (see <<a2049>>); from detaching
the entity from the persistence context; from clearing the persistence
context; from closing an entity manager; or from serializing an entity
or otherwise passing an entity by value—e.g., to a separate application
tier, through a remote interface, etc.

Detached entity instances continue to live
outside the persistence context in which they were persisted or
retrieved. Their state is no longer guaranteed to be synchronized with
the database state.

The application may access the available
state of available detached entity instances after the persistence
context ends. The available state includes:

* Any persistent field or property not marked `fetch=LAZY`
* Any persistent field or property that was
accessed by the application or fetched by means of an entity graph

If the persistent field or property is an
association, the available state of an associated instance may only be
safely accessed if the associated instance is available. The available
instances include:

* Any entity instance retrieved using `find()`.
* Any entity instances retrieved using a query or explicitly requested in a fetch join.
* Any entity instance for which an instance
variable holding non-primary-key persistent state was accessed by the
application.
* Any entity instance that can be reached from
another available instance by navigating associations marked `fetch=EAGER`.

===== Merging Detached Entity State [[a1983]]

The merge operation allows for the
propagation of state from detached entities onto persistent entities
managed by the entity manager.

The semantics of the merge operation applied
to an entity X are as follows:

* If X is a detached entity, the state of X is
copied onto a pre-existing managed entity instance X' of the same
identity or a new managed copy X' of X is created.
* If X is a new entity instance, a new managed
entity instance X' is created and the state of X is `copied` into the
new managed entity instance X'.
* If X is a removed entity instance, an
`IllegalArgumentException` will be thrown by the merge operation (or the
transaction commit will fail).
* If X is a managed entity, it is ignored by
the merge operation, however, the merge operation is cascaded to
entities referenced by relationships from X if these relationships have
been annotated with the `cascade` element value `cascade=MERGE` or
`cascade=ALL` annotation.
* For all entities Y referenced by
relationships from X having the `cascade` element value `cascade=MERGE`
or `cascade=ALL`, Y is merged recursively as Y'. For all such Y
referenced by X, X' is set to reference Y'. (Note that if X is managed
then X is the same object as X'.)
* If X is an entity merged to X', with a
reference to another entity Y, where `cascade=MERGE` or `cascade=ALL` is
not specified, then navigation of the same association from X' yields a
reference to a managed object Y' with the same persistent identity as Y.

The persistence provider must not merge
fields marked LAZY that have not been fetched: it must ignore such
fields when merging.

Any `Version` columns used by the entity must
be checked by the persistence runtime implementation during the merge
operation and/or at flush or commit time. In the absence of `Version`
columns there is no additional version checking done by the persistence
provider runtime during the merge operation.

===== Detached Entities and Lazy Loading

Serializing entities and merging those
entities back into a persistence context may not be interoperable across
vendors when lazy properties or fields and/or relationships are used.

A vendor is required to support the
serialization and subsequent deserialization and merging of detached
entity instances (which may contain lazy properties or fields and/or
relationships that have not been fetched) back into a separate JVM
instance of that vendor's runtime, where both runtime instances have
access to the entity classes and any required vendor persistence
implementation classes.

When interoperability across vendors is
required, the application must not use lazy loading.

==== Managed Instances

It is the responsibility of the application
to insure that an instance is managed in only a single persistence
context. The behavior is undefined if the same Java instance is made
managed in more than one persistence context.

The `contains()` method can be used to
determine whether an entity instance is managed in the current
persistence context.

The `contains` method returns true:

* If the entity has been retrieved from the
database or has been returned by `getReference`, and has not been
removed or detached.
* If the entity instance is new, and the
`persist` method has been called on the entity or the persist operation
has been cascaded to it.

The `contains` method returns false:

* If the instance is detached.
* If the `remove` method has been called on the
entity, or the remove operation has been cascaded to it.
* If the instance is new, and the `persist`
method has not been called on the entity or the persist operation has
not been cascaded to it.

Note that the effect of the cascading of
persist, merge, remove, or detach is immediately visible to the
`contains` method, whereas the actual insertion, modification, or
deletion of the database representation for the entity may be deferred
until the end of the transaction.

==== Load State [[a2019]]

An entity is considered to be loaded if all
attributes with `FetchType.EAGER` —whether explictly specified or by
default—(including relationship and other collection-valued attributes)
have been loaded from the database or assigned by the application.
Attributes with `FetchType.LAZY` may or may not have been loaded. The
available state of the entity instance and associated instances is as
described in <<a1982>>.

An attribute that is an embeddable is
considered to be loaded if the embeddable attribute was loaded from the
database or assigned by the application, and, if the attribute
references an embeddable instance (i.e., is not null), the embeddable
instance state is known to be loaded (i.e., all attributes of the
embeddable with `FetchType.EAGER` have been loaded from the database or
assigned by the application).

A collection-valued attribute is considered
to be loaded if the collection was loaded from the database or the value
of the attribute was assigned by the application, and, if the attribute
references a collection instance (i.e., is not null), each element of
the collection (e.g. entity or embeddable) is considered to be loaded.

A single-valued relationship attribute is
considered to be loaded if the relationship attribute was loaded from
the database or assigned by the application, and, if the attribute
references an entity instance (i.e., is not null), the entity instance
state is known to be loaded.

A basic attribute is considered to be loaded
if its state has been loaded from the database or assigned by the
application.

The `PersistenceUtil.isLoaded` methods can be
used to determine the load state of an entity and its attributes
regardless of the persistence unit with which the entity is associated.
The `PersistenceUtil.isLoaded` methods return true if the above
conditions hold, and false otherwise. If the persistence unit is known,
the `PersistenceUnitUtil.isLoaded` methods can be used instead. See <<a12177>>.

Persistence provider contracts for
determining the load state of an entity or entity attribute are
described in <<a13592>>.

=== Persistence Context Lifetime and Synchronization Type [[a2027]]

The lifetime of a container-managed
persistence context can either be scoped to a transaction
(transaction-scoped persistence context), or have a lifetime scope that
extends beyond that of a single transaction (extended persistence
context). The enum `PersistenceContextType` is used to define the
persistence context lifetime scope for container-managed entity
managers. The persistence context lifetime scope is defined when the
`EntityManager` instance is created (whether explicitly, or in conjunction
with injection or JNDI lookup). See <<a11791>>.

[source,java]
----
include::../../../../api/src/main/java/jakarta/persistence/PersistenceContextType.java[lines=18..-1]
----

By default, the lifetime of the persistence
context of a container-managed entity manager corresponds to the scope
of a transaction (i.e., it is of type
`PersistenceContextType.TRANSACTION`).

When an extended persistence context is used,
the extended persistence context exists from the time the `EntityManager`
instance is created until it is closed. This persistence context might
span multiple transactions and non-transactional invocations of the
`EntityManager`.

An `EntityManager` with an extended persistence
context maintains its references to the entity objects after a
transaction has committed. Those objects remain managed by the
`EntityManager`, and they can be updated as managed objects between
transactions.footnote:[Note that when a new
transaction is begun, the managed objects in an extended persistence
context are `not` reloaded from the database.] Navigation from a managed object in
an extended persistence context results in one or more other managed
objects regardless of whether a transaction is active.

When an `EntityManager` with an extended
persistence context is used, the persist, remove, merge, and refresh
operations can be called regardless of whether a transaction is active.
The effects of these operations will be committed to the database when
the extended persistence context is enlisted in a transaction and the
transaction commits.

The scope of the persistence context of an
application-managed entity manager is extended. It is the responsibility
of the application to manage the lifecycle of the persistence context.

Container-managed persistence contexts are
described further in <<a11791>>. Persistence contexts managed by
the application are described further in <<a11894>>.

==== Synchronization with the Current Transaction

By default, a container-managed persistence
context is of `SynchronizationType.SYNCHRONIZED` and is automatically
joined to the current transaction. A persistence context of
`SynchronizationType.UNSYNCHRONIZED` will not be enlisted in the current
transaction, unless the `EntityManager` `joinTransaction` method is
invoked.

By default, an application-managed
persistence context that is associated with a JTA entity manager and
that is created within the scope of an active transaction is
automatically joined to that transaction. An application-managed JTA
persistence context that is created outside the scope of a transaction
or an application-managed persistence context of type
`SynchronizationType.UNSYNCHRONIZED` will not be joined to that
transaction unless the `EntityManager` `joinTransaction` method is
invoked.

An application-managed persistence context
associated with a resource-local entity manager is always automatically
joined to any resource-local transaction that is begun for that entity
manager.

Persistence context synchronization type is
described further in <<a11797>>.

==== Transaction Commit

The managed entities of a transaction-scoped
persistence context become detached when the transaction commits; the
managed entities of an extended persistence context remain managed.

==== Transaction Rollback [[a2049]]

For both transaction-scoped
persistence contexts and for extended persistence contexts that are
joined to the current transaction, transaction rollback causes all
_pre-existing_ managed instances and removed
instancesfootnote:[These are instances
that were persistent in the database at the start of the transaction.] to become detached. The instances'
state will be the state of the instances at the point at which the
transaction was rolled back. Transaction rollback typically causes the
persistence context to be in an inconsistent state at the point of
rollback. In particular, the state of version attributes and generated
state (e.g., generated primary keys) may be inconsistent. Instances that
were formerly managed by the persistence context (including new
instances that were made persistent in that transaction) may therefore
not be reusable in the same manner as other detached objects—for
example, they may fail when passed to the merge
operation.footnote:[It is unspecified as
to whether instances that were not persistent in the database behave as
new instances or detached instances after rollback. This may be
implementation-dependent.]

[NOTE]
====
Because a transaction-scoped
persistence context's lifetime is scoped to a transaction regardless of
whether it is joined to that transaction, the container closes the
persistence context upon transaction rollback. However, an extended
persistence context that is not joined to a transaction is unaffected by
transaction rollback.
====

=== Locking and Concurrency [[a2052]]

This specification assumes the use of
optimistic concurrency control. It assumes that the databases to which
persistence units are mapped will be accessed by the implementation
using read-committed isolation (or a vendor equivalent in which
long-term read locks are not held), and that writes to the database will
typically occur only when the `flush` method has been invoked—whether
explicitly by the application, or by the persistence provider runtime in
accordance with the flush mode setting.

[NOTE]
====
If a transaction is active and the
persistence context is joined to the transaction, a compliant
implementation of this specification is permitted to write to the
database immediately (i.e., whenever a managed entity is updated,
created, and/or removed), however, the configuration of an
implementation to require such non-deferred database writes is outside
the scope of this specification.footnote:[Applications may
require that database isolation levels higher than read-committed be in
effect. The configuration of the setting database isolation levels,
however, is outside the scope of this specification.]
====

In addition, both pessimistic and optimistic
locking are supported for selected entities by means of specified lock
modes. Optimistic locking is described in <<a2056>> and <<a2059>>; pessimistic locking
in <<a2066>>. <<a2084>> describes the setting of
optimistic and pessimistic lock modes. The configuration of the setting
of optimistic lock modes is described in <<a2100>>,
and the configuration of the setting of pessimistic lock modes is
described in <<a2113>>.

==== Optimistic Locking [[a2056]]

_Optimistic locking_ is a system of concurrency control where each
revision of an item of data is assigned a version number or timestamp.
When the data is read and then updated within a given unit of work,
the version or timestamp is:

1. read from the database when the data itself is read, and
2. verified and then updated in the database when the data is updated.

Similarly, when the data is read and then deleted within a given unit
of work, the version or timestamp is:

1. read from the database when the data itself is read, and
2. verified when the data is deleted.

An _optimistic lock failure_ occurs when verification fails, that is,
if the version or timestamp held in the database changes between
reading the data (step 1), and attempting to update or delete the data
(step 2).

Thus, the unit of work is prevented from updating the data and creating
a new revision, or from deleting the data, unless the revision it
previously obtained is still the current revision. Optimistic lock
verification ensures that an update of a given item is successful only
when no intervening transaction has already updated the item, preventing
the loss of updates made by such intervening transactions.

The persistence provider is required to perform optimistic locking
automatically for every entity with a version, as defined in <<a2060>>.
A portable application which wishes to take advantage of automatic
optimistic locking must specify a version field or property for each
optimistically-locked entity using the `@Version` annotation defined in
<<a16432>> or equivalent XML element.

When an optimistic lock failure is detected, the persistence provider
must:

- throw an `OptimisticLockException` and
- mark the current transaction for rollback.

A persistence provider might offer alternative implementations of
optimistic locking, which do not depend on the entity having a version,
but such functionality is not portable between providers.footnote:[Such
alternative mechanisms might be standardized by a future release of this
specification.]

[NOTE]
====
Applications are strongly encouraged to enable optimistic locking for
every entity which may be concurrently accessed or which may be merged
from a detached state. Failure to make use of optimistic locking often
leads to inconsistent entity state, lost updates, and other anomalies.
If an entity does not have a version, the application itself must bear
the burden of maintaining data consistency during optimistic units of
work.
====

For the purposes of versioning and optimistic locking, the state of a
given entity is considered to include:

- every persistent field or property which is not a relationship to
  another entity, and
- every relationship owned by the entity, as defined by <<a516>>.
footnote:[This includes owned relationships maintained in join tables.]

Unowned relationships are not considered part of the state of the entity.

==== Entity Versions and Optimistic Locking [[a2059]]

The entity version must be updated by the persistence provider each
time the state of an entity instance is written to the database.
footnote:[Typically, by incrementing the version number, or by replacing
the previous timestamp with a timestamp representing the current time.]
Furthermore, if the current persistence context contains a revision
of the entity instance when the instance is written to the database,
the persistence provider must verify that the revision held in the
persistence context is identical to the revision held in the database
by comparing the versions held in memory and in the database.
footnote:[Ideally, version verification and update happen in a single
atomic operation against the datastore, for example, in a single SQL
update statement.] If the versions do not match, the persistence
provider must thow an `OptimisticLockException`.

The persistence provider must examine the version field or property of
a detached entity instance when it is merged, as defined in <<a1983>>,
and throw an `OptimisticLockException` if the instance being merged
holds a stale revision of the state of the entity--that is, if the
entity was updated since the entity instance became detached. The
timing of this version check is provider-dependent:

- the version check might occur synchronously with the call to `merge()`,
  or
- a provider might choose to delay the version check until a flush
  operation occurs, as defined in <<a1955>>, or until the transaction
  commits.

If an update or merge operation involves entities with versions, and
entities without versions, the persistence provider runtime is only
required to perform optimistic lock verification for those entities
which do have a version, and the consistency of the whole object graph
is not guaranteed. The absence a version for some entity involved in
the update or merge operation does not impede completion of the
operation.

==== Pessimistic Locking [[a2066]]

While optimistic locking is typically
appropriate in dealing with moderate contention among concurrent
transactions, in some applications it may be useful to immediately
obtain long-term database locks for selected entities because of the
often late failure of optimistic transactions. Such immediately obtained
long-term database locks are referred to here as “pessimistic”
locks.footnote:[Implementations are
permitted to use database mechanisms other than locking to achieve the
semantic effects described here, for example, multiversion concurrency
control mechanisms.]

Pessimistic locking guarantees that once a
transaction has obtained a pessimistic lock on an entity instance:

* no other transaction (whether a transaction
of an application using the Jakarta Persistence API or any other
transaction using the underlying resource) may successfully modify or
delete that instance until the transaction holding the lock has ended.
* if the pessimistic lock is an exclusive
lockfootnote:[This is achieved by
using a lock with `LockModeType.PESSIMISTIC_WRITE` or
`LockModeType.PESSIMISTIC_FORCE_INCREMENT` as described in <<a2084>>.],
that same transaction may modify or delete
that entity instance.

When an entity instance is locked using
pessimistic locking, the persistence provider must lock the database
row(s) that correspond to the non-collection-valued persistent state of
that instance. If a joined inheritance strategy is used, or if the
entity is otherwise mapped to a secondary table, this entails locking
the row(s) for the entity instance in the additional table(s). Entity
relationships for which the locked entity contains the foreign key will
also be locked, but not the state of the referenced entities (unless
those entities are explicitly locked). Element collections and
relationships for which the entity does not contain the foreign key
(such as relationships that are mapped to join tables or unidirectional
one-to-many relationships for which the target entity contains the
foreign key) will not be locked by default.

Element collections and relationships owned
by the entity that are contained in join tables will be locked if the
`jakarta.persistence.lock.scope` property is specified with a value of
`PessimisticLockScope.EXTENDED`. The state of entities referenced by
such relationships will not be locked (unless those entities are
explicitly locked). This property may be passed as an argument to the
methods of the `EntityManager`, `Query`, and `TypedQuery` interfaces
that allow lock modes to be specified or used with the `NamedQuery`
annotation.

Locking such a relationship or element
collection generally locks only the rows in the join table or collection
table for that relationship or collection. This means that phantoms will
be possible.

The values of the
`jakarta.persistence.lock.scope` property are defined by the
`PessimisticLockScope` enum.

[source,java]
----
include::../../../../api/src/main/java/jakarta/persistence/PessimisticLockScope.java[lines=18..-1]
----

This specification does not define the
mechanisms a persistence provider uses to obtain database locks, and a
portable application should not rely on how pessimistic locking is
achieved on the database.footnote:[For example, a
persistence provider may use an underlying database platform's SELECT
FOR UPDATE statements to implement pessimistic locking if that construct
provides appropriate semantics, or the provider may use an isolation
level of repeatable read.] In particular, a
persistence provider or the underlying database management system may
lock more rows than the ones selected by the application.

Whenever a pessimistically locked entity
containing a version attribute is updated on the database, the
persistence provider must also update (increment) the entity's version
column to enable correct interaction with applications using optimistic
locking. See <<a2059>> and <<a2084>>.

Pessimistic locking may be applied to
entities that do not contain version attributes. However, in this case
correct interaction with applications using optimistic locking cannot be
ensured.

==== Lock Modes [[a2084]]

Lock modes are intended to provide a facility
that enables the effect of “repeatable read” semantics for the items
read, whether “optimistically” (as described in <<a2100>>)
or “pessimistically” (as described in <<a2113>>).

A lock mode may be explicitly specified as an argument to the
`lock()` method of `EntityManager` or to any other method of
`EntityManager`, `Query`, and `TypedQuery` which accepts a lock
mode, or via the `NamedQuery` annotation.

Lock mode values are defined by the `LockModeType` enum which may
be found in <<_lockmodetype_>>. Six distinct lock modes are defined.
footnote:[The lock mode type NONE may be specified as a method
argument and also provides a default value for annotations.]
The lock mode type values `READ` and `WRITE` are synonyms for
`OPTIMISTIC` and `OPTIMISTIC_FORCE_INCREMENT` respectively.
The latter are to be preferred for new applications.


===== OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT [[a2100]]

The lock modes `OPTIMISTIC` and
`OPTIMISTIC_FORCE_INCREMENT` are used for optimistic locking. The lock
mode type values `READ` and `WRITE` are synonymous with `OPTIMISTIC` and
`OPTIMISTIC_FORCE_INCREMENT` respectively.

The semantics of requesting locks of type
`LockModeType.OPTIMISTIC` and `LockModeType.OPTIMISTIC_FORCE_INCREMENT`
are the following.

If transaction T1 calls `lock(entity, LockModeType.OPTIMISTIC)` on a
versioned object, the entity manager
must ensure that neither of the following phenomena can occur:

* P1 (Dirty read): Transaction T1 modifies a
row. Another transaction T2 then reads that row and obtains the modified
value, before T1 has committed or rolled back. Transaction T2 eventually
commits successfully; it does not matter whether T1 commits or rolls
back and whether it does so before or after T2 commits.
* P2 (Non-repeatable read): Transaction T1
reads a row. Another transaction T2 then modifies or deletes that row,
before T1 has committed. Both transactions eventually commit
successfully.

This will generally be achieved by the entity
manager acquiring a lock on the underlying database row. While with
optimistic concurrency concurrency, long-term database read locks are
typically not obtained immediately, a compliant implementation is
permitted to obtain an immediate lock (so long as it is retained until
commit completes). If the lock is deferred until commit time, it must be
retained until the commit completes. Any implementation that supports
repeatable reads in a way that prevents the above phenomena is
permissible.

The persistence implementation is not
required to support calling `lock(entity, LockModeType.OPTIMISTIC)` on
a non-versioned object. When it cannot support such a lock call, it must
throw the `PersistenceException`. When supported, whether for versioned
or non-versioned objects, `LockModeType.OPTIMISTIC` must always prevent
the phenomena P1 and P2. Applications that call
`lock(entity, LockModeType.OPTIMISTIC)` on non-versioned objects are not
portable.

If transaction T1 calls `lock(entity, LockModeType.OPTIMISTIC_FORCE_INCREMENT)`
on a versioned object, the entity manager must avoid the phenomena P1 and P2
(as with `LockModeType.OPTIMISTIC`) and must also force an update (increment) to
the entity's version column. A forced version update may be performed
immediately, or may be deferred until a flush or commit. If an entity is
removed before a deferred version update was to have been applied, the
forced version update is omitted.

The persistence implementation is not required to support calling
`lock(entity, LockModeType.OPTIMISTIC_FORCE_INCREMENT)` on a non-versioned
object. When it cannot support such a lock call, it must throw the
`PersistenceException`. When supported, whether for versioned or
non-versioned objects, `LockModeType.OPTIMISTIC_FORCE_INCREMENT` must
always prevent the phenomena P1 and P2. For non-versioned objects,
whether or not `LockModeType.OPTIMISTIC_FORCE_INCREMENT` has any
additional behavior is vendor-specific. Applications that call
`lock(entity, LockModeType.OPTIMISTIC_FORCE_INCREMENT)` on non-versioned
objects will not be portable.

For versioned objects, it is permissible for
an implementation to use `LockModeType.OPTIMISTIC_FORCE_INCREMENT` where
`LockModeType.OPTIMISTIC` was requested, but not vice versa.

If a versioned object is otherwise updated or
removed, then the implementation must ensure that the requirements of
`LockModeType.OPTIMISTIC_FORCE_INCREMENT` are met, even if no explicit
call to `EntityManager.lock` was made.

For portability, an application should not
depend on vendor-specific hints or configuration to ensure repeatable
read for objects that are not updated or removed via any mechanism other
than the use of version attributes and the EntityManager `lock` method.
However, it should be noted that if an implementation has acquired
up-front pessimistic locks on some database rows, then it is free to
ignore `lock(entity, LockModeType.OPTIMISTIC)` calls on the entity
objects representing those rows.

===== PESSIMISTIC_READ, PESSIMISTIC_WRITE, PESSIMISTIC_FORCE_INCREMENT [[a2113]]

The lock modes `PESSIMISTIC_READ`,
`PESSIMISTIC_WRITE`, and `PESSIMISTIC_FORCE_INCREMENT` are used to
immediately obtain long-term database locks.footnote:[Databases concurrency
control mechanisms that provide comparable semantics, e.g., multiversion
concurrency control, can be used by the provider.]

The semantics of requesting locks of type
`LockModeType.PESSIMISTIC_READ`, `LockModeType.PESSIMISTIC_WRITE`, and
`LockModeType.PESSIMISTIC_FORCE_INCREMENT` are the following.

If transaction T1 calls `lock(entity, LockModeType.PESSIMISTIC_READ)` or
`lock(entity, LockModeType.PESSIMISTIC_WRITE)` on an object, the entity
manager must ensure that neither of the following phenomena can occur:

* P1 (Dirty read): Transaction T1 modifies a
row. Another transaction T2 then reads that row and obtains the modified
value, before T1 has committed or rolled back.
* P2 (Non-repeatable read): Transaction T1
reads a row. Another transaction T2 then modifies or deletes that row,
before T1 has committed or rolled back.

Any such lock must be obtained immediately
and retained until transaction T1 completes (commits or rolls back).

Avoidance of phenomena P1 and P2 is generally
achieved by the entity manager acquiring a long-term lock on the
underlying database row(s). Any implementation that supports pessimistic
repeatable reads as described above is permissible.

[NOTE]
====
A lock with `LockModeType.PESSIMISTIC_WRITE`
can be obtained on an entity instance to force serialization among
transactions attempting to update the entity data. A lock with
`LockModeType.PESSIMISTIC_READ` can be used to query data using
repeatable-read semantics without the need to reread the data at the end
of the transaction to obtain a lock, and without blocking other
transactions reading the data. A lock with
`LockModeType.PESSIMISTIC_WRITE` can be used when querying data and
there is a high likelihood of deadlock or update failure among
concurrent updating transactions.
====

The persistence implementation must support
calling `lock(entity, LockModeType.PESSIMISTIC_READ)` and `lock(entity,
LockModeType.PESSIMISTIC_WRITE)` on a non-versioned entity as well as on
a versioned entity.

It is permissible for an implementation to
use `LockModeType.PESSIMISTIC_WRITE` where
`LockModeType.PESSIMISTIC_READ` was requested, but not vice versa.

When the lock cannot be obtained, and the
database locking failure results in transaction-level rollback, the
provider must throw the `PessimisticLockException` and ensure that the
JTA transaction or `EntityTransaction` has been marked for rollback.

When the lock cannot be obtained, and the
database locking failure results in only statement-level rollback, the
provider must throw the `LockTimeoutException` (and must not mark the
transaction for rollback).

When an application locks an entity with
`LockModeType.PESSIMISTIC_READ` and later updates that entity, the lock
must be converted to an exclusive lock when the entity is flushed to the
database.footnote:[The persistence
provider is not required to flush the entity to the database
immediately.] If the lock conversion fails, and the
database locking failure results in transaction-level rollback, the
provider must throw the `PessimisticLockException` and ensure that the
JTA transaction or `EntityTransaction` has been marked for rollback. When
the lock conversion fails, and the database locking failure results in
only statement-level rollback, the provider must throw the
`LockTimeoutException` (and must not mark the transaction for
rollback).

When `lock(entity, LockModeType.PESSIMISTIC_READ)`,
`lock(entity, LockModeType.PESSIMISTIC_WRITE)`, or
`lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)`
is invoked on a versioned
entity that is already in the persistence context, the provider must
also perform optimistic version checks when obtaining the lock. An
`OptimisticLockException` must be thrown if the version checks fail.
Depending on the implementation strategy used by the provider, it is
possible that this exception may not be thrown until flush is called or
commit time, whichever occurs first.

If transaction T1 calls
`lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)` on a versioned
object, the entity manager must avoid the phenomenon P1 and P2 (as with
`LockModeType.PESSIMISTIC_READ` and `LockModeType.PESSIMISTIC_WRITE`)
and must also force an update (increment) to the entity's version
column.

The persistence implementation is not required to support calling
`lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)` on a non-versioned
object. When it cannot support such a lock call, it must throw the
`PersistenceException`. When supported, whether for versioned or
non-versioned objects, `LockModeType.PESSIMISTIC_FORCE_INCREMENT` must
always prevent the phenomena P1 and P2. For non-versioned objects,
whether or not `LockModeType.PESSIMISTIC_FORCE_INCREMENT` has any
additional behavior is vendor-specific. Applications that call
`lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)` on
non-versioned objects will not be portable.

For versioned objects, it is permissible for
an implementation to use `LockModeType.PESSIMISTIC_FORCE_INCREMENT`
where `LockModeType.PESSIMISTIC_READ` or
`LockModeType.PESSIMISTIC_WRITE` was requested, but not vice versa.

If a versioned object locked with
`LockModeType.PESSIMISTIC_READ` or `LockModeType.PESSIMISTIC_WRITE` is
updated, then the implementation must ensure that the requirements of
`LockModeType.PESSIMISTIC_FORCE_INCREMENT` are met.

===== Lock Mode Properties and Uses [[a2132]]

The following property is defined by this
specification for use in pessimistic locking, as described in <<a2066>>:

[source,java]
----
jakarta.persistence.lock.scope
----

This property may be used with the methods of
the `EntityManager` interface that allow lock modes to be specified, the
`Query` and `TypedQuery` `setLockMode` methods, and the `NamedQuery`
annotation. When specified, this property must be observed. The provider
is permitted to lock more (but not fewer) rows than requested.

The following hint is defined by this
specification for use in pessimistic locking.

[source,java]
----
jakarta.persistence.lock.timeout // time in milliseconds
----

This hint may be used with the methods of the
`EntityManager` interface that allow lock modes to be specified, the
`Query.setLockMode` method and the `NamedQuery` annotation. It may also
be passed as a property to the `Persistence.createEntityManagerFactory`
method and used in the `properties` element of the `persistence.xml`
file. See <<a1066>>, <<a4385>>, <<a12384>>, <<a13443>>,
and <<a13711>>. When used in
the `createEntityManagerFactory` method, the `persistence.xml` file, and
the `NamedQuery` annotation, the timeout hint serves as a default value
which can be selectively overridden by use in the methods of the
`EntityManager`, `Query`, and `TypedQuery` interfaces as specified
above. When this hint is not specified, database timeout values are
assumed to apply.

A timeout value of `0` is used to specify “no wait” locking.

Portable applications should not rely on this
hint. Depending on the database in use and the locking mechanisms used
by the persistence provider, the hint may or may not be observed.

Vendors are permitted to support the use of
additional, vendor-specific locking hints. Vendor-specific hints must
not use the `jakarta.persistence` namespace. Vendor-specific hints must be
ignored if they are not understood.

If the same property or hint is specified
more than once, the following order of overriding applies, in order of
decreasing precedence:

* argument to method of `EntityManager`, `Query`, or `TypedQuery` interface
* specification to `NamedQuery` (annotation or XML)
* argument to `createEntityManagerFactory` method
* specification in `persistence.xml`

==== OptimisticLockException

Provider implementations may defer writing to
the database until the end of the transaction, when consistent with the
lock mode and flush mode settings in effect. In this case, an optimistic
lock check may not occur until commit time, and the
`OptimisticLockException` may be thrown in the “before completion” phase
of the commit. If the `OptimisticLockException` must be caught or
handled by the application, the `flush` method should be used by the
application to force the database writes to occur. This will allow the
application to catch and handle optimistic lock exceptions.

The `OptimisticLockException` provides an API
to return the object that caused the exception to be thrown. The object
reference is not guaranteed to be present every time the exception is
thrown but should be provided whenever the persistence provider can
supply it. Applications cannot rely upon this object being available.

In some cases an `OptimisticLockException`
will be thrown and wrapped by another exception, such as a
`RemoteException`, when VM boundaries are crossed. Entities that may be
referenced in wrapped exceptions should implement `Serializable` so that
marshalling will not fail.

An `OptimisticLockException` always causes
the transaction to be marked for rollback.

Refreshing objects or reloading objects in a
new transaction context and then retrying the transaction is a potential
response to an `OptimisticLockException`.

=== Entity Listeners and Callback Methods [[a2153]]

A method may be designated as a lifecycle
callback method to receive notification of entity lifecycle events. A
lifecycle callback method can be defined on an entity class, a mapped
superclass, or an entity listener class associated with an entity or
mapped superclass. An entity listener class is a class whose methods are
invoked in response to lifecycle events on an entity. Any number of
entity listener classes can be defined for an entity class or mapped
superclass.

Default entity listeners—entity listener
classes whose callback methods apply to all entities in the persistence
unit—can be specified by means of the XML descriptor.

Lifecycle callback methods and entity
listener classes are defined by means of metadata annotations or the XML
descriptor. When annotations are used, one or more entity listener
classes are denoted using the `EntityListeners` annotation on the entity
class or mapped superclass. If multiple entity listeners are defined,
the order in which they are invoked is determined by the order in which
they are specified in the `EntityListeners` annotation. The XML
descriptor may be used as an alternative to specify the invocation order
of entity listeners or to override the order specified in metadata
annotations.

Any subset or combination of annotations may
be specified on an entity class, mapped superclass, or listener class. A
single class must not have more than one lifecycle callback method for
the same lifecycle event. The same method may be used for multiple
callback events.

Multiple entity classes and mapped
superclasses in an inheritance hierarchy may define listener classes
and/or lifecycle callback methods directly on the class. <<a2251>>
describes the rules that apply to method invocation order in this case.

==== Entity Listeners

The entity listener class must have a public no-arg constructor.

Entity listener classes in Jakarta EE
environments support dependency injection through the Contexts and
Dependency Injection API (CDI) <<a19500>> when CDI is
enabledfootnote:[CDI is enabled by
default in Jakarta EE. See the Jakarta EE specification
<<a19499>>.]. An entity listener class that makes use
of CDI injection may also define lifecycle callback methods annotated
with the `PostConstruct` and `PreDestroy` annotations. These methods
will be invoked after injection has taken place and before the entity
listener instance is destroyed respectively.

The persistence provider is responsible for
using the CDI SPI to create instances of the entity listener class; to
perform injection upon such instances; to invoke their `PostConstruct`
and `PreDestroy` methods, if any; and to dispose of the entity listener
instances.

The persistence provider is only required to
support CDI injection into entity listeners in Jakarta EE container
environmentsfootnote:[The persistence
provider may support CDI injection into entity listeners in other
environments in which the BeanManager is available.]. If the CDI is not enabled, the
persistence provider must not invoke entity listeners that depend upon
CDI injection.

An entity listener is a noncontextual object.
In supporting injection into entity listeners, the persistence provider
must behave as if it carries out the following steps involving the use
of the CDI SPI. (See <<a19500>>).

* Obtain a `BeanManager` instance. (See <<a12802>>)
* Create an `AnnotatedType` instance for the entity listener class.
* Create an `InjectionTarget` instance for the annotated type.
* Create a `CreationalContext`.
* Instantiate the listener by calling the `InjectionTarget` `produce` method.
* Inject the listener instance by calling the
`InjectionTarget` `inject` method on the instance.
* Invoke the `PostConstruct` callback, if any,
by calling the `InjectionTarget` `postConstruct` method on the instance.

When the listener instance is to be
destroyed, the persistence provider must behave as if it carries out the
following steps.

* Call the `InjectionTarget` `preDestroy` method on the instance.
* Call the `InjectionTarget` `dispose` method on the instance
* Call the `CreationalContext` `release` method.

Persistence providers may optimize the steps
above, e.g. by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

Entity listeners that do not make use of CDI
injection are stateless. The lifecycle of such entity listeners is
unspecified.

When invoked from within a Jakarta EE
environment, the callback listeners for an entity share the enterprise
naming context of the invoking component, and the entity callback
methods are invoked in the transaction and security contexts of the
calling component at the time at which the callback method is invoked.
footnote:[For example, if a
transaction commit occurs as a result of the normal termination of a
session bean business method with transaction attribute `RequiresNew`,
the `PostPersist` and `PostRemove` callbacks are executed in the naming
context, the transaction context, and the security context of that
component.]

==== Lifecycle Callback Methods

Entity lifecycle callback methods can be defined on an entity listener
class and/or directly on an entity class or mapped superclass.

A lifecycle callback method must be either:

- annotated with annotations designating the callback events for which
  it is invoked, or
- mapped to a callback event type using the XML descriptor.

The same annotations (and XML elements) are used to declare:

- callback methods of an entity class or mapped superclass, and
- callback methods of an entity listener class.

The signatures of the callback methods differ between these two cases:

- a callback method defined by an entity class or mapped superclass has
  the signature:
+
 void <METHOD>()
+
- a callback method defined by an entity listener class has the signature:
+
 void <METHOD>(S)
+
where `S` is any supertype of the entity class or mapped superclass to
which the entity listener is applied. At runtime, the argument to the
entity listener callback method is the entity instance for which the
callback method is being invoked.

Callback methods can have public, private, protected, or package level
access, but must not be `static` or `final`.

The following annotations designate lifecycle event callback methods of
the corresponding types.

* `PrePersist`
* `PostPersist`
* `PreRemove`
* `PostRemove`
* `PreUpdate`
* `PostUpdate`
* `PostLoad`

The following rules apply to lifecycle callback methods:

* Lifecycle callback methods may throw unchecked/runtime exceptions.
  A runtime exception thrown by a callback method that executes within
  a transaction causes that transaction to be marked for rollback if
  the persistence context is joined to the transaction.
* Lifecycle callbacks can invoke JNDI, JDBC, JMS, and enterprise beans.
* A lifecycle callback method may modify the non-relationship state of
  the entity on which it is invoked.
* In general, the lifecycle method of a portable application should not
  invoke `EntityManager` or query operations, access other entity
  instances, or modify relationships within the same persistence
  contextfootnote:[Note that this caution applies also to the actions of
  objects that might be injected into an entity listener].

==== Semantics of the Life Cycle Callback Methods for Entities [[a2202]]

The `PrePersist` and `PreRemove` callback
methods are invoked for a given entity before the respective
`EntityManager` persist and remove operations for that entity are
executed. For entities to which the merge operation has been applied and
causes the creation of newly managed instances, the `PrePersist`
callback methods will be invoked for the managed instance after the
entity state has been copied to it. These `PrePersist` and `PreRemove`
callbacks will also be invoked on all entities to which these operations
are cascaded. The `PrePersist` and `PreRemove` methods will always be
invoked as part of the synchronous persist, merge, and remove operations.
Primary key values generated using the `SEQUENCE`, `TABLE`, or `UUID`
strategy are available in the `PrePersist` method. Primary key values
generated using the `IDENTITY` strategy are not available in the
`PrePersist` method.

The `PostPersist` and `PostRemove` callback
methods are invoked for an entity after the entity has been made
persistent or removed. These callbacks will also be invoked on all
entities to which these operations are cascaded. The `PostPersist` and
`PostRemove` methods will be invoked after the database insert and
delete operations respectively. These database operations may occur
directly after the persist, merge, or remove operations have been
invoked or they may occur directly after a flush operation has occurred
(which may be at the end of the transaction). Generated primary key
values are always available in the `PostPersist` method.

The `PreUpdate` and `PostUpdate` callbacks
occur before and after the database update operations to entity data
respectively. These database operations may occur at the time the entity
state is updated or they may occur at the time state is flushed to the
database (which may be at the end of the transaction).

[NOTE]
====
Note that it is implementation-dependent as
to whether `PreUpdate` and `PostUpdate` callbacks occur when an entity
is persisted and subsequently modified in a single transaction or when
an entity is modified and subsequently removed within a single
transaction. Portable applications should not rely on such behavior.
====

The `PostLoad` method for an entity is
invoked after the entity has been loaded into the current persistence
context from the database or after the refresh operation has been
applied to it. The `PostLoad` method is invoked before a query result is
returned or accessed or before an association is traversed.

It is implementation-dependent as to whether
callback methods are invoked before or after the cascading of the
lifecycle events to related entities. Applications should not depend on
this ordering.

For example:

[source,java]
----
@Entity
@EntityListeners(com.acme.AlertMonitor.class)
public class Account {
    Long accountId;
    Integer balance;
    boolean preferred;

    @Id
    public Long getAccountId() { ... }

    // ...

    public Integer getBalance() { ... }

    // ...

    @Transient // because status depends upon non-persistent context
    public boolean isPreferred() { ... }

    // ...

    public void deposit(Integer amount) { ... }

    public Integer withdraw(Integer amount) throws NSFException { ... }

    @PrePersist
    protected void validateCreate() {
        if (getBalance() < MIN_REQUIRED_BALANCE)
            throw new AccountException("Insufficient balance to open an account");
    }

    @PostLoad
    protected void adjustPreferredStatus() {
        preferred = (getBalance() >= AccountManager.getPreferredStatusLevel());
    }
}

public class AlertMonitor {
    @PostPersist
    public void newAccountAlert(Account acct) {
        Alerts.sendMarketingInfo(acct.getAccountId(), acct.getBalance());
    }
}
----

==== Multiple Lifecycle Callback Methods for an Entity Lifecycle Event [[a2251]]

If multiple callback methods are defined for
an entity lifecycle event, the ordering of the invocation of these
methods is as follows.

Default listeners, if any, are invoked first,
in the order specified in the XML descriptor. Default listeners apply to
all entities in the persistence unit, unless explicitly excluded by
means of the `ExcludeDefaultListeners` annotation or
`exclude-default-listeners` XML element.

The lifecycle callback methods defined on the
entity listener classes for an entity class or mapped superclass are
invoked in the same order as the specification of the entity listener
classes in the `EntityListeners` annotation.

If multiple classes in an inheritance
hierarchy—entity classes and/or mapped superclasses—define entity
listeners, the listeners defined for a superclass are invoked before the
listeners defined for its subclasses in this order. The
`ExcludeSuperclassListeners` annotation or
`exclude-superclass-listeners` XML element may be applied to an entity
class or mapped superclass to exclude the invocation of the listeners
defined by the entity listener classes for the superclasses of the
entity or mapped superclass. The excluded listeners are excluded from
the class to which the `ExcludeSuperclassListeners` annotation or
element has been specified and its subclassesfootnote:[Excluded listeners
may be reintroduced on an entity class by listing them explicitly in the
`EntityListeners` annotation or XML `entity-listeners` element.].
The `ExcludeSuperclassListeners` annotation (or
`exclude-superclass-listeners` XML element) does not cause default
entity listeners to be excluded from invocation.

If a lifecycle callback method for the
same lifecycle event is also specified on the entity class and/or one or
more of its entity or mapped superclasses, the callback methods on the
entity class and/or superclasses are invoked after the other lifecycle
callback methods, most general superclass first. A class is permitted to
override an inherited callback method of the same callback type, and in
this case, the overridden method is not invokedfootnote:[If a method overrides
an inherited callback method but specifies a different lifecycle event
or is not a lifecycle callback method, the overridden method will not be
invoked.].

Callback methods are invoked by the
persistence provider runtime in the order specified. If the callback
method execution terminates normally, the persistence provider runtime
then invokes the next callback method, if any.

The XML descriptor may be used to override
the lifecycle callback method invocation order specified in annotations.

For example:

There are several entity classes and listeners for animals:

[source,java]
----
@Entity
public class Animal {

    // ...

    @PostPersist
    protected void postPersistAnimal() {
        // ...
    }
}

@Entity
@EntityListeners(PetListener.class)
public class Pet extends Animal {
    // ...
}

@Entity
@EntityListeners({CatListener.class, CatListener2.class})
public class Cat extends Pet {
    // ...
}

public class PetListener {
    @PostPersist
    protected void postPersistPetListenerMethod(Object pet) {
        // ...
    }
}

public class CatListener {
    @PostPersist
    protected void postPersistCatListenerMethod(Object cat) {
        // ...
    }
}

public class CatListener2 {
    @PostPersist
    protected void postPersistCatListener2Method(Object cat) {
        // ...
    }
}
----

If a `PostPersist` event occurs on an
instance of `Cat`, the following methods are called in order:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistAnimal

Assume that `SiameseCat` is defined as a
subclass of `Cat`:

[source,java]
----
@EntityListeners(SiameseCatListener.class)
@Entity
public class SiameseCat extends Cat {
    // ...

    @PostPersist
    protected void postPersistSiameseCat() {
        // ...
    }
}

public class SiameseCatListener {
    @PostPersist
    protected void postPersistSiameseCatListenerMethod(Object cat) {
        // ...
    }
}
----

If a `PostPersist` event occurs on an
instance of `SiameseCat`, the following methods are called in order:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistSiameseCatListenerMethod
. postPersistAnimal
. postPersistSiameseCat

Assume the definition of `SiameseCat` were instead:

[source,java]
----
@EntityListeners(SiameseCatListener.class)
@Entity
public class SiameseCat extends Cat {
    // ...

    @PostPersist
    protected void postPersistAnimal() {
        // ...
    }
}
----

In this case, the following methods would be
called in order, where `postPersistAnimal` is the `PostPersist` method
defined in the `SiameseCat` class:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistSiameseCatListenerMethod
. postPersistAnimal

==== Exceptions

Lifecycle callback methods may throw runtime
exceptions. A runtime exception thrown by a callback method that
executes within a transaction causes that transaction to be marked for
rollback if the persistence context is joined to the transaction. No
further lifecycle callback methods will be invoked after a runtime
exception is thrown.

==== Specification of Callback Listener Classes and Lifecycle Methods in the XML Descriptor

The XML descriptor can be used as an
alternative to metadata annotations to specify entity listener classes
and their binding to entities or to override the invocation order of
lifecycle callback methods as specified in annotations.

===== Specification of Callback Listeners

The `entity-listener` XML descriptor element
is used to specify the lifecycle listener methods of an entity listener
class. The lifecycle listener methods are specified by using the
`pre-persist`, `post-persist`, `pre-remove`, `post-remove`,
`pre-update`, `post-update`, and/or `post-load` elements.

An entity listener class can define multiple
callback methods. However, at most one method of an entity listener
class can be designated as a pre-persist method, post-persist method,
pre-remove method, post-remove method, pre-update method, post-update
method, and/or post-load method, regardless of whether the XML
descriptor is used to define entity listeners or whether some
combination of annotations and XML descriptor elements is used.

===== Specification of the Binding of Entity Listener Classes to Entities

The `entity-listeners` subelement of the
`persistence-unit-defaults` element is used to specify the default
entity listeners for the persistence unit.

The `entity-listeners` subelement of the
`entity` or `mapped-superclass` element is used to specify the entity
listener classes for the respective entity or mapped superclass and its
subclasses.

The binding of entity listeners to entity
classes is additive. The entity listener classes bound to the
superclasses of an entity or mapped superclass are applied to it as
well.

The `exclude-superclass-listeners` element
specifies that the listener methods for superclasses are not to be
invoked for an entity class (or mapped superclass) and its subclasses.

The `exclude-default-listeners` element
specifies that default entity listeners are not to be invoked for an
entity class (or mapped superclass) and its subclasses.

Explicitly listing an excluded default or
superclass listener for a given entity class or mapped superclass causes
it to be applied to that entity or mapped superclass and its subclasses.

In the case of multiple callback methods for
a single lifecycle event, the invocation order rules described in <<a2251>> apply.

=== Bean Validation [[a2366]]

This specification defines support for use of
Bean Validation <<a19498>> within Jakarta Persistence
applications.

Managed classes (entities, mapped
superclasses, and embeddable classes) may be configured to include Bean
Validation constraints.

Automatic validation using these constraints
is achieved by specifying that Jakarta Persistence delegate validation to
the Bean Validation implementation upon the pre-persist, pre-update, and
pre-remove entity lifecycle events described in <<a2202>>.

Validation can also be achieved by the
application calling the `validate` method of a `Validator` instance upon
an instance of a managed class, as described in the Bean Validation
specification <<a19498>>.

==== Automatic Validation Upon Lifecycle Events

This specification supports the use of bean
validation for the automatic validation of entities upon the
pre-persist, pre-update, and pre-remove lifecycle validation events.
These lifecycle validation events occur immediately after the point at
which all the `PrePersist`, `PreUpdate`, and `PreRemove` lifecycle
callback method invocations respectively have been completed, or
immediately after the point at which such lifecycle callback methods
would have been completed (in the event that such callback methods are
not present).

[NOTE]
====
In the case where an entity is persisted and
subsequently modified in a single transaction or when an entity is
modified and subsequently removed in a single transaction, it is
implementation dependent as to whether the pre-update validation event
occurs. Portable applications should not rely on this behavior.
====

===== Enabling Automatic Validation [[a2374]]

The `validation-mode` element of the
`persistence.xml` file determines whether the automatic lifecycle event
validation is in effect. The values of the `validation-mode` element are
`AUTO`, `CALLBACK`, `NONE`. The default validation mode is `AUTO`.

If the application creates the entity manager
factory using the `Persistence.createEntityManagerFactory` method, the
validation mode can be specified using the
`jakarta.persistence.validation.mode` map key, which will override the
value specified (or defaulted) in the `persistence.xml` file. The map
values for this key are _"auto"_, _"callback"_, _"none"_.

If the auto validation mode is specified by
the `validation-mode` element or the `jakarta.persistence.validation.mode`
property, or if neither the `validation-mode` element nor the
`jakarta.persistence.validation.mode` property is specified, and a Bean
Validation provider is present in the environment, the persistence
provider must perform the automatic validation of entities as described
in <<a2380>>. If no Bean Validation provider is
present in the environment, no lifecycle event validation takes place.

If the callback validation mode is specified
by the `validation-mode` element or the
`jakarta.persistence.validation.mode` property, the persistence provider
must perform the lifecycle event validation as described in <<a2380>>.
It is an error if there is no Bean Validation
provider present in the environment, and the provider must throw the
`PersistenceException` if the `jakarta.persistence.validation.mode`
property value _"callback"_ has been passed to the
`Persistence.createEntityManagerFactory` method.

If the none validation mode is specified by
the `validation-mode` element or the `jakarta.persistence.validation.mode`
property, the persistence provider must not perform lifecycle event
validation.

===== Requirements for Automatic Validation upon Lifecycle Events [[a2380]]

For each event type, a list of groups is
targeted for validation. By default, the default Bean Validation group
(the group `Default`) will be validated upon the pre-persist and
pre-update lifecycle validation events, and no group will be validated
upon the pre-remove event.

This default validation behavior can be
overridden by specifying the target groups using the following
validation properties in the `persistence.xml` file or by passing these
properties in the configuration of the entity manager factory through
the `createEntityManagerFactory` method:


* `jakarta.persistence.validation.group.pre-persist`
* `jakarta.persistence.validation.group.pre-update`
* `jakarta.persistence.validation.group.pre-remove`

The value of a validation property must be a
list of the targeted groups. A targeted group must be specified by its
fully qualified class name. Names must be separated by a comma.

When one of the above events occurs for an
entity, the persistence provider must validate that entity by obtaining
a `Validator` instance from the validator factory in use (see <<a2394>>) and
invoking its `validate` method with the targeted groups. If the list of
targeted groups is empty, no validation is performed. If the set of
`ConstraintViolation` objects returned by the `validate` method is not
empty, the persistence provider must throw the
`jakarta.validation.ConstraintViolationException` containing a reference
to the returned set of `ConstraintViolation` objects, and must mark the
transaction for rollback if the persistence context is joined to the
transaction.

The validator instance that is used for
automatic validation upon lifecycle events must use a
`TraversableResolver` that has the following behavior:

* Attributes that have not been loaded must not
be loaded.
* Validation cascade (`@Valid`) must not
occur for entity associations (single- or multi-valued).

These requirements guarantee that no unloaded
attribute or association will be loaded by side effect and that no
entity will be validated more than once during a given flush cycle.

Embeddable attributes must be validated only
if the `Valid` annotation has been specified on them.

It is the responsibility of the persistence
provider to pass an instance implementing the
`jakarta.validation.TraversableResolver` interface to the Bean Validation
provider by calling
`ValidatorFactory.usingContext().traversableResolver(tr).getValidator()` where `tr` is the resolver having the behavior described above.

==== Providing the ValidatorFactory [[a2394]]

In Jakarta EE environments, a `ValidatorFactory`
instance is made available by the Jakarta EE container. The container is
responsible for passing this validator factory to the persistence
provider via the map that is passed as an argument to the
`createContainerEntityManagerFactory` call. The map key used by the
container must be the standard property name
`jakarta.persistence.validation.factory`.

In Java SE environments, the application can
pass the `ValidatorFactory` instance via the map that is passed as an
argument to the `Persistence.createEntityManagerFactory` call. The map
key used must be the standard property name
`jakarta.persistence.validation.factory`. If no `ValidatorFactory`
instance is provided by the application, and if a Bean Validation
provider is present in the classpath, the persistence provider must
instantiate the `ValidatorFactory` using the default bootstrapping
approach defined by the Bean Validation specification
<<a19498>>, namely `Validation.buildDefaultValidatorFactory()`.

=== Entity Graphs [[a2397]]

An entity graph is a template that captures
the path and boundaries for an operation or query. It is defined in the
form of metadata or an object created by the dynamic `EntityGraph` API.

Entity graphs are used in the specification
of “fetch plans” for query or `find` operations.

The `EntityGraph`, `AttributeNode`, and `Subgraph` interfaces found in
<<persistence-api>> are used to dynamically construct entity graphs.

The annotations `NamedEntityGraph`, `NamedAttributeNode`, and
`NamedSubgraph` described in <<a13662>> are used to statically define
entity graphs. The `named-entity-graph` XML element and its subelements
may be used to override these annotations or to define additional named
entity graphs.

The semantics of entity graphs with regard to
find and query operations are described in <<a2814>>.

==== Use of Entity Graphs in find and query operations [[a2814]]

An entity graph can be used with the `find`
method or as a query hint to override or augment `FetchType` semantics.

The standard properties
`jakarta.persistence.fetchgraph` and `jakarta.persistence.loadgraph` are
used to specify such graphs to queries and `find` operations.

The default fetch graph for an entity or
embeddable is defined to consist of the transitive closure of all of its
attributes that are specified as `FetchType.EAGER` (or defaulted as
such).

The persistence provider is permitted to
fetch additional entity state beyond that specified by a fetch graph or
load graph. It is required, however, that the persistence provider fetch
all state specified by the fetch or load graph.

===== Fetch Graph Semantics

When the `jakarta.persistence.fetchgraph`
property is used to specify an entity graph, attributes that are
specified by attribute nodes of the entity graph are treated as
`FetchType.EAGER` and attributes that are not specified are treated as
`FetchType.LAZY`.

The following rules apply, depending on
attribute type. The rules of this section are applied recursively.

A primary key or version attribute never
needs to be specified in an attribute node of a fetch graph. (This
applies to composite primary keys as well, including embedded id primary
keys.) When an entity is fetched, its primary key and version attributes
are always fetched. It is not incorrect, however, to specify primary key
attributes or version attributes.

Attributes other than primary key and version
attributes are assumed not to be fetched unless the attribute is
specified. The following rules apply to the specification of attributes.

* If the attribute is an embedded attribute,
and the attribute is specified in an attribute node, but a subgraph is
not specified for the attribute, the default fetch graph for the
embeddable is fetched. If a subgraph is specified for the attribute, the
attributes of the embeddable are fetched according to their
specification in the corresponding subgraph.
* If the attribute is an element collection of
basic type, and the attribute is specified in an attribute node, the
element collection together with its basic elements is fetched.
* If the attribute is an element collection of
embeddables, and the attribute is specified in an attribute node, but a
subgraph is not specified for the attribute, the element collection
together with the default fetch graph of its embeddable elements is
fetched. If a subgraph is specified for the attribute, the attributes of
the embeddable elements are fetched according to the corresponding
subgraph specification.
* If the attribute is a one-to-one or
many-to-one relationship, and the attribute is specified in an attribute
node, but a subgraph is not specified for the attribute, the default
fetch graph of the target entity is fetched. If a subgraph is specified
for the attribute, the attributes of the target entity are fetched
according to the corresponding subgraph specification.
* If the attribute is a one-to-many or
many-to-many relationship, and the attribute is specified in an
attribute node, but a subgraph is not specified, the collection is
fetched and the default fetch graphs of the referenced entities are
fetched. If a subgraph is specified for the attribute, the entities in
the collection are fetched according to the corresponding subgraph
specification.
* If the key of a map which has been specified
in an attribute node is a basic type, it is fetched. If the key of a map
which has been specified in an attribute node is an embedded type, the
default fetch graph is fetched for the embeddable. Otherwise, if the key
of the map is an entity, and a map key subgraph is not specified for the
attribute node, the map key is fetched according to its default fetch
graph. If a key subgraph is specified for the map key attribute, the map
key attribute is fetched according to the map key subgraph
specification.


*Examples:*

[source,java]
----
@NamedEntityGraph
@Entity
public class Phonenumber {
    @Id
    protected String number;

    protected PhoneTypeEnum type;

    // ...
}
----

In the above example, only the `number` attribute would be eagerly fetched.

[source,java]
----
@NamedEntityGraph
@Entity
public class Employee {
    @Id
    @GeneratedValue
    protected long id;

    @Basic
    protected String name;

    @Basic
    protected String employeeNumber;

    @OneToMany
    protected List<Dependents> dependents;

    @OneToMany
    @NamedEntityGraphAttributeNode
    protected List<Project> projects;

    @OneToMany
    protected List<PhoneNumber> phoneNumbers;

    // ...
}

@Entity
@Inheritance
public class Project {
    @Id
    @GeneratedValue
    protected long id;

    String name;

    @OneToOne(fetch=FetchType.EAGER)
    protected Requirements doc;

    // ...
}

@Entity
public class LargeProject extends Project {
    @OneToOne(fetch=FetchType.LAZY)
    protected Employee approver;

    // ...
}

@Entity
public class Requirements {
    @Id
    protected long id;

    @Lob
    protected String description;

    @OneToOne(fetch=FetchType.LAZY)
    protected Approval approval

    // ...
}
----

In the above example, the `Employee` entity's
primary key will be fetched as well as the related `Project` instances,
whose default fetch graph (`id`, `name`, and `doc` attributes) will
be fetched. The related `Requirements` object will be fetched according
to its default fetch graph.

If the `approver` attribute of `LargeProject`
were `FetchType.EAGER`, and if any of the projects were instances of
`LargeProject`, their `approver` attributes would also be fetched.
Since the type of the `approver` attribute is `Employee`, the
approver's default fetch graph (`id`, `name`, and `employeeNumber`
attributes) would also be fetched.

===== Load Graph Semantics

When the `jakarta.persistence.loadgraph`
property is used to specify an entity graph, attributes that are
specified by attribute nodes of the entity graph are treated as
`FetchType.EAGER` and attributes that are not specified are treated
according to their specified or default FetchType.

The following rules apply. The rules of this
section are applied recursively.

* A primary key or version attribute never
needs to be specified in an attribute node of a load graph. (This
applies to composite primary keys as well, including embedded id primary
keys.) When an entity is fetched, its primary key and version attributes
are always fetched. It is not incorrect, however, to specify primary key
attributes or version attributes.
* If the attribute is an embedded attribute,
and the attribute is specified in an attribute node, but a subgraph is
not specified for the attribute, the default fetch graph for the
embeddable is fetched. If a subgraph is specified for the attribute,
attributes that are specified by the subgraph are also fetched.
* If the attribute is an element collection of
basic type, and the attribute is specified in an attribute node, the
element collection together with its basic elements is fetched.
* If the attribute is an element collection of
embeddables, and the attribute is specified in an attribute node, the
element collection together with the default fetch graph of its
embeddable elements is fetched. If a subgraph is specified for the
attribute, attributes that are specified by the subgraph are also
fetched.
* If the attribute is a one-to-one or
many-to-one relationship, and the attribute is specified in an attribute
node, the default fetch graph of the target entity is fetched. If a
subgraph is specified for the attribute, attributes that are specified
by the subgraph are also fetched.
* If the attribute is a one-to-many or
many-to-many relationship, and the attribute is specified in an
attribute node, the collection is fetched and the default fetch graphs
of the referenced entities are fetched. If a subgraph is specified for
the attribute, attributes that are specified by the subgraph are also
fetched.
* If the key of a map which has been specified
in an attribute node is a basic type, it is fetched. If the key of a map
which has been specified in an attribute node is an embedded type, the
default fetch graph is fetched for the embeddable. Otherwise, if the key
of the map is an entity, the map key is fetched according to its default
fetch graph. If a key subgraph is specified for the map key attribute,
additional attributes are fetched as specified in the key subgraph.

*Examples:*

[source,java]
----
@NamedEntityGraph
@Entity
public class Phonenumber {
    @Id
    protected String number;

    protected PhoneTypeEnum type;

    // ...
}
----

In the above example, the `number` and `type` attributes are fetched.

[source,java]
----
@NamedEntityGraph
@Entity
public class Employee {
    @Id
    @GeneratedValue
    protected long id;

    @Basic
    protected String name;

    @Basic
    protected String employeeNumber;

    @OneToMany
    protected List<Dependents> dependents;

    @OneToMany
    protected List<Project> projects;

    @OneToMany
    @NamedEntityGraphAttributeNode
    protected List<PhoneNumber> phoneNumbers;

    // ...
}

@Entity
@Inheritance
public class Project {
    @Id
    @GeneratedValue
    protected long id;

    String name;

    @OneToOne(fetch=FetchType.EAGER)
    protected Requirements doc;

    // ...
}

@Entity
public class LargeProject extends Project {
    @OneToOne(fetch=FetchType.LAZY)
    protected Employee approver;

    // ...
}

@Entity
public class Requirements {
    @Id
    protected long id;

    @Lob
    protected String description;

    @OneToOne(fetch=FetchType.LAZY)
    protected Approval approval

    // ...
}
----

In the above example, the default fetch graph
(`id`, `name`, `employeeNumber` attributes) of `Employee` is fetched.
The default fetch graphs of the related `Project` instances (`id`,
`name`, and `doc` attributes) and their `Requirements` instances (`id`
and `description` attributes) are also fetched.

=== Type Conversion of Basic Attributes [[a2999]]

The attribute conversion facility allows the developer to define custom
attribute converters. A `converter` is a class whose methods convert
between:

- the _target type_ of the converter, an arbitrary Java type which may be
  used as the type of a persistent field or property, and
- a basic type (see <<a486>>) used as an intermediate step in mapping to
  the database representation.

A converter can be used to convert attributes defined by entity classes,
mapped superclasses, or embeddable classes.footnote:[We plan to provide a
facility for more complex attribute conversions in a future release of
this specification.] A converted attribute is considered a basic attribute,
since, with the aid of the converter, its values can be represented as
instances of a basic type.

Every attribute converter class must implement the interface
`jakarta.persistence.AttributeConverter` and must be annotated with the
`Converter` annotation or declared as a converter in the XML descriptor.
If the value of the `autoApply` element of the `Converter` annotation is
`true`, the converter is automatically applied to all attributes of the
target type, including to basic attribute values that are contained within
other, more complex attribute types. See <<a13903>>.

[source,java]
----
include::../../../../api/src/main/java/jakarta/persistence/AttributeConverter.java[lines=18..-1]
----


Attribute converter classes in Jakarta EE
environments support dependency injection through the Contexts and
Dependency Injection API (CDI) <<a19500>> when CDI is
enabledfootnote:[CDI is enabled by
default in Jakarta EE. See the Jakarta EE specification
<<a19499>>.]. An attribute converter class that makes
use of CDI injection may also define lifecycle callback methods
annotated with the `PostConstruct` and `PreDestroy` annotations. These
methods will be invoked after injection has taken place and before the
attribute converter instance is destroyed respectively.

The persistence provider is responsible for
using the CDI SPI to create instances of the attribute converter class;
to perform injection upon such instances; to invoke their
`PostConstruct` and `PreDestroy` methods, if any; and to dispose of the
attribute converter instances.

The persistence provider is only required to
support CDI injection into attribute converters in Jakarta EE container
environmentsfootnote:[The persistence
provider may support CDI injection into attribute converters in other
environments in which the BeanManager is available.]. If CDI is not enabled, the
persistence provider must not invoke attribute converters that depend
upon CDI injection.

An attribute converter is a noncontextual
object. In supporting injection into attribute converters, the
persistence provider must behave as if it carries out the following
steps involving the use of the CDI SPI. (See
<<a19500>>).

* Obtain a `BeanManager` instance. (See <<a12802>>.)
* Create an `AnnotatedType` instance for the attribute converter class.
* Create an `InjectionTarget` instance for the annotated type.
* Create a `CreationalContext`.
* Instantiate the listener by calling the `InjectionTarget` `produce` method.
* Inject the listener instance by calling the `InjectionTarget` `inject` method on the instance.
* Invoke the `PostConstruct` callback, if any,
by calling the `InjectionTarget` `postConstruct` method on the instance.

When the listener instance is to be
destroyed, the persistence provider must behave as if it carries out the
following steps.

* Call the `InjectionTarget` `preDestroy` method on the instance.
* Call the `InjectionTarget` `dispose` method on the instance.
* Call the `CreationalContext` `release` method.

Persistence providers may optimize the steps
above, e.g. by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

Attribute converters that do not make use of
CDI injection are stateless. The lifecycle of such attribute converters
is unspecified.

The conversion of all basic types is
supported except for the following: Id attributes (including the
attributes of embedded ids and derived identities), version attributes,
relationship attributes, and attributes explicitly annotated as
`Enumerated` or `Temporal` or designated as such in the XML descriptor.
Auto-apply converters will not be applied to such attributes, and
applications that apply converters to such attributes through use of the
`Convert` annotation will not be portable.

Type conversion may be specified at the level
of individual attributes by means of the `Convert` annotation. The
`Convert` annotation may also be used to override or disable an
auto-apply conversion. See <<a14398>>.

The `Convert` annotation may be applied
directly to an attribute of an entity, mapped superclass, or embeddable
class to specify conversion of the attribute or to override the use of a
converter that has been specified as `autoApply=true`. When persistent
properties are used, the `Convert` annotation is applied to the getter
method.

The `Convert` annotation may be applied to an
entity that extends a mapped superclass to specify or override the
conversion mapping for an inherited basic or embedded attribute.

The persistence provider runtime is
responsible for invoking the specified conversion methods for the target
attribute type when loading the entity attribute from the database and
before storing the entity attribute state to the database. The
persistence provider must apply any conversion methods to instances of
attribute values in path expressions used within Jakarta Persistence query
language queries or criteria queries (such as in comparisons, bulk
updates, etc.) before sending them to the database for the query
execution. When such converted attributes are used in comparison
operations with literals or parameters, the value of the literal or
parameter to which they are compared must also be converted. If the
result of a Jakarta Persistence query language query or criteria query
includes one or more entity attributes for which conversion mappings
have been specified, the persistence provider must apply the specified
conversions to the corresponding values in the query result before
returning them to the application. The use of functions, including
aggregates, on converted attributes is undefined. If an exception is
thrown from a conversion method, the persistence provider must wrap the
exception in a PersistenceException and, if the persistence context is
joined to a transaction, mark the transaction for rollback.

=== Second-Level Cache [[a3061]]

A persistence provider may support the use of a _second-level cache_,
that is, it might have a way to store data read in one persistence context
for use in subsequent persistence contexts. A second-level cache might
enhance performance, but tends to undermine the semantics of transaction
processing, possibly exposing the application to stale data or similar
anomalies.

Access to the second-level cache, if enabled, is mediated via the
persistence context, and is largely transparent to the application.
As an exception, the `Cache` interface described below in <<a12124>>
allows the application to directly evict data from the second-level cache.

The persistence provider is not required to support use of a second-level
cache.

==== The Shared Cache Mode and Cacheable Annotation [[a3065]]

Whether a given entity is eligible for storage in the second level cache
is determined by:

- the annotations of the entity class, and
- the value specified for the `shared-cache-mode` element of the
  `persistence.xml` file or by the configuration property
  `jakarta.persistence.sharedCache.mode`.

The value of the property `jakarta.persistence.sharedCache.mode` takes
precedence over the value of the `shared-cache-mode` element.

The `shared-cache-mode` element takes one of five possible values,
which are enumerated by `jakarta.persistence.SharedCacheMode`:

- `ALL` specifies that every entity and all its state may be cached.

- `NONE` specifies that caching is disabled for the persistence unit,
  and that the persistence provider must not cache any entity data.

- `ENABLE_SELECTIVE` specifies that an entity may be cached if the
  entity class is explicitly annotated `@Cacheable` or `@Cacheable(true)`,
  or if the equivalent setting is specified in XML.

- `DISABLE_SELECTIVE` specifies that an entity may be cached unless
  the entity class is explicitly annotated `@Cacheable(false)`, or
  unless the equivalent setting is specified in XML.

- `UNSPECIFIED` selects the provider-specific default behavior.

If neither the `shared-cache-mode` element nor the property
`jakarta.persistence.sharedCache.mode` is specified, or if the specified
value is `UNSPECIFIED`, the behavior is not defined, and provider-specific
defaults may apply. In particular, the semantics of the `Cacheable`
annotation (and XML equivalent) is undefined.

If the persistence provider does not support use of a second-level cache,
or if a second-level cache is not installed or not enabled, this setting
may be ignored and no caching will occur.

A persistence provider may support additional vendor-specific mechanisms
for configuring the cache and marking entities eligible (or not) for
storage in the second-level cache. However, if a second-level cache is
supported, and enabled, the provider must respect the configuration options
defined in this section, if specified by the application.

==== Cache Modes

The _cache retrieve mode_ and _cache store mode_ control how a given
persistence context by interacts with the second-level cache.

- The cache retrieve mode may be set by calling `setCacheRetrieveMode()`
  on `EntityManager` or `Query`.
- The cache store mode may be set by calling `setCacheStoreMode()` on
  `EntityManager` or `Query`.
- A cache store mode or cache retrieve mode, or both, may be passed to
  the `find()` method of `EntityManager` as a `FindOption`.
- A cache store mode may be passed to the `refresh()` method of
  `EntityManager` as a `RefreshOption`.

A cache mode specified for a given `Query` instance applies only to
executions of that query, but takes precedence over the current cache
mode of the `EntityManager` to which the `Query` belongs. A cache mode
passed to `find()` or `refresh()` applies only to the method invocation,
and takes precedence over the current cache mode of the `EntityManager`.

Alternatively, a cache mode may be specified using the property name
`jakarta.persistence.cache.retrieveMode` or
`jakarta.persistence.cache.storeMode` by:

- calling the `setProperty()` method of `EntityManager`,
- calling the `setHint()` method of `Query`, or
- passing a map containing one of these properties to `find()` or `refresh()`.

If second-level caching is not enabled (for example, if the
`shared-cache-mode` element is set to `NONE`), cache modes must be
ignored. Similarly, if a given entity is not eligible for storage in
the second-level cache (for example, if the `shared-cache-mode` element
is set to `ENABLE_SELECTIVE`, and the entity is not annotated `@Cacheable`),
cache modes are ignored for operations applying to that entity.

Cache modes must be respected when caching is enabled, regardless of
whether caching is enabled via the configuration options defined by this
specification or via provider-specific mechanisms.

Applications which depend on the cache retrieve mode or cache store mode
but which do not specify the `shared-cache-mode` element are not portable.


`CacheRetrieveMode` enumerates the cache retrieve modes recognized by this
specification. The semantics of each mode is defined by its Javadoc.

[source,java]
----
include::../../../../api/src/main/java/jakarta/persistence/CacheRetrieveMode.java[lines=18..-1]
----


`CacheStoreMode` enumerates the cache store modes recognized by this
specification. The semantics of each mode is defined by its Javadoc.


[source,java]
----
include::../../../../api/src/main/java/jakarta/persistence/CacheStoreMode.java[lines=18..-1]
----

==== Cache Interface [[a12124]]

The `Cache` interface found in <<_cache_>> allows the application to
request eviction of entity data from the second-level cache directly
and immediately, outside the scope of any persistence context.

=== Query APIs [[a3125]]

The `Query` and `TypedQuery` APIs are used
for the execution of both static queries and dynamic queries. These APIs
also support parameter binding and pagination control. The
`StoredProcedureQuery` API is used for the execution of queries that
invoke stored procedures defined in the database.

These interfaces may be found in <<persistence-api>>.

==== Query Execution

Jakarta Persistence query language, Criteria API, and native SQL
select queries are executed using the methods `getResultList`,
`getSingleResult`, and `getSingleResultOrNull`.
Update and delete operations (update and delete “queries”) are
executed using the `executeUpdate` method.

* For `TypedQuery` instances, the query result
type is determined in the case of criteria queries by the type of the
query specified when the `CriteriaQuery` object is created, as described
in <<a10621>>. In the case of Jakarta Persistence query language queries, the type of the
result is determined by the `resultClass` argument to the `createQuery`
or `createNamedQuery` method, and the select list of the query must
contain only a single item which must be assignable to the specified
type.
* For `Query` instances, the elements of a
query result whose select list consists of more than one select
expression are of type `Object[]`. If the select list consists of only
one select expression, the elements of the query result are of type
`Object`. When native SQL queries are used, the SQL result set mapping
(see <<a4427>>), determines
how many items (entities, scalar values, etc.) are returned. If multiple
items are returned, the elements of the query result are of type
`Object[]`. If only a single item is returned as a result of the SQL
result set mapping or if a result class is specified, the elements of
the query result are of type `Object`.

[NOTE]
====
The semantics of the methods

[source,java]
public <T> TypedQuery<T> createQuery(String qlString, Class<T> resultClass)

[source,java]
public <T> TypedQuery<T> createNamedQuery(String name, Class<T> resultClass)

may be extended in a future release of this specification to support other
result types. Use of other result types, including `Tuple.class`, is not
portable.
====


Stored procedure queries can be executed using the `getResultList`,
`getSingleResult`, `getSingleResultOrNull`, and `execute` methods.
Stored procedures that perform only updates or deletes can be executed
using the `executeUpdate` method. Stored procedure query execution is
described in detail in <<a4625>>.

An `IllegalArgumentException` is thrown if a
parameter instance is specified that does not correspond to a parameter
of the query, if a parameter name is specified that does not correspond
to a named parameter of the query, if a positional value is specified
that does not correspond to a positional parameter of the query, or if
the type of the parameter is not valid for the query. This exception may
be thrown when the parameter is bound, or the execution of the query may
fail. See <<a4397>>, <<a4401>>, and <<a4405>> for supported
parameter usage.

The effect of applying `setMaxResults` or
`setFirstResult` to a query involving fetch joins over collections is
undefined. The use of `setMaxResults` and `setFirstResult` is not
supported for stored procedure queries.

`Query` and `TypedQuery` methods other than
the `executeUpdate` method are not required to be invoked within a
transaction context, unless a lock mode other than `LockModeType.NONE`
has been specified for the query. In particular, the `getResultList`,
`getSingleResult`, and `getSingleResultOrNull` methods are not required
to be invoked within a transaction context unless such a lock mode has
been specified for the queryfootnote:[A lock mode is
specified for a query by means of the `setLockMode` method or by
specifying the lock mode in the `NamedQuery` annotation.]. If an entity manager with
transaction-scoped persistence context is in use, the resulting entities
will be detached; if an entity manager with an extended persistence
context is used, they will be managed. See <<a11431>> for further
discussion of entity manager use outside a transaction and persistence context types.

Whether a `StoredProcedureQuery` should be
invoked in a transaction context should be determined by the
transactional semantics and/or requirements of the stored procedure
implementation and the database in use. In particular, problems may
occur if the stored procedure initiates a transaction and a transaction
is already in effect. The state of any entities returned by the stored
procedure query invocation is determined as decribed above.

Runtime exceptions other than the
`NoResultException`, `NonUniqueResultException`,
`QueryTimeoutException`, and `LockTimeoutException` thrown by the
methods of the `Query`, `TypedQuery`, and `StoredProcedureQuery`
interfaces other than those methods specified below cause the current
transaction to be marked for rollback if the persistence context is
joined to the transaction. On database platforms on which a query
timeout causes transaction rollback, the persistence provider must throw
the `PersistenceException` instead of the `QueryTimeoutException`.

Runtime exceptions thrown by the following
methods of the `Query`, `TypedQuery`, and `StoredProcedureQuery`
interfaces do not cause the current transaction to be marked for
rollback: `getParameters`, `getParameter`, `getParameterValue`,
`getOutputParameterValue`, `getLockMode`.

Runtime exceptions thrown by the methods of
the `Tuple`, `TupleElement`, and `Parameter` interfaces do not cause
the current transaction to be marked for rollback.

For example:

[source,java]
----
public List findWithName(String name) {
    return em.createQuery("SELECT c FROM Customer c WHERE c.name LIKE :custName")
        .setParameter("custName", name)
        .setMaxResults(10)
        .getResultList();
}
----

==== Queries and Flush Mode [[a4374]]

The flush mode setting affects the result of
a query as follows.

When queries are executed within a
transaction, if `FlushModeType.AUTO` is set on the `Query`,
`TypedQuery`, or `StoredProcedureQuery` object, or if the flush mode
setting for the persistence context is `AUTO` (the default) and a flush
mode setting has not been specified for the query object, the
persistence provider is responsible for ensuring that all updates to the
state of all entities in the persistence context which could potentially
affect the result of the query are visible to the processing of the
query. The persistence provider implementation may achieve this by
flushing those entities to the database or by some other means. If
`FlushModeType.COMMIT` is set, the effect of updates made to entities in
the persistence context upon queries is unspecified.

If the persistence context has not been
joined to the current transaction, the persistence provider must not
flush to the database regardless of the flush mode setting.

[source,java]
----
include::../../../../api/src/main/java/jakarta/persistence/FlushModeType.java[lines=18..-1]
----


If there is no transaction active, the
persistence provider must not flush to the database.

==== Queries and Lock Mode [[a4385]]

The `setLockMode` method of the
`Query` or `TypedQuery` interface or the `lockMode` element of the
`NamedQuery` annotation may be used to lock the results of a query. A
lock is obtained for each entity specified in the query result
(including entities passed to constructors in the query SELECT
clause).footnote:[Note that the
setLockMode method may be called more than once (with different values)
on a Query or TypedQuery object.]

If the lock mode type is `PESSIMISTIC_READ`,
`PESSIMISTIC_WRITE`, or `PESSIMISTIC_FORCE_INCREMENT`, and the query
returns scalar data (e.g., the values of entity field or properties,
including scalar data passed to constructors in the query SELECT
clause), the underlying database rows will be
lockedfootnote:[Note that locking
will not occur for data passed to aggregate functions. Further, queries
involving aggregates with pessimistic locking may not be supported on
all database platforms.], but the version columns (if any) for any
entities corresponding to such scalar data will not be updated unless
the entities themselves are also otherwise retrieved and updated.

If the lock mode type is `OPTIMISTIC` or
`OPTIMISTIC_FORCE_INCREMENT`, and the query returns scalar data, any
entities returned by the query will be locked, but no locking will occur
for scalar data that does not correspond to the state of any entity
instance in the query result.

If a lock mode other than `NONE` is specified
for a query, the query must be executed within a transaction (and the
persistence context must be joined to the transaction) or the
`TransactionRequiredException` will be thrown.

Locking is supported for Jakarta Persistence
query language queries and criteria queries only. If the `setLockMode`
or `getLockMode` method is invoked on a query that is not a Jakarta
Persistence query language select query or a criteria query, the
`IllegalStateException` may be thrown or the query execution will fail.

==== Query Hints [[a4391]]

The following hint is defined by this specification for use in query configuration.

 jakarta.persistence.query.timeout // time in milliseconds

This hint may:

- be passed to the `setHint()` method of the `Query`, `TypedQuery`,
  and `StoredProcedureQuery` interfaces found in <<persistence-api>>,
- used with the `NamedQuery`, `NamedNativeQuery`, and
  `NamedStoredProcedureQuery` annotations specified in <<a13710>>,
- passed as a property to the `createEntityManagerFactory()` method
  of the `Persistence` class, as defined in <<a13443>>, or
- used in the `properties` element of the `persistence.xml` file, as
  defined in <<a12384>>.

The timeout specified by calling the `createEntityManagerFactory()`
method, via the `persistence.xml` file, or in annotations, serves as
a default value which can be selectively overridden by calling the
`setHint()` method.

Portable applications should not rely on this
hint. Depending on the persistence provider and database in use, the
hint may or may not be observed.

Vendors are permitted to support the use of
additional, vendor-specific hints. Vendor-specific hints must not use
the `jakarta.persistence` namespace. Vendor-specific hints must be ignored
if they are not understood.

==== Parameter Objects [[a4397]]

`Parameter` objects can be used for criteria
queries and for Jakarta Persistence query language queries.

Implementations may support the use of
`Parameter` objects for native queries, however support for `Parameter`
objects with native queries is not required by this specification. The
use of `Parameter` objects for native queries will not be portable. The
mixing of parameter objects with named or positional parameters is invalid.

Portable applications should not attempt to
reuse a `Parameter` object obtained from a `Query` or `TypedQuery`
instance in the context of a different `Query` or `TypedQuery` instance.

==== Named Parameters [[a4401]]

Named parameters can be used for Jakarta
Persistence query language queries, for criteria queries (although use
of `Parameter` objects is to be preferred), and for stored procedure
queries that support named parameters.

Named parameters follow the rules for
identifiers defined in <<a4760>>.
Named parameters are case-sensitive. The mixing of named and positional
parameters is invalid.

A named parameter of a Jakarta Persistence query
language query is an identifier that is prefixed by the " _:_ " symbol.
The parameter names passed to the `setParameter` methods of the `Query`
and `TypedQuery` interfaces do not include this " _:_ " prefix.

==== Positional Parameters [[a4405]]

Only positional parameter binding and
positional access to result items may be portably used for native
queries, except for stored procedure queries for which named parameters
have been defined. When binding the values of positional parameters, the
numbering starts as “ `1` ”. It is assumed that for native queries the
parameters themselves use the SQL syntax (i.e., “ _?_ ”, rather than “
_?1_ ”).

The use of positional parameters is not supported for criteria queries.

==== Arguments to query parameters

Arguments are assigned to query parameters by calling `Query.setParameter()`.
The first parameter of `setParameter()` identifies the named or positional
parameter of the query.

An argument may be assigned to a single-valued parameter of a JPQL or
native SQL query by passing the argument to the second parameter of
`setParameter()`.

[source,java]
----
query.setParameter("name", name)
----

A list of arguments may be assigned to a collection-valued parameter
of a JPQL query by packaging the arguments in a non-null instance of
`java.util.List` and passing the list as an argument to the second
parameter of `setParameter()`. The list should contain at least one
element. If the list is empty the behavior is undefined. Portable
applications should not pass an empty list to a collection-valued
parameter.

[source,java]
----
query.setParameter("names", List.of(name1, name2, name3))
----

==== Named Queries

Named queries are static queries expressed in
metadata or queries registered by means of the EntityManagerFactory
`addNamedQuery` method. Named queries can be defined in the Jakarta
Persistence query language or in SQL. Query names are scoped to the
persistence unit.

The following is an example of the definition
of a named query defined in metadata:

[source,java]
----
@NamedQuery(
    name="findAllCustomersWithName",
    query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
)
----

The following is an example of the use of a named query:

[source,java]
----
@PersistenceContext
public EntityManager em;
    // ...

    customers = em.createNamedQuery("findAllCustomersWithName")
        .setParameter("custName", "Smith")
        .getResultList();
----

==== Polymorphic Queries

By default, all queries are polymorphic. That
is, the FROM clause of a query designates not only instances of the
specific entity class(es) to which it explicitly refers, but subclasses
as well. The instances returned by a query include instances of the
subclasses that satisfy the query conditions.

For example, the following query returns the
average salary of all employees, including subtypes of `Employee`, such
as `Manager` and `Exempt`.

[source,sql]
----
select avg(e.salary) from Employee e where e.salary > 80000
----

Entity type expressions, described in <<a5381>>, as well as the
use of downcasting, described in <<a4965>>, can be used to restrict query polymorphism.

==== SQL Queries [[a4427]]

Queries may be expressed in native SQL. The
result of a native SQL query may consist of entities, unmanaged
instances created via constructors, scalar values, or some combination
of these.

[NOTE]
====
The SQL query facility is intended to provide
support for those cases where it is necessary to use the native SQL of
the target database in use (and/or where the Jakarta Persistence query
language cannot be used). Native SQL queries are not expected to be
portable across databases.
====

===== Returning Managed Entities from Native Queries

The persistence provider is responsible for
performing the mapping between the values returned by the SQL query and
entity attributes in accordance with the object/relational mapping
metadata for the entity or entities. In particular, the names of the
columns in the SQL result are used to map to the entity attributes as
defined by this metadata. This mapping includes the mapping of the
attributes of any embeddable classes that are part of the
non-collection-valued entity state and attributes corresponding to
foreign keys contained as part of the entity
statefootnote:[Support for joins is
currently limited to single-valued relationships that are mapped
directly—i.e., not via join tables.].

When an entity is to be returned from a
native query, the SQL statement should select all of the columns that
are mapped to the entity object. This should include foreign key columns
to related entities. The results obtained when insufficient data is
available are undefined.

In the simplest case—i.e., when the results
of the query are limited to entities of a single entity class and the
mapping information can be derived from the columns of the SQL result
and the object/relational mapping metadata—it is sufficient to specify
only the expected class of the entity result.

The following example illustrates the case
where a native SQL query is created dynamically using the
`createNativeQuery` method and the entity class that specifies the type
of the result is passed in as an argument.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item " +
        "FROM Order o, Item i " +
        "WHERE (o.item = i.id) AND (i.name = 'widget')",
    com.acme.Order.class);
----

When executed, this query will return a
collection of all `Order` entities for items named “widget”.

The `SqlResultSetMapping` metadata
annotation—which is designed to handle more complex cases—can be used as
an alternative here. See <<a13797>> for the definition of the
`SqlResultSetMapping` metadata annotation and related annotations.

For the query shown above, the
`SqlResultSetMapping` metadata for the query result type might be
specified as follows:

[source,java]
----
@SqlResultSetMapping(
    name="WidgetOrderResults",
    entities=@EntityResult(entityClass=com.acme.Order.class))
----

The same results as produced by the query
above can then obtained by the following:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item " +
        "FROM Order o, Item i " +
        "WHERE (o.item = i.id) AND (i.name = 'widget')",
    "WidgetOrderResults");
----

When multiple entities are returned by a SQL
query or when the column names of the SQL result do not correspond to
those of the object/relational mapping metadata, a `SqlResultSetMapping`
metadata definition must be provided to specify the entity mapping.

The following query and `SqlResultSetMapping`
metadata illustrates the return of multiple entity types. It assumes
default metadata and column name defaults.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item, i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (o.quantity > 25) AND (o.item = i.id)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

When the column names of the SQL result do
not correspond to those of the object/relational mapping metadata
or introduce a conflict in mapping column defaults as in the example code above,
more explicit SQL result mapping metadata must be provided to enable the
persistence provider runtime to map the JDBC results into the expected
objects. This might arise, for example, when column aliases must be used
in the SQL SELECT clause when the SQL result would otherwise contain
multiple columns of the same name or when columns in the SQL result are
the results of operators or functions. The `FieldResult` annotation
element within the `EntityResult` annotation is used to specify the
mapping of such columns to entity attributes.

The following example combining multiple
entity types includes aliases in the SQL statement. This requires that
the column names be explicitly mapped to the entity fields corresponding
to those columns. The `FieldResult` annotation is used for this purpose.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item AS order_item, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item = i.id)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item", column="order_item")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

When the returned entity type contains an
embeddable class, the `FieldResult` element must use a dot (“ `.` ”)
notation to indicate which column maps to which field or property of the
contained embeddable.

*Example:*

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT c.id AS customer_id, " +
        "c.street AS customer_street, " +
        "c.city AS customer_city, " +
        "c.state AS customer_state, " +
        "c.status AS customer_status " +
        "FROM Customer c " +
        "WHERE c.status = 'GOLD' ",
    "CustomerResults");

@SqlResultSetMapping(name=”CustomerResults”, entities={
    @EntityResult(entityClass=com.acme.Customer.class, fields={
        @FieldResult(name="id", column="customer_id"),
        @FieldResult(name="address.street", column="customer_street"),
        @FieldResult(name="address.city", column="customer_city"),
        @FieldResult(name="address.state", column="customer_state"),
        @FieldResult(name="status", column="customer_status")
    })
})
----

When the returned entity type is the owner of
a single-valued relationship and the foreign key is a composite foreign
key (composed of multiple columns), a `FieldResult` element should be
used for each of the foreign key columns. The `FieldResult` element must
use the dot (“ `.` ”) notation form to indicate the column that maps to
each property or field of the target entity primary key.

If the target entity has a primary key of
type `IdClass`, this specification takes the form of the name of the
field or property for the relationship, followed by a dot (“ `.` ”),
followed by the name of the field or property of the primary key in the
target entity. The latter will be annotated with `Id`, as specified in
<<a14836>>.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item_id AS order_item_id, " +
        "o.item_name AS order_item_name, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item_id = i.id) " +
        "AND (order_item_name = i.name)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item.id", column="order_item_id")}),
        @FieldResult(name="item.name", column="order_item_name")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

If the target entity has a primary key of
type `EmbeddedId`, this specification is composed of the name of the
field or property for the relationship, followed by a dot (“ `.` ”),
followed by the name or the field or property of the primary key (i.e.,
the name of the field or property annotated as `EmbeddedId`), followed
by the name of the corresponding field or property of the embedded
primary key class.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item_id AS order_item_id, " +
        "o.item_name AS order_item_name, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item_id = i.id) AND (order_item_name = i.name)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item.itemPk.id", column="order_item_id")}),
        @FieldResult(name="item.itemPk.name", column="order_item_name")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

The `FieldResult` elements for the composite
foreign key are combined to form the primary key `EmbeddedId` class for
the target entity. This may then be used to subsequently retrieve the
entity if the relationship is to be eagerly loaded.

The dot-notation form is not required to be
supported for any usage other than for embeddables, composite foreign
keys, or composite primary keys.

===== Returning Unmanaged Instances

Instances of other classes (including
non-managed entity instances) as well as scalar results can be returned
by a native query. These can be used singly, or in combination,
including with entity results.

====== Scalar Results

Scalar results can be included in the query
result by specifying the `ColumnResult` annotation element of the
`SqlResultSetMapping` annotation. The intended type of the result can be
specified using the `type` element of the `ColumnResult` annotation.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item AS order_item, " +
        "i.name AS item_name, " +
        "i.availabilityDate AS item_shipdate " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item = i.id)",
    "OrderResults");

@SqlResultSetMapping(
    name="OrderResults",
    entities={
        @EntityResult(entityClass=com.acme.Order.class, fields={
            @FieldResult(name="id", column="order_id"),
            @FieldResult(name="quantity", column="order_quantity"),
            @FieldResult(name="item", column="order_item")}
        )},
    columns={
        @ColumnResult(name="item_name"),
        @ColumnResult(name="item_shipdate", type=java.util.Date.class)
    })
----

====== Constructor Results

The mapping to constructors is specified
using the `ConstructorResult` annotation element of the
`SqlResultSetMapping` annotation. The `targetClass` element of the
`ConstructorResult` annotation specifies the class whose constructor
corresponds to the specified columns. All columns corresponding to
arguments of the intended constructor must be specified using the
`columns` element of the `ConstructorResult` annotation in the same
order as that of the argument list of the constructor. Any entities
returned as constructor results will be in either the new or the
detached state, depending on whether a primary key is retrieved for the
constructed object.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT c.id, c.name, COUNT(o) as orderCount, AVG(o.price) AS avgOrder " +
        "FROM Customer c, Orders o " +
        "WHERE o.cid = c.id " +
        "GROUP BY c.id, c.name",
    "CustomerDetailsResult");

@SqlResultSetMapping(name="CustomerDetailsResult", classes={
    @ConstructorResult(targetClass=com.acme.CustomerDetails.class, columns={
        @ColumnResult(name="id"),
        @ColumnResult(name="name"),
        @ColumnResult(name="orderCount"),
        @ColumnResult(name="avgOrder", type=Double.class)})
})
----

===== Combinations of Result Types

When a `SqlResultSetMapping` specifies more
than one mapping type (i.e., more than one of `EntityResult`,
`ConstructorResult`, `ColumnResult`), then for each row in the SQL
result, the query execution will result in an `Object[]` instance whose
elements are as follows, in order: any entity results (in the order in
which they are defined in the `entities` element); any instances of
classes corresponding to constructor results (in the order defined in
the `classes` element); and any instances corresponding to column
results (in the order defined in the `columns` element). If there are
any columns whose result mappings have not been specified, they are
ignored.

===== Restrictions

When an entity is being returned, the SQL
statement should select all of the columns that are mapped to the entity
object. This should include foreign key columns to related entities. The
results obtained when insufficient data is available are undefined. A
SQL result set mapping must not be used to map results to the
non-persistent state of an entity.

The use of named parameters is not defined
for native SQL queries. Only positional parameter binding for SQL
queries may be used by portable applications.

==== Stored Procedures

The `StoredProcedureQuery` interface supports
the use of database stored procedures.

Stored procedures can be specified either by
means of the `NamedStoredProcedureQuery` annotation or dynamically.
Annotations for the specification of stored procedures are described in
<<a13759>>.

===== Named Stored Procedure Queries

Unlike in the case of a named native query,
the `NamedStoredProcedureQuery` annotation names a stored procedure that
exists in the database rather than providing a stored procedure
definition. The `NamedStoredProcedureQuery` annotation specifies the
types of all parameters to the stored procedure, their corresponding
parameter modes (IN, OUT, INOUT, REF_CURSORfootnote:[Note that REF_CURSOR
parameters are used by some databases to return result sets from stored
procedures.]), and
how result sets, if any, are to be mapped. The name that is assigned to
the stored procedure in the `NamedStoredProcedureQuery` annotation is
passed as an argument to the `createNamedStoredProcedureQuery` method to
create an executable `StoredProcedureQuery` object.

A stored procedure may return more than one
result set. As with native queries, the mapping of result sets can be
specified either in terms of a `resultClasses` or as a
`resultSetMappings` annotation element. If there are multiple result
sets, it is assumed that they will be mapped using the same mechanism —
e.g., all via a set of result class mappings or all via a set of result
set mappings. The order of the specification of these mappings must be
the same as the order in which the result sets will be returned by the
stored procedure invocation. If the stored procedure returns one or more
result sets and no `resultClasses` or `resultSetMappings` element has
been specified, any result set will be returned as a list of type
`Object[]`. The combining of different strategies for the mapping of
stored procedure result sets is undefined.

`StoredProcedureParameter` metadata needs to
be provided for all parameters. Parameters must be specified in the
order in which they occur in the parameter list of the stored procedure.
If parameter names are used, the parameter name is used to bind the
parameter value and to extract the output value (if the parameter is an
INOUT or OUT parameter). If parameter names are not specified, it is
assumed that positional parameters are used. The mixing of named and
positional parameters is invalid.

===== Dynamically-specified Stored Procedure Queries

If the stored procedure is not defined using
metadata, parameter and result set information must be provided
dynamically.

All parameters of a dynamically-specified
stored procedure query must be registered using the
`registerStoredProcedureParameter` method of the `StoredProcedureQuery`
interface.

Result set mapping information can be
provided by means of the `createStoredProcedureQuery` method.

===== Stored Procedure Query Execution [[a4625]]

Stored procedure query execution can be
controlled as described below.

The `setParameter` methods are used to set
the values of all required IN and INOUT parameters. It is not required
to set the values of stored procedure parameters for which default
values have been defined by the stored procedure.

When `getResultList`, `getSingleResult`, and `getSingleResultOrNull`
are called on a `StoredProcedureQuery` object, the persistence provider
will call `execute` on an unexecuted stored procedure query before
processing `getResultList`, `getSingleResult` or `getSingleResultOrNull`.

When `executeUpdate` is called on a
`StoredProcedureQuery` object, the persistence provider will call
`execute` on an unexecuted stored procedure query followed by
`getUpdateCount`. The results of `executeUpdate` will be those of
`getUpdateCount`.

The `execute` method supports both the simple
case where scalar results are passed back only via INOUT and OUT
parameters as well as the most general case (multiple result sets and/or
update counts, possibly also in combination with output parameter
values).

The `execute` method returns `true` if the
first result is a result set, and `false` if it is an update count or
there are no results other than through INOUT and OUT parameters, if
any.

If the `execute` method returns `true`, the pending result set can be
obtained by calling `getResultList`, `getSingleResult`, or
`getSingleResultOrNull`. The `hasMoreResults` method can then be used to
test for further results.

If `execute` or `hasMoreResults` returns
`false`, the `getUpdateCount` method can be called to obtain the
pending result if it is an update count. The `getUpdateCount` method
will return either the update count (zero or greater) or -1 if there is
no update count (i.e., either the next result is a result set or there
is no next update count).

For portability, results that correspond to
JDBC result sets and update counts need to be processed before the
values of any INOUT or OUT parameters are extracted.

After results returned through
`getResultList` and `getUpdateCount` have been exhausted, results
returned through INOUT and OUT parameters can be retrieved.

The `getOutputParameterValue` methods are
used to retrieve the values passed back from the procedure through INOUT
and OUT parameters.

When using `REF_CURSOR` parameters for result
sets, the update counts should be exhausted before calling
`getResultList` to retrieve the result set. Alternatively, the
`REF_CURSOR` result set can be retrieved through
`getOutputParameterValue`. Result set mappings will be applied to
results corresponding to `REF_CURSOR` parameters in the order the
`REF_CURSOR` parameters were registered with the query.

In the simplest case, where results are
returned only via INOUT and OUT parameters, `execute` can be followed
immediately by calls to `getOutputParameterValue`.

=== Summary of Exceptions [[a4639]]

The following is a summary of the exceptions defined by this specification:

*PersistenceException*

The `PersistenceException` is thrown by the
persistence provider when a problem occurs. It may be thrown to report
that the invoked operation could not complete because of an unexpected
error (e.g., failure of the persistence provider to open a database
connection).

All other exceptions defined by this
specification are subclasses of the `PersistenceException`. All
instances of `PersistenceException` except for instances of
`NoResultException`, `NonUniqueResultException`, `LockTimeoutException`
, and `QueryTimeoutException` will cause the current transaction, if one
is active and the persistence context has been joined to it, to be
marked for rollback.

*TransactionRequiredException*

The `TransactionRequiredException` is thrown
by the persistence provider when a transaction is required but is not
active.

*OptimisticLockException*

The `OptimisticLockException` is thrown by
the persistence provider when an optimistic locking conflict occurs.
This exception may be thrown as part of an API call, at flush, or at
commit time. The current transaction, if one is active, will be marked
for rollback.

*PessimisticLockException*

The `PessimisticLockException` is thrown by
the persistence provider when a pessimistic locking conflict occurs. The
current transaction will be marked for rollback. Typically the
`PessimisticLockException` occurs because the database transaction has
been rolled back due to deadlock or because the database uses
transaction-level rollback when a pessimistic lock cannot be granted.

*LockTimeoutException*

The `LockTimeoutException` is thrown by the
persistence provider when a pessimistic locking conflict occurs that
does not result in transaction rollback. Typically this occurs because
the database uses statement-level rollback when a pessimistic lock
cannot be granted (and there is no deadlock). The `LockTimeoutException`
does not cause the current transaction to be marked for rollback.

*RollbackException*

The `RollbackException` is thrown by the
persistence provider when `EntityTransaction.commit` fails.

*EntityExistsException*

The `EntityExistsException` may thrown by the
persistence provider when the `persist` operation is invoked and the
entity already exists. The `EntityExistsException` may be thrown when
the persist operation is invoked, or the `EntityExistsException` or
another `PersistenceException` may be thrown at commit time. The current
transaction, if one is active and the persistence context has been
joined to it, will be marked for rollback.

*EntityNotFoundException*

The `EntityNotFoundException` is thrown by
the persistence provider when an entity reference obtained by
`getReference` is accessed but the entity does not exist. It is thrown
by the `refresh` operation when the entity no longer exists in the
database. It is also thrown by the `lock` operation when pessimistic
locking is used and the entity no longer exists in the database. The
current transaction, if one is active and the persistence context has
been joined to it, will be marked for rollback.

*NoResultException*

The `NoResultException` is thrown by the persistence provider when
`Query.getSingleResult` is invoked and there is no result to return.
This exception will not cause the current transaction, if one is
active, to be marked for rollback.

*NonUniqueResultException*

The `NonUniqueResultException` is thrown by the persistence provider
when `Query.getSingleResult` or `Query.getSingleResultOrNull` is
invoked and there is more than one result from the query. This
exception will not cause the current transaction, if one is active,
to be marked for rollback.

*QueryTimeoutException*

The `QueryTimeoutException` is thrown by the
persistence provider when a query times out and only the statement is
rolled back. The `QueryTimeoutException` does not cause the current
transaction, if one is active, to be marked for rollback.
