//
// Copyright (c) 2017, 2021 Contributors to the Eclipse Foundation
//

== Entity Operations [[a1060]]

This chapter describes the use of the
_EntityManager_ API to manage the entity instance lifecycle and the use
of the _Query_ API to retrieve and query entities and their persistent
state.

=== EntityManager [[a1062]]

An EntityManager instance is associated with
a persistence context. A persistence context is a set of entity
instances in which for any persistent entity identity there is a unique
entity instance. Within the persistence context, the entity instances
and their lifecycle are managed. The _EntityManager_ interface defines
the methods that are used to interact with the persistence context. The
_EntityManager_ API is used to create and remove persistent entity
instances, to find persistent entities by primary key, and to query over
persistent entities.

The set of entities that can be managed by a
given _EntityManager_ instance is defined by a persistence unit. A
persistence unit defines the set of all classes that are related or
grouped by the application, and which must be colocated in their mapping
to a single database.

<<a1062>> defines the _EntityManager_ interface. The entity
instance lifecycle is described in <<a1929>>. The
relationships between entity managers and persistence contexts are
described in <<a2027>> and in further detail in <<a11431>>.
<<a2052>> describes mechanisms for concurrency control and locking.
<<a2153>> describes entity listeners and lifecycle callback methods for
entities. <<a2366>> describes support for automatic use of Bean Validation.
<<a2397>> describes the use of
entity graphs to control the path and boundaries of find and query
operations. <<a2397>> describes mechanisms for defining conversions between entity
and database representations for attributes of basic types. <<a3061>> describes mechanisms for
portable second-level cache configuration. The _Query_, _TypedQuery_,
_StoredProcedureQuery_, and related interfaces are described in <<a3125>>. <<a4639>> provides a
summary of exceptions. The Jakarta Persistence query language is defined in <<a4665>> and the APIs for
the construction of Criteria queries in <<a6925>>. The definition of
persistence units is described in <<a12229>>.

==== EntityManager Interface [[a1066]]

[source,java]
----
package jakarta.persistence;

import java.util.Map;
import java.util.List;
import jakarta.persistence.metamodel.Metamodel;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.CriteriaUpdate;
import jakarta.persistence.criteria.CriteriaDelete;

/**
 * Interface used to interact with the persistence context.
 *
 * <p> An <code>EntityManager</code> instance is associated with
 * a persistence context. A persistence context is a set of entity
 * instances in which for any persistent entity identity there is
 * a unique entity instance. Within the persistence context, the
 * entity instances and their lifecycle are managed.
 * The <code>EntityManager</code> API is used
 * to create and remove persistent entity instances, to find entities
 * by their primary key, and to query over entities.
 *
 * <p> The set of entities that can be managed by a given
 * <code>EntityManager</code> instance is defined by a persistence
 * unit. A persistence unit defines the set of all classes that are
 * related or grouped by the application, and which must be
 * colocated in their mapping to a single database.
 *
 * @see Query
 * @see TypedQuery
 * @see CriteriaQuery
 * @see PersistenceContext
 * @see StoredProcedureQuery
 *
 * @since 1.0
 */
public interface EntityManager extends AutoCloseable {

    /**
     * Make an instance managed and persistent.
     * @param entity  entity instance
     * @throws EntityExistsException if the entity already exists.
     * (If the entity already exists, the <code>EntityExistsException</code> may
     * be thrown when the persist operation is invoked, or the
     * <code>EntityExistsException</code> or another <code>PersistenceException</code> may be
     * thrown at flush or commit time.)
     * @throws IllegalArgumentException if the instance is not an
     *         entity
     * @throws TransactionRequiredException if there is no transaction when
     *         invoked on a container-managed entity manager of that is of type
     *         <code>PersistenceContextType.TRANSACTION</code>
     */
    public void persist(Object entity);

    /**
     * Merge the state of the given entity into the
     * current persistence context.
     * @param entity  entity instance
     * @return the managed instance that the state was merged to
     * @throws IllegalArgumentException if instance is not an
     *         entity or is a removed entity
     * @throws TransactionRequiredException if there is no transaction when
     *         invoked on a container-managed entity manager of that is of type
     *         <code>PersistenceContextType.TRANSACTION</code>
     */
    public <T> T merge(T entity);

    /**
     * Remove the entity instance.
     * @param entity  entity instance
     * @throws IllegalArgumentException if the instance is not an
     *         entity or is a detached entity
     * @throws TransactionRequiredException if invoked on a
     *         container-managed entity manager of type
     *         <code>PersistenceContextType.TRANSACTION</code> and there is
     *         no transaction
     */
    public void remove(Object entity);

    /**
     * Find by primary key.
     * Search for an entity of the specified class and primary key.
     * If the entity instance is contained in the persistence context,
     * it is returned from there.
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         is not a valid type for that entity's primary key or
     *         is null
     */
    public <T> T find(Class<T> entityClass, Object primaryKey);

    /**
     * Find by primary key, using the specified properties.
     * Search for an entity of the specified class and primary key.
     * If the entity instance is contained in the persistence
     * context, it is returned from there.
     * If a vendor-specific property or hint is not recognized,
     * it is silently ignored.
     * @param entityClass  entity class
     * @param primaryKey   primary key
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         is not a valid type for that entity's primary key or
     *         is null
     * @since 2.0
     */
    public <T> T find(Class<T> entityClass, Object primaryKey,
                      Map<String, Object> properties);

    /**
     * Find by primary key and lock.
     * Search for an entity of the specified class and primary key
     * and lock it with respect to the specified lock type.
     * If the entity instance is contained in the persistence context,
     * it is returned from there, and the effect of this method is
     * the same as if the lock method had been called on the entity.
     * <p> If the entity is found within the persistence context and the
     * lock mode type is pessimistic and the entity has a version
     * attribute, the persistence provider must perform optimistic
     * version checks when obtaining the database lock.  If these
     * checks fail, the <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @param lockMode  lock mode
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         not a valid type for that entity's primary key or
     *         is null
     * @throws TransactionRequiredException if there is no
     *         transaction and a lock mode other than <code>NONE</code> is
     *         specified or if invoked on an entity manager which has
     *         not been joined to the current transaction and a lock
     *         mode other than <code>NONE</code> is specified
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public <T> T find(Class<T> entityClass, Object primaryKey,
                      LockModeType lockMode);

    /**
     * Find by primary key and lock, using the specified properties.
     * Search for an entity of the specified class and primary key
     * and lock it with respect to the specified lock type.
     * If the entity instance is contained in the persistence context,
     * it is returned from there.
     * <p> If the entity is found
     * within the persistence context and the lock mode type
     * is pessimistic and the entity has a version attribute, the
     * persistence provider must perform optimistic version checks
     * when obtaining the database lock.  If these checks fail,
     * the <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * <p>If a vendor-specific property or hint is not recognized,
     * it is silently ignored.
     * <p>Portable applications should not rely on the standard timeout
     * hint. Depending on the database in use and the locking
     * mechanisms used by the provider, the hint may or may not
     * be observed.
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @param lockMode  lock mode
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         not a valid type for that entity's primary key or
     *         is null
     * @throws TransactionRequiredException if there is no
     *         transaction and a lock mode other than <code>NONE</code> is
     *         specified or if invoked on an entity manager which has
     *         not been joined to the current transaction and a lock
     *         mode other than <code>NONE</code> is specified
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public <T> T find(Class<T> entityClass, Object primaryKey,
                      LockModeType lockMode,
                      Map<String, Object> properties);

    /**
     * Get an instance, whose state may be lazily fetched.
     * If the requested instance does not exist in the database,
     * the <code>EntityNotFoundException</code> is thrown when the instance
     * state is first accessed. (The persistence provider runtime is
     * permitted to throw the <code>EntityNotFoundException</code> when
     * <code>getReference</code> is called.)
     * The application should not expect that the instance state will
     * be available upon detachment, unless it was accessed by the
     * application while the entity manager was open.
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @return the found entity instance
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         not a valid type for that entity's primary key or
     *         is null
     * @throws EntityNotFoundException if the entity state
     *         cannot be accessed
     */
    public <T> T getReference(Class<T> entityClass,
                                  Object primaryKey);

    /**
     * Synchronize the persistence context to the
     * underlying database.
     * @throws TransactionRequiredException if there is
     *         no transaction or if the entity manager has not been
     *         joined to the current transaction
     * @throws PersistenceException if the flush fails
     */
    public void flush();

    /**
     * Set the flush mode that applies to all objects contained
     * in the persistence context.
     * @param flushMode  flush mode
     */
    public void setFlushMode(FlushModeType flushMode);

    /**
     * Get the flush mode that applies to all objects contained
     * in the persistence context.
     * @return flushMode
     */
    public FlushModeType getFlushMode();

    /**
     * Lock an entity instance that is contained in the persistence
     * context with the specified lock mode type.
     * <p>If a pessimistic lock mode type is specified and the entity
     * contains a version attribute, the persistence provider must
     * also perform optimistic version checks when obtaining the
     * database lock.  If these checks fail, the
     * <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @throws IllegalArgumentException if the instance is not an
     *         entity or is a detached entity
     * @throws TransactionRequiredException if there is no
     *         transaction or if invoked on an entity manager which
     *         has not been joined to the current transaction
     * @throws EntityNotFoundException if the entity does not exist
     *         in the database when pessimistic locking is
     *         performed
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     */
    public void lock(Object entity, LockModeType lockMode);

    /**
     * Lock an entity instance that is contained in the persistence
     * context with the specified lock mode type and with specified
     * properties.
     * <p>If a pessimistic lock mode type is specified and the entity
     * contains a version attribute, the persistence provider must
     * also perform optimistic version checks when obtaining the
     * database lock.  If these checks fail, the
     * <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * <p>If a vendor-specific property or hint is not recognized,
     * it is silently ignored.
     * <p>Portable applications should not rely on the standard timeout
     * hint. Depending on the database in use and the locking
     * mechanisms used by the provider, the hint may or may not
     * be observed.
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @throws IllegalArgumentException if the instance is not an
     *         entity or is a detached entity
     * @throws TransactionRequiredException if there is no
     *         transaction or if invoked on an entity manager which
     *         has not been joined to the current transaction
     * @throws EntityNotFoundException if the entity does not exist
     *         in the database when pessimistic locking is
     *         performed
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public void lock(Object entity, LockModeType lockMode,
                     Map<String, Object> properties);

    /**
     * Refresh the state of the instance from the database,
     * overwriting changes made to the entity, if any.
     * @param entity  entity instance
     * @throws IllegalArgumentException if the instance is not
     *         an entity or the entity is not managed
     * @throws TransactionRequiredException if there is no
     *         transaction when invoked on a container-managed
     *         entity manager of type <code>PersistenceContextType.TRANSACTION</code>
     * @throws EntityNotFoundException if the entity no longer
     *         exists in the database
     */
    public void refresh(Object entity);

    /**
     * Refresh the state of the instance from the database, using
     * the specified properties, and overwriting changes made to
     * the entity, if any.
     * <p> If a vendor-specific property or hint is not recognized,
     * it is silently ignored.
     * @param entity  entity instance
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @throws IllegalArgumentException if the instance is not
     *         an entity or the entity is not managed
     * @throws TransactionRequiredException if there is no
     *         transaction when invoked on a container-managed
     *         entity manager of type <code>PersistenceContextType.TRANSACTION</code>
     * @throws EntityNotFoundException if the entity no longer
     *         exists in the database
     * @since 2.0
     */
    public void refresh(Object entity,
                            Map<String, Object> properties);

    /**
     * Refresh the state of the instance from the database,
     * overwriting changes made to the entity, if any, and
     * lock it with respect to given lock mode type.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the
     *    database locking failure causes only statement-level
     *    rollback.
     * </ul>
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @throws IllegalArgumentException if the instance is not
     *         an entity or the entity is not managed
     * @throws TransactionRequiredException if invoked on a
     *         container-managed entity manager of type
     *         <code>PersistenceContextType.TRANSACTION</code> when there is
     *         no transaction; if invoked on an extended entity manager when
     *         there is no transaction and a lock mode other than <code>NONE</code>
     *         has been specified; or if invoked on an extended entity manager
     *         that has not been joined to the current transaction and a
     *         lock mode other than <code>NONE</code> has been specified
     * @throws EntityNotFoundException if the entity no longer exists
     *         in the database
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public void refresh(Object entity, LockModeType lockMode);

    /**
     * Refresh the state of the instance from the database,
     * overwriting changes made to the entity, if any, and
     * lock it with respect to given lock mode type and with
     * specified properties.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * <p>If a vendor-specific property or hint is not recognized,
     *    it is silently ignored.
     * <p>Portable applications should not rely on the standard timeout
     * hint. Depending on the database in use and the locking
     * mechanisms used by the provider, the hint may or may not
     * be observed.
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @throws IllegalArgumentException if the instance is not
     *         an entity or the entity is not managed
     * @throws TransactionRequiredException if invoked on a
     *         container-managed entity manager of type
     *         <code>PersistenceContextType.TRANSACTION</code> when there is
     *         no transaction; if invoked on an extended entity manager when
     *         there is no transaction and a lock mode other than <code>NONE</code>
     *         has been specified; or if invoked on an extended entity manager
     *         that has not been joined to the current transaction and a
     *         lock mode other than <code>NONE</code> has been specified
     * @throws EntityNotFoundException if the entity no longer exists
     *         in the database
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public void refresh(Object entity, LockModeType lockMode,
                        Map<String, Object> properties);

    /**
     * Clear the persistence context, causing all managed
     * entities to become detached. Changes made to entities that
     * have not been flushed to the database will not be
     * persisted.
     */
    public void clear();

    /**
     * Remove the given entity from the persistence context, causing
     * a managed entity to become detached.  Unflushed changes made
     * to the entity if any (including removal of the entity),
     * will not be synchronized to the database.  Entities which
     * previously referenced the detached entity will continue to
     * reference it.
     * @param entity  entity instance
     * @throws IllegalArgumentException if the instance is not an
     *         entity
     * @since 2.0
     */
    public void detach(Object entity);

    /**
     * Check if the instance is a managed entity instance belonging
     * to the current persistence context.
     * @param entity  entity instance
     * @return boolean indicating if entity is in persistence context
     * @throws IllegalArgumentException if not an entity
     */
    public boolean contains(Object entity);

    /**
     * Get the current lock mode for the entity instance.
     * @param entity  entity instance
     * @return lock mode
     * @throws TransactionRequiredException if there is no
     *         transaction or if the entity manager has not been
     *         joined to the current transaction
     * @throws IllegalArgumentException if the instance is not a
     *         managed entity and a transaction is active
     * @since 2.0
     */
    public LockModeType getLockMode(Object entity);

    /**
     * Set an entity manager property or hint.
     * If a vendor-specific property or hint is not recognized, it is
     * silently ignored.
     * @param propertyName name of property or hint
     * @param value  value for property or hint
     * @throws IllegalArgumentException if the second argument is
     *         not valid for the implementation
     * @since 2.0
     */
    public void setProperty(String propertyName, Object value);

    /**
     * Get the properties and hints and associated values that are in effect
     * for the entity manager. Changing the contents of the map does
     * not change the configuration in effect.
     * @return map of properties and hints in effect for entity manager
     * @since 2.0
     */
    public Map<String, Object> getProperties();

    /**
     * Create an instance of <code>Query</code> for executing a
     * Jakarta Persistence query language statement.
     * @param qlString a Jakarta Persistence query string
     * @return the new query instance
     * @throws IllegalArgumentException if the query string is
     *         found to be invalid
     */
    public Query createQuery(String qlString);

    /**
     * Create an instance of <code>TypedQuery</code> for executing a
     * criteria query.
     * @param criteriaQuery  a criteria query object
     * @return the new query instance
     * @throws IllegalArgumentException if the criteria query is
     *         found to be invalid
     * @since 2.0
     */
    public <T> TypedQuery<T> createQuery(CriteriaQuery<T> criteriaQuery);

    /**
     * Create an instance of <code>Query</code> for executing a criteria
     * update query.
     * @param updateQuery  a criteria update query object
     * @return the new query instance
     * @throws IllegalArgumentException if the update query is
     *         found to be invalid
     * @since 2.1
     */
    public Query createQuery(CriteriaUpdate updateQuery);

    /**
     * Create an instance of <code>Query</code> for executing a criteria
     * delete query.
     * @param deleteQuery  a criteria delete query object
     * @return the new query instance
     * @throws IllegalArgumentException if the delete query is
     *         found to be invalid
     * @since 2.1
     */
    public Query createQuery(CriteriaDelete deleteQuery);

    /**
     * Create an instance of <code>TypedQuery</code> for executing a
     * Jakarta Persistence query language statement.
     * The select list of the query must contain only a single
     * item, which must be assignable to the type specified by
     * the <code>resultClass</code> argument.
     * @param qlString a Jakarta Persistence query string
     * @param resultClass the type of the query result
     * @return the new query instance
     * @throws IllegalArgumentException if the query string is found
     *         to be invalid or if the query result is found to
     *         not be assignable to the specified type
     * @since 2.0
     */
    public <T> TypedQuery<T> createQuery(String qlString, Class<T> resultClass);

    /**
     * Create an instance of <code>Query</code> for executing a named query
     * (in the Jakarta Persistence query language or in native SQL).
     * @param name the name of a query defined in metadata
     * @return the new query instance
     * @throws IllegalArgumentException if a query has not been
     *         defined with the given name or if the query string is
     *         found to be invalid
     */
    public Query createNamedQuery(String name);

    /**
     * Create an instance of <code>TypedQuery</code> for executing a
     * Jakarta Persistence query language named query.
     * The select list of the query must contain only a single
     * item, which must be assignable to the type specified by
     * the <code>resultClass</code> argument.
     * @param name the name of a query defined in metadata
     * @param resultClass the type of the query result
     * @return the new query instance
     * @throws IllegalArgumentException if a query has not been
     *         defined with the given name or if the query string is
     *         found to be invalid or if the query result is found to
     *         not be assignable to the specified type
     * @since 2.0
     */
    public <T> TypedQuery<T> createNamedQuery(String name, Class<T> resultClass);

    /**
     * Create an instance of <code>Query</code> for executing
     * a native SQL statement, e.g., for update or delete.
     * If the query is not an update or delete query, query
     * execution will result in each row of the SQL result
     * being returned as a result of type Object[] (or a result
     * of type Object if there is only one column in the select
     * list.)  Column values are returned in the order of their
     * appearance in the select list and default JDBC type
     * mappings are applied.
     * @param sqlString a native SQL query string
     * @return the new query instance
     */
    public Query createNativeQuery(String sqlString);

    /**
     * Create an instance of <code>Query</code> for executing
     * a native SQL query.
     * @param sqlString a native SQL query string
     * @param resultClass the class of the resulting instance(s)
     * @return the new query instance
     */
    public Query createNativeQuery(String sqlString, Class resultClass);

    /**
     * Create an instance of <code>Query</code> for executing
     * a native SQL query.
     * @param sqlString a native SQL query string
     * @param resultSetMapping the name of the result set mapping
     * @return the new query instance
     */
    public Query createNativeQuery(String sqlString, String resultSetMapping);

    /**
     * Create an instance of <code>StoredProcedureQuery</code> for executing a
     * stored procedure in the database.
     * <p>Parameters must be registered before the stored procedure can
     * be executed.
     * <p>If the stored procedure returns one or more result sets,
     * any result set will be returned as a list of type Object[].
     * @param name name assigned to the stored procedure query
     * in metadata
     * @return the new stored procedure query instance
     * @throws IllegalArgumentException if a query has not been
     * defined with the given name
     * @since 2.1
     */
    public StoredProcedureQuery createNamedStoredProcedureQuery(String name);

    /**
     * Create an instance of <code>StoredProcedureQuery</code> for executing a
     * stored procedure in the database.
     * <p>Parameters must be registered before the stored procedure can
     * be executed.
     * <p>If the stored procedure returns one or more result sets,
     * any result set will be returned as a list of type Object[].
     * @param procedureName name of the stored procedure in the
     * database
     * @return the new stored procedure query instance
     * @throws IllegalArgumentException if a stored procedure of the
     * given name does not exist (or the query execution will
     * fail)
     * @since 2.1
     */
    public StoredProcedureQuery createStoredProcedureQuery(String procedureName);

    /**
     * Create an instance of <code>StoredProcedureQuery</code> for executing a
     * stored procedure in the database.
     * <p>Parameters must be registered before the stored procedure can
     * be executed.
     * <p>The <code>resultClass</code> arguments must be specified in the order in
     * which the result sets will be returned by the stored procedure
     * invocation.
     * @param procedureName name of the stored procedure in the
     * database
     * @param resultClasses classes to which the result sets
     * produced by the stored procedure are to
     * be mapped
     * @return the new stored procedure query instance
     * @throws IllegalArgumentException if a stored procedure of the
     * given name does not exist (or the query execution will
     * fail)
     * @since 2.1
     */
    public StoredProcedureQuery createStoredProcedureQuery(
	       String procedureName, Class... resultClasses);

    /**
     * Create an instance of <code>StoredProcedureQuery</code> for executing a
     * stored procedure in the database.
     * <p>Parameters must be registered before the stored procedure can
     * be executed.
     * <p>The <code>resultSetMapping</code> arguments must be specified in the order
     * in which the result sets will be returned by the stored
     * procedure invocation.
     * @param procedureName name of the stored procedure in the
     *        database
     * @param resultSetMappings the names of the result set mappings
     *        to be used in mapping result sets
     *        returned by the stored procedure
     * @return the new stored procedure query instance
     * @throws IllegalArgumentException if a stored procedure or
     *         result set mapping of the given name does not exist
     *         (or the query execution will fail)
     */
    public StoredProcedureQuery createStoredProcedureQuery(
              String procedureName, String... resultSetMappings);

    /**
     * Indicate to the entity manager that a JTA transaction is
     * active and join the persistence context to it.
     * <p>This method should be called on a JTA application
     * managed entity manager that was created outside the scope
     * of the active transaction or on an entity manager of type
     * <code>SynchronizationType.UNSYNCHRONIZED</code> to associate
     * it with the current JTA transaction.
     * @throws TransactionRequiredException if there is
     *         no transaction
     */
    public void joinTransaction();

    /**
     * Determine whether the entity manager is joined to the
     * current transaction. Returns false if the entity manager
     * is not joined to the current transaction or if no
     * transaction is active
     * @return boolean
     * @since 2.1
     */
    public boolean isJoinedToTransaction();

    /**
     * Return an object of the specified type to allow access to the
     * provider-specific API.   If the provider's <code>EntityManager</code>
     * implementation does not support the specified class, the
     * <code>PersistenceException</code> is thrown.
     * @param cls  the class of the object to be returned.  This is
     * normally either the underlying <code>EntityManager</code> implementation
     * class or an interface that it implements.
     * @return an instance of the specified class
     * @throws PersistenceException if the provider does not
     *         support the call
     * @since 2.0
     */
    public <T> T unwrap(Class<T> cls);

    /**
     * Return the underlying provider object for the <code>EntityManager</code>,
     * if available. The result of this method is implementation
     * specific.
     * <p>The <code>unwrap</code> method is to be preferred for new applications.
     * @return underlying provider object for EntityManager
     */
    public Object getDelegate();

    /**
     * Close an application-managed entity manager.
     * After the close method has been invoked, all methods
     * on the <code>EntityManager</code> instance and any
     * <code>Query</code>, <code>TypedQuery</code>, and
     * <code>StoredProcedureQuery</code> objects obtained from
     * it will throw the <code>IllegalStateException</code>
     * except for <code>getProperties</code>,
     * <code>getTransaction</code>, and <code>isOpen</code> (which will return false).
     * If this method is called when the entity manager is
     * joined to an active transaction, the persistence
     * context remains managed until the transaction completes.
     * @throws IllegalStateException if the entity manager
     *         is container-managed
     */
    public void close();

    /**
     * Determine whether the entity manager is open.
     * @return true until the entity manager has been closed
     */
    public boolean isOpen();

    /**
     * Return the resource-level <code>EntityTransaction</code> object.
     * The <code>EntityTransaction</code> instance may be used serially to
     * begin and commit multiple transactions.
     * @return EntityTransaction instance
     * @throws IllegalStateException if invoked on a JTA
     *         entity manager
     */
    public EntityTransaction getTransaction();

    /**
     * Return the entity manager factory for the entity manager.
     * @return EntityManagerFactory instance
     * @throws IllegalStateException if the entity manager has
     *         been closed
     * @since 2.0
     */
    public EntityManagerFactory getEntityManagerFactory();

    /**
     * Return an instance of <code>CriteriaBuilder</code> for the creation of
     * <code>CriteriaQuery</code> objects.
     * @return CriteriaBuilder instance
     * @throws IllegalStateException if the entity manager has
     *         been closed
     * @since 2.0
     */
    public CriteriaBuilder getCriteriaBuilder();

    /**
     * Return an instance of <code>Metamodel</code> interface for access to the
     * metamodel of the persistence unit.
     * @return Metamodel instance
     * @throws IllegalStateException if the entity manager has
     *         been closed
     * @since 2.0
     */
    public Metamodel getMetamodel();

    /**
     * Return a mutable EntityGraph that can be used to dynamically create an
     * EntityGraph.
     * @param rootType class of entity graph
     * @return entity graph
     * @since 2.1
     */
    public <T> EntityGraph<T> createEntityGraph(Class<T> rootType);

    /**
     * Return a mutable copy of the named EntityGraph.  If there
     * is no entity graph with the specified name, null is returned.
     * @param graphName name of an entity graph
     * @return entity graph
     * @since 2.1
     */
    public EntityGraph<?> createEntityGraph(String graphName);

    /**
     * Return a named EntityGraph. The returned EntityGraph
     * should be considered immutable.
     * @param graphName  name of an existing entity graph
     * @return named entity graph
     * @throws IllegalArgumentException if there is no EntityGraph of
     *         the given name
     * @since 2.1
     */
    public EntityGraph<?> getEntityGraph(String graphName);

    /**
     * Return all named EntityGraphs that have been defined for the provided
     * class type.
     * @param entityClass  entity class
     * @return list of all entity graphs defined for the entity
     * @throws IllegalArgumentException if the class is not an entity
     * @since 2.1
     */
    public <T> List<EntityGraph<? super T>> getEntityGraphs(Class<T> entityClass);

}
----

[NOTE]
====
The semantics of

    public <T> TypedQuery<T> createQuery(String qlString, Class<T> resultClass)

method may be extended in a future release of this specification to
support other result types. Applications that specify other result types
(e.g., Tuple.class) will not be portable.
====

[NOTE]
====
The semantics

    public <T> TypedQuery<T> createNamedQuery(String name, Class<T> resultClass)

method may be extended in a future release of this specification to
support other result types. Applications that specify other result types
(e.g., Tuple.class) will not be portable.
====

The _persist_, _merge_, _remove_, and
_refresh_ methods must be invoked within a transaction context when an
entity manager with a transaction-scoped persistence context is used. If
there is no transaction context, the
_jakarta.persistence.TransactionRequiredException_ is thrown.

Methods that specify a lock mode other than
_LockModeType.NONE_ must be invoked within a transaction. If there is no
transaction or if the entity manager has not been joined to the
transaction, the _jakarta.persistence.TransactionRequiredException_ is
thrown.

The _find_ method (provided it is invoked
without a lock or invoked with _LockModeType.NONE_) and the
_getReference_ method are not required to be invoked within a
transaction. If an entity manager with transaction-scoped persistence
context is in use, the resulting entities will be detached; if an entity
manager with an extended persistence context is used, they will be
managed. See <<a2027>> for entity manager use outside a
transaction.

The _Query_, _TypedQuery_,
_StoredProcedureQuery_, _CriteriaBuilder_, _Metamodel_, and
_EntityTransaction_ objects obtained from an entity manager are valid
while that entity manager is open.

If the argument to the _createQuery_ method
is not a valid Jakarta Persistence query string or a valid _CriteriaQuery_
object, the _IllegalArgumentException_ may be thrown or the query
execution will fail and a _PersistenceException_ will be thrown. If the
result class specification of a Jakarta Persistence query language query is
incompatible with the result of the query, the
_IllegalArgumentException_ may be thrown when the _createQuery_ method
is invoked or the query execution will fail and a _PersistenceException_
will be thrown when the query is executed. If a native query is not a
valid query for the database in use or if the result set specification
is incompatible with the result of the query, the query execution will
fail and a _PersistenceException_ will be thrown when the query is
executed. The _PersistenceException_ should wrap the underlying database
exception when possible.

Runtime exceptions thrown by the methods of
the _EntityManager_ interface other than the _LockTimeoutException_ will
cause the current transaction to be marked for rollback if the
persistence context is joined to that transaction.

The methods _close_, _isOpen_,
_joinTransaction_, and _getTransaction_ are used to manage
application-managed entity managers and their lifecycle. See <<a11465>>.

The _EntityManager_ interface and other
interfaces defined by this specification contain methods that take
properties and/or hints as arguments. This specification distinguishes
between _properties_ and _hints_ as follows:

* A property defined by this specification must
be observed by the provider unless otherwise explicitly stated.

* A hint specifies a preference on the part of
the application. While a hint defined by this specification should be
observed by the provider if possible, a hint may or may not always be
observed. A portable application must not depend on the observance of a
hint.

==== Example of Use of EntityManager API

[source,java]
----
@Stateless
public class OrderEntryBean implements OrderEntry {
    @PersistenceContext
    EntityManager em;

    public void enterOrder(int custID, Order newOrder) {
        Customer cust = em.find(Customer.class, custID);
        cust.getOrders().add(newOrder);
        newOrder.setCustomer(cust);
        em.persist(newOrder);
    }
}
----

=== Entity Instance's Life Cycle [[a1929]]

This section describes the _EntityManager_
operations for managing an entity instance's lifecycle. An entity
instance can be characterized as being new, managed, detached, or
removed.

* A new entity instance has no persistent
identity, and is not yet associated with a persistence context.
* A managed entity instance is an instance with
a persistent identity that is currently associated with a persistence
context.
* A detached entity instance is an instance
with a persistent identity that is not (or no longer) associated with a
persistence context.
* A removed entity instance is an instance with
a persistent identity, associated with a persistence context, that will
be removed from the database upon transaction commit.

The following subsections describe the effect
of lifecycle operations upon entities. Use of the _cascade_ annotation
element may be used to propagate the effect of an operation to
associated entities. The cascade functionality is most typically used in
parent-child relationships.

==== Entity Instance Creation

Entity instances are created by means of the
_new_ operation. An entity instance, when first created by _new_ is not
yet persistent. An instance becomes persistent by means of the
_EntityManager_ API.

==== Persisting an Entity Instance

A new entity instance becomes both managed
and persistent by invoking the _persist_ method on it or by cascading
the persist operation.

The semantics of the persist operation,
applied to an entity _X_ are as follows:

* If X is a new entity, it becomes managed. The
entity X will be entered into the database at or before transaction
commit or as a result of the flush operation.
* If X is a preexisting managed entity, it is
ignored by the persist operation. However, the persist operation is
cascaded to entities referenced by X, if the relationships from X to
these other entities are annotated with the _cascade=PERSIST_ or
_cascade=ALL_ annotation element value or specified with the equivalent
XML descriptor element.
* If X is a removed entity, it becomes managed.
* If X is a detached object, the
_EntityExistsException_ may be thrown when the persist operation is
invoked, or the _EntityExistsException_ or another
_PersistenceException_ _may_ be thrown at flush or commit time.
* For all entities Y referenced by a
relationship from X, if the relationship to Y has been annotated with
the _cascade_ element value _cascade=PERSIST_ or _cascade=ALL_, the
persist operation is applied to Y.

==== Removal [[a1946]]

A managed entity instance becomes removed by
invoking the _remove_ method on it or by cascading the remove operation.

The semantics of the remove operation,
applied to an entity X are as follows:

* If X is a new entity, it is ignored by the
remove operation. However, the remove operation is cascaded to entities
referenced by X, if the relationship from X to these other entities is
annotated with the _cascade=REMOVE_ or _cascade=ALL_ annotation element
value.
* If X is a managed entity, the remove
operation causes it to become removed. The remove operation is cascaded
to entities referenced by X, if the relationships from X to these other
entities is annotated with the _cascade=REMOVE_ or _cascade=ALL_
annotation element value.
* If X is a detached entity, an
_IllegalArgumentException_ will be thrown by the remove operation (or
the transaction commit will fail).
* If X is a removed entity, it is ignored by the remove operation.
* A removed entity X will be removed from the
database at or before transaction commit or as a result of the flush
operation.

After an entity has been removed, its state
(except for generated state) will be that of the entity at the point at
which the remove operation was called.

==== Synchronization to the Database [[a1955]]

In general, a persistence context will be
synchronized to the database as described below. However, a persistence
context of type _SynchronizationType.UNSYNCHRONIZED_ or an
application-managed persistence context that has been created outside
the scope of the current transaction will only be synchronized to the
database if it has been joined to the current transaction by the
application's use of the _EntityManager_ _joinTransaction_ method.

The state of persistent entities is
synchronized to the database at transaction commit. This synchronization
involves writing to the database any updates to persistent entities and
their relationships as specified above.

An update to the state of an entity includes
both the assignment of a new value to a persistent property or field of
the entity as well as the modification of a mutable value of a
persistent property or fieldfootnote:[This includes, for
example. modifications to persistent attributes of type char[\] and
byte[\].].

Synchronization to the database does not
involve a refresh of any managed entities unless the _refresh_ operation
is explicitly invoked on those entities or cascaded to them as a result
of the specification of the _cascade=REFRESH_ or _cascade=ALL_
annotation element value.

Bidirectional relationships between
managed entities will be persisted based on references held by the
owning side of the relationship. It is the developer's responsibility to
keep the in-memory references held on the owning side and those held on
the inverse side consistent with each other when they change. In the
case of unidirectional one-to-one and one-to-many relationships, it is
the developer's responsibility to insure that the semantics of the
relationships are adhered to.footnote:[This might be an
issue if unique constraints (such as those described for the default
mappings in <<a640>> and <<a764>>) were not applied in the
definition of the object/relational mapping.]

[NOTE]
====
It is particularly important to ensure that
changes to the inverse side of a relationship result in appropriate
updates on the owning side, so as to ensure the changes are not lost
when they are synchronized to the database.
====

The persistence provider runtime is permitted
to perform synchronization to the database at other times as well when a
transaction is active and the persistence context is joined to the
transaction. The _flush_ method can be used by the application to force
synchronization. It applies to entities associated with the persistence
context. The _setFlushMode_ methods of the _EntityManager_, _Query_,
_TypedQuery_, and _StoredProcedureQuery_ interfaces can be used to
control synchronization semantics. The effect of _FlushModeType.AUTO_ is
defined in <<a4374>>. If _FlushModeType.COMMIT_ is specified, flushing will occur at
transaction commit; the persistence provider is permitted, but not
required, to perform to flush at other times. If there is no transaction
active or if the persistence context has not been joined to the current
transaction, the persistence provider must not flush to the database.

The semantics of the flush operation, applied
to an entity _X_ are as follows:

* If X is a managed entity, it is synchronized
to the database.
** For all entities Y referenced by a
relationship from X, if the relationship to Y has been annotated with
the _cascade_ element value _cascade=PERSIST_ or _cascade=ALL_, the
persist operation is applied to Y.
** For any entity Y referenced by a relationship
from X, where the relationship to Y has not been annotated with the
_cascade_ element value _cascade=PERSIST_ or _cascade=ALL_:
*** If Y is new or removed, an
_IllegalStateException_ will be thrown by the flush operation (and the
transaction marked for rollback) or the transaction commit will fail.
*** If Y is detached, the semantics depend upon
the ownership of the relationship. If X owns the relationship, any
changes to the relationship are synchronized with the database;
otherwise, if Y owns the relationships, the behavior is undefined.
* If X is a removed entity, it is removed from
the database. No cascade options are relevant.

==== Refreshing an Entity Instance

The state of a managed entity instance is
refreshed from the database by invoking the _refresh_ method on it or by
cascading the refresh operation.

The semantics of the refresh operation,
applied to an entity X are as follows:

* If X is a managed entity, the state of X is
refreshed from the database, overwriting changes made to the entity, if
any. The refresh operation is cascaded to entities referenced by X if
the relationship from X to these other entities is annotated with the
_cascade=REFRESH_ or _cascade=ALL_ annotation element value.
* If X is a new, detached, or removed entity,
the _IllegalArgumentException_ is thrown.

==== Evicting an Entity Instance from the Persistence Context

An entity instance is removed from the
persistence context by invoking the _detach_ method on it or cascading
the detach operation. Changes made to the entity, if any (including
removal of the entity), will not be synchronized to the database after
such eviction has taken place.

Applications must use the _flush_ method
prior to the _detach_ method to ensure portable semantics if changes
have been made to the entity (including removal of the entity). Because
the persistence provider may write to the database at times other than
the explicit invocation of the _flush_ method, portable applications
must not assume that changes have not been written to the database if
the _flush_ method has not been called prior to detach.

The semantics of the detach operation,
applied to an entity X are as follows:

* If X is a managed entity, the detach
operation causes it to become detached. The detach operation is cascaded
to entities referenced by X if the relationships from X to these other
entities is annotated with the _cascade=DETACH_ or _cascade=ALL_
annotation element value. Entities which previously referenced X will
continue to reference X.
* If X is a new or detached entity, it is
ignored by the detach operation.
* If X is a removed entity, the detach
operation causes it to become detached. The detach operation is cascaded
to entities referenced by X if the relationships from X to these other
entities is annotated with the _cascade=DETACH_ or _cascade=ALL_
annotation element value. Entities which previously referenced X will
continue to reference X. Portable applications should not pass removed
entities that have been detached from the persistence context to further
EntityManager operations.

==== Detached Entities [[a1982]]

A detached entity results from transaction
commit if a transaction-scoped persistence context is used (see <<a2027>>);
from transaction rollback (see <<a2049>>); from detaching
the entity from the persistence context; from clearing the persistence
context; from closing an entity manager; or from serializing an entity
or otherwise passing an entity by valuee.g., to a separate application
tier, through a remote interface, etc.

Detached entity instances continue to live
outside of the persistence context in which they were persisted or
retrieved. Their state is no longer guaranteed to be synchronized with
the database state.

The application may access the available
state of available detached entity instances after the persistence
context ends. The available state includes:

* Any persistent field or property not marked _fetch=LAZY_
* Any persistent field or property that was
accessed by the application or fetched by means of an entity graph

If the persistent field or property is an
association, the available state of an associated instance may only be
safely accessed if the associated instance is available. The available
instances include:

* Any entity instance retrieved using _find()_.
* Any entity instances retrieved using a query or explicitly requested in a fetch join.
* Any entity instance for which an instance
variable holding non-primary-key persistent state was accessed by the
application.
* Any entity instance that can be reached from
another available instance by navigating associations marked _fetch=EAGER_.

===== Merging Detached Entity State

The merge operation allows for the
propagation of state from detached entities onto persistent entities
managed by the entity manager.

The semantics of the merge operation applied
to an entity X are as follows:

* If X is a detached entity, the state of X is
copied onto a pre-existing managed entity instance X' of the same
identity or a new managed copy X' of X is created.
* If X is a new entity instance, a new managed
entity instance X' is created and the state of X is _copied_ into the
new managed entity instance X'.
* If X is a removed entity instance, an
_IllegalArgumentException_ will be thrown by the merge operation (or the
transaction commit will fail).
* If X is a managed entity, it is ignored by
the merge operation, however, the merge operation is cascaded to
entities referenced by relationships from X if these relationships have
been annotated with the _cascade_ element value _cascade=MERGE_ or
_cascade=ALL_ annotation.
* For all entities Y referenced by
relationships from X having the _cascade_ element value _cascade=MERGE_
or _cascade=ALL_, Y is merged recursively as Y'. For all such Y
referenced by X, X' is set to reference Y'. (Note that if X is managed
then X is the same object as X'.)
* If X is an entity merged to X', with a
reference to another entity Y, where _cascade=MERGE_ or _cascade=ALL_ is
not specified, then navigation of the same association from X' yields a
reference to a managed object Y' with the same persistent identity as Y.

The persistence provider must not merge
fields marked LAZY that have not been fetched: it must ignore such
fields when merging.

Any _Version_ columns used by the entity must
be checked by the persistence runtime implementation during the merge
operation and/or at flush or commit time. In the absence of _Version_
columns there is no additional version checking done by the persistence
provider runtime during the merge operation.

===== Detached Entities and Lazy Loading

Serializing entities and merging those
entities back into a persistence context may not be interoperable across
vendors when lazy properties or fields and/or relationships are used.

A vendor is required to support the
serialization and subsequent deserialization and merging of detached
entity instances (which may contain lazy properties or fields and/or
relationships that have not been fetched) back into a separate JVM
instance of that vendor's runtime, where both runtime instances have
access to the entity classes and any required vendor persistence
implementation classes.

When interoperability across vendors is
required, the application must not use lazy loading.

==== Managed Instances

It is the responsibility of the application
to insure that an instance is managed in only a single persistence
context. The behavior is undefined if the same Java instance is made
managed in more than one persistence context.

The _contains()_ method can be used to
determine whether an entity instance is managed in the current
persistence context.

The _contains_ method returns true:

* If the entity has been retrieved from the
database or has been returned by _getReference_, and has not been
removed or detached.
* If the entity instance is new, and the
_persist_ method has been called on the entity or the persist operation
has been cascaded to it.

The _contains_ method returns false:

* If the instance is detached.
* If the _remove_ method has been called on the
entity, or the remove operation has been cascaded to it.
* If the instance is new, and the _persist_
method has not been called on the entity or the persist operation has
not been cascaded to it.

Note that the effect of the cascading of
persist, merge, remove, or detach is immediately visible to the
_contains_ method, whereas the actual insertion, modification, or
deletion of the database representation for the entity may be deferred
until the end of the transaction.

==== Load State [[a2019]]

An entity is considered to be loaded if all
attributes with _FetchType.EAGER_ whether explictly specified or by
default(including relationship and other collection-valued attributes)
have been loaded from the database or assigned by the application.
Attributes with _FetchType.LAZY_ may or may not have been loaded. The
available state of the entity instance and associated instances is as
described in <<a1982>>.

An attribute that is an embeddable is
considered to be loaded if the embeddable attribute was loaded from the
database or assigned by the application, and, if the attribute
references an embeddable instance (i.e., is not null), the embeddable
instance state is known to be loaded (i.e., all attributes of the
embeddable with _FetchType.EAGER_ have been loaded from the database or
assigned by the application).

A collection-valued attribute is considered
to be loaded if the collection was loaded from the database or the value
of the attribute was assigned by the application, and, if the attribute
references a collection instance (i.e., is not null), each element of
the collection (e.g. entity or embeddable) is considered to be loaded.

A single-valued relationship attribute is
considered to be loaded if the relationship attribute was loaded from
the database or assigned by the application, and, if the attribute
references an entity instance (i.e., is not null), the entity instance
state is known to be loaded.

A basic attribute is considered to be loaded
if its state has been loaded from the database or assigned by the
application.

The _PersistenceUtil.isLoaded_ methods can be
used to determine the load state of an entity and its attributes
regardless of the persistence unit with which the entity is associated.
The _PersistenceUtil.isLoaded_ methods return true if the above
conditions hold, and false otherwise. If the persistence unit is known,
the _PersistenceUnitUtil.isLoaded_ methods can be used instead. See <<a12177>>.

Persistence provider contracts for
determining the load state of an entity or entity attribute are
described in <<a13592>>.

=== Persistence Context Lifetime and Synchronization Type [[a2027]]

The lifetime of a container-managed
persistence context can either be scoped to a transaction
(transaction-scoped persistence context), or have a lifetime scope that
extends beyond that of a single transaction (extended persistence
context). The enum _PersistenceContextType_ is used to define the
persistence context lifetime scope for container-managed entity
managers. The persistence context lifetime scope is defined when the
EntityManager instance is created (whether explicitly, or in conjunction
with injection or JNDI lookup). See <<a11791>>.

[source,java]
----
package jakarta.persistence;

public enum PersistenceContextType {
    TRANSACTION,
    EXTENDED
}
----

By default, the lifetime of the persistence
context of a container-managed entity manager corresponds to the scope
of a transaction (i.e., it is of type
_PersistenceContextType.TRANSACTION_).

When an extended persistence context is used,
the extended persistence context exists from the time the EntityManager
instance is created until it is closed. This persistence context might
span multiple transactions and non-transactional invocations of the
EntityManager.

An EntityManager with an extended persistence
context maintains its references to the entity objects after a
transaction has committed. Those objects remain managed by the
EntityManager, and they can be updated as managed objects between
transactions.footnote:[Note that when a new
transaction is begun, the managed objects in an extended persistence
context are _not_ reloaded from the database.] Navigation from a managed object in
an extended persistence context results in one or more other managed
objects regardless of whether a transaction is active.

When an EntityManager with an extended
persistence context is used, the persist, remove, merge, and refresh
operations can be called regardless of whether a transaction is active.
The effects of these operations will be committed to the database when
the extended persistence context is enlisted in a transaction and the
transaction commits.

The scope of the persistence context of an
application-managed entity manager is extended. It is the responsibility
of the application to manage the lifecycle of the persistence context.

Container-managed persistence contexts are
described further in <<a11791>>. Persistence contexts managed by
the application are described further in <<a11894>>.

==== Synchronization with the Current Transaction

By default, a container-managed persistence
context is of _SynchronizationType.SYNCHRONIZED_ and is automatically
joined to the current transaction. A persistence context of
_SynchronizationType.UNSYNCHRONIZED_ will not be enlisted in the current
transaction, unless the _EntityManager_ _joinTransaction_ method is
invoked.

By default, an application-managed
persistence context that is associated with a JTA entity manager and
that is created within the scope of an active transaction is
automatically joined to that transaction. An application-managed JTA
persistence context that is created outside the scope of a transaction
or an application-managed persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ will not be joined to that
transaction unless the _EntityManager_ _joinTransaction_ method is
invoked.

An application-managed persistence context
associated with a resource-local entity manager is always automatically
joined to any resource-local transaction that is begun for that entity
manager.

Persistence context synchronization type is
described further in <<a11797>>.

==== Transaction Commit

The managed entities of a transaction-scoped
persistence context become detached when the transaction commits; the
managed entities of an extended persistence context remain managed.

==== Transaction Rollback [[a2049]]

For both transaction-scoped
persistence contexts and for extended persistence contexts that are
joined to the current transaction, transaction rollback causes all
_pre-existing_ managed instances and removed
instancesfootnote:[These are instances
that were persistent in the database at the start of the transaction.] to become detached. The instances'
state will be the state of the instances at the point at which the
transaction was rolled back. Transaction rollback typically causes the
persistence context to be in an inconsistent state at the point of
rollback. In particular, the state of version attributes and generated
state (e.g., generated primary keys) may be inconsistent. Instances that
were formerly managed by the persistence context (including new
instances that were made persistent in that transaction) may therefore
not be reusable in the same manner as other detached objectsfor
example, they may fail when passed to the merge
operation.footnote:[It is unspecified as
to whether instances that were not persistent in the database behave as
new instances or detached instances after rollback. This may be
implementation-dependent.]

[NOTE]
====
Because a transaction-scoped
persistence context's lifetime is scoped to a transaction regardless of
whether it is joined to that transaction, the container closes the
persistence context upon transaction rollback. However, an extended
persistence context that is not joined to a transaction is unaffected by
transaction rollback.
====

=== Locking and Concurrency [[a2052]]

This specification assumes the use of
optimistic concurrency control. It assumes that the databases to which
persistence units are mapped will be accessed by the implementation
using read-committed isolation (or a vendor equivalent in which
long-term read locks are not held), and that writes to the database will
typically occur only when the _flush_ method has been invokedwhether
explicitly by the application, or by the persistence provider runtime in
accordance with the flush mode setting.

[NOTE]
====
If a transaction is active and the
persistence context is joined to the transaction, a compliant
implementation of this specification is permitted to write to the
database immediately (i.e., whenever a managed entity is updated,
created, and/or removed), however, the configuration of an
implementation to require such non-deferred database writes is outside
the scope of this specification.footnote:[Applications may
require that database isolation levels higher than read-committed be in
effect. The configuration of the setting database isolation levels,
however, is outside the scope of this specification.]
====

In addition, both pessimistic and optimistic
locking are supported for selected entities by means of specified lock
modes. Optimistic locking is described in <<a2056>> and <<a2059>>; pessimistic locking
in <<a2066>>. <<a2084>> describes the setting of
optimistic and pessimistic lock modes. The configuration of the setting
of optimistic lock modes is described in <<a2100>>,
and the configuration of the setting of pessimistic lock modes is
described in <<a2113>>.

==== Optimistic Locking [[a2056]]

Optimistic locking is a technique that is
used to insure that updates to the database data corresponding to the
state of an entity are made only when no intervening transaction has
updated that data since the entity state was read. This insures that
updates or deletes to that data are consistent with the current state of
the database and that intervening updates are not lost. Transactions
that would cause this constraint to be violated result in an
_OptimisticLockException_ being thrown and the transaction marked for
rollback.

Portable applications that wish to enable
optimistic locking for entities must specify _Version_ attributes for
those entitiesi.e., persistent properties or fields annotated with the
_Version_ annotation or specified in the XML descriptor as version
attributes. Applications are strongly encouraged to enable optimistic
locking for all entities that may be concurrently accessed or that may
be merged from a disconnected state. Failure to use optimistic locking
may lead to inconsistent entity state, lost updates and other state
irregularities. If optimistic locking is not defined as part of the
entity state, the application must bear the burden of maintaining data
consistency.

==== Version Attributes [[a2059]]

The _Version_ field or property is used by
the persistence provider to perform optimistic locking. It is accessed
and/or set by the persistence provider in the course of performing
lifecycle operations on the entity instance. An entity is automatically
enabled for optimistic locking if it has a property or field mapped with
a _Version_ mapping.

An entity may access the state of its version
field or property or export a method for use by the application to
access the version, but must not modify the version
value.footnote:[Bulk update
statements, however, are permitted to set the value of version
attributes. See <<a5636>>.] With the exception noted in <<a5636>>, only
the persistence provider is permitted to set or update the value of the
version attribute in the object.

The version attribute is updated by the
persistence provider runtime when the object is written to the database.
All non-relationship fields and properties and all relationships owned
by the entity are included in version checks.footnote:[This includes owned
relationships maintained in join tables.]

The persistence provider's implementation of
the merge operation must examine the version attribute when an entity is
being merged and throw an _OptimisticLockException_ if it is discovered
that the object being merged is a stale copy of the entityi.e. that the
entity has been updated since the entity became detached. Depending on
the implementation strategy used, it is possible that this exception may
not be thrown until _flush_ is called or commit time, whichever happens
first.

The persistence provider runtime is
required to use only the version attribute when performing optimistic
lock checking. Persistence provider implementations may provide
additional mechanisms beside version attributes to enable optimistic
lock checking. However, support for such mechanisms is not required of
an implementation of this specification.footnote:[Such additional
mechanisms may be standardized by a future release of this
specification.]

If only some entities contain version
attributes, the persistence provider runtime is required to check those
entities for which version attributes have been specified. The
consistency of the object graph is not guaranteed, but the absence of
version attributes on some of the entities will not stop operations from
completing.

==== Pessimistic Locking [[a2066]]

While optimistic locking is typically
appropriate in dealing with moderate contention among concurrent
transactions, in some applications it may be useful to immediately
obtain long-term database locks for selected entities because of the
often late failure of optimistic transactions. Such immediately obtained
long-term database locks are referred to here as pessimistic
locks.footnote:[Implementations are
permitted to use database mechanisms other than locking to achieve the
semantic effects described here, for example, multiversion concurrency
control mechanisms.]

Pessimistic locking guarantees that once a
transaction has obtained a pessimistic lock on an entity instance:

* no other transaction (whether a transaction
of an application using the Jakarta Persistence API or any other
transaction using the underlying resource) may successfully modify or
delete that instance until the transaction holding the lock has ended.
* if the pessimistic lock is an exclusive
lockfootnote:[This is achieved by
using a lock with LockModeType.PESSIMISTIC_WRITE or
LockModeType.PESSIMISTIC_FORCE_INCREMENT as described in <<a2084>>.],
that same transaction may modify or delete
that entity instance.

When an entity instance is locked using
pessimistic locking, the persistence provider must lock the database
row(s) that correspond to the non-collection-valued persistent state of
that instance. If a joined inheritance strategy is used, or if the
entity is otherwise mapped to a secondary table, this entails locking
the row(s) for the entity instance in the additional table(s). Entity
relationships for which the locked entity contains the foreign key will
also be locked, but not the state of the referenced entities (unless
those entities are explicitly locked). Element collections and
relationships for which the entity does not contain the foreign key
(such as relationships that are mapped to join tables or unidirectional
one-to-many relationships for which the target entity contains the
foreign key) will not be locked by default.

Element collections and relationships owned
by the entity that are contained in join tables will be locked if the
_jakarta.persistence.lock.scope_ property is specified with a value of
_PessimisticLockScope.EXTENDED_. The state of entities referenced by
such relationships will not be locked (unless those entities are
explicitly locked). This property may be passed as an argument to the
methods of the _EntityManager_, _Query_, and _TypedQuery_ interfaces
that allow lock modes to be specified or used with the _NamedQuery_
annotation.

Locking such a relationship or element
collection generally locks only the rows in the join table or collection
table for that relationship or collection. This means that phantoms will
be possible.

The values of the
_jakarta.persistence.lock.scope_ property are defined by the
_PessimisticLockScope_ enum.

[source,java]
----
package jakarta.persistence;

public enum PessimisticLockScope {
  NORMAL,
  EXTENDED
}
----

This specification does not define the
mechanisms a persistence provider uses to obtain database locks, and a
portable application should not rely on how pessimistic locking is
achieved on the database.footnote:[For example, a
persistence provider may use an underlying database platform's SELECT
FOR UPDATE statements to implement pessimistic locking if that construct
provides appropriate semantics, or the provider may use an isolation
level of repeatable read.] In particular, a
persistence provider or the underlying database management system may
lock more rows than the ones selected by the application.

Whenever a pessimistically locked entity
containing a version attribute is updated on the database, the
persistence provider must also update (increment) the entity's version
column to enable correct interaction with applications using optimistic
locking. See <<a2059>> and <<a2084>>.

Pessimistic locking may be applied to
entities that do not contain version attributes. However, in this case
correct interaction with applications using optimistic locking cannot be
ensured.

==== Lock Modes [[a2084]]

Lock modes are intended to provide a facility
that enables the effect of repeatable read semantics for the items
read, whether optimistically (as described in <<a2100>>)
or pessimistically (as described in <<a2113>>).

Lock modes can be specified by means of the
EntityManager _lock_ method, the methods of the _EntityManager_,
_Query_, and _TypedQuery_ interfaces that allow lock modes to be
specified, and the _NamedQuery_ annotation.

Lock mode values are defined by the
_LockModeType_ enum. Six distinct lock modes are defined. The lock mode
type values _READ_ and _WRITE_ are synonyms of _OPTIMISTIC_ and
_OPTIMISTIC_FORCE_INCREMENT_ respectively.footnote:[The lock mode type
NONE may be specified as a value of lock mode arguments and also
provides a default value for annotations.] The
latter are to be preferred for new applications.

[source,java]
----
package jakarta.persistence;

public enum LockModeType {
  READ,
  WRITE,
  OPTIMISTIC,
  OPTIMISTIC_FORCE_INCREMENT,
  PESSIMISTIC_READ,
  PESSIMISTIC_WRITE,
  PESSIMISTIC_FORCE_INCREMENT,
  NONE
}
----

===== OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT [[a2100]]

The lock modes _OPTIMISTIC_ and
_OPTIMISTIC_FORCE_INCREMENT_ are used for optimistic locking. The lock
mode type values _READ_ and _WRITE_ are synonymous with _OPTIMISTIC_ and
_OPTIMISTIC_FORCE_INCREMENT_ respectively.

The semantics of requesting locks of type
_LockModeType.OPTIMISTIC_ and _LockModeType.OPTIMISTIC_FORCE_INCREMENT_
are the following.

If transaction T1 calls _lock(entity,_
_LockModeType.OPTIMISTIC)_ on a versioned object, the entity manager
must ensure that neither of the following phenomena can occur:

* P1 (Dirty read): Transaction T1 modifies a
row. Another transaction T2 then reads that row and obtains the modified
value, before T1 has committed or rolled back. Transaction T2 eventually
commits successfully; it does not matter whether T1 commits or rolls
back and whether it does so before or after T2 commits.
* P2 (Non-repeatable read): Transaction T1
reads a row. Another transaction T2 then modifies or deletes that row,
before T1 has committed. Both transactions eventually commit
successfully.

This will generally be achieved by the entity
manager acquiring a lock on the underlying database row. While with
optimistic concurrency concurrency, long-term database read locks are
typically not obtained immediately, a compliant implementation is
permitted to obtain an immediate lock (so long as it is retained until
commit completes). If the lock is deferred until commit time, it must be
retained until the commit completes. Any implementation that supports
repeatable reads in a way that prevents the above phenomena is
permissible.

The persistence implementation is not
required to support calling _lock(entity,_ _LockModeType.OPTIMISTIC)_ on
a non-versioned object. When it cannot support such a lock call, it must
throw the _PersistenceException_. When supported, whether for versioned
or non-versioned objects, _LockModeType.OPTIMISTIC_ must always prevent
the phenomena P1 and P2. Applications that call _lock(entity,
LockModeType.OPTIMISTIC)_ on non-versioned objects will not be portable.

If transaction T1 calls _lock(entity,_
_LockModeType.OPTIMISTIC_FORCE_INCREMENT)_ on a versioned object, the
entity manager must avoid the phenomena P1 and P2 (as with
_LockModeType.OPTIMISTIC_) and must also force an update (increment) to
the entity's version column. A forced version update may be performed
immediately, or may be deferred until a flush or commit. If an entity is
removed before a deferred version update was to have been applied, the
forced version update is omitted.

The persistence implementation is not
required to support calling _lock(entity,_
_LockModeType.OPTIMISTIC_FORCE_INCREMENT)_ on a non-versioned object.
When it cannot support such a lock call, it must throw the
_PersistenceException_. When supported, whether for versioned or
non-versioned objects, _LockModeType.OPTIMISTIC_FORCE_INCREMENT_ must
always prevent the phenomena P1 and P2. For non-versioned objects,
whether or not _LockModeType.OPTIMISTIC_FORCE_INCREMENT_ has any
additional behavior is vendor-specific. Applications that call
_lock(entity, LockModeType.OPTIMISTIC_FORCE_INCREMENT)_ on non-versioned
objects will not be portable.

For versioned objects, it is permissible for
an implementation to use _LockModeType.OPTIMISTIC_FORCE_INCREMENT_ where
_LockModeType.OPTIMISTIC_ was requested, but not vice versa.

If a versioned object is otherwise updated or
removed, then the implementation must ensure that the requirements of
_LockModeType.OPTIMISTIC_FORCE_INCREMENT_ are met, even if no explicit
call to _EntityManager.lock_ was made.

For portability, an application should not
depend on vendor-specific hints or configuration to ensure repeatable
read for objects that are not updated or removed via any mechanism other
than the use of version attributes and the EntityManager _lock_ method.
However, it should be noted that if an implementation has acquired
up-front pessimistic locks on some database rows, then it is free to
ignore _lock(entity, LockModeType.OPTIMISTIC)_ calls on the entity
objects representing those rows.

===== PESSIMISTIC_READ, PESSIMISTIC_WRITE, PESSIMISTIC_FORCE_INCREMENT [[a2113]]

The lock modes _PESSIMISTIC_READ_,
_PESSIMISTIC_WRITE_, and _PESSIMISTIC_FORCE_INCREMENT_ are used to
immediately obtain long-term database locks.footnote:[Databases concurrency
control mechanisms that provide comparable semantics, e.g., multiversion
concurrency control, can be used by the provider.]

The semantics of requesting locks of type
_LockModeType.PESSIMISTIC_READ_, _LockModeType.PESSIMISTIC_WRITE_, and
_LockModeType.PESSIMISTIC_FORCE_INCREMENT_ are the following.

If transaction T1 calls _lock(entity,
LockModeType.PESSIMISTIC_READ)_ or _lock(entity,
LockModeType.PESSIMISTIC_WRITE)_ on an object, the entity manager must
ensure that neither of the following phenomena can occur:

* P1 (Dirty read): Transaction T1 modifies a
row. Another transaction T2 then reads that row and obtains the modified
value, before T1 has committed or rolled back.
* P2 (Non-repeatable read): Transaction T1
reads a row. Another transaction T2 then modifies or deletes that row,
before T1 has committed or rolled back.

Any such lock must be obtained immediately
and retained until transaction T1 completes (commits or rolls back).

Avoidance of phenomena P1 and P2 is generally
achieved by the entity manager acquiring a long-term lock on the
underlying database row(s). Any implementation that supports pessimistic
repeatable reads as described above is permissible.

[NOTE]
====
A lock with _LockModeType.PESSIMISTIC_WRITE_
can be obtained on an entity instance to force serialization among
transactions attempting to update the entity data. A lock with
_LockModeType.PESSIMISTIC_READ_ can be used to query data using
repeatable-read semantics without the need to reread the data at the end
of the transaction to obtain a lock, and without blocking other
transactions reading the data. A lock with
_LockModeType.PESSIMISTIC_WRITE_ can be used when querying data and
there is a high likelihood of deadlock or update failure among
concurrent updating transactions.
====

The persistence implementation must support
calling _lock(entity, LockModeType.PESSIMISTIC_READ_) and _lock(entity,
LockModeType.PESSIMISTIC_WRITE)_ on a non-versioned entity as well as on
a versioned entity.

It is permissible for an implementation to
use _LockModeType.PESSIMISTIC_WRITE_ where
_LockModeType.PESSIMISTIC_READ_ was requested, but not vice versa.

When the lock cannot be obtained, and the
database locking failure results in transaction-level rollback, the
provider must throw the _PessimisticLockException_ and ensure that the
JTA transaction or EntityTransaction has been marked for rollback.

When the lock cannot be obtained, and the
database locking failure results in only statement-level rollback, the
provider must throw the _LockTimeoutException_ (and must not mark the
transaction for rollback).

When an application locks an entity with
_LockModeType.PESSIMISTIC_READ_ and later updates that entity, the lock
must be converted to an exclusive lock when the entity is flushed to the
database.footnote:[The persistence
provider is not required to flush the entity to the database
immediately.] If the lock conversion fails, and the
database locking failure results in transaction-level rollback, the
provider must throw the _PessimisticLockException_ and ensure that the
JTA transaction or EntityTransaction has been marked for rollback. When
the lock conversion fails, and the database locking failure results in
only statement-level rollback, the provider must throw the
_LockTimeoutException_ (and must not mark the transaction for
rollback).

When _lock(entity,
LockModeType.PESSIMISTIC_READ)_, _lock(entity,
LockModeType.PESSIMISTIC_WRITE)_, or _lock(entity,
LockModeType.PESSIMISTIC_FORCE_INCREMENT)_ is invoked on a versioned
entity that is already in the persistence context, the provider must
also perform optimistic version checks when obtaining the lock. An
_OptimisticLockException_ must be thrown if the version checks fail.
Depending on the implementation strategy used by the provider, it is
possible that this exception may not be thrown until flush is called or
commit time, whichever occurs first.

If transaction T1 calls _lock(entity,
LockModeType.PESSIMISTIC_FORCE_INCREMENT)_ on a versioned object, the
entity manager must avoid the phenomenon P1 and P2 (as with
_LockModeType.PESSIMISTIC_READ_ and _LockModeType.PESSIMISTIC_WRITE_)
and must also force an update (increment) to the entity's version
column.

The persistence implementation is not
required to support calling _lock(entity,_
_LockModeType.PESSIMISTIC_FORCE_INCREMENT)_ on a non-versioned object.
When it cannot support such a lock call, it must throw the
_PersistenceException_. When supported, whether for versioned or
non-versioned objects, _LockModeType.PESSIMISTIC_FORCE_INCREMENT_ must
always prevent the phenomena P1 and P2. For non-versioned objects,
whether or not _LockModeType.PESSIMISTIC_FORCE_INCREMENT_ has any
additional behavior is vendor-specific. Applications that call
_lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)_ on
non-versioned objects will not be portable.

For versioned objects, it is permissible for
an implementation to use _LockModeType.PESSIMISTIC_FORCE_INCREMENT_
where _LockModeType.PESSIMISTIC_READ_ or
_LockModeType.PESSIMISTIC_WRITE_ was requested, but not vice versa.

If a versioned object locked with
_LockModeType.PESSIMISTIC_READ_ or _LockModeType.PESSIMISTIC_WRITE_ is
updated, then the implementation must ensure that the requirements of
_LockModeType.PESSIMISTIC_FORCE_INCREMENT_ are met.

===== Lock Mode Properties and Uses [[a2132]]

The following property is defined by this
specification for use in pessimistic locking, as described in <<a2066>>:

[source,java]
----
jakarta.persistence.lock.scope
----

This property may be used with the methods of
the _EntityManager_ interface that allow lock modes to be specified, the
_Query_ and _TypedQuery_ _setLockMode_ methods, and the _NamedQuery_
annotation. When specified, this property must be observed. The provider
is permitted to lock more (but not fewer) rows than requested.

The following hint is defined by this
specification for use in pessimistic locking.

[source,java]
----
jakarta.persistence.lock.timeout // time in milliseconds
----

This hint may be used with the methods of the
_EntityManager_ interface that allow lock modes to be specified, the
_Query.setLockMode_ method and the _NamedQuery_ annotation. It may also
be passed as a property to the _Persistence.createEntityManagerFactory_
method and used in the _properties_ element of the _persistence.xml_
file. See <<a1066>>, <<a4385>>, <<a12384>>, <<a13443>>,
and <<a13711>>. When used in
the _createEntityManagerFactory_ method, the _persistence.xml_ file, and
the _NamedQuery_ annotation, the timeout hint serves as a default value
which can be selectively overridden by use in the methods of the
_EntityManager_, _Query_, and _TypedQuery_ interfaces as specified
above. When this hint is not specified, database timeout values are
assumed to apply.

A timeout value of _0_ is used to specify no wait locking.

Portable applications should not rely on this
hint. Depending on the database in use and the locking mechanisms used
by the persistence provider, the hint may or may not be observed.

Vendors are permitted to support the use of
additional, vendor-specific locking hints. Vendor-specific hints must
not use the _jakarta.persistence_ namespace. Vendor-specific hints must be
ignored if they are not understood.

If the same property or hint is specified
more than once, the following order of overriding applies, in order of
decreasing precedence:

* argument to method of _EntityManager_, _Query_, or _TypedQuery_ interface
* specification to _NamedQuery_ (annotation or XML)
* argument to _createEntityManagerFactory_ method
* specification in _persistence.xml_

==== OptimisticLockException

Provider implementations may defer writing to
the database until the end of the transaction, when consistent with the
lock mode and flush mode settings in effect. In this case, an optimistic
lock check may not occur until commit time, and the
_OptimisticLockException_ may be thrown in the before completion phase
of the commit. If the _OptimisticLockException_ must be caught or
handled by the application, the _flush_ method should be used by the
application to force the database writes to occur. This will allow the
application to catch and handle optimistic lock exceptions.

The _OptimisticLockException_ provides an API
to return the object that caused the exception to be thrown. The object
reference is not guaranteed to be present every time the exception is
thrown but should be provided whenever the persistence provider can
supply it. Applications cannot rely upon this object being available.

In some cases an _OptimisticLockException_
will be thrown and wrapped by another exception, such as a
_RemoteException_, when VM boundaries are crossed. Entities that may be
referenced in wrapped exceptions should implement _Serializable_ so that
marshalling will not fail.

An _OptimisticLockException_ always causes
the transaction to be marked for rollback.

Refreshing objects or reloading objects in a
new transaction context and then retrying the transaction is a potential
response to an _OptimisticLockException_.

=== Entity Listeners and Callback Methods [[a2153]]

A method may be designated as a lifecycle
callback method to receive notification of entity lifecycle events. A
lifecycle callback method can be defined on an entity class, a mapped
superclass, or an entity listener class associated with an entity or
mapped superclass. An entity listener class is a class whose methods are
invoked in response to lifecycle events on an entity. Any number of
entity listener classes can be defined for an entity class or mapped
superclass.

Default entity listenersentity listener
classes whose callback methods apply to all entities in the persistence
unitcan be specified by means of the XML descriptor.

Lifecycle callback methods and entity
listener classes are defined by means of metadata annotations or the XML
descriptor. When annotations are used, one or more entity listener
classes are denoted using the _EntityListeners_ annotation on the entity
class or mapped superclass. If multiple entity listeners are defined,
the order in which they are invoked is determined by the order in which
they are specified in the _EntityListeners_ annotation. The XML
descriptor may be used as an alternative to specify the invocation order
of entity listeners or to override the order specified in metadata
annotations.

Any subset or combination of annotations may
be specified on an entity class, mapped superclass, or listener class. A
single class must not have more than one lifecycle callback method for
the same lifecycle event. The same method may be used for multiple
callback events.

Multiple entity classes and mapped
superclasses in an inheritance hierarchy may define listener classes
and/or lifecycle callback methods directly on the class. <<a2251>>
describes the rules that apply to method invocation order in this case.

==== Entity Listeners

The entity listener class must have a public no-arg constructor.

Entity listener classes in Jakarta EE
environments support dependency injection through the Contexts and
Dependency Injection API (CDI) <<a19500>> when CDI is
enabledfootnote:[CDI is enabled by
default in Jakarta EE. See the Jakarta EE specification
<<a19499>>.]. An entity listener class that makes use
of CDI injection may also define lifecycle callback methods annotated
with the _PostConstruct_ and _PreDestroy_ annotations. These methods
will be invoked after injection has taken place and before the entity
listener instance is destroyed respectively.

The persistence provider is responsible for
using the CDI SPI to create instances of the entity listener class; to
perform injection upon such instances; to invoke their _PostConstruct_
and _PreDestroy_ methods, if any; and to dispose of the entity listener
instances.

The persistence provider is only required to
support CDI injection into entity listeners in Jakarta EE container
environmentsfootnote:[The persistence
provider may support CDI injection into entity listeners in other
environments in which the BeanManager is available.]. If the CDI is not enabled, the
persistence provider must not invoke entity listeners that depend upon
CDI injection.

An entity listener is a noncontextual object.
In supporting injection into entity listeners, the persistence provider
must behave as if it carries out the following steps involving the use
of the CDI SPI. (See <<a19500>>).

* Obtain a _BeanManager_ instance. (See <<a12802>>)
* Create an _AnnotatedType_ instance for the entity listener class.
* Create an _InjectionTarget_ instance for the annotated type.
* Create a _CreationalContext_.
* Instantiate the listener by calling the _InjectionTarget_ _produce_ method.
* Inject the listener instance by calling the
_InjectionTarget_ _inject_ method on the instance.
* Invoke the _PostConstruct_ callback, if any,
by calling the _InjectionTarget_ _postConstruct_ method on the instance.

When the listener instance is to be
destroyed, the persistence provider must behave as if it carries out the
following steps.

* Call the _InjectionTarget_ _preDestroy_ method on the instance.
* Call the _InjectionTarget_ _dispose_ method on the instance
* Call the _CreationalContext_ _release_ method.

Persistence providers may optimize the steps
above, e.g. by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

Entity listeners that do not make use of CDI
injection are stateless. The lifecycle of such entity listeners is
unspecified.

When invoked from within a Jakarta EE
environment, the callback listeners for an entity share the enterprise
naming context of the invoking component, and the entity callback
methods are invoked in the transaction and security contexts of the
calling component at the time at which the callback method is invoked.
footnote:[For example, if a
transaction commit occurs as a result of the normal termination of a
session bean business method with transaction attribute _RequiresNew_,
the _PostPersist_ and _PostRemove_ callbacks are executed in the naming
context, the transaction context, and the security context of that
component.]

==== Lifecycle Callback Methods

Entity lifecycle callback methods can be
defined on an entity listener class and/or directly on an entity class
or mapped superclass.

Lifecycle callback methods are annotated with
annotations designating the callback events for which they are invoked
or are mapped to the callback event using the XML descriptor.

The annotations (and XML elements) used for
callback methods on the entity class or mapped superclass and for
callback methods on the entity listener class are the same. The
signatures of individual methods, however, differ.

Callback methods defined on an entity class
or mapped superclass have the following signature:

 void <METHOD>()

Callback methods defined on an entity
listener class have the following signature:

 void <METHOD>(Object)

The _Object_ argument is the entity instance
for which the callback method is invoked. It may be declared as the
actual entity type.

The callback methods can have public,
private, protected, or package level access, but must not be _static_ or
_final_.

The following annotations designate lifecycle
event callback methods of the corresponding types.

* _PrePersist_
* _PostPersist_
* _PreRemove_
* _PostRemove_
* _PreUpdate_
* _PostUpdate_
* _PostLoad_

The following rules apply to lifecycle callback methods:

* Lifecycle callback methods may throw
unchecked/runtime exceptions. A runtime exception thrown by a callback
method that executes within a transaction causes that transaction to be
marked for rollback if the persistence context is joined to the
transaction.
* Lifecycle callbacks can invoke JNDI, JDBC,
JMS, and enterprise beans.
* In general, the lifecycle method of a
portable application should not invoke _EntityManager_ or query
operations, access other entity instances, or modify relationships
within the same persistence
contextfootnote:[Note that this
caution applies also to the actions of objects that might be injected
into an entity listener]footnote:[The semantics of such
operations may be standardized in a future release of this
specification.]. A lifecycle
callback method may modify the non-relationship state of the entity on
which it is invoked.

==== Semantics of the Life Cycle Callback Methods for Entities [[a2202]]

The _PrePersist_ and _PreRemove_ callback
methods are invoked for a given entity before the respective
EntityManager persist and remove operations for that entity are
executed. For entities to which the merge operation has been applied and
causes the creation of newly managed instances, the _PrePersist_
callback methods will be invoked for the managed instance after the
entity state has been copied to it. These _PrePersist_ and _PreRemove_
callbacks will also be invoked on all entities to which these operations
are cascaded. The _PrePersist_ and _PreRemove_ methods will always be
invoked as part of the synchronous persist, merge, and remove
operations.

The _PostPersist_ and _PostRemove_ callback
methods are invoked for an entity after the entity has been made
persistent or removed. These callbacks will also be invoked on all
entities to which these operations are cascaded. The _PostPersist_ and
_PostRemove_ methods will be invoked after the database insert and
delete operations respectively. These database operations may occur
directly after the persist, merge, or remove operations have been
invoked or they may occur directly after a flush operation has occurred
(which may be at the end of the transaction). Generated primary key
values are available in the _PostPersist_ method.

The _PreUpdate_ and _PostUpdate_ callbacks
occur before and after the database update operations to entity data
respectively. These database operations may occur at the time the entity
state is updated or they may occur at the time state is flushed to the
database (which may be at the end of the transaction).

[NOTE]
====
Note that it is implementation-dependent as
to whether _PreUpdate_ and _PostUpdate_ callbacks occur when an entity
is persisted and subsequently modified in a single transaction or when
an entity is modified and subsequently removed within a single
transaction. Portable applications should not rely on such behavior.
====

The _PostLoad_ method for an entity is
invoked after the entity has been loaded into the current persistence
context from the database or after the refresh operation has been
applied to it. The _PostLoad_ method is invoked before a query result is
returned or accessed or before an association is traversed.

It is implementation-dependent as to whether
callback methods are invoked before or after the cascading of the
lifecycle events to related entities. Applications should not depend on
this ordering.

==== Example

[source,java]
----
@Entity
@EntityListeners(com.acme.AlertMonitor.class)
public class Account {
    Long accountId;
    Integer balance;
    boolean preferred;

    @Id
    public Long getAccountId() { ... }

    // ...

    public Integer getBalance() { ... }

    // ...

    @Transient // because status depends upon non-persistent context
    public boolean isPreferred() { ... }

    // ...

    public void deposit(Integer amount) { ... }

    public Integer withdraw(Integer amount) throws NSFException { ... }

    @PrePersist
    protected void validateCreate() {
        if (getBalance() < MIN_REQUIRED_BALANCE)
            throw new AccountException("Insufficient balance to open an account");
    }

    @PostLoad
    protected void adjustPreferredStatus() {
        preferred = (getBalance() >= AccountManager.getPreferredStatusLevel());
    }
}

public class AlertMonitor {
    @PostPersist
    public void newAccountAlert(Account acct) {
        Alerts.sendMarketingInfo(acct.getAccountId(), acct.getBalance());
    }
}
----

==== Multiple Lifecycle Callback Methods for an Entity Lifecycle Event [[a2251]]

If multiple callback methods are defined for
an entity lifecycle event, the ordering of the invocation of these
methods is as follows.

Default listeners, if any, are invoked first,
in the order specified in the XML descriptor. Default listeners apply to
all entities in the persistence unit, unless explicitly excluded by
means of the _ExcludeDefaultListeners_ annotation or
_exclude-default-listeners_ XML element.

The lifecycle callback methods defined on the
entity listener classes for an entity class or mapped superclass are
invoked in the same order as the specification of the entity listener
classes in the _EntityListeners_ annotation.

If multiple classes in an inheritance
hierarchyentity classes and/or mapped superclassesdefine entity
listeners, the listeners defined for a superclass are invoked before the
listeners defined for its subclasses in this order. The
_ExcludeSuperclassListeners_ annotation or
_exclude-superclass-listeners_ XML element may be applied to an entity
class or mapped superclass to exclude the invocation of the listeners
defined by the entity listener classes for the superclasses of the
entity or mapped superclass. The excluded listeners are excluded from
the class to which the _ExcludeSuperclassListeners_ annotation or
element has been specified and its subclassesfootnote:[Excluded listeners
may be reintroduced on an entity class by listing them explicitly in the
_EntityListeners_ annotation or XML _entity-listeners_ element.].
The _ExcludeSuperclassListeners_ annotation (or
_exclude-superclass-listeners_ XML element) does not cause default
entity listeners to be excluded from invocation.

If a lifecycle callback method for the
same lifecycle event is also specified on the entity class and/or one or
more of its entity or mapped superclasses, the callback methods on the
entity class and/or superclasses are invoked after the other lifecycle
callback methods, most general superclass first. A class is permitted to
override an inherited callback method of the same callback type, and in
this case, the overridden method is not invokedfootnote:[If a method overrides
an inherited callback method but specifies a different lifecycle event
or is not a lifecycle callback method, the overridden method will not be
invoked.].

Callback methods are invoked by the
persistence provider runtime in the order specified. If the callback
method execution terminates normally, the persistence provider runtime
then invokes the next callback method, if any.

The XML descriptor may be used to override
the lifecycle callback method invocation order specified in annotations.

==== Example

There are several entity classes and listeners for animals:

[source,java]
----
@Entity
public class Animal {

    // ...

    @PostPersist
    protected void postPersistAnimal() {
        // ...
    }
}

@Entity
@EntityListeners(PetListener.class)
public class Pet extends Animal {
    // ...
}

@Entity
@EntityListeners({CatListener.class, CatListener2.class})
public class Cat extends Pet {
    // ...
}

public class PetListener {
    @PostPersist
    protected void postPersistPetListenerMethod(Object pet) {
        // ...
    }
}

public class CatListener {
    @PostPersist
    protected void postPersistCatListenerMethod(Object cat) {
        // ...
    }
}

public class CatListener2 {
    @PostPersist
    protected void postPersistCatListener2Method(Object cat) {
        // ...
    }
}
----

If a _PostPersist_ event occurs on an
instance of _Cat_, the following methods are called in order:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistAnimal

Assume that _SiameseCat_ is defined as a
subclass of _Cat_:

[source,java]
----
@EntityListeners(SiameseCatListener.class)
@Entity
public class SiameseCat extends Cat {
    // ...

    @PostPersist
    protected void postPersistSiameseCat() {
        // ...
    }
}

public class SiameseCatListener {
    @PostPersist
    protected void postPersistSiameseCatListenerMethod(Object cat) {
        // ...
    }
}
----

If a _PostPersist_ event occurs on an
instance of _SiameseCat_, the following methods are called in order:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistSiameseCatListenerMethod
. postPersistAnimal
. postPersistSiameseCat

Assume the definition of _SiameseCat_ were instead:

[source,java]
----
@EntityListeners(SiameseCatListener.class)
@Entity
public class SiameseCat extends Cat {
    // ...

    @PostPersist
    protected void postPersistAnimal() {
        // ...
    }
}
----

In this case, the following methods would be
called in order, where _postPersistAnimal_ is the _PostPersist_ method
defined in the _SiameseCat_ class:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistSiameseCatListenerMethod
. postPersistAnimal

==== Exceptions

Lifecycle callback methods may throw runtime
exceptions. A runtime exception thrown by a callback method that
executes within a transaction causes that transaction to be marked for
rollback if the persistence context is joined to the transaction. No
further lifecycle callback methods will be invoked after a runtime
exception is thrown.

==== Specification of Callback Listener Classes and Lifecycle Methods in the XML Descriptor

The XML descriptor can be used as an
alternative to metadata annotations to specify entity listener classes
and their binding to entities or to override the invocation order of
lifecycle callback methods as specified in annotations.

===== Specification of Callback Listeners

The _entity-listener_ XML descriptor element
is used to specify the lifecycle listener methods of an entity listener
class. The lifecycle listener methods are specified by using the
_pre-persist_, _post-persist_, _pre-remove_, _post-remove_,
_pre-update_, _post-update_, and/or _post-load_ elements.

An entity listener class can define multiple
callback methods. However, at most one method of an entity listener
class can be designated as a pre-persist method, post-persist method,
pre-remove method, post-remove method, pre-update method, post-update
method, and/or post-load method, regardless of whether the XML
descriptor is used to define entity listeners or whether some
combination of annotations and XML descriptor elements is used.

===== Specification of the Binding of Entity Listener Classes to Entities

The _entity-listeners_ subelement of the
_persistence-unit-defaults_ element is used to specify the default
entity listeners for the persistence unit.

The _entity-listeners_ subelement of the
_entity_ or _mapped-superclass_ element is used to specify the entity
listener classes for the respective entity or mapped superclass and its
subclasses.

The binding of entity listeners to entity
classes is additive. The entity listener classes bound to the
superclasses of an entity or mapped superclass are applied to it as
well.

The _exclude-superclass-listeners_ element
specifies that the listener methods for superclasses are not to be
invoked for an entity class (or mapped superclass) and its subclasses.

The _exclude-default-listeners_ element
specifies that default entity listeners are not to be invoked for an
entity class (or mapped superclass) and its subclasses.

Explicitly listing an excluded default or
superclass listener for a given entity class or mapped superclass causes
it to be applied to that entity or mapped superclass and its subclasses.

In the case of multiple callback methods for
a single lifecycle event, the invocation order rules described in <<a2251>> apply.

=== Bean Validation [[a2366]]

This specification defines support for use of
Bean Validation <<a19498>> within Jakarta Persistence
applications.

Managed classes (entities, mapped
superclasses, and embeddable classes) may be configured to include Bean
Validation constraints.

Automatic validation using these constraints
is achieved by specifying that Jakarta Persistence delegate validation to
the Bean Validation implementation upon the pre-persist, pre-update, and
pre-remove entity lifecycle events described in <<a2202>>.

Validation can also be achieved by the
application calling the _validate_ method of a _Validator_ instance upon
an instance of a managed class, as described in the Bean Validation
specification <<a19498>>.

==== Automatic Validation Upon Lifecycle Events

This specification supports the use of bean
validation for the automatic validation of entities upon the
pre-persist, pre-update, and pre-remove lifecycle validation events.
These lifecycle validation events occur immediately after the point at
which all the _PrePersist_, _PreUpdate_, and _PreRemove_ lifecycle
callback method invocations respectively have been completed, or
immediately after the point at which such lifecycle callback methods
would have been completed (in the event that such callback methods are
not present).

[NOTE]
====
In the case where an entity is persisted and
subsequently modified in a single transaction or when an entity is
modified and subsequently removed in a single transaction, it is
implementation dependent as to whether the pre-update validation event
occurs. Portable applications should not rely on this behavior.
====

===== Enabling Automatic Validation [[a2374]]

The _validation-mode_ element of the
_persistence.xml_ file determines whether the automatic lifecycle event
validation is in effect. The values of the _validation-mode_ element are
_AUTO_, _CALLBACK_, _NONE_. The default validation mode is _AUTO_.

If the application creates the entity manager
factory using the _Persistence.createEntityManagerFactory_ method, the
validation mode can be specified using the
_jakarta.persistence.validation.mode_ map key, which will override the
value specified (or defaulted) in the _persistence.xml_ file. The map
values for this key are _"auto"_, _"callback"_, _"none"_.

If the auto validation mode is specified by
the _validation-mode_ element or the _jakarta.persistence.validation.mode_
property, or if neither the _validation-mode_ element nor the
_jakarta.persistence.validation.mode_ property is specified, and a Bean
Validation provider is present in the environment, the persistence
provider must perform the automatic validation of entities as described
in <<a2380>>. If no Bean Validation provider is
present in the environment, no lifecycle event validation takes place.

If the callback validation mode is specified
by the _validation-mode_ element or the
_jakarta.persistence.validation.mode_ property, the persistence provider
must perform the lifecycle event validation as described in <<a2380>>.
It is an error if there is no Bean Validation
provider present in the environment, and the provider must throw the
_PersistenceException_ if the _jakarta.persistence.validation.mode_
property value _"callback"_ has been passed to the
_Persistence.createEntityManagerFactory_ method.

If the none validation mode is specified by
the _validation-mode_ element or the _jakarta.persistence.validation.mode_
property, the persistence provider must not perform lifecycle event
validation.

===== Requirements for Automatic Validation upon Lifecycle Events [[a2380]]

For each event type, a list of groups is
targeted for validation. By default, the default Bean Validation group
(the group _Default_) will be validated upon the pre-persist and
pre-update lifecycle validation events, and no group will be validated
upon the pre-remove event.

This default validation behavior can be
overridden by specifying the target groups using the following
validation properties in the _persistence.xml_ file or by passing these
properties in the configuration of the entity manager factory through
the _createEntityManagerFactory_ method:


* _jakarta.persistence.validation.group.pre-persist_
* _jakarta.persistence.validation.group.pre-update_
* _jakarta.persistence.validation.group.pre-remove_

The value of a validation property must be a
list of the targeted groups. A targeted group must be specified by its
fully qualified class name. Names must be separated by a comma.

When one of the above events occurs for an
entity, the persistence provider must validate that entity by obtaining
a _Validator_ instance from the validator factory in use (see <<a2394>>) and
invoking its _validate_ method with the targeted groups. If the list of
targeted groups is empty, no validation is performed. If the set of
_ConstraintViolation_ objects returned by the _validate_ method is not
empty, the persistence provider must throw the
_jakarta.validation.ConstraintViolationException_ containing a reference
to the returned set of _ConstraintViolation_ objects, and must mark the
transaction for rollback if the persistence context is joined to the
transaction.

The validator instance that is used for
automatic validation upon lifecycle events must use a
_TraversableResolver_ that has the following behavior:

* Attributes that have not been loaded must not
be loaded.
* Validation cascade (_@Valid_) must not
occur for entity associations (single- or multi-valued).

These requirements guarantee that no unloaded
attribute or association will be loaded by side effect and that no
entity will be validated more than once during a given flush cycle.

Embeddable attributes must be validated only
if the _Valid_ annotation has been specified on them.

It is the responsibility of the persistence
provider to pass an instance implementing the
_jakarta.validation.TraversableResolver_ interface to the Bean Validation
provider by calling
_ValidatorFactory.usingContext().traversableResolver(tr).getValidator()_ where _tr_ is the resolver having the behavior described above.

==== Providing the ValidatorFactory [[a2394]]

In Jakarta EE environments, a _ValidatorFactory_
instance is made available by the Jakarta EE container. The container is
responsible for passing this validator factory to the persistence
provider via the map that is passed as an argument to the
_createContainerEntityManagerFactory_ call. The map key used by the
container must be the standard property name
_jakarta.persistence.validation.factory_.

In Java SE environments, the application can
pass the _ValidatorFactory_ instance via the map that is passed as an
argument to the _Persistence.createEntityManagerFactory_ call. The map
key used must be the standard property name
_jakarta.persistence.validation.factory_. If no _ValidatorFactory_
instance is provided by the application, and if a Bean Validation
provider is present in the classpath, the persistence provider must
instantiate the _ValidatorFactory_ using the default bootstrapping
approach defined by the Bean Validation specification
<<a19498>>, namely _Validation.buildDefaultValidatorFactory()_.

=== Entity Graphs [[a2397]]

An entity graph is a template that captures
the path and boundaries for an operation or query. It is defined in the
form of metadata or an object created by the dynamic _EntityGraph_ API.

Entity graphs are used in the specification
of fetch plans for query or _find_ operations.

The _EntityGraph_, _AttributeNode_, and
_Subgraph_ interfaces are used to dynamically construct entity graphs.
The annotations to statically define entity graphs, namely
_NamedEntityGraph_, _NamedAttributeNode_, and _NamedSubgraph_, are
described in <<a13662>>.
The _named-entity-graph_ XML element and its subelements may be used to
override these annotations or to define additional named entity graphs.

The semantics of entity graphs with regard to
find and query operations are described in <<a2814>>.

==== EntityGraph Interface

[source,java]
----
package jakarta.persistence;

import jakarta.persistence.metamodel.Attribute;
import java.util.List;

/**
 * This type represents the root of an entity graph that will be used
 * as a template to define the attribute nodes and boundaries of a
 * graph of entities and entity relationships. The root must be an
 * entity type.
 * <p>
 * The methods to add subgraphs implicitly create the
 * corresponding attribute nodes as well; such attribute nodes
 * should not be redundantly specified.
 *
 * @param <T> The type of the root entity.
 *
 * @see AttributeNode
 * @see Subgraph
 * @see NamedEntityGraph
 *
 * @since 2.1
 */
public interface EntityGraph<T> {

    /**
     * Return the name of a named EntityGraph (an entity graph
     * defined by means of the <code>NamedEntityGraph</code>
     * annotation, XML descriptor element, or added by means of the
     * <code>addNamedEntityGraph</code> method.  Returns null if the
     * EntityGraph is not a named EntityGraph.
     */
    public String getName();

    /**
     * Add one or more attribute nodes to the entity graph.
     *
     * @param attributeName  name of the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public void addAttributeNodes(String ... attributeName);

    /**
     * Add one or more attribute nodes to the entity graph.
     *
     * @param attribute  attribute
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public void addAttributeNodes(Attribute<T, ?>... attribute);

    /**
     * Add a node to the graph that corresponds to a managed
     * type. This allows for construction of multi-node entity graphs
     * that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target type
     *         is not a managed type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(Attribute<T, X> attribute);

    /**
     * Add a node to the graph that corresponds to a managed
     * type with inheritance.  This allows for multiple subclass
     * subgraphs to be defined for this node of the entity
     * graph. Subclass subgraphs will automatically include the
     * specified attributes of superclass subgraphs.
     *
     * @param attribute  attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<? extends X> addSubgraph(Attribute<T, X> attribute, Class<? extends X> type);

    /**
     * Add a node to the graph that corresponds to a managed
     * type. This allows for construction of multi-node entity graphs
     * that include related managed types.
     *
     * @param attributeName  name of the attribute
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target type
     *         is not a managed type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(String attributeName);

    /**
     * Add a node to the graph that corresponds to a managed
     * type with inheritance.  This allows for multiple subclass
     * subgraphs to be defined for this node of the entity graph.
     * Subclass subgraphs will automatically include the specified
     * attributes of superclass subgraphs.
     *
     * @param attributeName  name of the attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this managed type.
     * @throws IllegalArgumentException if the attribute's target type
     *         is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(String attributeName, Class<X> type);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute's target type
     *         is not an entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addKeySubgraph(Attribute<T, X> attribute);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type with inheritance. This allows for
     * construction of multi-node entity graphs that include related
     * managed types.  Subclass subgraphs will include the specified
     * attributes of superclass subgraphs.
     *
     * @param attribute  attribute
     * @param type  entity subclass
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute's target type
     *         is not an entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<? extends X> addKeySubgraph(Attribute<T, X> attribute, Class<? extends X> type);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attributeName  name of the attribute
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target type
     *         is not an entity
     * @throws IllegalStateException if this EntityGraph has been
     *          statically defined
     */
    public <X> Subgraph<X> addKeySubgraph(String attributeName);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type with inheritance. This allows for
     * construction of multi-node entity graphs that include related
     * managed types. Subclass subgraphs will automatically include
     * the specified attributes of superclass subgraphs
     *
     * @param attributeName  name of the attribute
     * @param type  entity subclass
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target type
     *         is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addKeySubgraph(String attributeName, Class<X> type);


    /**
     * Add additional attributes to this entity graph that
     * correspond to attributes of subclasses of this EntityGraph's
     * entity type.  Subclass subgraphs will automatically include the
     * specified attributes of superclass subgraphs.
     *
     * @param type  entity subclass
     * @return subgraph for the subclass
     * @throws IllegalArgumentException if the type is not an entity type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public <T> Subgraph<? extends T> addSubclassSubgraph(Class<? extends T> type);


    /**
     * Return the attribute nodes of this entity that are included in
     * the entity graph.
     * @return attribute nodes for the annotated entity type or empty
     *         list if none have been defined
     */
    public List<AttributeNode<?>> getAttributeNodes();

}
----

==== AttributeNode Interface

[source,java]
----
package jakarta.persistence;

import java.util.Map;

/**
 * Represents an attribute node of an entity graph.
 *
 * @param <T> The type of the attribute.
 *
 * @see EntityGraph
 * @see Subgraph
 * @see NamedAttributeNode
 *
 * @since 2.1
 */
public interface AttributeNode<T> {

    /**
     * Return the name of the attribute corresponding to the
     * attribute node.
     * @return name of the attribute
     */
    public String getAttributeName();

    /**
     * Return the Map&#060;Class, Subgraph&#062; of subgraphs associated
     * with this attribute node.
     * @return Map of subgraphs associated with this attribute node
     * or empty Map if none have been defined
     */
    public Map<Class, Subgraph> getSubgraphs();

    /**
     * Return the Map&#060;Class, Subgraph&#062; of subgraphs associated
     * with this attribute node's map key.
     * @return Map of subgraphs associated with this attribute
     * node's map key or empty Map if none have been defined
     */
    public Map<Class, Subgraph> getKeySubgraphs();
}
----

==== Subgraph Interface

[source,java]
----
package jakarta.persistence;

import jakarta.persistence.metamodel.Attribute;
import java.util.List;

/**
 * This type represents a subgraph for an attribute node that
 * corresponds to a Managed Type. Using this class, an entity subgraph
 * can be embedded within an EntityGraph.
 *
 * @param <T> The type of the attribute.
 *
 * @see EntityGraph
 * @see AttributeNode
 * @see NamedSubgraph
 *
 * @since 2.1
 */
public interface Subgraph<T> {

    /**
     * Add one or more attribute nodes to the entity graph.
     *
     * @param attributeName  name of the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this managed type.
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public void addAttributeNodes(String ... attributeName);

    /**
     * Add one or more attribute nodes to the entity graph.
     * @param attribute  attribute
     *
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public void addAttributeNodes(Attribute<T, ?>... attribute);

    /**
     * Add a node to the graph that corresponds to a managed
     * type. This allows for construction of multi-node entity graphs
     * that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(Attribute<T, X> attribute);

    /**
     * Add a node to the graph that corresponds to a managed
     * type with inheritance.  This allows for multiple subclass
     * subgraphs to be defined for this node of the entity
     * graph. Subclass subgraphs will automatically include the specified
     * attributes of superclass subgraphs
     *
     * @param attribute  attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<? extends X> addSubgraph(Attribute<T, X> attribute, Class<? extends X> type);

    /**
     * Add a node to the graph that corresponds to a managed
     * type. This allows for construction of multi-node entity graphs
     * that include related managed types.
     *
     * @param attributeName  name of the attribute
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this managed type.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(String attributeName);

    /**
     * Add a node to the graph that corresponds to a managed
     * type with inheritance.  This allows for multiple subclass
     * subgraphs to be defined for this node of the entity
     * graph. Subclass subgraphs will automatically include the
     * specified attributes of superclass subgraphs
     *
     * @param attributeName  name of the attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute is not
     *         an attribute of this managed type.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(String attributeName, Class<X> type);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type. This allows for construction of
     * multinode entity graphs that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addKeySubgraph(Attribute<T, X> attribute);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type with inheritance. This allows for
     * construction of multi-node entity graphs that include related
     * managed types.  Subclass subgraphs will automatically include
     * the specified attributes of superclass subgraphs
     *
     * @param attribute  attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<? extends X> addKeySubgraph(Attribute<T, X> attribute, Class<? extends X> type);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attributeName  name of the attribute
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *          statically defined
     */
    public <X> Subgraph<X> addKeySubgraph(String attributeName);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type with inheritance. This allows for
     * construction of multi-node entity graphs that include related
     * managed types.  Subclass subgraphs will include the specified
     * attributes of superclass subgraphs
     *
     * @param attributeName  name of the attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addKeySubgraph(String attributeName, Class<X> type);

    /**
     * Return the attribute nodes corresponding to the attributes of
     * this managed type that are included in the subgraph.
     * @return list of attribute nodes included in the subgraph or
     * empty List if none have been defined
     */
    public List<AttributeNode<?>> getAttributeNodes();

    /**
     * Return the type for which this subgraph was defined.
     * @return managed type referenced by the subgraph
     */
    public Class<T> getClassType();
}
----

==== Use of Entity Graphs in find and query operations [[a2814]]

An entity graph can be used with the _find_
method or as a query hint to override or augment _FetchType_ semantics.

The standard properties
_jakarta.persistence.fetchgraph_ and _jakarta.persistence.loadgraph_ are
used to specify such graphs to queries and _find_ operations.

The default fetch graph for an entity or
embeddable is defined to consist of the transitive closure of all of its
attributes that are specified as _FetchType.EAGER_ (or defaulted as
such).

The persistence provider is permitted to
fetch additional entity state beyond that specified by a fetch graph or
load graph. It is required, however, that the persistence provider fetch
all state specified by the fetch or load graph.

===== Fetch Graph Semantics

When the _jakarta.persistence.fetchgraph_
property is used to specify an entity graph, attributes that are
specified by attribute nodes of the entity graph are treated as
_FetchType.EAGER_ and attributes that are not specified are treated as
_FetchType.LAZY_.

The following rules apply, depending on
attribute type. The rules of this section are applied recursively.

A primary key or version attribute never
needs to be specified in an attribute node of a fetch graph. (This
applies to composite primary keys as well, including embedded id primary
keys.) When an entity is fetched, its primary key and version attributes
are always fetched. It is not incorrect, however, to specify primary key
attributes or version attributes.

Attributes other than primary key and version
attributes are assumed not to be fetched unless the attribute is
specified. The following rules apply to the specification of attributes.

* If the attribute is an embedded attribute,
and the attribute is specified in an attribute node, but a subgraph is
not specified for the attribute, the default fetch graph for the
embeddable is fetched. If a subgraph is specified for the attribute, the
attributes of the embeddable are fetched according to their
specification in the corresponding subgraph.
* If the attribute is an element collection of
basic type, and the attribute is specified in an attribute node, the
element collection together with its basic elements is fetched.
* If the attribute is an element collection of
embeddables, and the attribute is specified in an attribute node, but a
subgraph is not specified for the attribute, the element collection
together with the default fetch graph of its embeddable elements is
fetched. If a subgraph is specified for the attribute, the attributes of
the embeddable elements are fetched according to the corresponding
subgraph specification.
* If the attribute is a one-to-one or
many-to-one relationship, and the attribute is specified in an attribute
node, but a subgraph is not specified for the attribute, the default
fetch graph of the target entity is fetched. If a subgraph is specified
for the attribute, the attributes of the target entity are fetched
according to the corresponding subgraph specification.
* If the attribute is a one-to-many or
many-to-many relationship, and the attribute is specified in an
attribute node, but a subgraph is not specified, the collection is
fetched and the default fetch graphs of the referenced entities are
fetched. If a subgraph is specified for the attribute, the entities in
the collection are fetched according to the corresponding subgraph
specification.
* If the key of a map which has been specified
in an attribute node is a basic type, it is fetched. If the key of a map
which has been specified in an attribute node is an embedded type, the
default fetch graph is fetched for the embeddable. Otherwise, if the key
of the map is an entity, and a map key subgraph is not specified for the
attribute node, the map key is fetched according to its default fetch
graph. If a key subgraph is specified for the map key attribute, the map
key attribute is fetched according to the map key subgraph
specification.


*Examples:*

[source,java]
----
@NamedEntityGraph
@Entity
public class Phonenumber {
    @Id
    protected String number;

    protected PhoneTypeEnum type;

    // ...
}
----

In the above example, only the _number_ attribute would be eagerly fetched.

[source,java]
----
@NamedEntityGraph(
    attributeNodes={@NamedAttributeNode("projects")}
)
@Entity
public class Employee {
    @Id
    @GeneratedValue
    protected long id;

    @Basic
    protected String name;

    @Basic
    protected String employeeNumber;

    @OneToMany()
    protected List<Dependents> dependents;

    @OneToMany()
    protected List<Project> projects;

    @OneToMany()
    protected List<PhoneNumber> phoneNumbers;

    // ...
}

@Entity
@Inheritance
public class Project {
    @Id
    @GeneratedValue
    protected long id;

    String name;

    @OneToOne(fetch=FetchType.EAGER)
    protected Requirements doc;

    // ...
}

@Entity
public class LargeProject extends Project {
    @OneToOne(fetch=FetchType.LAZY)
    protected Employee approver;

    // ...
}

@Entity
public class Requirements {
    @Id
    protected long id;

    @Lob
    protected String description;

    @OneToOne(fetch=FetchType.LAZY)
    protected Approval approval

    // ...
}
----

In the above example, the _Employee_ entity's
primary key will be fetched as well as the related _Project_ instances,
whose default fetch graph (_id_, _name_, and _doc_ attributes) will
be fetched. The related _Requirements_ object will be fetched according
to its default fetch graph.

If the _approver_ attribute of _LargeProject_
were _FetchType.EAGER_, and if any of the projects were instances of
_LargeProject_, their _approver_ attributes would also be fetched.
Since the type of the _approver_ attribute is _Employee_, the
approver's default fetch graph (_id_, _name_, and _employeeNumber_
attributes) would also be fetched.

===== Load Graph Semantics

When the _jakarta.persistence.loadgraph_
property is used to specify an entity graph, attributes that are
specified by attribute nodes of the entity graph are treated as
_FetchType.EAGER_ and attributes that are not specified are treated
according to their specified or default FetchType.

The following rules apply. The rules of this
section are applied recursively.

* A primary key or version attribute never
needs to be specified in an attribute node of a load graph. (This
applies to composite primary keys as well, including embedded id primary
keys.) When an entity is fetched, its primary key and version attributes
are always fetched. It is not incorrect, however, to specify primary key
attributes or version attributes.
* If the attribute is an embedded attribute,
and the attribute is specified in an attribute node, but a subgraph is
not specified for the attribute, the default fetch graph for the
embeddable is fetched. If a subgraph is specified for the attribute,
attributes that are specified by the subgraph are also fetched.
* If the attribute is an element collection of
basic type, and the attribute is specified in an attribute node, the
element collection together with its basic elements is fetched.
* If the attribute is an element collection of
embeddables, and the attribute is specified in an attribute node, the
element collection together with the default fetch graph of its
embeddable elements is fetched. If a subgraph is specified for the
attribute, attributes that are specified by the subgraph are also
fetched.
* If the attribute is a one-to-one or
many-to-one relationship, and the attribute is specified in an attribute
node, the default fetch graph of the target entity is fetched. If a
subgraph is specified for the attribute, attributes that are specified
by the subgraph are also fetched.
* If the attribute is a one-to-many or
many-to-many relationship, and the attribute is specified in an
attribute node, the collection is fetched and the default fetch graphs
of the referenced entities are fetched. If a subgraph is specified for
the attribute, attributes that are specified by the subgraph are also
fetched.
* If the key of a map which has been specified
in an attribute node is a basic type, it is fetched. If the key of a map
which has been specified in an attribute node is an embedded type, the
default fetch graph is fetched for the embeddable. Otherwise, if the key
of the map is an entity, the map key is fetched according to its default
fetch graph. If a key subgraph is specified for the map key attribute,
additional attributes are fetched as specified in the key subgraph.

*Examples:*

[source,java]
----
@NamedEntityGraph
@Entity
public class Phonenumber {
    @Id
    protected String number;

    protected PhoneTypeEnum type;

    // ...
}
----

In the above example, the _number_ and _type_ attributes are fetched.

[source,java]
----
@NamedEntityGraph(
    attributeNodes={@NamedAttributeNode("projects")}
)
@Entity
public class Employee {
    @Id
    @GeneratedValue
    protected long id;

    @Basic
    protected String name;

    @Basic
    protected String employeeNumber;

    @OneToMany()
    protected List<Dependents> dependents;

    @OneToMany()
    protected List<Project> projects;

    @OneToMany()
    protected List<PhoneNumber> phoneNumbers;

    // ...
}

@Entity
@Inheritance
public class Project {
    @Id
    @GeneratedValue
    protected long id;

    String name;

    @OneToOne(fetch=FetchType.EAGER)
    protected Requirements doc;

    // ...
}

@Entity
public class LargeProject extends Project {
    @OneToOne(fetch=FetchType.LAZY)
    protected Employee approver;

    // ...
}

@Entity
public class Requirements {
    @Id
    protected long id;

    @Lob
    protected String description;

    @OneToOne(fetch=FetchType.LAZY)
    protected Approval approval

    // ...
}
----

In the above example, the default fetch graph
(_id_, _name_, _employeeNumber_ attributes) of _Employee_ is fetched.
The default fetch graphs of the related _Project_ instances (_id_,
_name_, and _doc_ attributes) and their _Requirements_ instances (_id_
and _description_ attributes) are also fetched.

=== Type Conversion of Basic Attributes [[a2999]]

The attribute conversion facility
allows the developer to specify methods to convert between the entity
attribute representation and the database representation for attributes
of basic types. Converters can be used to convert basic attributes
defined by entity classes, mapped superclasses, or embeddable
classes.footnote:[We plan to provide a
facility for more complex attribute conversions in a future release of
this specification.]

An attribute converter must implement the
_jakarta.persistence.AttributeConverter_ interface. A converter
implementation class must be annotated with the _Converter_ annotation
or defined in the XML descriptor as a converter. If the value of the
_autoApply_ element of the _Converter_ annotation is _true_, the
converter will be applied to all attributes of the target type,
including to basic attribute values that are contained within other,
more complex attribute types. See <<a13903>>.

[source,java]
----
package jakarta.persistence;

/**
 * A class that implements this interface can be used to convert
 * entity attribute state into database column representation
 * and back again.
 * Note that the X and Y types may be the same Java type.
 *
 * @param <X>  the type of the entity attribute
 * @param <Y>  the type of the database column
 */
public interface AttributeConverter<X,Y> {

    /**
     * Converts the value stored in the entity attribute into the
     * data representation to be stored in the database.
     *
     * @param attribute  the entity attribute value to be converted
     * @return  the converted data to be stored in the database
     *          column
     */
    public Y convertToDatabaseColumn (X attribute);

    /**
     * Converts the data stored in the database column into the
     * value to be stored in the entity attribute.
     * Note that it is the responsibility of the converter writer to
     * specify the correct <code>dbData</code> type for the corresponding
     * column for use by the JDBC driver: i.e., persistence providers are
     * not expected to do such type conversion.
     *
     * @param dbData  the data from the database column to be
     *                converted
     * @return  the converted value to be stored in the entity
     *          attribute
     */
    public X convertToEntityAttribute (Y dbData);
}
----

Attribute converter classes in Jakarta EE
environments support dependency injection through the Contexts and
Dependency Injection API (CDI) <<a19500>> when CDI is
enabledfootnote:[CDI is enabled by
default in Jakarta EE. See the Jakarta EE specification
<<a19499>>.]. An attribute converter class that makes
use of CDI injection may also define lifecycle callback methods
annotated with the _PostConstruct_ and _PreDestroy_ annotations. These
methods will be invoked after injection has taken place and before the
attribute converter instance is destroyed respectively.

The persistence provider is responsible for
using the CDI SPI to create instances of the attribute converter class;
to perform injection upon such instances; to invoke their
_PostConstruct_ and _PreDestroy_ methods, if any; and to dispose of the
attribute converter instances.

The persistence provider is only required to
support CDI injection into attribute converters in Jakarta EE container
environmentsfootnote:[The persistence
provider may support CDI injection into attribute converters in other
environments in which the BeanManager is available.]. If CDI is not enabled, the
persistence provider must not invoke attribute converters that depend
upon CDI injection.

An attribute converter is a noncontextual
object. In supporting injection into attribute converters, the
persistence provider must behave as if it carries out the following
steps involving the use of the CDI SPI. (See
<<a19500>>).

* Obtain a _BeanManager_ instance. (See <<a12802>>.)
* Create an _AnnotatedType_ instance for the attribute converter class.
* Create an _InjectionTarget_ instance for the annotated type.
* Create a _CreationalContext_.
* Instantiate the listener by calling the _InjectionTarget_ _produce_ method.
* Inject the listener instance by calling the _InjectionTarget_ _inject_ method on the instance.
* Invoke the _PostConstruct_ callback, if any,
by calling the _InjectionTarget_ _postConstruct_ method on the instance.

When the listener instance is to be
destroyed, the persistence provider must behave as if it carries out the
following steps.

* Call the _InjectionTarget_ _preDestroy_ method on the instance.
* Call the _InjectionTarget_ _dispose_ method on the instance.
* Call the _CreationalContext_ _release_ method.

Persistence providers may optimize the steps
above, e.g. by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

Attribute converters that do not make use of
CDI injection are stateless. The lifecycle of such attribute converters
is unspecified.

The conversion of all basic types is
supported except for the following: Id attributes (including the
attributes of embedded ids and derived identities), version attributes,
relationship attributes, and attributes explicitly annotated as
_Enumerated_ or _Temporal_ or designated as such in the XML descriptor.
Auto-apply converters will not be applied to such attributes, and
applications that apply converters to such attributes through use of the
_Convert_ annotation will not be portable.

Type conversion may be specified at the level
of individual attributes by means of the _Convert_ annotation. The
_Convert_ annotation may also be used to override or disable an
auto-apply conversion. See <<a14398>>.

The _Convert_ annotation may be applied
directly to an attribute of an entity, mapped superclass, or embeddable
class to specify conversion of the attribute or to override the use of a
converter that has been specified as _autoApply=true_. When persistent
properties are used, the _Convert_ annotation is applied to the getter
method.

The _Convert_ annotation may be applied to an
entity that extends a mapped superclass to specify or override the
conversion mapping for an inherited basic or embedded attribute.

The persistence provider runtime is
responsible for invoking the specified conversion methods for the target
attribute type when loading the entity attribute from the database and
before storing the entity attribute state to the database. The
persistence provider must apply any conversion methods to instances of
attribute values in path expressions used within Jakarta Persistence query
language queries or criteria queries (such as in comparisons, bulk
updates, etc.) before sending them to the database for the query
execution. When such converted attributes are used in comparison
operations with literals or parameters, the value of the literal or
parameter to which they are compared must also be converted. If the
result of a Jakarta Persistence query language query or criteria query
includes one or more entity attributes for which conversion mappings
have been specified, the persistence provider must apply the specified
conversions to the corresponding values in the query result before
returning them to the application. The use of functions, including
aggregates, on converted attributes is undefined. If an exception is
thrown from a conversion method, the persistence provider must wrap the
exception in a PersistenceException and, if the persistence context is
joined to a transaction, mark the transaction for rollback.

=== Caching [[a3061]]

This specification supports the use of a
second-level cache by the persistence provider. The second-level cache,
if used, underlies the persistence context, and is largely transparent
to the application.

A second-level cache is typically used to
enhance performance. Use of a cache, however, may have consequences in
terms of the up-to-dateness of the data seen by the application,
resulting in stale reads. A stale read is defined as the reading of
entities or entity state that is older than the point at which the
persistence context was started.

This specification defines the following
portable configuration options that can be used by the application
developer to control caching behavior. Persistence providers may support
additional provider-specific options, but must observe all
specification-defined options.

==== The shared-cache-mode Element [[a3065]]

Whether the entities and entity-related state
of a persistence unit will be cached is determined by the value of the
_shared-cache-mode_ element of the _persistence.xml_ file.

The _shared-cache-mode_ element has five
possible values: _ALL_, _NONE_, _ENABLE_SELECTIVE_,
_DISABLE_SELECTIVE_, _UNSPECIFIED_.

A value of _ALL_ causes all entities and
entity-related state and data to be cached.

A value of _NONE_ causes caching to be
disabled for the persistence unit. Persistence providers must not cache
if _NONE_ is specified.

The values _ENABLE_SELECTIVE_ and
_DISABLE_SELECTIVE_ are used in conjunction with the _Cacheable_
annotation (or XML element). The _Cacheable_ annotation specifies
whether an entity should be cached if such selective caching is enabled
by the _persistence.xml_ _shared-cache-mode_ element. The _Cacheable_
element is specified on the entity class. It applies to the given entity
and its subclasses unless subsequently overridden by a subclass.

* _Cacheable(false)_ means that the entity and
its state must not be cached by the provider.
* A value of _ENABLE_SELECTIVE_ enables the
cache and causes entities for which _Cacheable(true)_ (or its XML
equivalent) is specified to be cached. Entities for which
_Cacheable(true)_ is not specified or for which _Cacheable(false)_ is
specified must not be cached.
* A value of _DISABLE_SELECTIVE_ enables the
cache and causes all entities to be cached except those for which
_Cacheable(false)_ is specified. Entities for which _Cacheable(false)_
is specified must not be cached.

If either the _shared-cache-mode_ element is
not specified in the _persistence.xml_ file or the value of the
_shared-cache-mode_ element is _UNSPECIFIED_, and the
_jakarta.persistence.sharedCache.mode_ property is not specified, the
behavior is not defined, and provider-specific defaults may apply. If
the _shared-cache-mode_ element and the
_jakarta.persistence.sharedCache.mode_ property are not specified, the
semantics of the _Cacheable_ annotation (and XML equivalent) are
undefined.

The persistence provider is not required to
support use of a second-level cache. If the persistence provider does
not support use of a second-level cache or a second-level cache is not
installed, this element will be ignored and no caching will occur.

Further control over the second-level cache
is described in <<a12124>>.

==== Cache Retrieve Mode and Cache Store Mode Properties

Cache retrieve mode and cache store mode
properties may be specified at the level of the persistence context by
means of the EntityManager _setProperty_ method. These properties may be
specified for the _EntityManager_ _find_ and _refresh_ methods and the
_Query_, _TypedQuery_, _and_ _StoredProcedureQuery_ _setHint_ methods.
Cache retrieve mode and/or cache store mode properties specified for the
_find_, _refresh_, and _Query_, _TypedQuery_, and
_StoredProcedureQuery setHint_ methods override those specified for the
persistence context for the specified _find_ and _refresh_ invocations,
and for the execution of the specified queries respectively.

If caching is disabled by the _NONE_ value of
the _shared-cache-mode_ element, cache retrieve mode and cache store
mode properties must be ignored. Otherwise, if the _ENABLE_SELECTIVE_
value is specified, but _Cacheable(true)_ is not specified for a
particular entity, they are ignored for that entity; if the
_DISABLE_SELECTIVE_ value is specified, they are ignored for any
entities for which _Cacheable(false)_ is specified.

Cache retrieve mode and cache store mode
properties must be observed when caching is enabled, regardless of
whether caching is enabled due to the specification of the
_shared-cache-mode_ element or enabled due to provider-specific options.
Applications that make use of cache retrieve mode or cache store mode
properties but which do not specify the _shared-cache-mode_ element will
not be portable.

The cache retrieve mode and cache store mode
properties are _jakarta.persistence.cache.retrieveMode_ and
_jakarta.persistence.cache.storeMode_ respectively. These properties have
the semantics defined below.

The _retrieveMode_ property specifies the
behavior when data is retrieved by the _find_ methods and by the
execution of queries. The _retrieveMode_ property is ignored for the
_refresh_ method, which always causes data to be retrieved from the
database, not the cache.

[source,java]
----
package jakarta.persistence;

/**
 * Used as the value of the
 * <code>jakarta.persistence.cache.retrieveMode</code> property to
 * specify the behavior when data is retrieved by the
 * <code>find</code> methods and by queries.
 *
 * @since 2.0
 */
public enum CacheRetrieveMode {

    /**
     * Read entity data from the cache: this is
     * the default behavior.
     */
    USE,

    /**
     * Bypass the cache: get data directly from
     * the database.
     */
    BYPASS
}
----

The _storeMode_ property specifies the
behavior when data is read from the database and when data is committed
into the database.

[source,java]
----
package jakarta.persistence;

/**
 * Used as the value of the
 * <code>jakarta.persistence.cache.storeMode</code> property to specify
 * the behavior when data is read from the database and when data is
 * committed into the database.
 *
 * @since 2.0
 */
public enum CacheStoreMode {

    /**
     * Insert entity data into cache when read from database
     * and insert/update entity data when committed into database:
     * this is the default behavior. Does not force refresh
     * of already cached items when reading from database.
     */
    USE,

    /**
     * Don't insert into cache.
     */
    BYPASS,

    /**
     * Insert/update entity data into cache when read
     * from database and when committed into database.
     * Forces refresh of cache for items read from database.
     */
    REFRESH
}
----

=== Query APIs [[a3125]]

The _Query_ and _TypedQuery_ APIs are used
for the execution of both static queries and dynamic queries. These APIs
also support parameter binding and pagination control. The
_StoredProcedureQuery_ API is used for the execution of queries that
invoke stored procedures defined in the database.

==== Query Interface [[a3127]]

[source,java]
----
package jakarta.persistence;

import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.stream.Stream;

/**
 * Interface used to control query execution.
 *
 * @see TypedQuery
 * @see StoredProcedureQuery
 * @see Parameter
 *
 * @since 1.0
 */
public interface Query {

    /**
     * Execute a SELECT query and return the query results
     * as an untyped List.
     * @return a list of the results
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    List getResultList();

    /**
     * Execute a SELECT query and return the query results
     * as an untyped <code>java.util.stream.Stream</code>.
     * By default this method delegates to <code>getResultList().stream()</code>,
     * however persistence provider may choose to override this method
     * to provide additional capabilities.
     *
     * @return a stream of the results
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     * @see Stream
     * @see #getResultList()
     * @since 2.2
     */
    default Stream getResultStream() {
        return getResultList().stream();
    }

    /**
     * Execute a SELECT query that returns a single untyped result.
     * @return the result
     * @throws NoResultException if there is no result
     * @throws NonUniqueResultException if more than one result
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    Object getSingleResult();

    /**
     * Execute an update or delete statement.
     * @return the number of entities updated or deleted
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language SELECT statement or for
     *         a criteria query
     * @throws TransactionRequiredException if there is
     *         no transaction or the persistence context has not
     *         been joined to the transaction
     * @throws QueryTimeoutException if the statement execution
     *         exceeds the query timeout value set and only
     *         the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    int executeUpdate();

    /**
     * Set the maximum number of results to retrieve.
     * @param maxResult  maximum number of results to retrieve
     * @return the same query instance
     * @throws IllegalArgumentException if the argument is negative
     */
    Query setMaxResults(int maxResult);

    /**
     * The maximum number of results the query object was set to
     * retrieve. Returns <code>Integer.MAX_VALUE</code> if <code>setMaxResults</code> was not
     * applied to the query object.
     * @return maximum number of results
     * @since 2.0
     */
    int getMaxResults();

    /**
     * Set the position of the first result to retrieve.
     * @param startPosition position of the first result,
     * numbered from 0
     * @return the same query instance
     * @throws IllegalArgumentException if the argument is negative
     */
    Query setFirstResult(int startPosition);

    /**
     * The position of the first result the query object was set to
     * retrieve. Returns 0 if <code>setFirstResult</code> was not applied to the
     * query object.
     * @return position of the first result
     * @since 2.0
     */
    int getFirstResult();

    /**
     * Set a query property or hint. The hints elements may be used
     * to specify query properties and hints. Properties defined by
     * this specification must be observed by the provider.
     * Vendor-specific hints that are not recognized by a provider
     * must be silently ignored. Portable applications should not
     * rely on the standard timeout hint. Depending on the database
     * in use and the locking mechanisms used by the provider,
     * this hint may or may not be observed.
     * @param hintName  name of the property or hint
     * @param value  value for the property or hint
     * @return the same query instance
     * @throws IllegalArgumentException if the second argument is not
     *         valid for the implementation
     */
    Query setHint(String hintName, Object value);

    /**
     * Get the properties and hints and associated values that are
     * in effect for the query instance.
     * @return query properties and hints
     * @since 2.0
     */
    Map<String, Object> getHints();

    /**
     * Bind the value of a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter
     *         does not correspond to a parameter of the
     *         query
     * @since 2.0
     */
    <T> Query setParameter(Parameter<T> param, T value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a <code>Parameter</code> object.
     * @param param parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     * @since 2.0
     */
    Query setParameter(Parameter<Calendar> param, Calendar value,
                       TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a <code>Parameter</code> object.
     * @param param parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     * @since 2.0
     */
    Query setParameter(Parameter<Date> param, Date value,
                       TemporalType temporalType);

    /**
     * Bind an argument value to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the argument is of incorrect type
     */
    Query setParameter(String name, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the value argument is of incorrect type
     */
    Query setParameter(String name, Calendar value,
                       TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the value argument is of incorrect type
     */
    Query setParameter(String name, Date value,
                       TemporalType temporalType);

    /**
     * Bind an argument value to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the
     *         query or if the argument is of incorrect type
     */
    Query setParameter(int position, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a positional
     * parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query or
     *         if the value argument is of incorrect type
     */
    Query setParameter(int position, Calendar value,
                       TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query or
     *         if the value argument is of incorrect type
     */
    Query setParameter(int position, Date value,
                       TemporalType temporalType);

    /**
     * Get the parameter objects corresponding to the declared
     * parameters of the query.
     * Returns empty set if the query has no parameters.
     * This method is not required to be supported for native
     * queries.
     * @return set of the parameter objects
     * @throws IllegalStateException if invoked on a native
     *         query when the implementation does not support
     *         this use
     * @since 2.0
     */
    Set<Parameter<?>> getParameters();

    /**
     * Get the parameter object corresponding to the declared
     * parameter of the given name.
     * This method is not required to be supported for native
     * queries.
     * @param name  parameter name
     * @return parameter object
     * @throws IllegalArgumentException if the parameter of the
     *         specified name does not exist
     * @throws IllegalStateException if invoked on a native
     *         query when the implementation does not support
     *         this use
     * @since 2.0
     */
    Parameter<?> getParameter(String name);

    /**
     * Get the parameter object corresponding to the declared
     * parameter of the given name and type.
     * This method is required to be supported for criteria queries
     * only.
     * @param name  parameter name
     * @param type  type
     * @return parameter object
     * @throws IllegalArgumentException if the parameter of the
     *         specified name does not exist or is not assignable
     *         to the type
     * @throws IllegalStateException if invoked on a native
     *         query or Jakarta Persistence query language query when
     *         the implementation does not support this use
     * @since 2.0
     */
    <T> Parameter<T> getParameter(String name, Class<T> type);

    /**
     * Get the parameter object corresponding to the declared
     * positional parameter with the given position.
     * This method is not required to be supported for native
     * queries.
     * @param position  position
     * @return parameter object
     * @throws IllegalArgumentException if the parameter with the
     *         specified position does not exist
     * @throws IllegalStateException if invoked on a native
     *         query when the implementation does not support
     *         this use
     * @since 2.0
     */
    Parameter<?> getParameter(int position);

    /**
     * Get the parameter object corresponding to the declared
     * positional parameter with the given position and type.
     * This method is not required to be supported by the provider.
     * @param position  position
     * @param type  type
     * @return parameter object
     * @throws IllegalArgumentException if the parameter with the
     *         specified position does not exist or is not assignable
     *         to the type
     * @throws IllegalStateException if invoked on a native
     *         query or Jakarta Persistence query language query when
     *         the implementation does not support this use
     * @since 2.0
     */
    <T> Parameter<T> getParameter(int position, Class<T> type);

    /**
     * Return a boolean indicating whether a value has been bound
     * to the parameter.
     * @param param parameter object
     * @return boolean indicating whether parameter has been bound
     * @since 2.0
     */
    boolean isBound(Parameter<?> param);

    /**
     * Return the input value bound to the parameter.
     * (Note that OUT parameters are unbound.)
     * @param param parameter object
     * @return parameter value
     * @throws IllegalArgumentException if the parameter is not
     *         a parameter of the query
     * @throws IllegalStateException if the parameter has not been
     *         been bound
     * @since 2.0
     */
    <T> T getParameterValue(Parameter<T> param);

    /**
     * Return the input value bound to the named parameter.
     * (Note that OUT parameters are unbound.)
     * @param name  parameter name
     * @return parameter value
     * @throws IllegalStateException if the parameter has not been
     *         been bound
     * @throws IllegalArgumentException if the parameter of the
     *         specified name does not exist
     * @since 2.0
     */
    Object getParameterValue(String name);

    /**
     * Return the input value bound to the positional parameter.
     * (Note that OUT parameters are unbound.)
     * @param position  position
     * @return parameter value
     * @throws IllegalStateException if the parameter has not been
     *         been bound
     * @throws IllegalArgumentException if the parameter with the
     *         specified position does not exist
     * @since 2.0
     */
    Object getParameterValue(int position);

    /**
     * Set the flush mode type to be used for the query execution.
     * The flush mode type applies to the query regardless of the
     * flush mode type in use for the entity manager.
     * @param flushMode  flush mode
     * @return the same query instance
     */
    Query setFlushMode(FlushModeType flushMode);

    /**
     * Get the flush mode in effect for the query execution.
     * If a flush mode has not been set for the query object,
     * returns the flush mode in effect for the entity manager.
     * @return flush mode
     * @since 2.0
     */
    FlushModeType getFlushMode();

    /**
     * Set the lock mode type to be used for the query execution.
     * @param lockMode  lock mode
     * @return the same query instance
     * @throws IllegalStateException if the query is found not to be
     *         a Jakarta Persistence query language SELECT query
     *         or a CriteriaQuery query
     * @since 2.0
     */
    Query setLockMode(LockModeType lockMode);

    /**
     * Get the current lock mode for the query.  Returns null if a lock
     * mode has not been set on the query object.
     * @return lock mode
     * @throws IllegalStateException if the query is found not to be
     *         a Jakarta Persistence query language SELECT query or
     *         a Criteria API query
     * @since 2.0
     */
    LockModeType getLockMode();

    /**
     * Return an object of the specified type to allow access to
     * the provider-specific API.  If the provider's query
     * implementation does not support the specified class, the
     * <code>PersistenceException</code> is thrown.
     * @param cls  the class of the object to be returned.  This is
     *             normally either the underlying query
     *             implementation class or an interface that it
     *             implements.
     * @return an instance of the specified class
     * @throws PersistenceException if the provider does not support
     *         the call
     * @since 2.0
     */
    <T> T unwrap(Class<T> cls);
}
----

==== TypedQuery Interface

[source,java]
----
package jakarta.persistence;

import java.util.List;
import java.util.Date;
import java.util.Calendar;
import java.util.stream.Stream;

/**
 * Interface used to control the execution of typed queries.
 * @param <X> query result type
 *
 * @see Query
 * @see Parameter
 *
 * @since 2.0
 */
public interface TypedQuery<X> extends Query {

    /**
     * Execute a SELECT query and return the query results
     * as a typed List.
     * @return a list of the results
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the
     *         transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    List<X> getResultList();

    /**
     * Execute a SELECT query and return the query results
     * as a typed <code>java.util.stream.Stream</code>.
     * By default this method delegates to <code>getResultList().stream()</code>,
     * however persistence provider may choose to override this method
     * to provide additional capabilities.
     *
     * @return a stream of the results
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     * @see Stream
     * @see #getResultList()
     * @since 2.2
     */
    default Stream<X> getResultStream() {
        return getResultList().stream();
    }

    /**
     * Execute a SELECT query that returns a single result.
     * @return the result
     * @throws NoResultException if there is no result
     * @throws NonUniqueResultException if more than one result
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the
     *         transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    X getSingleResult();

    /**
     * Set the maximum number of results to retrieve.
     * @param maxResult  maximum number of results to retrieve
     * @return the same query instance
     * @throws IllegalArgumentException if the argument is negative
     */
    TypedQuery<X> setMaxResults(int maxResult);

    /**
     * Set the position of the first result to retrieve.
     * @param startPosition position of the first result,
     *        numbered from 0
     * @return the same query instance
     * @throws IllegalArgumentException if the argument is negative
     */
    TypedQuery<X> setFirstResult(int startPosition);

    /**
     * Set a query property or hint. The hints elements may be used
     * to specify query properties and hints. Properties defined by
     * this specification must be observed by the provider.
     * Vendor-specific hints that are not recognized by a provider
     * must be silently ignored. Portable applications should not
     * rely on the standard timeout hint. Depending on the database
     * in use and the locking mechanisms used by the provider,
     * this hint may or may not be observed.
     * @param hintName  name of property or hint
     * @param value  value for the property or hint
     * @return the same query instance
     * @throws IllegalArgumentException if the second argument is not
     *         valid for the implementation
     */
    TypedQuery<X> setHint(String hintName, Object value);

    /**
     * Bind the value of a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter
     *         does not correspond to a parameter of the
     *         query
     */
     <T> TypedQuery<X> setParameter(Parameter<T> param, T value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     */
    TypedQuery<X> setParameter(Parameter<Calendar> param,
                               Calendar value,
                               TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     */
    TypedQuery<X> setParameter(Parameter<Date> param, Date value,
                               TemporalType temporalType);

    /**
     * Bind an argument value to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the argument is of incorrect type
     */
    TypedQuery<X> setParameter(String name, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the value argument is of incorrect type
     */
    TypedQuery<X> setParameter(String name, Calendar value,
                               TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a named parameter.
     * @param name   parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the value argument is of incorrect type
     */
    TypedQuery<X> setParameter(String name, Date value,
                               TemporalType temporalType);

    /**
     * Bind an argument value to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the
     *         query or if the argument is of incorrect type
     */
    TypedQuery<X> setParameter(int position, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a positional
     * parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query
     *         or if the value argument is of incorrect type
     */
    TypedQuery<X> setParameter(int position, Calendar value,
                               TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query
     *         or if the value argument is of incorrect type
     */
    TypedQuery<X> setParameter(int position, Date value,
                               TemporalType temporalType);

     /**
      * Set the flush mode type to be used for the query execution.
      * The flush mode type applies to the query regardless of the
      * flush mode type in use for the entity manager.
      * @param flushMode  flush mode
      * @return the same query instance
      */
     TypedQuery<X> setFlushMode(FlushModeType flushMode);

     /**
      * Set the lock mode type to be used for the query execution.
      * @param lockMode  lock mode
      * @return the same query instance
      * @throws IllegalStateException if the query is found not to
      *         be a Jakarta Persistence query language SELECT query
      *         or a CriteriaQuery query
      */
     TypedQuery<X> setLockMode(LockModeType lockMode);

}
----

==== Tuple Interface [[a3868]]

[source,java]
----
package jakarta.persistence;

import java.util.List;

/**
 * Interface for extracting the elements of a query result tuple.
 *
 * @see TupleElement
 *
 * @since 2.0
 */
public interface Tuple {

    /**
     * Get the value of the specified tuple element.
     * @param tupleElement  tuple element
     * @return value of tuple element
     * @throws IllegalArgumentException if tuple element
     *         does not correspond to an element in the
     *         query result tuple
     */
    <X> X get(TupleElement<X> tupleElement);

    /**
     * Get the value of the tuple element to which the
     * specified alias has been assigned.
     * @param alias  alias assigned to tuple element
     * @param type of the tuple element
     * @return value of the tuple element
     * @throws IllegalArgumentException if alias
     *         does not correspond to an element in the
     *         query result tuple or element cannot be
     *         assigned to the specified type
     */
    <X> X get(String alias, Class<X> type);

    /**
     * Get the value of the tuple element to which the
     * specified alias has been assigned.
     * @param alias  alias assigned to tuple element
     * @return value of the tuple element
     * @throws IllegalArgumentException if alias
     *         does not correspond to an element in the
     *         query result tuple
     */
    Object get(String alias);

    /**
     * Get the value of the element at the specified
     * position in the result tuple. The first position is 0.
     * @param i  position in result tuple
     * @param type  type of the tuple element
     * @return value of the tuple element
     * @throws IllegalArgumentException if i exceeds
     *         length of result tuple  or element cannot be
     *         assigned to the specified type
     */
    <X> X get(int i, Class<X> type);

    /**
     * Get the value of the element at the specified
     * position in the result tuple. The first position is 0.
     * @param i  position in result tuple
     * @return value of the tuple element
     * @throws IllegalArgumentException if i exceeds
     *         length of result tuple
     */
    Object get(int i);

    /**
     * Return the values of the result tuple elements as an array.
     * @return tuple element values
     */
    Object[] toArray();

    /**
     * Return the tuple elements.
     * @return tuple elements
     */
    List<TupleElement<?>> getElements();
}
----

==== TupleElement Interface [[a3949]]

[source,java]
----
package jakarta.persistence;

/**
 * The <code>TupleElement</code> interface defines an element that is returned in
 * a query result tuple.
 * @param <X> the type of the element
 *
 * @see Tuple
 *
 * @since 2.0
 */
public interface TupleElement<X> {

    /**
     * Return the Java type of the tuple element.
     * @return the Java type of the tuple element
     */
    Class<? extends X> getJavaType();

    /**
     * Return the alias assigned to the tuple element or null,
     * if no alias has been assigned.
     * @return alias
     */
    String getAlias();
}
----

==== Parameter Interface

[source,java]
----
package jakarta.persistence;

/**
 * Type for query parameter objects.
 * @param <T> the type of the parameter
 *
 * @see Query
 * @see TypedQuery
 *
 * @since 2.0
 */
public interface Parameter<T> {

    /**
     * Return the parameter name, or null if the parameter is
     * not a named parameter or no name has been assigned.
     * @return parameter name
     */
    String getName();

    /**
     * Return the parameter position, or null if the parameter
     * is not a positional parameter.
     * @return position of parameter
     */
    Integer getPosition();

    /**
     * Return the Java type of the parameter. Values bound to the
     * parameter must be assignable to this type.
     * This method is required to be supported for criteria queries
     * only.   Applications that use this method for Jakarta
     * Persistence query language queries and native queries will
     * not be portable.
     * @return the Java type of the parameter
     * @throws IllegalStateException if invoked on a parameter
     *         obtained from a query language
     *         query or native query when the implementation does
     *         not support this use
     */
     Class<T> getParameterType();
}
----

==== StoredProcedureQuery Interface

[source,java]
----
package jakarta.persistence;

import java.util.Calendar;
import java.util.Date;
import java.util.List;

/**
 * Interface used to control stored procedure query execution.
 *
 * <p>
 * Stored procedure query execution may be controlled in accordance with
 * the following:
 * <ul>
 * <li>The <code>setParameter</code> methods are used to set the values of
 * all required <code>IN</code> and <code>INOUT</code> parameters.
 * It is not required to set the values of stored procedure parameters
 * for which default values have been defined by the stored procedure.</li>
 * <li>
 * When <code>getResultList</code> and <code>getSingleResult</code> are
 * called on a <code>StoredProcedureQuery</code> object, the provider
 * will call <code>execute</code> on an unexecuted stored procedure
 * query before processing <code>getResultList</code> or
 * <code>getSingleResult</code>.</li>
 * <li>
 * When <code>executeUpdate</code> is called on a
 * <code>StoredProcedureQuery</code> object, the provider will call
 * <code>execute</code> on an unexecuted stored procedure query
 *  followed by <code>getUpdateCount</code>.  The results of
 * <code>executeUpdate</code> will be those of <code>getUpdateCount</code>.</li>
 * <li>
 * The <code>execute</code> method supports both the simple case where
 * scalar results are passed back only via <code>INOUT</code> and
 * <code>OUT</code> parameters as well as the most general case
 * (multiple result sets and/or update counts, possibly also in
 * combination with output parameter values).</li>
 * <li>
 * The <code>execute</code> method returns true if the first result is a
 * result set, and false if it is an update count or there are no results
 * other than through <code>INOUT</code> and <code>OUT</code> parameters,
 * if any.</li>
 * <li>
 * If the <code>execute</code> method returns true, the pending result set
 * can be obtained by calling <code>getResultList</code> or
 * <code>getSingleResult</code>.</li>
 * <li>
 * The <code>hasMoreResults</code> method can then be used to test
 * for further results.</li>
 * <li>
 * If <code>execute</code> or <code>hasMoreResults</code> returns false,
 * the <code>getUpdateCount</code> method can be called to obtain the
 * pending result if it is an update count.  The <code>getUpdateCount</code>
 * method will return either the update count (zero or greater) or -1
 * if there is no update count (i.e., either the next result is a result set
 * or there is no next update count).</li>
 * <li>
 * For portability, results that correspond to JDBC result sets and
 * update counts need to be processed before the values of any
 * <code>INOUT</code> or <code>OUT</code> parameters are extracted.</li>
 * <li>
 * After results returned through <code>getResultList</code> and
 * <code>getUpdateCount</code> have been exhausted, results returned through
 * <code>INOUT</code> and <code>OUT</code> parameters can be retrieved.</li>
 * <li>
 * The <code>getOutputParameterValue</code> methods are used to retrieve
 * the values passed back from the procedure through <code>INOUT</code>
 * and <code>OUT</code> parameters.</li>
 * <li>
 * When using <code>REF_CURSOR</code> parameters for result sets the
 * update counts should be exhausted before calling <code>getResultList</code>
 * to retrieve the result set.  Alternatively, the <code>REF_CURSOR</code>
 * result set can be retrieved through <code>getOutputParameterValue</code>.
 * Result set mappings will be applied to results corresponding to
 * <code>REF_CURSOR</code> parameters in the order the <code>REF_CURSOR</code>
 * parameters were registered with the query.</li>
 * <li>
 * In the simplest case, where results are returned only via
 * <code>INOUT</code> and <code>OUT</code> parameters, <code>execute</code>
 * can be followed immediately by calls to
 * <code>getOutputParameterValue</code>.</li>
 * </ul>
 *
 * @see Query
 * @see Parameter
 *
 * @since 2.1
 */
public interface StoredProcedureQuery extends Query {

    /**
     * Set a query property or hint. The hints elements may be used
     * to specify query properties and hints. Properties defined by
     * this specification must be observed by the provider.
     * Vendor-specific hints that are not recognized by a provider
     * must be silently ignored. Portable applications should not
     * rely on the standard timeout hint. Depending on the database
     * in use, this hint may or may not be observed.
     * @param hintName  name of the property or hint
     * @param value  value for the property or hint
     * @return the same query instance
     * @throws IllegalArgumentException if the second argument is not
     *         valid for the implementation
     */
    StoredProcedureQuery setHint(String hintName, Object value);

    /**
     * Bind the value of a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     */
    <T> StoredProcedureQuery setParameter(Parameter<T> param,
                                          T value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a <code>Parameter</code> object.
     * @param param parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     */
    StoredProcedureQuery setParameter(Parameter<Calendar> param,
                                      Calendar value,
                                      TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a <code>Parameter</code> object.
     * @param param parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     */
    StoredProcedureQuery setParameter(Parameter<Date> param,
                                      Date value,
                                      TemporalType temporalType);

    /**
     * Bind an argument value to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if the
     *         argument is of incorrect type
     */
    StoredProcedureQuery setParameter(String name, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if the
     *         value argument is of incorrect type
     */
    StoredProcedureQuery setParameter(String name,
                                      Calendar value,
                                      TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if the
     *         value argument is of incorrect type
     */
    StoredProcedureQuery setParameter(String name,
                                      Date value,
                                      TemporalType temporalType);

    /**
     * Bind an argument value to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query
     *         or if the argument is of incorrect type
     */
    StoredProcedureQuery setParameter(int position, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a positional
     * parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query or
     *         if the value argument is of incorrect type
     */
    StoredProcedureQuery setParameter(int position,
                                      Calendar value,
                                      TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query or
     *         if the value argument is of incorrect type
     */
    StoredProcedureQuery setParameter(int position,
                                      Date value,
                                      TemporalType temporalType);

    /**
     * Set the flush mode type to be used for the query execution.
     * The flush mode type applies to the query regardless of the
     * flush mode type in use for the entity manager.
     * @param flushMode  flush mode
     * @return the same query instance
     */
    StoredProcedureQuery setFlushMode(FlushModeType flushMode);

    /**
     * Register a positional parameter.
     * All parameters must be registered.
     * @param position  parameter position
     * @param type  type of the parameter
     * @param mode  parameter mode
     * @return the same query instance
     */
    StoredProcedureQuery registerStoredProcedureParameter(
	  int position,
	  Class type,
	  ParameterMode mode);

    /**
     * Register a named parameter.
     * @param parameterName  name of the parameter as registered or
     *             specified in metadata
     * @param type  type of the parameter
     * @param mode  parameter mode
     * @return the same query instance
     */
    StoredProcedureQuery registerStoredProcedureParameter(
	  String parameterName,
	  Class type,
	  ParameterMode mode);

    /**
     *  Retrieve a value passed back from the procedure
     *  through an INOUT or OUT parameter.
     *  For portability, all results corresponding to result sets
     *  and update counts must be retrieved before the values of
     *  output parameters.
     *  @param position  parameter position
     *  @return the result that is passed back through the parameter
     *  @throws IllegalArgumentException if the position does
     *          not correspond to a parameter of the query or is
     *          not an INOUT or OUT parameter
     */
    Object getOutputParameterValue(int position);

    /**
     *  Retrieve a value passed back from the procedure
     *  through an INOUT or OUT parameter.
     *  For portability, all results corresponding to result sets
     *  and update counts must be retrieved before the values of
     *  output parameters.
     *  @param parameterName  name of the parameter as registered or
     *              specified in metadata
     *  @return the result that is passed back through the parameter
     *  @throws IllegalArgumentException if the parameter name does
     *          not correspond to a parameter of the query or is
     *          not an INOUT or OUT parameter
     */
    Object getOutputParameterValue(String parameterName);

    /**
     * Return true if the first result corresponds to a result set,
     * and false if it is an update count or if there are no results
     * other than through INOUT and OUT parameters, if any.
     * @return  true if first result corresponds to result set
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    boolean execute();

    /**
     * Return the update count of -1 if there is no pending result or
     * if the first result is not an update count.  The provider will
     * call <code>execute</code> on the query if needed.
     * @return the update count or -1 if there is no pending result
     * or if the next result is not an update count.
     * @throws TransactionRequiredException if there is
     *         no transaction or the persistence context has not
     *         been joined to the transaction
     * @throws QueryTimeoutException if the statement execution
     *         exceeds the query timeout value set and only
     *         the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    int executeUpdate();

    /**
     * Retrieve the list of results from the next result set.
     * The provider will call <code>execute</code> on the query
     * if needed.
     * A <code>REF_CURSOR</code> result set, if any, will be retrieved
     * in the order the <code>REF_CURSOR</code> parameter was
     * registered with the query.
     * @return a list of the results or null is the next item is not
     * a result set
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    List getResultList();

    /**
     * Retrieve a single result from the next result set.
     * The provider will call <code>execute</code> on the query
     * if needed.
     * A <code>REF_CURSOR</code> result set, if any, will be retrieved
     * in the order the <code>REF_CURSOR</code> parameter was
     * registered with the query.
     * @return the result or null if the next item is not a result set
     * @throws NoResultException if there is no result in the next
     *         result set
     * @throws NonUniqueResultException if more than one result
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    Object getSingleResult();

    /**
     * Return true if the next result corresponds to a result set,
     * and false if it is an update count or if there are no results
     * other than through INOUT and OUT parameters, if any.
     * @return  true if next result corresponds to result set
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    boolean hasMoreResults();

    /**
     * Return the update count or  -1 if there is no pending result
     * or if the next result is not an update count.
     * @return  update count or -1 if there is no pending result or if
     *          the next result is not an update count
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    int getUpdateCount();

}
----

==== Query Execution

Jakarta Persistence query language, Criteria
API, and native SQL select queries are executed using the
_getResultList_ and _getSingleResult_ methods. Update and delete
operations (update and delete queries) are executed using the
_executeUpdate_ method.

* For _TypedQuery_ instances, the query result
type is determined in the case of criteria queries by the type of the
query specified when the _CriteriaQuery_ object is created, as described
in <<a10621>>. In the case of Jakarta Persistence query language queries, the type of the
result is determined by the _resultClass_ argument to the _createQuery_
or _createNamedQuery_ method, and the select list of the query must
contain only a single item which must be assignable to the specified
type.
* For _Query_ instances, the elements of a
query result whose select list consists of more than one select
expression are of type _Object[]_. If the select list consists of only
one select expression, the elements of the query result are of type
_Object_. When native SQL queries are used, the SQL result set mapping
(see <<a4427>>), determines
how many items (entities, scalar values, etc.) are returned. If multiple
items are returned, the elements of the query result are of type
_Object[]_. If only a single item is returned as a result of the SQL
result set mapping or if a result class is specified, the elements of
the query result are of type _Object_.

Stored procedure queries can be executed
using the _getResultList_, _getSingleResult_, and _execute_ methods.
Stored procedures that perform only updates or deletes can be executed
using the _executeUpdate_ method. Stored procedure query execution is
described in detail in <<a4625>>.

An _IllegalArgumentException_ is thrown if a
parameter instance is specified that does not correspond to a parameter
of the query, if a parameter name is specified that does not correspond
to a named parameter of the query, if a positional value is specified
that does not correspond to a positional parameter of the query, or if
the type of the parameter is not valid for the query. This exception may
be thrown when the parameter is bound, or the execution of the query may
fail. See <<a4397>>, <<a4401>>, and <<a4405>> for supported
parameter usage.

The effect of applying _setMaxResults_ or
_setFirstResult_ to a query involving fetch joins over collections is
undefined. The use of _setMaxResults_ and _setFirstResult_ is not
supported for stored procedure queries.

_Query_ and _TypedQuery_ methods other than
the _executeUpdate_ method are not required to be invoked within a
transaction context, unless a lock mode other than _LockModeType.NONE_
has been specified for the query. In particular, the _getResultList_ and
_getSingleResult_ methods are not required to be invoked within a
transaction context unless such a lock mode has been specified for the
queryfootnote:[A lock mode is
specified for a query by means of the _setLockMode_ method or by
specifying the lock mode in the _NamedQuery_ annotation.]. If an entity manager with
transaction-scoped persistence context is in use, the resulting entities
will be detached; if an entity manager with an extended persistence
context is used, they will be managed. See <<a11431>> for further
discussion of entity manager use outside a transaction and persistence context types.

Whether a _StoredProcedureQuery_ should be
invoked in a transaction context should be determined by the
transactional semantics and/or requirements of the stored procedure
implementation and the database in use. In particular, problems may
occur if the stored procedure initiates a transaction and a transaction
is already in effect. The state of any entities returned by the stored
procedure query invocation is determined as decribed above.

Runtime exceptions other than the
_NoResultException_, _NonUniqueResultException_,
_QueryTimeoutException_, and _LockTimeoutException_ thrown by the
methods of the _Query_, _TypedQuery_, and _StoredProcedureQuery_
interfaces other than those methods specified below cause the current
transaction to be marked for rollback if the persistence context is
joined to the transaction. On database platforms on which a query
timeout causes transaction rollback, the persistence provider must throw
the _PersistenceException_ instead of the _QueryTimeoutException_.

Runtime exceptions thrown by the following
methods of the _Query_, _TypedQuery_, and _StoredProcedureQuery_
interfaces do not cause the current transaction to be marked for
rollback: _getParameters_, _getParameter_, _getParameterValue_,
_getOutputParameterValue_, _getLockMode_.

Runtime exceptions thrown by the methods of
the _Tuple_, _TupleElement_, and _Parameter_ interfaces do not cause
the current transaction to be marked for rollback.

===== Example

[source,java]
----
public List findWithName(String name) {
    return em.createQuery("SELECT c FROM Customer c WHERE c.name LIKE :custName")
        .setParameter("custName", name)
        .setMaxResults(10)
        .getResultList();
}
----

==== Queries and Flush Mode [[a4374]]

The flush mode setting affects the result of
a query as follows.

When queries are executed within a
transaction, if _FlushModeType.AUTO_ is set on the _Query_,
_TypedQuery_, or _StoredProcedureQuery_ object, or if the flush mode
setting for the persistence context is _AUTO_ (the default) and a flush
mode setting has not been specified for the query object, the
persistence provider is responsible for ensuring that all updates to the
state of all entities in the persistence context which could potentially
affect the result of the query are visible to the processing of the
query. The persistence provider implementation may achieve this by
flushing those entities to the database or by some other means. If
_FlushModeType.COMMIT_ is set, the effect of updates made to entities in
the persistence context upon queries is unspecified.

If the persistence context has not been
joined to the current transaction, the persistence provider must not
flush to the database regardless of the flush mode setting.

[source,java]
----
package jakarta.persistence;

public enum FlushModeType {

    /**
     * Flushing to occur at transaction commit.  The provider may flush
     * at other times, but is not required to.
     */
    COMMIT,

    /**
     * (Default) Flushing to occur at query execution.
     */
    AUTO
}
----

If there is no transaction active, the
persistence provider must not flush to the database.

==== Queries and Lock Mode [[a4385]]

The _setLockMode_ method of the
_Query_ or _TypedQuery_ interface or the _lockMode_ element of the
_NamedQuery_ annotation may be used to lock the results of a query. A
lock is obtained for each entity specified in the query result
(including entities passed to constructors in the query SELECT
clause).footnote:[Note that the
setLockMode method may be called more than once (with different values)
on a Query or TypedQuery object.]

If the lock mode type is _PESSIMISTIC_READ_,
_PESSIMISTIC_WRITE_, or _PESSIMISTIC_FORCE_INCREMENT_, and the query
returns scalar data (e.g., the values of entity field or properties,
including scalar data passed to constructors in the query SELECT
clause), the underlying database rows will be
lockedfootnote:[Note that locking
will not occur for data passed to aggregate functions. Further, queries
involving aggregates with pessimistic locking may not be supported on
all database platforms.], but the version columns (if any) for any
entities corresponding to such scalar data will not be updated unless
the entities themselves are also otherwise retrieved and updated.

If the lock mode type is _OPTIMISTIC_ or
_OPTIMISTIC_FORCE_INCREMENT_, and the query returns scalar data, any
entities returned by the query will be locked, but no locking will occur
for scalar data that does not correspond to the state of any entity
instance in the query result.

If a lock mode other than _NONE_ is specified
for a query, the query must be executed within a transaction (and the
persistence context must be joined to the transaction) or the
_TransactionRequiredException_ will be thrown.

Locking is supported for Jakarta Persistence
query language queries and criteria queries only. If the _setLockMode_
or _getLockMode_ method is invoked on a query that is not a Jakarta
Persistence query language select query or a criteria query, the
_IllegalStateException_ may be thrown or the query execution will fail.

==== Query Hints [[a4391]]

The following hint is defined by this specification for use in query configuration.

 jakarta.persistence.query.timeout // time in milliseconds

This hint may be used with the _Query_,
_TypedQuery_, or _StoredProcedureQuery_ _setHint_ method or the
_NamedQuery_, _NamedNativeQuery_, and _NamedStoredProcedureQuery_
annotations. It may also be passed as a property to the
_Persistence.createEntityManagerFactory_ method and used in the
_properties_ element of the _persistence.xml_ file. See <<a3127>>,
<<a12384>>, <<a13443>>, <<a13710>>. When used in
the _createEntityManagerFactory_ method, the _persistence.xml_ file, and
annotations, the _timeout_ hint serves as a default value which can be
selectively overridden by use in the _setHint_ method.

Portable applications should not rely on this
hint. Depending on the persistence provider and database in use, the
hint may or may not be observed.

Vendors are permitted to support the use of
additional, vendor-specific hints. Vendor-specific hints must not use
the _jakarta.persistence_ namespace. Vendor-specific hints must be ignored
if they are not understood.

==== Parameter Objects [[a4397]]

_Parameter_ objects can be used for criteria
queries and for Jakarta Persistence query language queries.

Implementations may support the use of
_Parameter_ objects for native queries, however support for _Parameter_
objects with native queries is not required by this specification. The
use of _Parameter_ objects for native queries will not be portable. The
mixing of parameter objects with named or positional parameters is
undefined.

Portable applications should not attempt to
reuse a _Parameter_ object obtained from a _Query_ or _TypedQuery_
instance in the context of a different _Query_ or _TypedQuery_ instance.

==== Named Parameters [[a4401]]

Named parameters can be used for Jakarta
Persistence query language queries, for criteria queries (although use
of _Parameter_ objects is to be preferred), and for stored procedure
queries that support named parameters.

Named parameters follow the rules for
identifiers defined in <<a4760>>.
Named parameters are case-sensitive. The mixing of named and positional
parameters is undefined.

A named parameter of a Jakarta Persistence query
language query is an identifier that is prefixed by the " _:_ " symbol.
The parameter names passed to the _setParameter_ methods of the _Query_
and _TypedQuery_ interfaces do not include this " _:_ " prefix.

==== Positional Parameters [[a4405]]

Only positional parameter binding and
positional access to result items may be portably used for native
queries, except for stored procedure queries for which named parameters
have been defined. When binding the values of positional parameters, the
numbering starts as  _1_ . It is assumed that for native queries the
parameters themselves use the SQL syntax (i.e.,  _?_ , rather than 
_?1_ ).

The use of positional parameters is not supported for criteria queries.

==== Named Queries

Named queries are static queries expressed in
metadata or queries registered by means of the EntityManagerFactory
_addNamedQuery_ method. Named queries can be defined in the Jakarta
Persistence query language or in SQL. Query names are scoped to the
persistence unit.

The following is an example of the definition
of a named query defined in metadata:

[source,java]
----
@NamedQuery(
    name="findAllCustomersWithName",
    query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
)
----

The following is an example of the use of a named query:

[source,java]
----
@PersistenceContext
public EntityManager em;
    // ...

    customers = em.createNamedQuery("findAllCustomersWithName")
        .setParameter("custName", "Smith")
        .getResultList();
----

==== Polymorphic Queries

By default, all queries are polymorphic. That
is, the FROM clause of a query designates not only instances of the
specific entity class(es) to which it explicitly refers, but subclasses
as well. The instances returned by a query include instances of the
subclasses that satisfy the query conditions.

For example, the following query returns the
average salary of all employees, including subtypes of _Employee_, such
as _Manager_ and _Exempt_.

[source,sql]
----
select avg(e.salary) from Employee e where e.salary > 80000
----

Entity type expressions, described in <<a5381>>, as well as the
use of downcasting, described in <<a4965>>, can be used to restrict query polymorphism.

==== SQL Queries [[a4427]]

Queries may be expressed in native SQL. The
result of a native SQL query may consist of entities, unmanaged
instances created via constructors, scalar values, or some combination
of these.

[NOTE]
====
The SQL query facility is intended to provide
support for those cases where it is necessary to use the native SQL of
the target database in use (and/or where the Jakarta Persistence query
language cannot be used). Native SQL queries are not expected to be
portable across databases.
====

===== Returning Managed Entities from Native Queries

The persistence provider is responsible for
performing the mapping between the values returned by the SQL query and
entity attributes in accordance with the object/relational mapping
metadata for the entity or entities. In particular, the names of the
columns in the SQL result are used to map to the entity attributes as
defined by this metadata. This mapping includes the mapping of the
attributes of any embeddable classes that are part of the
non-collection-valued entity state and attributes corresponding to
foreign keys contained as part of the entity
statefootnote:[Support for joins is
currently limited to single-valued relationships that are mapped
directlyi.e., not via join tables.].

When an entity is to be returned from a
native query, the SQL statement should select all of the columns that
are mapped to the entity object. This should include foreign key columns
to related entities. The results obtained when insufficient data is
available are undefined.

In the simplest casei.e., when the results
of the query are limited to entities of a single entity class and the
mapping information can be derived from the columns of the SQL result
and the object/relational mapping metadatait is sufficient to specify
only the expected class of the entity result.

The following example illustrates the case
where a native SQL query is created dynamically using the
_createNativeQuery_ method and the entity class that specifies the type
of the result is passed in as an argument.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item " +
        "FROM Order o, Item i " +
        "WHERE (o.item = i.id) AND (i.name = 'widget')",
    com.acme.Order.class);
----

When executed, this query will return a
collection of all _Order_ entities for items named widget.

The _SqlResultSetMapping_ metadata
annotationwhich is designed to handle more complex casescan be used as
an alternative here. See <<a13797>> for the definition of the
_SqlResultSetMapping_ metadata annotation and related annotations.

For the query shown above, the
_SqlResultSetMapping_ metadata for the query result type might be
specified as follows:

[source,java]
----
@SqlResultSetMapping(
    name="WidgetOrderResults",
    entities=@EntityResult(entityClass=com.acme.Order.class))
----

The same results as produced by the query
above can then obtained by the following:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item " +
        "FROM Order o, Item i " +
        "WHERE (o.item = i.id) AND (i.name = 'widget')",
    "WidgetOrderResults");
----

When multiple entities are returned by a SQL
query or when the column names of the SQL result do not correspond to
those of the object/relational mapping metadata, a _SqlResultSetMapping_
metadata definition must be provided to specify the entity mapping.

The following query and _SqlResultSetMapping_
metadata illustrates the return of multiple entity types. It assumes
default metadata and column name defaults.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item, i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (o.quantity > 25) AND (o.item = i.id)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

When the column names of the SQL result do
not correspond to those of the object/relational mapping metadata, more
explicit SQL result mapping metadata must be provided to enable the
persistence provider runtime to map the JDBC results into the expected
objects. This might arise, for example, when column aliases must be used
in the SQL SELECT clause when the SQL result would otherwise contain
multiple columns of the same name or when columns in the SQL result are
the results of operators or functions. The _FieldResult_ annotation
element within the _EntityResult_ annotation is used to specify the
mapping of such columns to entity attributes.

The following example combining multiple
entity types includes aliases in the SQL statement. This requires that
the column names be explicitly mapped to the entity fields corresponding
to those columns. The _FieldResult_ annotation is used for this purpose.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item AS order_item, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item = i.id)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item", column="order_item")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

When the returned entity type contains an
embeddable class, the _FieldResult_ element must use a dot ( _._ )
notation to indicate which column maps to which field or property of the
contained embeddable.

*Example:*

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT c.id AS customer_id, " +
        "c.street AS customer_street, " +
        "c.city AS customer_city, " +
        "c.state AS customer_state, " +
        "c.status AS customer_status " +
        "FROM Customer c " +
        "WHERE c.status = 'GOLD' ",
    "CustomerResults");

@SqlResultSetMapping(name=CustomerResults, entities={
    @EntityResult(entityClass=com.acme.Customer.class, fields={
        @FieldResult(name="id", column="customer_id"),
        @FieldResult(name="address.street", column="customer_street"),
        @FieldResult(name="address.city", column="customer_city"),
        @FieldResult(name="address.state", column="customer_state"),
        @FieldResult(name="status", column="customer_status")
    })
})
----

When the returned entity type is the owner of
a single-valued relationship and the foreign key is a composite foreign
key (composed of multiple columns), a _FieldResult_ element should be
used for each of the foreign key columns. The _FieldResult_ element must
use the dot ( _._ ) notation form to indicate the column that maps to
each property or field of the target entity primary key.

If the target entity has a primary key of
type _IdClass_, this specification takes the form of the name of the
field or property for the relationship, followed by a dot ( _._ ),
followed by the name of the field or property of the primary key in the
target entity. The latter will be annotated with _Id_, as specified in
<<a14836>>.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item_id AS order_item_id, " +
        "o.item_name AS order_item_name, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item_id = i.id) " +
        "AND (order_item_name = i.name)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item.id", column="order_item_id")}),
        @FieldResult(name="item.name", column="order_item_name")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

If the target entity has a primary key of
type _EmbeddedId_, this specification is composed of the name of the
field or property for the relationship, followed by a dot ( _._ ),
followed by the name or the field or property of the primary key (i.e.,
the name of the field or property annotated as _EmbeddedId_), followed
by the name of the corresponding field or property of the embedded
primary key class.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item_id AS order_item_id, " +
        "o.item_name AS order_item_name, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item_id = i.id) AND (order_item_name = i.name)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item.itemPk.id", column="order_item_id")}),
        @FieldResult(name="item.itemPk.name", column="order_item_name")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

The _FieldResult_ elements for the composite
foreign key are combined to form the primary key _EmbeddedId_ class for
the target entity. This may then be used to subsequently retrieve the
entity if the relationship is to be eagerly loaded.

The dot-notation form is not required to be
supported for any usage other than for embeddables, composite foreign
keys, or composite primary keys.

===== Returning Unmanaged Instances

Instances of other classes (including
non-managed entity instances) as well as scalar results can be returned
by a native query. These can be used singly, or in combination,
including with entity results.

====== Scalar Results

Scalar results can be included in the query
result by specifying the _ColumnResult_ annotation element of the
_SqlResultSetMapping_ annotation. The intended type of the result can be
specified using the _type_ element of the _ColumnResult_ annotation.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item AS order_item, " +
        "i.name AS item_name, " +
        "i.availabilityDate AS item_shipdate " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item = i.id)",
    "OrderResults");

@SqlResultSetMapping(
    name="OrderResults",
    entities={
        @EntityResult(entityClass=com.acme.Order.class, fields={
            @FieldResult(name="id", column="order_id"),
            @FieldResult(name="quantity", column="order_quantity"),
            @FieldResult(name="item", column="order_item")}
        )},
    columns={
        @ColumnResult(name="item_name"),
        @ColumnResult(name="item_shipdate", type=java.util.Date.class)
    })
----

====== Constructor Results

The mapping to constructors is specified
using the _ConstructorResult_ annotation element of the
_SqlResultSetMapping_ annotation. The _targetClass_ element of the
_ConstructorResult_ annotation specifies the class whose constructor
corresponds to the specified columns. All columns corresponding to
arguments of the intended constructor must be specified using the
_columns_ element of the _ConstructorResult_ annotation in the same
order as that of the argument list of the constructor. Any entities
returned as constructor results will be in either the new or the
detached state, depending on whether a primary key is retrieved for the
constructed object.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT c.id, c.name, COUNT(o) as orderCount, AVG(o.price) AS avgOrder " +
        "FROM Customer c, Orders o " +
        "WHERE o.cid = c.id " +
        "GROUP BY c.id, c.name",
    "CustomerDetailsResult");

@SqlResultSetMapping(name="CustomerDetailsResult", classes={
    @ConstructorResult(targetClass=com.acme.CustomerDetails.class, columns={
        @ColumnResult(name="id"),
        @ColumnResult(name="name"),
        @ColumnResult(name="orderCount"),
        @ColumnResult(name="avgOrder", type=Double.class)})
})
----

===== Combinations of Result Types

When a _SqlResultSetMapping_ specifies more
than one mapping type (i.e., more than one of _EntityResult_,
_ConstructorResult_, _ColumnResult_), then for each row in the SQL
result, the query execution will result in an _Object[]_ instance whose
elements are as follows, in order: any entity results (in the order in
which they are defined in the _entities_ element); any instances of
classes corresponding to constructor results (in the order defined in
the _classes_ element); and any instances corresponding to column
results (in the order defined in the _columns_ element). If there are
any columns whose result mappings have not been specified, they are
ignored.

===== Restrictions

When an entity is being returned, the SQL
statement should select all of the columns that are mapped to the entity
object. This should include foreign key columns to related entities. The
results obtained when insufficient data is available are undefined. A
SQL result set mapping must not be used to map results to the
non-persistent state of an entity.

The use of named parameters is not defined
for native SQL queries. Only positional parameter binding for SQL
queries may be used by portable applications.

==== Stored Procedures

The _StoredProcedureQuery_ interface supports
the use of database stored procedures.

Stored procedures can be specified either by
means of the _NamedStoredProcedureQuery_ annotation or dynamically.
Annotations for the specification of stored procedures are described in
<<a13759>>.

===== Named Stored Procedure Queries

Unlike in the case of a named native query,
the _NamedStoredProcedureQuery_ annotation names a stored procedure that
exists in the database rather than providing a stored procedure
definition. The _NamedStoredProcedureQuery_ annotation specifies the
types of all parameters to the stored procedure, their corresponding
parameter modes (IN, OUT, INOUT, REF_CURSORfootnote:[Note that REF_CURSOR
parameters are used by some databases to return result sets from stored
procedures.]), and
how result sets, if any, are to be mapped. The name that is assigned to
the stored procedure in the _NamedStoredProcedureQuery_ annotation is
passed as an argument to the _createNamedStoredProcedureQuery_ method to
create an executable _StoredProcedureQuery_ object.

A stored procedure may return more than one
result set. As with native queries, the mapping of result sets can be
specified either in terms of a _resultClasses_ or as a
_resultSetMappings_ annotation element. If there are multiple result
sets, it is assumed that they will be mapped using the same mechanism 
e.g., all via a set of result class mappings or all via a set of result
set mappings. The order of the specification of these mappings must be
the same as the order in which the result sets will be returned by the
stored procedure invocation. If the stored procedure returns one or more
result sets and no _resultClasses_ or _resultSetMappings_ element has
been specified, any result set will be returned as a list of type
_Object[]_. The combining of different strategies for the mapping of
stored procedure result sets is undefined.

_StoredProcedureParameter_ metadata needs to
be provided for all parameters. Parameters must be specified in the
order in which they occur in the parameter list of the stored procedure.
If parameter names are used, the parameter name is used to bind the
parameter value and to extract the output value (if the parameter is an
INOUT or OUT parameter). If parameter names are not specified, it is
assumed that positional parameters are used. The mixing of named and
positional parameters is undefined.

===== Dynamically-specified Stored Procedure Queries

If the stored procedure is not defined using
metadata, parameter and result set information must be provided
dynamically.

All parameters of a dynamically-specified
stored procedure query must be registered using the
_registerStoredProcedureParameter_ method of the _StoredProcedureQuery_
interface.

Result set mapping information can be
provided by means of the _createStoredProcedureQuery_ method.

===== Stored Procedure Query Execution [[a4625]]

Stored procedure query execution can be
controlled as described below.

The _setParameter_ methods are used to set
the values of all required IN and INOUT parameters. It is not required
to set the values of stored procedure parameters for which default
values have been defined by the stored procedure.

When _getResultList_ and _getSingleResult_
are called on a _StoredProcedureQuery_ object, the persistence provider
will call _execute_ on an unexecuted stored procedure query before
processing _getResultList_ or _getSingleResult_.

When _executeUpdate_ is called on a
_StoredProcedureQuery_ object, the persistence provider will call
_execute_ on an unexecuted stored procedure query followed by
_getUpdateCount_. The results of _executeUpdate_ will be those of
_getUpdateCount_.

The _execute_ method supports both the simple
case where scalar results are passed back only via INOUT and OUT
parameters as well as the most general case (multiple result sets and/or
update counts, possibly also in combination with output parameter
values).

The _execute_ method returns _true_ if the
first result is a result set, and _false_ if it is an update count or
there are no results other than through INOUT and OUT parameters, if
any.

If the _execute_ method returns _true_, the
pending result set can be obtained by calling _getResultList_ or
_getSingleResult_. The _hasMoreResults_ method can then be used to test
for further results.

If _execute_ or _hasMoreResults_ returns
_false_, the _getUpdateCount_ method can be called to obtain the
pending result if it is an update count. The _getUpdateCount_ method
will return either the update count (zero or greater) or -1 if there is
no update count (i.e., either the next result is a result set or there
is no next update count).

For portability, results that correspond to
JDBC result sets and update counts need to be processed before the
values of any INOUT or OUT parameters are extracted.

After results returned through
_getResultList_ and _getUpdateCount_ have been exhausted, results
returned through INOUT and OUT parameters can be retrieved.

The _getOutputParameterValue_ methods are
used to retrieve the values passed back from the procedure through INOUT
and OUT parameters.

When using _REF_CURSOR_ parameters for result
sets, the update counts should be exhausted before calling
_getResultList_ to retrieve the result set. Alternatively, the
_REF_CURSOR_ result set can be retrieved through
_getOutputParameterValue_. Result set mappings will be applied to
results corresponding to _REF_CURSOR_ parameters in the order the
_REF_CURSOR_ parameters were registered with the query.

In the simplest case, where results are
returned only via INOUT and OUT parameters, _execute_ can be followed
immediately by calls to _getOutputParameterValue_.

=== Summary of Exceptions [[a4639]]

The following is a summary of the exceptions defined by this specification:

*PersistenceException*

The _PersistenceException_ is thrown by the
persistence provider when a problem occurs. It may be thrown to report
that the invoked operation could not complete because of an unexpected
error (e.g., failure of the persistence provider to open a database
connection).

All other exceptions defined by this
specification are subclasses of the _PersistenceException_. All
instances of _PersistenceException_ except for instances of
_NoResultException_, _NonUniqueResultException,_ _LockTimeoutException_
, and _QueryTimeoutException_ will cause the current transaction, if one
is active and the persistence context has been joined to it, to be
marked for rollback.

*TransactionRequiredException*

The _TransactionRequiredException_ is thrown
by the persistence provider when a transaction is required but is not
active.

*OptimisticLockException*

The _OptimisticLockException_ is thrown by
the persistence provider when an optimistic locking conflict occurs.
This exception may be thrown as part of an API call, at flush, or at
commit time. The current transaction, if one is active, will be marked
for rollback.

*PessimisticLockException*

The _PessimisticLockException_ is thrown by
the persistence provider when a pessimistic locking conflict occurs. The
current transaction will be marked for rollback. Typically the
_PessimisticLockException_ occurs because the database transaction has
been rolled back due to deadlock or because the database uses
transaction-level rollback when a pessimistic lock cannot be granted.

*LockTimeoutException*

The _LockTimeoutException_ is thrown by the
persistence provider when a pessimistic locking conflict occurs that
does not result in transaction rollback. Typically this occurs because
the database uses statement-level rollback when a pessimistic lock
cannot be granted (and there is no deadlock). The _LockTimeoutException_
does not cause the current transaction to be marked for rollback.

*RollbackException*

The _RollbackException_ is thrown by the
persistence provider when _EntityTransaction.commit_ fails. __

*EntityExistsException*

The _EntityExistsException_ may thrown by the
persistence provider when the _persist_ operation is invoked and the
entity already exists. The _EntityExistsException_ may be thrown when
the persist operation is invoked, or the _EntityExistsException_ or
another _PersistenceException_ may be thrown at commit time. The current
transaction, if one is active and the persistence context has been
joined to it, will be marked for rollback.

*EntityNotFoundException*

The _EntityNotFoundException_ is thrown by
the persistence provider when an entity reference obtained by
_getReference_ is accessed but the entity does not exist. It is thrown
by the _refresh_ operation when the entity no longer exists in the
database. It is also thrown by the _lock_ operation when pessimistic
locking is used and the entity no longer exists in the database. The
current transaction, if one is active and the persistence context has
been joined to it, will be marked for rollback.

*NoResultException*

The _NoResultException_ is thrown by the
persistence provider when _Query.getSingleResult_ or
_TypedQuery.getSingleResult_ is invoked and there is no result to
return. This exception will not cause the current transaction, if one is
active, to be marked for rollback.

*NonUniqueResultException*

The _NonUniqueResultException_ is thrown by
the persistence provider when _Query.getSingleResult_ or
_TypedQuery.getSingleResult_ is invoked and there is more than one
result from the query. This exception will not cause the current
transaction, if one is active, to be marked for rollback.

*QueryTimeoutException*

The _QueryTimeoutException_ is thrown by the
persistence provider when a query times out and only the statement is
rolled back. The _QueryTimeoutException_ does not cause the current
transaction, if one is active, to be marked for rollback.
