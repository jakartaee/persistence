//
// Copyright (c) 2017, 2021 Contributors to the Eclipse Foundation
//

== Entity Managers and Persistence Contexts [[a11431]]

=== Persistence Contexts [[a11432]]

A persistence context is a set of managed
entity instances in which for any persistent entity identity there is a
unique entity instance. Within the persistence context, the entity
instances and their lifecycle are managed by the entity manager.

In Jakarta EE environments, a JTA transaction
typically involves calls across multiple components. Such components may
often need to access the same persistence context within a single
transaction. To facilitate such use of entity managers in Jakarta EE
environments, when an entity manager is injected into a component or
looked up directly in the JNDI naming context, its persistence context
will automatically be propagated with the current JTA transaction, and
the EntityManager references that are mapped to the same persistence
unit will provide access to this same persistence context within the JTA
transaction. This propagation of persistence contexts by the Jakarta EE
container avoids the need for the application to pass references to
EntityManager instances from one component to another. An entity manager
for which the container manages the persistence context in this manner
is termed a _container-managed entity manager_. A container-managed
entity manager's lifecycle is managed by the Jakarta EE container.

In less common use cases within Jakarta EE
environments, applications may need to access a persistence context that
is “stand-alone”—i.e. not propagated along with the JTA transaction
across the EntityManager references for the given persistence unit.
Instead, each instance of creating an entity manager causes a new
isolated persistence context to be created that is not accessible
through other EntityManager references within the same transaction.
These use cases are supported through the _createEntityManager_ methods
of the _EntityManagerFactory_ interface. An entity manager that is used
by the application to create and destroy a persistence context in this
manner is termed an _application-managed entity manager_. An
application-managed entity manager's lifecycle is managed by the
application.

Both container-managed entity managers and
application-managed entity managers and their persistence contexts are
required to be supported in Jakarta EE web containers and EJB containers.
Within an EJB environment, container-managed entity managers are
typically used.

In Java SE environments and in Jakarta EE
application client containers, only application-managed entity managers
are required to be footnote:[Note that the use of
JTA is not required to be supported in application client containers.].

=== Obtaining an EntityManager

The entity manager for a persistence context
is obtained from an entity manager factory.

When container-managed entity managers are
used (in Jakarta EE environments), the application does not interact with
the entity manager factory. The entity managers are obtained directly
through dependency injection or from JNDI, and the container manages
interaction with the entity manager factory transparently to the
application.

When application-managed entity managers are
used, the application must use the entity manager factory to manage the
entity manager and persistence context lifecycle.

An entity manager must not be shared among
multiple concurrently executing threads, as the entity manager and
persistence context are not required to be threadsafe. Entity managers
must only be accessed in a single-threaded manner.

==== Obtaining an Entity Manager in the Jakarta EE Environment

A container-managed entity manager is
obtained by the application through dependency injection or through
direct lookup of the entity manager in the JNDI namespace. The container
manages the persistence context lifecycle and the creation and the
closing of the entity manager instance transparently to the application.

The _PersistenceContext_ annotation is used
for entity manager injection. The _type_ element specifies whether a
transaction-scoped or extended persistence context is to be used, as
described in <<a11791>>. The _synchronization_ element specifies whether
the persistence context is always automatically joined to the current
transaction (the default) or is not joined to the current transaction
unless the _joinTransaction_ method is invoked by the application. The
_unitName_ element may optionally be specified to designate the
persistence unit whose entity manager factory is used by the container.
The semantics of the persistence context synchronization type are
further described in <<a11797>. Section <<a13887>> provides further
information about the _unitName_ element.

For example,

[source,java]
----
@PersistenceContext
EntityManager em;

@PersistenceContext(type=PersistenceContextType.EXTENDED)
EntityManager orderEM;
----

The JNDI lookup of an entity manager is illustrated below:

[source,java]
----
@Stateless
@PersistenceContext(name="OrderEM")
public class MySessionBean implements MyInterface {
    @Resource
    SessionContext ctx;

    public void doSomething() {
        EntityManager em = (EntityManager)ctx.lookup("OrderEM");

        // ...
    }
}
----

==== Obtaining an Application-managed Entity Manager [[a11465]]

An application-managed entity manager is
obtained by the application from an entity manager factory.

The _EntityManagerFactory_ API used to obtain
an application-managed entity manager is the same independent of whether
this API is used in Jakarta EE or Java SE environments.

=== Obtaining an Entity Manager Factory

The _EntityManagerFactory_ interface is used
by the application to create an application-managed entity
managerfootnote:[It may also be used
internally by the Jakarta EE container. See <<a12100>>.].

Each entity manager factory provides entity
manager instances that are all configured in the same manner (e.g.,
configured to connect to the same database, use the same initial
settings as defined by the implementation, etc.)

More than one entity manager factory
instance may be available simultaneously in the
JVM.footnote:[This may be the case
when using multiple databases, since in a typical configuration a single
entity manager only communicates with a single database. There is only
one entity manager factory per persistence unit, however.]

Methods of the _EntityManagerFactory_ interface are threadsafe.

==== Obtaining an Entity Manager Factory in a Jakarta EE Container

Within a Jakarta EE environment, an entity
manager factory can be injected using the _PersistenceUnit_ annotation
or obtained through JNDI lookup. The _unitName_ element may optionally
be specified to designate the persistence unit whose entity manager
factory is used. (See <<a13887>>).

For example,

[source,java]
----
@PersistenceUnit
EntityManagerFactory emf;
----

==== Obtaining an Entity Manager Factory in a Java SE Environment

Outside a Jakarta EE container environment, the
_jakarta.persistence.Persistence_ class is the bootstrap class that
provides access to an entity manager factory. The application creates an
entity manager factory by calling the _createEntityManagerFactory_
method of the _jakarta.persistence.Persistence_ class, described in
<<a13443>>.

For example,

[source,java]
----
EntityManagerFactory emf =
    jakarta.persistence.Persistence.createEntityManagerFactory("Order");
EntityManager em = emf.createEntityManager();
----

=== EntityManagerFactory Interface

The _EntityManagerFactory_ interface is used
by the application to obtain an application-managed entity manager. When
the application has finished using the entity manager factory, and/or at
application shutdown, the application should close the entity manager
factory. Once an entity manager factory has been closed, all its entity
managers are considered to be in the closed state.

The _EntityManagerFactory_ interface provides
access to information and services that are global to the persistence
unit. This includes access to the second level cache that is maintained
by the persistence provider and to the _PersistenceUnitUtil_ interface.
The _Cache_ interface is described in <<a12124>>; the
_PersistenceUnitUtil_ interface in <<a12177>>.

[source,java]
----
package jakarta.persistence;

import java.util.Map;
import jakarta.persistence.metamodel.Metamodel;
import jakarta.persistence.criteria.CriteriaBuilder;

/**
 * Interface used to interact with the entity manager factory
 * for the persistence unit.
 *
 * <p>When the application has finished using the entity manager
 * factory, and/or at application shutdown, the application should
 * close the entity manager factory.  Once an
 * <code>EntityManagerFactory</code> has been closed, all its entity managers
 * are considered to be in the closed state.
 *
 * @since 1.0
 */
public interface EntityManagerFactory extends AutoCloseable {

    /**
     * Create a new application-managed <code>EntityManager</code>.
     * This method returns a new <code>EntityManager</code> instance each time
     * it is invoked.
     * The <code>isOpen</code> method will return true on the returned instance.
     * @return entity manager instance
     * @throws IllegalStateException if the entity manager factory
     * has been closed
     */
    public EntityManager createEntityManager();

    /**
     * Create a new application-managed <code>EntityManager</code> with the
     * specified Map of properties.
     * This method returns a new <code>EntityManager</code> instance each time
     * it is invoked.
     * The <code>isOpen</code> method will return true on the returned instance.
     * @param map properties for entity manager
     * @return entity manager instance
     * @throws IllegalStateException if the entity manager factory
     * has been closed
     */
    public EntityManager createEntityManager(Map map);

    /**
     * Create a new JTA application-managed <code>EntityManager</code> with the
     * specified synchronization type.
     * This method returns a new <code>EntityManager</code> instance each time
     * it is invoked.
     * The <code>isOpen</code> method will return true on the returned instance.
     * @param synchronizationType  how and when the entity manager should be
     * synchronized with the current JTA transaction
     * @return entity manager instance
     * @throws IllegalStateException if the entity manager factory
     * has been configured for resource-local entity managers or is closed
     *
     * @since 2.1
     */
    public EntityManager createEntityManager(SynchronizationType synchronizationType);

    /**
     * Create a new JTA application-managed <code>EntityManager</code> with the
     * specified synchronization type and map of properties.
     * This method returns a new <code>EntityManager</code> instance each time
     * it is invoked.
     * The <code>isOpen</code> method will return true on the returned instance.
     * @param synchronizationType  how and when the entity manager should be
     * synchronized with the current JTA transaction
     * @param map properties for entity manager
     * @return entity manager instance
     * @throws IllegalStateException if the entity manager factory
     * has been configured for resource-local entity managers or is closed
     *
     * @since 2.1
     */
    public EntityManager createEntityManager(SynchronizationType synchronizationType, Map map);

    /**
     * Return an instance of <code>CriteriaBuilder</code> for the creation of
     * <code>CriteriaQuery</code> objects.
     * @return CriteriaBuilder instance
     * @throws IllegalStateException if the entity manager factory
     * has been closed
     *
     * @since 2.0
     */
    public CriteriaBuilder getCriteriaBuilder();

    /**
     * Return an instance of <code>Metamodel</code> interface for access to the
     * metamodel of the persistence unit.
     * @return Metamodel instance
     * @throws IllegalStateException if the entity manager factory
     * has been closed
     *
     * @since 2.0
     */
    public Metamodel getMetamodel();

    /**
     * Indicates whether the factory is open. Returns true
     * until the factory has been closed.
     * @return boolean indicating whether the factory is open
     */
    public boolean isOpen();

    /**
     * Close the factory, releasing any resources that it holds.
     * After a factory instance has been closed, all methods invoked
     * on it will throw the <code>IllegalStateException</code>, except
     * for <code>isOpen</code>, which will return false. Once an
     * <code>EntityManagerFactory</code> has been closed, all its
     * entity managers are considered to be in the closed state.
     * @throws IllegalStateException if the entity manager factory
     * has been closed
     */
    public void close();

    /**
     * Get the properties and associated values that are in effect
     * for the entity manager factory. Changing the contents of the
     * map does not change the configuration in effect.
     * @return properties
     * @throws IllegalStateException if the entity manager factory
     * has been closed
     *
     * @since 2.0
     */
    public Map<String, Object> getProperties();

    /**
     * Access the cache that is associated with the entity manager
     * factory (the "second level cache").
     * @return instance of the <code>Cache</code> interface or null if
     * no cache is in use
     * @throws IllegalStateException if the entity manager factory
     * has been closed
     *
     * @since 2.0
     */
    public Cache getCache();

    /**
     * Return interface providing access to utility methods
     * for the persistence unit.
     * @return <code>PersistenceUnitUtil</code> interface
     * @throws IllegalStateException if the entity manager factory
     * has been closed
     *
     * @since 2.0
     */
    public PersistenceUnitUtil getPersistenceUnitUtil();

    /**
     * Define the query, typed query, or stored procedure query as
     * a named query such that future query objects can be created
     * from it using the <code>createNamedQuery</code> or
     * <code>createNamedStoredProcedureQuery</code> method.
     * <p>Any configuration of the query object (except for actual
     * parameter binding) in effect when the named query is added
     * is retained as part of the named query definition.
     * This includes configuration information such as max results,
     * hints, flush mode, lock mode, result set mapping information,
     * and information about stored procedure parameters.
     * <p>When the query is executed, information that can be set
     * by means of the query APIs can be overridden. Information
     * that is overridden does not affect the named query as
     * registered with the entity manager factory, and thus does
     * not affect subsequent query objects created from it by
     * means of the <code>createNamedQuery</code> or
     * <code>createNamedStoredProcedureQuery</code> method.
     * <p>If a named query of the same name has been previously
     * defined, either statically via metadata or via this method,
     * that query definition is replaced.
     *
     * @param name name for the query
     * @param query Query, TypedQuery, or StoredProcedureQuery object
     *
     * @since 2.1
     */
    public void addNamedQuery(String name, Query query);

    /**
     * Return an object of the specified type to allow access to the
     * provider-specific API. If the provider's EntityManagerFactory
     * implementation does not support the specified class, the
     * PersistenceException is thrown.
     * @param cls the class of the object to be returned. This is
     * normally either the underlying EntityManagerFactory
     * implementation class or an interface that it implements.
     * @return an instance of the specified class
     * @throws PersistenceException if the provider does not
     * support the call
     * @since 2.1
     */
    public <T> T unwrap(Class<T> cls);

    /**
     * Add a named copy of the EntityGraph to the
     * EntityManagerFactory.  If an entity graph with the same name
     * already exists, it is replaced.
     * @param graphName  name for the entity graph
     * @param entityGraph  entity graph
     * @since 2.1
     */
    public <T> void addNamedEntityGraph(String graphName, EntityGraph<T> entityGraph);

}
----

Any number of vendor-specific properties may
be included in the map passed to the _createEntityManager_ methods.
Properties that are not recognized by a vendor must be ignored.

Note that the policies of the installation
environment may restrict some information from being made available
through the _EntityManagerFactory_ _getProperties_ method (for example,
JDBC user, password, URL).

Vendors should use vendor namespaces for
properties (e.g., _com.acme.persistence.logging_). Entries that make
use of the namespace _jakarta.persistence_ and its subnamespaces must not
be used for vendor-specific information. The namespace
_jakarta.persistence_ is reserved for use by this specification.

=== Controlling Transactions

Depending on the transactional type of the
entity manager, transactions involving EntityManager operations may be
controlled either through JTA or through use of the resource-local
_EntityTransaction_ API, which is mapped to a resource transaction over
the resource that underlies the entities managed by the entity manager.

An entity manager whose underlying
transactions are controlled through JTA is termed a _JTA entity manager_.

An entity manager whose underlying
transactions are controlled by the application through the
_EntityTransaction_ API is termed a _resource-local entity manager_.

A container-managed entity manager must be a
JTA entity manager. JTA entity managers are only specified for use in
Jakarta EE containers.

An application-managed entity manager may be
either a JTA entity manager or a resource-local entity manager.

An entity manager is defined to be of a given
transactional type—either JTA or resource-local—at the time its
underlying entity manager factory is configured and created. See
sections <<a12296>> and <<a12802>>.

Both JTA entity managers and resource-local
entity managers are required to be supported in Jakarta EE web containers
and EJB containers. Within an EJB environment, a JTA entity manager is
typically used. In general, in Java SE environments only resource-local
entity managers are supported.

==== JTA EntityManagers

An entity manager whose transactions are
controlled through JTA is a JTA entity manager. In general, a JTA entity
manager participates in the current JTA transaction, which is begun and
committed external to the entity manager and propagated to the
underlying resource manager.

==== Resource-local EntityManagers

An entity manager whose transactions are
controlled by the application through the _EntityTransaction_ API is a
resource-local entity manager. A resource-local entity manager
transaction is mapped to a resource transaction over the resource by the
persistence provider. Resource-local entity managers may use server or
local resources to connect to the database and are unaware of the
presence of JTA transactions that may or may not be active.

==== The EntityTransaction Interface

The _EntityTransaction_ interface is used to
control resource transactions on resource-local entity managers. The
_EntityManager.getTransaction()_ method returns an instance of the
_EntityTransaction_ interface.

When a resource-local entity manager is used,
and the persistence provider runtime throws an exception defined to
cause transaction rollback, the persistence provider must mark the
transaction for rollback.

If the _EntityTransaction.commit_ operation
fails, the persistence provider must roll back the transaction.

[source,java]
----
package jakarta.persistence;

/**
 * Interface used to control transactions on resource-local entity
 * managers.  The {@link EntityManager#getTransaction
 * EntityManager.getTransaction()} method returns the
 * <code>EntityTransaction</code> interface.
 *
 * @since 1.0
 */
public interface EntityTransaction {

     /**
      * Start a resource transaction.
      * @throws IllegalStateException if <code>isActive()</code> is true
      */
     public void begin();

     /**
      * Commit the current resource transaction, writing any
      * unflushed changes to the database.
      * @throws IllegalStateException if <code>isActive()</code> is false
      * @throws RollbackException if the commit fails
      */
     public void commit();

     /**
      * Roll back the current resource transaction.
      * @throws IllegalStateException if <code>isActive()</code> is false
      * @throws PersistenceException if an unexpected error
      *         condition is encountered
      */
     public void rollback();

     /**
      * Mark the current resource transaction so that the only
      * possible outcome of the transaction is for the transaction
      * to be rolled back.
      * @throws IllegalStateException if <code>isActive()</code> is false
      */
     public void setRollbackOnly();

     /**
      * Determine whether the current resource transaction has been
      * marked for rollback.
      * @return boolean indicating whether the transaction has been
      *         marked for rollback
      * @throws IllegalStateException if <code>isActive()</code> is false
      */
     public boolean getRollbackOnly();

     /**
      * Indicate whether a resource transaction is in progress.
      * @return boolean indicating whether transaction is
      *         in progress
      * @throws PersistenceException if an unexpected error
      *         condition is encountered
      */
     public boolean isActive();
}
----

==== Example

The following example illustrates the
creation of an entity manager factory in a Java SE environment, and its
use in creating and using a resource-local entity manager.

[source,java]
----
import jakarta.persistence.*;

public class PasswordChanger {
    public static void main (String[] args) {
        EntityManagerFactory emf =
            Persistence.createEntityManagerFactory("Order");
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        User user = (User)em.createQuery
            ("SELECT u FROM User u WHERE u.name=:name AND u.pass=:pass")
            .setParameter("name", args[0])
            .setParameter("pass", args[1])
            .getSingleResult();

        if (user!=null)
            user.setPassword(args[2]);

        em.getTransaction().commit();
        em.close();
        emf.close();
    }
}
----

=== Container-managed Persistence Contexts [[a11791]]

When a container-managed entity manager is
used, the lifecycle of the persistence context is always managed
automatically, transparently to the application, and the persistence
context is propagated with the JTA transaction.

A container-managed persistence context may
be defined to have either a lifetime that is scoped to a single
transaction or an extended lifetime that spans multiple transactions,
depending on the _PersistenceContextType_ that is specified when its
entity manager is created. This specification refers to such persistence
contexts as _transaction-scoped persistence contexts_ and _extended
persistence contexts_ respectively.

The lifetime of the persistence context is
declared using the _PersistenceContext_ annotation or the
_persistence-context-ref_ deployment descriptor element. By default, a
transaction-scoped persistence context is used.

Sections <<a11805>> and <<a11810>> describe transaction-scoped and extended persistence contexts
in the absence of persistence context propagation. Persistence context
propagation is described in <<a11816>>.

Persistence contexts are always associated
with an entity manager factory. In the following sections, “the
persistence context” should be understood to mean “the persistence
context associated with a particular entity manager factory”.

==== Persistence Context Synchronization Type [[a11797]]

By default, a container-managed persistence
context is of type _SynchronizationType.SYNCHRONIZED_. Such a
persistence context is automatically joined to the current JTA
transaction, and updates made to the persistence context are propagated
to the underlying resource manager.

A container-managed persistence context may
be specified to be of type _SynchronizationType.UNSYNCHRONIZED_. A
persistence context of type _SynchronizationType.UNSYNCHRONIZED_ is not
enlisted in any JTA transaction unless explicitly joined to that
transaction by the application. A persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ is enlisted in a JTA transaction
and registered for subsequent transaction notifications against that
transaction by the invocation of the _EntityManager_ _joinTransaction_
method. The persistence context remains joined to the transaction until
the transaction commits or rolls back. After the transaction commits or
rolls back, the persistence context will not be joined to any subsequent
transaction unless the _joinTransaction_ method is invoked in the scope
of that subsequent transaction.

A persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ must not be flushed to the database
unless it is joined to a transaction. The application's use of queries
with pessimistic locks, bulk update or delete queries, etc. result in
the provider throwing the _TransactionRequiredException_. After the
persistence context has been joined to the JTA transaction, these
operations are again allowed.

The application is permitted to invoke the
persist, merge, remove, and refresh entity lifecycle operations on an
entity manager of type _SynchronizationType.UNSYNCHRONIZED_ independent
of whether the persistence context is joined to the current transaction.
After the persistence context has been joined to a transaction, changes
in a persistence context can be flushed to the database either
explicitly by the application or by the provider. If the _flush_ method
is not explicitly invoked, the persistence provider may defer flushing
until commit time depending on the operations invoked and the flush mode
setting in effect.

If an extended persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ has not been joined to the current
JTA transaction, rollback of the JTA transaction will have no effect
upon the persistence context. In general, it is recommended that a
non-JTA datasource be specified for use by the persistence provider for
a persistence context of type _SynchronizationType.UNSYNCHRONIZED_ that
has not been joined to a JTA transaction in order to alleviate the risk
of integrating uncommitted changes into the persistence context in the
event that the transaction is later rolled back.

If a persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ has been joined to the JTA
transaction, transaction rollback will cause the persistence context to
be cleared and all pre-existing managed and removed instances to become
detached. (See <<a2049>>.)

When a JTA transaction exists, a persistence
context of type _SynchronizationType.UNSYNCHRONIZED_ is propagated with
that transaction according to the rules in <<a11820>> regardless of whether the persistence context has been
joined to that transaction.

==== Container-managed Transaction-scoped Persistence Context [[a11805]]

The application can obtain a
container-managed entity manager with transaction-scoped persistence
context by injection or direct lookup in the JNDI namespace. The
persistence context type for the entity manager is defaulted or defined
as _PersistenceContextType.TRANSACTION_.

A new persistence context begins when the
container-managed entity manager is invokedfootnote:[Specifically, when
one of the methods of the EntityManager interface is invoked.] in
the scope of an active JTA transaction, and there is no current
persistence context already associated with the JTA transaction. The
persistence context is created and then associated with the JTA
transaction. This association of the persistence context with the JTA
transaction is independent of the synchronization type of the
persistence context and whether the persistence context has been joined
to the transaction.

The persistence context ends when the
associated JTA transaction commits or rolls back, and all entities that
were managed by the EntityManager become detached.footnote:[Note that this
applies to a transaction-scoped persistence context of type
SynchronizationType.UNSYNCHRONIZED that has not been joined to the
transaction as well.]

If the entity manager is invoked outside the
scope of a transaction, any entities loaded from the database will
immediately become detached at the end of the method call.

==== Container-managed Extended Persistence Context [[a11810]]

A container-managed extended persistence
context can only be initiated within the scope of a stateful session
bean. It exists from the point at which the stateful session bean that
declares a dependency on an entity manager of type
_PersistenceContextType.EXTENDED_ is created, and is said to be _bound_
to the stateful session bean. The dependency on the extended persistence
context is declared by means of the _PersistenceContext_ annotation or
_persistence-context-ref_ deployment descriptor element. The association
of the extended persistence context with the JTA transaction is
independent of the synchronization type of the persistence context and
whether the persistence context has been joined to the transaction.

The persistence context is closed by the
container when the _@Remove_ method of the stateful session bean
completes (or the stateful session bean instance is otherwise
destroyed).

===== Inheritance of Extended Persistence Context

If a stateful session bean instantiates a
stateful session bean (executing in the same EJB container instance)
which also has such an extended persistence context with the same
synchronization type, the extended persistence context of the first
stateful session bean is inherited by the second stateful session bean
and bound to it, and this rule recursively applies—independently of
whether transactions are active or not at the point of the creation of
the stateful session beans. If the stateful session beans differ in
declared synchronization type, the EJBException is thrown by the
container.

If the persistence context has been inherited
by any stateful session beans, the container does not close the
persistence context until all such stateful session beans have been
removed or otherwise destroyed.

==== Persistence Context Propagation [[a11816]]

As described in <<a11432>>, a single
persistence context may correspond to one or more JTA entity manager
instances (all associated with the same entity manager
factoryfootnote:[Entity manager
instances obtained from different entity manager factories never share
the same persistence context.]).

The persistence context is propagated across
the entity manager instances as the JTA transaction is propagated. A
persistence context of type _SynchronizationType.UNSYNCHRONIZED_ is
propagated with the JTA transaction regardless of whether it has been
joined to the transaction.

Propagation of persistence contexts only
applies within a local environment. Persistence contexts are not
propagated to remote tiers.

===== Requirements for Persistence Context Propagation [[a11820]]

Persistence contexts are propagated by the
container across component invocations as follows.

If a component is called and there is no JTA
transaction or the JTA transaction is not propagated, the persistence
context is not propagated.

* If an entity manager is then invoked from
within the component:
** Invocation of an entity manager defined with
_PersistenceContextType.TRANSACTION_ will result in use of a new
persistence context (as described in <<a11805>>).
** Invocation of an entity manager defined with
_PersistenceContextType.EXTENDED_ will result in the use of the existing
extended persistence context bound to that component.
** If the entity manager is invoked within a JTA
transaction, the persistence context will be associated with the JTA
transaction.

If a component is called and the JTA
transaction is propagated into that component:

* If the component is a stateful session bean
to which an extended persistence context has been bound and there is a
different persistence context associated with the JTA transaction, an
_EJBException_ is thrown by the container.
* If there is a persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ associated with the JTA transaction
and the target component specifies a persistence context of type
_SynchronizationType.SYNCHRONIZED_, the _IllegalStateException_ is
thrown by the container.
* Otherwise, if there is a persistence context
associated with the JTA transaction, that persistence context is
propagated and used.

[NOTE]
====
Note that a component with a persistence
context of type _SynchronizationType.UNSYNCHRONIZED_ may be called by a
component propagating either a persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ or a persistence context of type
_SynchronizationType.SYNCHRONIZED_ into it.
====

==== Examples

===== Container-managed Transaction-scoped Persistence Context

[source,java]
----
@Stateless
public class ShoppingCartImpl implements ShoppingCart {
    @PersistenceContext
    EntityManager em;

    public Order getOrder(Long id) {
        Order order = em.find(Order.class, id);
        order.getLineItems();
        return order;
    }

    public Product getProduct(String name) {
        return (Product) em.createQuery("select p from Product p where p.name = : name")
               .setParameter("name", name)
               .getSingleResult();
    }

    public LineItem createLineItem(Order order, Product product, int quantity) {
        LineItem li = new LineItem(order, product, quantity);
        order.getLineItems().add(li);
        em.persist(li);
        return li;
    }
}
----

===== Container-managed Extended Persistence Context

[source,java]
----
/*
 * An extended transaction context is used. The entities remain
 * managed in the persistence context across multiple transactions.
 */
@Stateful
@Transaction(REQUIRES_NEW)
public class ShoppingCartImpl implements ShoppingCart {
    @PersistenceContext(type = EXTENDED)
    EntityManager em;

    private Order order;
    private Product product;

    public void initOrder(Long id) {
        order = em.find(Order.class, id);
    }

    public void initProduct(String name) {
        product = (Product) em.createQuery("select p from Product p where p.name = : name")
                  .setParameter("name", name)
                  .getSingleResult();
    }

    public LineItem createLineItem(int quantity) {
        LineItem li = new LineItem(order, product, quantity);
        order.getLineItems().add(li);
        em.persist(li);
        return li;
    }
}
----

=== Application-managed Persistence Contexts [[a11894]]

When an application-managed entity manager is
used, the application interacts directly with the persistence provider's
entity manager factory to manage the entity manager lifecycle and to
obtain and destroy persistence contexts.

All such application-managed persistence
contexts are extended in scope, and can span multiple transactions.

The _EntityManagerFactory_ .
_createEntityManager_ method and the _EntityManager_ _close_ and
_isOpen_ methods are used to manage the lifecycle of an
application-managed entity manager and its associated persistence
context.

The extended persistence context exists from
the point at which the entity manager has been created using
_EntityManagerFactory.createEntityManager_ until the entity manager is
closed by means of _EntityManager.close_.

An extended persistence context obtained from
the application-managed entity manager is a stand-alone persistence
context—it is not propagated with the transaction.

When a JTA application-managed entity manager
is used, an application-managed persistence context may be specified to
be of type _SynchronizationType.UNSYNCHRONIZED_. A persistence context
of type _SynchronizationType.UNSYNCHRONIZED_ is not enlisted in any JTA
transaction unless explicitly joined to that transaction by the
application. A persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ is enlisted in a JTA transaction
and registered for subsequent transaction notifications against that
transaction by the invocation of the _EntityManager_ _joinTransaction_
method. The persistence context remains joined to the transaction until
the transaction commits or rolls back. After the transaction commits or
rolls back, the persistence context will not be joined to any subsequent
transaction unless the _joinTransaction_ method is invoked in the scope
of that subsequent transaction.

When a JTA application-managed entity manager
is used, if the entity manager is created outside the scope of the
current JTA transaction, it is the responsibility of the application to
join the entity manager to the transaction (if desired) by calling
_EntityManager.joinTransaction_. If the entity manager is created
outside the scope of a JTA transaction, it is not joined to the
transaction unless _EntityManager.joinTransaction_ is called.

The _EntityManager.close_ method closes an
entity manager to release its persistence context and other resources.
After calling _close_, the application must not invoke any further
methods on the _EntityManager_ instance except for _getTransaction_ and
_isOpen_, or the _IllegalStateException_ will be thrown. If the _close_
method is invoked when a transaction is active, the persistence context
remains managed until the transaction completes.

The _EntityManager.isOpen_ method indicates
whether the entity manager is open. The _isOpen_ method returns true
until the entity manager has been closed.

==== Examples

===== Application-managed Persistence Context used in Stateless Session Bean

[source,java]
----
/*
 * Container-managed transaction demarcation is used.
 * The session bean creates and closes an entity manager
 * in each business method.
 */
@Stateless
public class ShoppingCartImpl implements ShoppingCart {
    @PersistenceUnit
    private EntityManagerFactory emf;

    public Order getOrder(Long id) {
        EntityManager em = emf.createEntityManager();
        Order order = em.find(Order.class, id);
        order.getLineItems();
        em.close();
        return order;
    }

    public Product getProduct() {
        EntityManager em = emf.createEntityManager();
        Product product = (Product)
                          em.createQuery("select p from Product p where p.name = :name")
                          .setParameter("name", name)
                          .getSingleResult();
        em.close();
        return product;
    }

    public LineItem createLineItem(Order order, Product product, int quantity) {
        EntityManager em = emf.createEntityManager();
        LineItem li = new LineItem(order, product, quantity);
        order.getLineItems().add(li);
        em.persist(li);
        em.close();
        return li; // remains managed until JTA transaction ends
    }
}
----

===== Application-managed Persistence Context used in Stateless Session Bean

[source,java]
----
/*
 * Container-managed transaction demarcation is used.
 * The session bean creates entity manager in PostConstruct
 * method and clears persistence context at the end of each
 * business method.
 */
@Stateless
public class ShoppingCartImpl implements ShoppingCart {
    @PersistenceUnit
    private EntityManagerFactory emf;

    private EntityManager em;

    @PostConstruct
    public void init() {
        em = emf.createEntityManager();
    }

    public Order getOrder(Long id) {
        Order order = em.find(Order.class, id);
        order.getLineItems();
        em.clear(); // entities are detached
        return order;
    }

    public Product getProduct() {
        Product product = (Product)
                          em.createQuery("select p from Product p where p.name = :name")
                          .setParameter("name", name)
                          .getSingleResult();
        em.clear();
        return product;
    }

    public LineItem createLineItem(Order order, Product product, int quantity) {
        em.joinTransaction();
        LineItem li = new LineItem(order, product, quantity);
        order.getLineItems().add(li);
        em.persist(li);
        // persistence context is flushed to database;
        // all updates will be committed to database on tx commit
        em.flush();
        // entities in persistence context are detached
        em.clear();
        return li;
    }

    @PreDestroy
    public void destroy() {
        em.close();
    }
}
----

===== Application-managed Persistence Context used in Stateful Session Bean

[source,java]
----
/*
 * Container-managed transaction demarcation is used.
 * Entities remain managed until the entity manager is closed.
 */
@Stateful
public class ShoppingCartImpl implements ShoppingCart {
    @PersistenceUnit
    private EntityManagerFactory emf;

    private EntityManager em;

    private Order order;

    private Product product;

    @PostConstruct
    public void init() {
        em = emf.createEntityManager();
    }

    public void initOrder(Long id) {
        order = em.find(Order.class, id);
    }

    public void initProduct(String name) {
        product = (Product) em.createQuery("select p from Product p where p.name = : name")
                  .setParameter("name", name)
                  .getSingleResult();
    }

    public LineItem createLineItem(int quantity) {
        em.joinTransaction();
        LineItem li = new LineItem(order, product, quantity);
        order.getLineItems().add(li);
        em.persist(li);
        return li;
    }

    @Remove
    public void destroy() {
        em.close();
    }
}
----

===== Application-managed Persistence Context with Resource Transaction

[source,java]
----
// Usage in an ordinary Java class
public class ShoppingImpl {
    private EntityManager em;
    private EntityManagerFactory emf;

    public ShoppingCart() {
        emf = Persistence.createEntityManagerFactory("orderMgt");
        em = emf.createEntityManager();
    }

    private Order order;
    private Product product;

    public void initOrder(Long id) {
        order = em.find(Order.class, id);
    }

    public void initProduct(String name) {
        product = (Product) em.createQuery("select p from Product p where p.name = : name")
                  .setParameter("name", name)
                  .getSingleResult();
    }

    public LineItem createLineItem(int quantity) {
        em.getTransaction().begin();
        LineItem li = new LineItem(order, product, quantity);
        order.getLineItems().add(li);
        em.persist(li);
        em.getTransaction().commit();
        return li;
    }

    public void destroy() {
        em.close();
        emf.close();
    }
}
----

=== Requirements on the Container

==== Application-managed Persistence Contexts

When application-managed persistence contexts
are used, the container must instantiate the entity manager factory and
expose it to the application via JNDI. The container might use internal
APIs to create the entity manager factory, or it might use the
_PersistenceProvider.createContainerEntityManagerFactory_ method.
However, the container is required to support third-party persistence
providers, and in this case the container must use the
_PersistenceProvider.createContainerEntityManagerFactory_ method to
create the entity manager factory and the _EntityManagerFactory.close_
method to destroy the entity manager factory prior to shutdown (if it
has not been previously closed by the application).

==== Container Managed Persistence Contexts

The container is responsible for managing the
lifecycle of container-managed persistence contexts, for injecting
_EntityManager_ references into web components and session bean and
message-driven bean components, and for making _EntityManager_
references available to direct lookups in JNDI.

When operating with a third-party persistence
provider, the container uses the contracts defined in <<a12100>>
to create and destroy container-managed
persistence contexts. It is undefined whether a new entity manager
instance is created for every persistence context, or whether entity
manager instances are sometimes reused. Exactly how the container
maintains the association between persistence context and JTA
transaction is not defined.

If a persistence context is already
associated with a JTA transaction, the container uses that persistence
context for subsequent invocations within the scope of that transaction,
according to the semantics for persistence context propagation defined
in <<a11816>>.

=== Runtime Contracts between the Container and Persistence Provider [[a12100]]

This section describes contracts
between the container and the persistence provider for the pluggability
of third-party persistence providers. Containers are required to support
these pluggability contracts.footnote:[It is not required
that these contracts be used when a third-party persistence provider is
not used: the container might use these same APIs or its might use its
own internal APIs.]

==== Container Responsibilities

For the management of a transaction-scoped
persistence context, if there is no EntityManager already associated
with the JTA transaction:

* The container creates a new entity manager by
calling _EntityManagerFactory.createEntityManager_ when the first
invocation of an entity manager with
_PersistenceContextType.TRANSACTION_ occurs within the scope of a
business method executing in the JTA transaction.
* After the JTA transaction has completed
(either by transaction commit or rollback), the container closes the
entity manager by calling _EntityManager.close_.
footnote:[The container may
choose to pool EntityManagers: it instead of creating and closing in
each case, it may acquire one from its pool and call _clear()_ on it.]
Note that the JTA transaction may rollback in a
background thread (e.g., as a result of transaction timeout), in which
case the container should arrange for the entity manager to be closed
but the _EntityManager.close_ method should not be concurrently invoked
while the application is in an EntityManager invocation.

The container must throw the
_TransactionRequiredException_ if a transaction-scoped persistence
context is used and the _EntityManager_ _persist_, _remove_, _merge_,
or _refresh_ method is invoked when no transaction is active.

For stateful session beans with extended
persistence contexts:

* The container creates an entity manager by
calling _EntityManagerFactory.createEntityManager_ when a stateful
session bean is created that declares a dependency on an entity manager
with _PersistenceContextType.EXTENDED_. (See <<a11810>>).
* The container closes the entity manager by
calling _EntityManager.close_ after the stateful session bean and all
other stateful session beans that have inherited the same persistence
context as the entity manager have been removed.
* When a business method of the stateful
session bean is invoked, if the stateful session bean uses container
managed transaction demarcation, and the entity manager is not already
associated with the current JTA transaction, the container associates
the entity manager with the current JTA transaction and, if the
persistence context is of type _SynchronizationType.SYNCHRONIZED_, the
container calls _EntityManager.joinTransaction_. If there is a
different persistence context already associated with the JTA
transaction, the container throws the _EJBException_.
* When a business method of the stateful
session bean is invoked, if the stateful session bean uses bean managed
transaction demarcation and a UserTransaction is begun within the
method, the container associates the persistence context with the JTA
transaction and, if the persistence context is of type
_SynchronizationType.SYNCHRONIZED_, the container calls
_EntityManager.joinTransaction_.

The container must throw the
_IllegalStateException_ if the application calls _EntityManager.close_
on a container-managed entity manager.

When the container creates an entity manager,
it may pass a map of properties to the persistence provider by using the
_EntityManagerFactory.createEntityManager(Map map)_ method. If
properties have been specified in the _PersistenceContext_ annotation or
the _persistence-context-ref_ deployment descriptor element, this method
must be used and the map must include the specified properties.

If the application invokes
_EntityManager.unwrap(Class<T> cls)_, and the container cannot satisfy
the request, the container must delegate the _unwrap_ invocation to the
provider's entity manager instance.

==== Provider Responsibilities

The Provider has no knowledge of the
distinction between transaction-scoped and extended persistence
contexts. It provides entity managers to the container when requested
and registers for transaction synchronization notifications.

* When
_EntityManagerFactory.createEntityManager_ is invoked, the provider must
create and return a new entity manager. If a JTA transaction is active
and the persistence context is of type
_SynchronizationType.SYNCHRONIZED_, the provider must register for
synchronization notifications against the JTA transaction.
* When _EntityManager.joinTransaction_ is
invoked, the provider must register for synchronization notifications
against the current JTA transaction if a previous _joinTransaction_
invocation for the transaction has not already been processed.
* When the JTA transaction commits, if the
persistence context is of type _SynchronizationType.SYNCHRONIZED_ or has
otherwise been joined to the transaction, the provider must flush all
modified entity state to the database.
* When the JTA transaction rolls back, the
provider must detach all managed entities if the persistence context is
of type _SynchronizationType.SYNCHRONIZED_ or has otherwise been joined
to the transaction. Note that the JTA transaction may rollback in a
background thread (e.g., as a result of transaction timeout), in which
case the provider should arrange for the managed entities to be detached
from the persistence context but not concurrently while the application
is in an EntityManager invocation.
* When the provider throws an exception defined
to cause transaction rollback, the provider must mark the transaction
for rollback if the persistence context is of type
_SynchronizationType.SYNCHRONIZED_ or has otherwise been joined to the
transaction.
* When _EntityManager.close_ is invoked, the
provider should release all resources that it may have allocated after
any outstanding transactions involving the entity manager have
completed. If the entity manager was already in a closed state, the
provider must throw the _IllegalStateException_.
* When _EntityManager.clear_ is invoked, the
provider must detach all managed entities.

=== Cache Interface [[a12124]]

The _Cache_ interface provides basic
functionality over the persistence provider's second level cache, if
used.

[source,java]
----
package jakarta.persistence;

/**
 * Interface used to interact with the second-level cache.
 * If a cache is not in use, the methods of this interface have
 * no effect, except for <code>contains</code>, which returns false.
 *
 * @since 2.0
 */
public interface Cache {

    /**
     * Whether the cache contains data for the given entity.
     * @param cls  entity class
     * @param primaryKey  primary key
     * @return boolean indicating whether the entity is in the cache
     */
    public boolean contains(Class cls, Object primaryKey);

    /**
     * Remove the data for the given entity from the cache.
     * @param cls  entity class
     * @param primaryKey  primary key
     */
    public void evict(Class cls, Object primaryKey);

    /**
     * Remove the data for entities of the specified class (and its
     * subclasses) from the cache.
     * @param cls  entity class
     */
    public void evict(Class cls);

    /**
     * Clear the cache.
     */
    public void evictAll();

    /**
     * Return an object of the specified type to allow access to the
     * provider-specific API.  If the provider's Cache
     * implementation does not support the specified class, the
     * PersistenceException is thrown.
     * @param cls  the class of the object to be returned.  This is
     * normally either the underlying Cache implementation
     * class or an interface that it implements.
     * @return an instance of the specified class
     * @throws PersistenceException if the provider does not
     * support the call
     * @since 2.1
     */
    public <T> T unwrap(Class<T> cls);
}
----

=== PersistenceUnitUtil Interface [[a12177]]

The _PersistenceUnitUtil_ interface provides
access to utility methods that can be invoked on entities associated
with the persistence unit. The behavior is undefined if these methods
are invoked on an entity instance that is not associated with the
persistence unit from whose entity manager factory this interface has
been obtained.

[source,java]
----
package jakarta.persistence;

/**
 * Utility interface between the application and the persistence
 * provider managing the persistence unit.
 *
 * <p>The methods of this interface should only be invoked on entity
 * instances obtained from or managed by entity managers for this
 * persistence unit or on new entity instances.
 *
 * @since 2.0
 */
public interface PersistenceUnitUtil extends PersistenceUtil {

    /**
     * Determine the load state of a given persistent attribute
     * of an entity belonging to the persistence unit.
     * @param entity  entity instance containing the attribute
     * @param attributeName name of attribute whose load state is
     *        to be determined
     * @return false if entity's state has not been loaded or if
     *         the attribute state has not been loaded, else true
     */
    public boolean isLoaded(Object entity, String attributeName);

    /**
     * Determine the load state of an entity belonging to the
     * persistence unit.  This method can be used to determine the
     * load state of an entity passed as a reference.  An entity is
     * considered loaded if all attributes for which
     * <code>FetchType.EAGER</code> has been specified have been
     * loaded.
     * <p> The <code>isLoaded(Object, String)</code> method
     * should be used to determine the load state of an attribute.
     * Not doing so might lead to unintended loading of state.
     * @param entity   entity instance whose load state is to be determined
     * @return false if the entity has not been loaded, else true
     */
    public boolean isLoaded(Object entity);

    /**
     *  Return the id of the entity.
     *  A generated id is not guaranteed to be available until after
     *  the database insert has occurred.
     *  Returns null if the entity does not yet have an id.
     *  @param entity  entity instance
     *  @return id of the entity
     *  @throws IllegalArgumentException if the object is found not
     *          to be an entity
     */
    public Object getIdentifier(Object entity);
}
----