//
// Copyright (c) 2017, 2020 Contributors to the Eclipse Foundation
//

== Entities

An entity is a lightweight persistent domain object.footnote:[An entity
instance is a local object inaccessible to remote processes. If instances
of an entity are to be passed by value as detached objects (e.g., via a
remote interface), the entity class must be serializable.] Entities support
inheritance, polymorphic associations, and polymorphic queries.

The primary programming artifact is the _entity class_. An entity class
may make use of auxiliary classes that serve as helper classes or that
are used to represent the state of the entity.

This chapter describes requirements on entity classes and instances.

=== The Entity Class [[a18]]

The entity class must be annotated with the `Entity` annotation or
declared as an `entity` in its XML descriptor.

- The entity class must be a top-level class or a static inner class.
  An enum, record, or interface may not be designated as an entity.

- The entity class must have a `public` or `protected` constructor with no
  parameters, which is called by the persistence provider runtime to
  instantiate the entity.footnote:[The term "persistence provider runtime"
  refers to the runtime environment of the persistence implementation. In
  a JakartaEE environment, this might be the Jakarta EE container itself,
  or a third-party persistence provider implementation integrated with the
  container.] This constructor is usually declared in the Java source code,
  but it might be added using source or bytecode processing by the build
  process or runtime environment.footnote:[When the constructor is added
  by tooling or by the container, the entity source code is not portable
  to environments where such tooling is unavailable.] The entity class
  may have additional constructors for use by the application.

- The entity class must be non-`final`. Every method and persistent
  instance variable of the entity class must also be non-`final`.

An entity might be an abstract class, or it might be a concrete class.
An entity may extend a non-entity class, or it may extend another entity
class. A non-entity class may extend an entity class.

The persistent state of an entity is represented by instance variables,
which may correspond to JavaBeans properties. An instance variable may
be directly accessed only within the methods of the entity, by the
entity instance itself. An instance variable of an entity must _not_ be
directly accessed by a client of the entity. The state of the entity is
available to clients only through the methods of the entity--that is,
via accessor (getter/setter) methods, or via other business methods.

=== Persistent Fields and Properties [[a19]]

The persistent state of an entity is accessed by the persistence provider
runtime via either:

- _property access_ using JavaBeans-style property accessors, or
- _field access_, that is, direct access to instance variables.

The instance variables of a class must have `private`, `protected`, or package
visibility, independent of whether field access or property access is used.
When property access is used, the property accessor methods must be `public`
or `protected`.

The type of a persistent field or property of an entity class may be:

- any basic type listed below in <<a486>>, including any Java `enum` type,
- an entity type or a collection of some entity type, as specified in <<a516>>,
- an embeddable class, as defined in <<a487>>, or
- a collection of a basic type or embeddable type, as specified in <<a494>>.

Object/relational mapping metadata may be specified to customize the
object/relational mapping and the loading and storing of the entity state
and relationships, as specified in <<a13915>>.

The placement of object/relational mapping annotations depends on whether
property access or field access is used:

- When field access is used, mapping annotations must be placed on instance
  variables, and the persistence provider runtime accesses instance variables
  directly. Every non-`transient` instance variable not annotated with the
  `Transient` annotation is persistent.

- When property-based access is used, mapping annotations must be placed on
  getter methodsfootnote:[These annotations must not be applied to the setter
  methods.], and the persistence provider runtime accesses persistent state
  via the property accessor methods. Every property not annotated with the
  `Transient` annotation is persistent.

Mapping annotations must not be applied to a field or property marked `static`,
`transient`, or `@Transient`, since the field or property is not persistent.

Whether property access, field access, or a mix of the two options is used by
the provider to access the persistent state of a given entity class or entity
hierarchy is determined by the rules defined in <<a113>>.

[NOTE]
Terminology Note: The persistent fields and properties of an entity class
are generically referred to in this document as _attributes_ of the class.

Collection-valued persistent fields and properties must be defined in
terms of one of the following collection-valued interfaces, regardless
of whether the entity class otherwise adheres to the JavaBeans method
conventions noted below, and of whether field or property access is used:
`java.util.Collection`, `java.util.Set`, `java.util.List` footnote:[Portable
applications should not expect the order of a list to be maintained across
persistence contexts unless the `OrderColumn` or `OrderBy` annotation is
used and modifications to the list observe the specified ordering.],
`java.util.Map`.

Use of the generic variants of these collection types is strongly encouraged,
for example, `Set<Order>` is preferred to the raw type `Set`.

[NOTE]
Terminology Note: The terms _collection_ and _collection-valued_ are used
in this specification to denote any of the above types, unless further
qualified. In cases where a `java.util.Collection` type--or one of its
subtypes--must be distinguished, the type is identified explicitly. The
terms _map_ and _map collection_ are used to denote a collection of type
`java.util.Map`.

A collection implementation type such as `HashSet` or `ArrayList` may be
used by the application to initialize a collection-valued field or property
before the entity is made persistent. Once the entity becomes managed
(or detached), subsequent access to the collection must be through the
interface type. The persistence provider runtime is permitted to replace,
at any time, any reference held by an entity to a collection instantiated by
the application with a different provider-specific object implementing the
same interface type.

==== Persistent Attribute Type

The enumeration `jakarta.persistence.metamodel.Attribute.PersistentAttributeType`
defines a classification of persistent entity attributes: `BASIC` for
basic attributes, `EMBEDDED` for embedded attributes, `ELEMENT_COLLECTION`
for element collections, and `MANY_TO_ONE`, `ONE_TO_ONE`, `ONE_TO_MANY`,
and `MANY_TO_MANY` for associations of the indicated multiplicity.
Each persistent attribute of an entity belongs to exactly one of the
listed types.

It is an error for an attribute of an entity to be annotated with
mapping annotations indicating conflicting persistent attribute types.
For example, a field must not be annotated `@Basic @Embedded`,
`@ManyToOne @ElementCollection`, or `@OneToOne @ManyToMany`. The
persistence provider must detect such contradictory combinations of
mapping annotations and report the error.footnote:[A persistence
provider is permitted--but not required--to accept the combinations
`@Basic @ElementCollection` and `@Embedded @ElementCollection`.]

==== Property Access

When property access is used, persistent properties of the entity class
must follow the method signature conventions for JavaBeans read/write
properties, as defined by the JavaBeans `Introspector` class. For every
persistent property `property` of type `T` of the entity, there must be
a getter method, `getProperty`, and setter method `setProperty`. For
boolean properties, `isProperty` may be used as an alternative name for
the getter method.footnote:[Specifically, if `getX` is the name of the
getter method and `setX` is the name of the setter method, where `X` is
any string, the name of the persistent property is obtained by calling
`java.beans.Introspector.decapitalize(X)`.]

For single-valued persistent properties, these method signatures are:

[source,java]
----
T getProperty()

void setProperty(T t)
----

For collection-valued persistent properties, the type `T` in the method
signatures above must be one of the collection interface types listed
above in <<a19>>.

In addition to returning and setting the persistent state of the entity
instance, a property accessor method may contain additional logic, for
example, logic to perform validation. The persistence provider runtime
triggers execution of this logic when property-based access is used.

Therefore, caution should be exercised in adding business logic to
accessor methods when property access is used. The order in which the
persistence provider runtime calls these methods when loading or storing
persistent state is not defined. Logic contained in such methods should
therefore not rely on any specific invocation order.

If property access is used and lazy fetching is specified, portable
applications should not directly access the entity state underlying the
property methods of managed instances until after it has been fetched by
the persistence provider.footnote:[Lazy fetching is a hint to the
persistence provider and can be specified by means of the
`Basic`, `OneToOne`, `OneToMany`, `ManyToOne`, `ManyToMany`, and
`ElementCollection` annotations and their XML equivalents. See <<a13915>>.]

If a persistence context is joined to a transaction, runtime exceptions
thrown by property accessor methods cause the current transaction to be
marked for rollback; any exception thrown by such methods when called by
the persistence runtime to load or store persistent state causes the
persistence runtime to mark the current transaction for rollback and to
throw a `PersistenceException` wrapping the application exception.

An entity subclass may override a property accessor method inherited
from a superclass. However, portable applications must not override
the object/relational mapping metadata applied to the persistent fields
and properties of entity superclasses.

For example:

[source,java]
----
@Entity
public class Customer implements Serializable {
    private Long id;
    private String name;
    private Address address;
    private Collection<Order> orders = new HashSet();
    private Set<PhoneNumber> phones = new HashSet();

    // No-arg constructor
    public Customer() {}

    @Id // property access is used
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    @OneToMany
    public Collection<Order> getOrders() {
        return orders;
    }

    public void setOrders(Collection<Order> orders) {
        this.orders = orders;
    }

    @ManyToMany
    public Set<PhoneNumber> getPhones() {
        return phones;
    }

    public void setPhones(Set<PhoneNumber> phones) {
        this.phones = phones;
    }

    // Business method to add a phone number to the customer
    public void addPhone(PhoneNumber phone) {
        this.getPhones().add(phone);

        // Update the phone entity instance to refer to this customer
        phone.addCustomer(this);
    }
}
----

=== Access Type [[a113]]

An _access type_ determines how the persistence provider runtime reads
and writes the persistent state of an entity from and to an instance of
the entity class, as specified above in <<a19>>.
`AccessType` enumerates the two possibilities:

[source,java]
----
public enum AccessType {
    FIELD,
    PROPERTY
}
----

The access type for a persistent attribute depends on the placement of
object/relational mapping annotations in the entity class, and may be
explicitly overridden via use of the `Access` annotation defined in
<<a13941>>.

==== Default Access Type

By default, a single access type (`FIELD` or `PROPERTY`) is inferred for
an entity hierarchy. The _default access type_ of an entity hierarchy is
determined by the placement of mapping annotations on the attributes of
the entity classes and mapped superclasses of the entity hierarchy which
do not explicitly specify an access type.

- If mapping annotations are placed on instance variables, `FIELD` access
  is inferred.
- If mapping annotations are placed on getter methods, `PROPERTY` access
  is inferred.

An access type may be explicitly specified by means of the `Access`
annotationfootnote:[The use of XML as an alternative and the interaction
between Java language annotations and XML elements in defining default
and explicit access types is described in <<a16944>>.], as described
below in <<a122>>.

Every class in an entity hierarchy whose access type is defaulted in this
way must be consistent in its placement of mapping annotations on either
fields or properties, such that a single, consistent default access type
applies within the hierarchy. Any embeddable class used by an entity within
the hierarchy has the same access type as the default access type of the
hierarchy unless the `Access` annotation is specified, as defined below.

It is an error if a default access type cannot be determined and an access
type is not explicitly specified by a class-level `Access` annotation or
the XML descriptor. The behavior of applications which mix the placement
of mapping annotations on fields and properties within an entity hierarchy
without explicitly specifying the class-level `Access` annotation is
undefined.footnote:[An `Access` annotation of a field or property getter
is considered a "mapping annotation" for the purposes of this section.
Therefore, an attribute-level `Access` annotation may not be used to
selectively override the access type of an attribute of an entity class
with a defaulted access type.]

==== Explicit Access Type [[a122]]

The access type of an individual entity class, mapped superclass, or
embeddable class may be specified for that class, independent of the
default for the entity hierarchy to which it belongs, by annotating the
class with the `Access` annotation.

- When `Access(FIELD)` is applied to an entity class, mapped superclass,
  or embeddable class, mapping annotations may be placed on the instance
  variables of that class, and the persistence provider runtime accesses
  persistent state via direct access to the instance variables declared
  by the class. Every non-`transient` instance variable not annotated
  with the `Transient` annotation is persistent.

- When `Access(PROPERTY)` is applied to an entity class, mapped superclass,
  or embeddable class, mapping annotations may be placed on the properties
  of that class, and the persistence provider runtime accesses persistent
  state via the properties declared by that class. Every property not
  annotated with the `Transient` annotation is persistent.

The explicit access type may be overridden at the attribute level. That
is, a class which explicitly specifies an access type using the `Access`
annotation may also have fields or properties annotated `Access`, and so
the class may have a mix of access types.

- When `Access(FIELD)` is specified at the class level, an individual
  attribute within the class may be selectively designated for property
  access by annotating a property getter `Access(PROPERTY)`. Mapping
  annotations for this attribute must be placed on the getter. If a
  mapping annotation is placed on a property getter which is not
  annotated `Access(PROPERTY)`, the behavior is undefined.

- When `Access(PROPERTY)` is specified at the class level, an individual
  attribute within the class may be selectively designated for field
  access by annotating an instance variable `Access(FIELD)`. Mapping
  annotations for this attribute must be placed on the field. If a mapping
  annotation is placed on a field which is not annotated `Access(FIELD)`,
  the behavior is undefined.

It is permitted (but redundant) to place `Access(FIELD)` on a field whose
class has field access or `Access(PROPERTY)` on a property whose class has
property access. On the other hand, the behavior is undefined if:

- `Access(PROPERTY)` annotates a field,
- `Access(FIELD)` annotates a property getter, or
- the `Access` annotation occurs on a property setter.

Portable application should avoid such misplaced `@Access` annotations.

When access types are combined within a class, the `Transient` annotation
should be used to avoid duplicate persistent mappings. For example:

[source,java]
----
@Entity @Access(PROPERTY)
public class Customer {
    private Long id;

    @Access(FIELD) // use field access for name
    private String name;

    @Id
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Transient // suppress duplicated name attribute
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    ...
}
----

The `Access` annotation does not affect the access type of other entity
classes or mapped superclasses in the entity hierarchy. In particular,
persistent state inherited from a superclass is always accessed according
to the access type of that superclass.

==== Access Type of an Embeddable Class

The access type of an embeddable class is determined by the access type of
the entity class, mapped superclass, or embeddable class in which it is
embedded (including as a member of an element collection) independent of
whether the access type of the containing class is explicitly specified or
defaulted. A different access type for an embeddable class can be specified
for that embeddable class by means of the `Access` annotation as described
above in <<a122>>.

==== Defaulted Access Types of Embeddable Classes and Mapped Superclasses

Care must be taken when implementing an embeddable class or mapped superclass
which is used both in a context of field access and in a context of property
access, and whose access type is not explicitly specified by means of the
`Access` annotation or XML mapping file.

Such a class should be implemented so that the number, names, and types of
its persistent attributes are independent of the access type in use. If an
embeddable class violates this principle, and if it is used in contexts of
non-uniform access type, the representation of the embeddable class in the
metamodel API defined in <<a6072>> is undefined and unportable.

=== Primary Keys and Entity Identity [[a132]]

Every entity must have a primary key. The value of its primary key uniquely
identifies an entity instance within a persistence context and to operations
of the `EntityManager` or `EntityAgent`, as described in <<a1060>>.

The primary key must be declared by:

- the entity class that is the root of the entity hierarchy, or
- a mapped superclass that is a (direct or indirect) superclass of all
  entity classes in the entity hierarchy.

A primary key must be defined exactly once in each entity hierarchy.

A primary key comprises one or more fields or properties (attributes)
of the entity class.

- A _simple primary key_ is a single persistent field or property of the
  entity class whose type is one of the legal simple primary key types
  listed below. The `Id` annotation defined in <<a14827>> or `id` XML
  element must be used to identify the simple primary key.
- A _composite primary key_ may be declared as either a single persistent
  field or property, or as a set of fields or properties, as described
  below.footnote:[Composite primary keys often arise when mapping a legacy
  database with primary keys comprising multiple columns.] A _primary key
  class_ must be defined to represent the composite primary key.
  * If the composite primary key is represented by a single field or
    property of the entity, the `EmbeddedId` annotation defined by
    <<a14687>> identifies the primary key, and the type of the annotated
    field or property is the primary key class.
  * Otherwise, when the composite primary key encompasses multiple fields
    or properties, the `Id` annotation defined by <<a14827>> identifies
    the fields and properties which belong to the composite key, and the
    `IdClass` annotation defined by <<a14836>> must specify the primary
    key class.

A simple primary key or a field or property belonging to a composite primary
key must have one of the following basic types:

- any Java primitive type, or `java.lang` wrapper for a primitive type,
  footnote:[Although tolerated by Jakarta Persistence, approximate numeric
  types (floating point types) should never be used in primary keys.]
- `java.lang.String`,
- `java.util.UUID`,
- `java.time.LocalDate`, `java.util.Date`, or `java.sql.Date`,
- `BigDecimal` or `BigInteger` from `java.math`.

If a primary key field or property has type `java.util.Date`, the temporal
type must be explicitly specified as `DATE` using the `Temporal` annotation
defined by <<a16361>>, or by equivalent XML.

If the primary key is a composite primary key derived from the primary
key of another entity, the primary key may contain an attribute whose
type is that of the primary key of the referenced entity, as specified
below in <<a149>>.

An entity with a primary key involving any type other than the types
listed above is not portable. If the primary key is generated by the
persistence provider, as defined by <<a14790>>, and its type is not
`long`, `int`, `java.util.UUID`, `java.lang.String`, `java.lang.Long`,
or `java.lang.Integer`, the entity is not portable.

The application must not change the value of the primary key of an entity
instance after the instance is made persistentfootnote:[This includes not
changing the value of a mutable type that is primary key or an attribute of
a composite primary key.]. If the application does change the value of a
primary key of an entity instance after the entity instance is made
persistent, the behavior is undefined.footnote:[The implementation may, but
is not required to, throw an exception. Portable applications must not rely
on any such specific behavior.]

==== Composite primary keys

The following rules apply to composite primary keys:

- The primary key class may be a non-abstract regular Java class with a
  `public` or `protected` constructor with no parameters. Alternatively,
  the primary key class may be any Java record type, in which case it
  is not required to have a constructor with no parameters.

- The access type (`FIELD` or `PROPERTY`) of a primary key class is
  determined by the access type of the entity for which it is the primary
  key, unless the primary key is an embedded id and an explicit access type
  is specified using the `Access` annotation, as defined in <<a122>>.

- If property-based access is used, the property accessors of the primary
  key class must be `public` or `protected`.

- The primary key class must define `equals` and `hashCode` methods. The
  semantics of value equality for these methods must be consistent with the
  database equality for the database types to which the key is mapped.

- A composite primary key must either be represented and mapped as an
  embeddable class (see <<a14687>>) or it must be represented as an id
  class and mapped to multiple fields or properties of the entity class
  (see <<a14836>>).

- If the composite primary key is represented as an id class, the names
  of the primary key fields or properties of the primary key class and
  those of the entity class to which the id class is mapped must match
  and their types must be the same, unless the primary key involves a
  derived identity.

- A primary key which involves a derived identity must conform to the
  rules specified below in <<a149>>.

==== Primary Keys Involving Derived Identities [[a149]]

The identity of an entity is said to be partially _derived_ from the
identity of a second entity when the _child_ or _dependent_ first entity
is the owner of a many-to-one or one-to-one relationship which targets
the _parent_ second entity and the foreign key referencing the parent
entity forms part of the primary key of the dependent entity.

A derived identity might be represented as a simple primary key or as a
composite primary key, as described in <<a155>> below. The dependent
entity class has a composite primary key if

- it declares one or more primary key attributes in addition to those
  corresponding to the primary key of the parent, or
- the parent itself has a composite primary key

and then an embedded id or id class must be used to represent the primary
key of the dependent entity. In the case that the parent has a composite
key, it is _not_ required that parent entity and dependent entity both use
embedded ids, nor that both use id classes.

A `ManyToOne` or `OneToOne` relationship which maps a primary key column
or columns may be declared using either:

- the `Id` annotation, when no other `Id` or `EmbeddedId` attribute maps
  the same primary key column or columns, or
- the `MapsId` annotation, if some other attribute or attributes annotated
  `Id` or `EmbeddedId` also map the primary key column or columns.

If a `ManyToOne` or `OneToOne` relationship declared by a dependent
entity is annotated `Id` or `MapsId`, an instance of the entity cannot be
made persistent until the relationship has been assigned a reference to an
instance of the parent entity, since the identity of the dependent entity
declaring the relationship is derived from the referenced parent entity.
footnote:[If the application does not set a primary key attribute mapped
to the same column or columns as the relationship, the value of that
attribute might not be available until after the entity has been flushed
to the database.]

A dependent entity may have more than one parent entity.

===== Specification of Derived Identities [[a155]]

If a dependent entity uses an id class to represent its primary key,
one of the two following rules must be observed:

- The names and types of the attributes of the id class and the `Id`
  attributes of the dependent entity class must correspond as follows:

* The `Id` attribute of the dependent entity class and the corresponding
  attribute in the id class must have the same name.

* If an `Id` attribute of the dependent entity class is of basic type,
  the corresponding attribute in the id class must have the same type.

* If an `Id` attribute of the entity is a `ManyToOne` or `OneToOne`
  relationship to the parent entity, the corresponding attribute in the
  id class must be of the same Java type as the id class or embedded id
  of the parent entity (if the parent entity has a composite primary key)
  or the type of the `Id` attribute of the parent entity (if the parent
  entity has a simple primary key).

- Alternatively, if the dependent entity declares a single primary key
  attribute, that is, a `OneToOne` relationship attribute annotated `Id`,
  then the id class specified by the dependent entity must be the same as
  the primary key class of the parent entity.

If a dependent entity uses an embedded id to represent its primary key,
the relationship attribute which targets the parent entity must be annotated
`MapsId`.

- If the embedded id of the dependent entity is of the same Java type as
  the primary key of the parent entity, then the relationship attribute maps
  both the relationship to the parent and the primary key of the dependent
  entity, the relationship attribute must be a `OneToOne` association, and
  the `MapsId` annotation must leave the `value` element unspecified.
  footnote:[The primary key of the parent might be represented as an embedded
  id or as an id class.]

- Otherwise, the `value` element of the `MapsId` annotation must specify
  the name of the attribute within the embedded id to which the relationship
  attribute corresponds and this attribute of the embedded id must be of the
  same type as the primary key of the parent entity.

An attribute of an embedded id which corresponds to a relationship targeting
a parent entity is treated by the provider as “read only”—that is, any direct
mutation of the attribute is not propagated to the database.

If a dependent entity has a single primary key attribute annotated `Id`,
and the primary key of the parent entity is a simple primary key, then
the primary key of the dependent entity is a simple primary key of the
same Java type as that of the parent entity, the relationship attribute
must be a `OneToOne` association targeting the parent entity, and either:

1. the primary key attribute annotated `Id` is the relationship attribute
   itself, or
2. the primary key attribute annotated `Id` has the same type as the simple
   primary key of the parent entity, the relationship attribute is annotated
   `MapsId`, and the `value` element of the `MapsId` annotation is left
   unspecified.

Neither `EmbeddedId` nor `IdClass` is specified for the dependent entity.

===== Mapping of Derived Identities

A dependent entity has derived primary key attributes, and might also have
additional primary key attributes which are not derived from any parent
entity.

- Any primary key attribute of a dependent entity which is derived from the
  identity of a parent entity is mapped by annotations of the corresponding
  `ManyToOne` or `OneToOne` relationship attribute. The default mapping for
  this relationship is specified in <<a538>>. The default mapping may be
  overridden by annotating the relationship attribute with the `JoinColumn`
  or `JoinColumns` annotation.

- If the dependent entity uses an id class, the `Column` annotation may be
  used to override the default mapping of `Id` attributes which are `not`
  derived from any parent entity.

- If the dependent entity uses an embedded id to represent its primary key,
  the `AttributeOverride` annotation applied to the `EmbeddedId` attribute
  may be used to override the default mapping of embedded id attributes which
  are _not_ derived from any parent entity.

===== Examples of Derived Identities

The following examples illustrate the rules specified above.

*Example 1:*

The parent entity has a simple primary key:

[source,java]
----
@Entity
public class Employee {
    @Id long empId;
    String empName;

    // ...
}
----

*Case (a):* The dependent entity uses `IdClass` to represent a composite key:

[source,java]
----
public class DependentId {
    String name; // matches name of @Id attribute
    long emp; // matches name of @Id attribute and type of Employee PK
}

@Entity
@IdClass(DependentId.class)
public class Dependent {
    @Id String name;

    // id attribute mapped by join column default
    @Id @ManyToOne
    Employee emp;

    // ...
}
----

Sample query:

[source,sql]
----
SELECT d
FROM Dependent d
WHERE d.name = 'Joe' AND d.emp.empName = 'Sam'
----

*Case(b):* The dependent entity uses `EmbeddedId` to represent a composite key:

[source,java]
----
@Embeddable
public class DependentId {
    String name;
    long empPK; // corresponds to PK type of Employee
}

@Entity
public class Dependent {
    @EmbeddedId DependentId id;

    // id attribute mapped by join column default
    @MapsId("empPK") // maps empPK attribute of embedded id
    @ManyToOne
    Employee emp;

    // ...
}
----

Sample query:

[source,sql]
----
SELECT d
FROM Dependent d
WHERE d.id.name = 'Joe' AND d.emp.empName = 'Sam'
----

*Example 2:*

The parent entity uses `IdClass`:

[source,java]
----
public class EmployeeId {
    String firstName;
    String lastName;

    // ...
}

@Entity
@IdClass(EmployeeId.class)
public class Employee {
    @Id String firstName
    @Id String lastName

   // ...
}
----

*Case (a):* The dependent entity uses `IdClass`:

[source,java]
----
public class DependentId {
    String name; // matches name of attribute
    EmployeeId emp; //matches name of attribute and type of Employee PK
}

@Entity
@IdClass(DependentId.class)
public class Dependent {
    @Id
    String name;

    @Id
    @JoinColumns({
        @JoinColumn(name="FK1", referencedColumnName="firstName"),
        @JoinColumn(name="FK2", referencedColumnName="lastName")
    })

    @ManyToOne
    Employee emp;
}
----

Sample query:

[source,sql]
----
SELECT d
FROM Dependent d
WHERE d.name = 'Joe' AND d.emp.firstName = 'Sam'
----

*Case (b):* The dependent entity uses
`EmbeddedId`. The type of the `empPK` attribute is the same as that of
the primary key of `Employee`. The `EmployeeId` class needs to be
annotated `Embeddable` or denoted as an embeddable class in the XML
descriptor.

[source,java]
----
@Embeddable
public class DependentId {
    String name;
    EmployeeId empPK;
}

@Entity
public class Dependent {
    @EmbeddedId
    DependentId id;

    @MapsId("empPK")
    @JoinColumns({
        @JoinColumn(name="FK1", referencedColumnName="firstName"),
        @JoinColumn(name="FK2", referencedColumnName="lastName")
    })

    @ManyToOne
    Employee emp;

    // ...
}
----

Sample query:

[source,sql]
----
SELECT d
FROM Dependent d
WHERE d.id.name = 'Joe' AND d.emp.firstName = 'Sam'
----

Note that the following alternative query
will yield the same result:

[source,sql]
----
SELECT d
FROM Dependent d
WHERE d.id.name = 'Joe' AND d.id.empPK.firstName = 'Sam'
----

*Example 3:*

The parent entity uses `EmbeddedId`:

[source,java]
----
@Embeddable
public class EmployeeId {
    String firstName;
    String lastName;

    // ...
}

@Entity
public class Employee {
    @EmbeddedId
    EmployeeId empId;

    // ...
}
----

*Case (a):* The dependent entity uses `IdClass`:

[source,java]
----
public class DependentId {
    String name; // matches name of @Id attribute
    EmployeeId emp; // matches name of @Id attribute and type of embedded id of Employee
}

@Entity
@IdClass(DependentId.class)
public class Dependent {
    @Id
    @Column(name="dep_name") // default column name is overridden
    String name;

    @Id
    @JoinColumns({
        @JoinColumn(name="FK1", referencedColumnName="firstName"),
        @JoinColumn(name="FK2", referencedColumnName="lastName")
    })

    @ManyToOne Employee
    emp;
}
----

Sample query:

[source,sql]
----
SELECT d
FROM Dependent d
WHERE d.name = 'Joe' and d.emp.empId.firstName = 'Sam'
----

*Case (b):* The dependent entity uses `EmbeddedId`:

[source,java]
----
@Embeddable
public class DependentId {
    String name;
    EmployeeId empPK; // corresponds to PK type of Employee
}

@Entity
public class Dependent {
    // default column name for "name" attribute is overridden
    @AttributeOverride(name="name", column=@Column(name="dep_name"))
    @EmbeddedId DependentId id;

    @MapsId("empPK")
    @JoinColumns({
        @JoinColumn(name="FK1", referencedColumnName="firstName"),
        @JoinColumn(name="FK2", referencedColumnName="lastName")
    })
    @ManyToOne
    Employee emp;

    // ...
}
----

Sample query:

[source,sql]
----
SELECT d
FROM Dependent d
WHERE d.id.name = 'Joe' and d.emp.empId.firstName = 'Sam'
----

Note that the following alternative query will yield the same result:

[source,sql]
----
SELECT d
FROM Dependent d
WHERE d.id.name = 'Joe' AND d.id.empPK.firstName = 'Sam'
----

*Example 4:*

The parent entity has a simple primary key:

[source,java]
----
@Entity
public class Person {
    @Id
    String ssn;

    // ...
}
----

*Case (a):* The dependent entity has a
single primary key attribute which is mapped by the relationship
attribute. The primary key of `MedicalHistory` is of type `String`.

[source,java]
----
@Entity
public class MedicalHistory {
    // default join column name is overridden
    @Id
    @OneToOne
    @JoinColumn(name="FK")
    Person patient;

    // ...
}
----

Sample query:

[source,sql]
----
SELECT m
FROM MedicalHistory m
WHERE m.patient.ssn = '123-45-6789'
----

*Case (b):* The dependent entity has
a single primary key attribute corresponding to the relationship
attribute. The primary key attribute is of the same basic type as the
primary key of the parent entity. The `MapsId` annotation applied to the
relationship attribute indicates that the primary key is mapped by the
relationship attribute.footnote:[Note that the use of
PrimaryKeyJoinColumn instead of MapsId would result in the same mapping
in this example. Use of MapsId is preferred for the mapping of derived
identities.]

[source,java]
----
@Entity
public class MedicalHistory {
    @Id
    String id; // overriding not allowed

    // ...

    // default join column name is overridden
    @MapsId
    @JoinColumn(name="FK")
    @OneToOne
    Person patient;

    // ...
}
----

Sample query:

[source,sql]
----
SELECT m
FROM MedicalHistory m WHERE m.patient.ssn = '123-45-6789'
----

*Example 5:*

The parent entity uses `IdClass`. The
dependent's primary key class is of same type as that of the parent
entity.

[source,java]
----
public class PersonId {
    String firstName;
    String lastName;
}

@Entity
@IdClass(PersonId.class)
public class Person {
    @Id
    String firstName;

    @Id
    String lastName;

    // ...
}
----

*Case (a):* The dependent entity uses `IdClass`:

[source,java]
----
@Entity
@IdClass(PersonId.class)
public class MedicalHistory {
    @Id
    @JoinColumns({
        @JoinColumn(name="FK1", referencedColumnName="firstName"),
        @JoinColumn(name="FK2", referencedColumnName="lastName")
    })

    @OneToOne
    Person patient;

    // ...
}
----

Sample query:

[source,sql]
----
SELECT m
FROM MedicalHistory m
WHERE m.patient.firstName = 'Charles'
----

*Case (b):* The dependent entity uses the
`EmbeddedId` and `MapsId` annotations. The `PersonId` class needs to be
annotated `Embeddable` or denoted as an embeddable class in the XML
descriptor.

[source,java]
----
@Entity
public class MedicalHistory {
    // all attributes map to relationship:
    AttributeOverride not allowed

    @EmbeddedId
    PersonId id;

    // ...

    @MapsId
    @JoinColumns({
        @JoinColumn(name="FK1", referencedColumnName="firstName"),
        @JoinColumn(name="FK2", referencedColumnName="lastName")
    })

    @OneToOne Person patient;

    // ...
}
----

Sample query:

[source,sql]
----
SELECT m
FROM MedicalHistory m
WHERE m.patient.firstName = 'Charles'
----

Note that the following alternative query
will yield the same result:

[source,sql]
----
SELECT m
FROM MedicalHistory m
WHERE m.id.firstName = 'Charles'
----

*Example 6:*

The parent entity uses `EmbeddedId`. The
dependent's primary key is of the same type as that of the parent.

[source,java]
----
@Embeddable
public class PersonId {
    String firstName;
    String lastName;
}

@Entity
public class Person {
    @EmbeddedId PersonId id;

    // ...
}
----

*Case (a):* The dependent class uses `IdClass`:

[source,java]
----
@Entity
@IdClass(PersonId.class)
public class MedicalHistory {
    @Id
    @OneToOne
    @JoinColumns({
        @JoinColumn(name="FK1", referencedColumnName="firstName"),
        @JoinColumn(name="FK2", referencedColumnName="lastName")
    })

    Person patient;

    // ...
}
----

*Case (b):* The dependent class uses `EmbeddedId`:

[source,java]
----
@Entity
public class MedicalHistory {
    // All attributes are mapped by the relationship
    // AttributeOverride is not allowed
    @EmbeddedId PersonId id;

    // ...

    @MapsId
    @JoinColumns({
        @JoinColumn(name="FK1", referencedColumnName="firstName"),
        @JoinColumn(name="FK2", referencedColumnName="lastName")
    })
    @OneToOne
    Person patient;

    // ...
}
----

=== Entity Versions [[a2060]]

An entity might have a _version_, a persistent field or property used by
the persistence provider to perform _optimistic lock verification_, as
specified in <<a2059>>. The version field or property holds a version number
or timestamp identifying the revision of the entity data held by an entity
class instance. In the course of performing lifecycle operations involving
the entity instance, the persistence provider gets and sets the version
field or property of the entity instance to determine or modify its version
number or timestamp. The `Version` annotation defined in <<a16432>> or
`version` XML element must be used to explicitly identify the version field
or property of an entity.

An entity class may access the state of its version field or property or
export a method which allows other user-written code to access the version,
but user-written code must not directly modify the value of the version
field or property of an entity instance after the entity is made persistent.
footnote:[Bulk update statements, however, are permitted to set the version
of an entity. See <<a5636>>.] With the exception noted in <<a5636>>, only
the persistence provider is permitted to set or update the entity version.
If the application does directly modify the value of the version field or
property of an entity instance after it is made persistent, the behavior is
undefined.

The version must be of one of the following basic types:

- `int`, `Integer`, `short`, `Short`, `long`, `Long`, or
- `java.time.LocalDateTime`, `java.time.Instant`, or `java.sql.Timestamp`.

A portable application must not declare a version field or property with any
other type.

An entity class should have at most one version. A portable application
must not define an entity class having more than one version field or
property.

The version should be declared by the root entity class in an entity class
hierarchy, or by one of its mapped superclasses. A portable application
must not declare a version field or property in a subclass of the root
class of an entity class hierarchy.

=== Basic Types [[a486]]

The following Java types are considered _basic types_:

- any Java primitive type, or `java.lang` wrapper class for a primitive type,
- `java.lang.String`,
- `java.util.UUID`,
- `BigInteger` or `BigDecimal` from `java.math`,
- `LocalDate`, `LocalTime`, `LocalDateTime`,
  `OffsetTime`, `OffsetDateTime`,
  `Instant`, or `Year` from `java.time`,
- `Date` or `Calendar` footnote:[Note that an instance of `Calendar` must be
  fully initialized for the SQL type it maps.] from `java.util` footnote:[The
  use of `java.util.Calendar` or of `java.util.Date` is strongly discouraged.
  Newly-written programs should use the date/time types defined in the package
  `java.time`.],
- `Date`, `Time`, or `Timestamp` from `java.sql` footnote:[The use of date/time
  types defined in the package `java.sql` is strongly discouraged. Newly-written
  programs should use the date/time types defined in `java.time`.],
- `byte[]` or `char[]`.
- any Java `enum` type,
- any other type which implements `java.io.Serializable`.

Persistence for basic types is defined in <<a14205>> and <<a14719>>.

=== Embeddable Classes [[a487]]

An _embeddable class_ is a fine-grained class that represents part of
the state of an entity. An instance of an embeddable class, unlike an
entity instance, does not have a persistent identity of its own.
Instead, it exists only to represent part of the state of the entity
instance to which it belongs.

An entity may have:

- an _embedded attribute_, that is, single-valued field or property
  whose type is an embeddable class, or even
- a collection-valued attribute whose element type is an embeddable
  class.

An embeddable type may even be used to represent the key or value of
a map.

An embedded object belongs strictly to its owning entity instance and
is not sharable across persistent entity instances; sharing of an
embedded object across multiple managed entity instances has undefined
semantics. A persistence provider is not required to preserve the
identity of the shared state, and this identity is typically not made
persistent in the database.

An embeddable class must be annotated as `Embeddable` or designated as
`embeddable` in its XML descriptor. The access type for an embedded
object is determined as described in <<a113>>.

An embeddable class may be a regular Java class that adheres to the
requirements specified in <<a18>> for entities, with the exception that
an embeddable class is not annotated as `Entity`, and an embeddable
class must not be `abstract`.

Alternatively, an embeddable class may be a Java record type.

An embeddable class may have attributes of basic type, embedded attributes,
collections, and associations:

- An embeddable class may have an embedded field or property. However,
  an embeddable class may not occur, directly or indirectly, as the type
  of one of its own embedded attributes. Circular containment dependencies
  among embeddable classes are not permitted.

- An embeddable class, including an embeddable class embedded within
  another embeddable class, may have a collection-valued field or property
  with elements of basic type or of another embeddable class type.

- An embeddable class may have a relationship to an entity type, even a
  collection-valued relationship to an entity type. Since an instance of
  an embeddable class has no persistent identity, any inverse relationship
  _from_ such a referenced entity must be to the _entity_ that contains the
  embeddable instance and not to the embeddable object itself.footnote:[An
  entity cannot have a unidirectional relationship to an embedded object
  belonging to another entity.] An embeddable class that is used as an
  embedded id or as a map key must not declare such a relationship.

Additional requirements and restrictions on embeddable classes are described
in <<a494>>.

=== Collections of Embeddable Classes and Basic Types [[a494]]

An _element collection_ is a persistent field or property of an entity
or embeddable class that is collection-valued, and whose elements are
of a basic type, as specified above in <<a486>>, or of an embeddable
class, as specified immediately above in <<a487>>.

An element collection must be explicitly declared as such by the
`ElementCollection` annotation or `element-collection` XML element.
If the `ElementCollection` annotation (or XML equivalent) is not
specified for a collection-valued field or property, the rules of
<<a511>> apply.

An element collection maps to a _collection table_, as defined in
<<a14250>>.

An embeddable class, including an embeddable class embedded within
another embeddable class, that is contained, directly or indirectly,
within an element collection:

- must not have its own element collection;
- must not have a one-to-many or many-to-many relationship to an
  entity;
- but it may have a many-to-one or one-to-one association to an
  entity if the relationship is represented by a foreign key
  mapping, as defined in <<a516>>.

=== Map Collections

Element collections and entity relationships can be represented as
`java.util.Map` collections. Every such map collection has a key
type and a value type. A key or value type may be a basic type,
an embeddable class, or an entity type. The key type and map type
are completely independent of each other.

A map collection must be declared using an `ElementCollection`,
`OneToMany`, or `ManyToMany` annotation:

- when the map value type is a basic type or embeddable class,
  the `ElementCollection` annotation is used;
- but when the map value type is an entity, a `OneToMany` or
  `ManyToMany` annotation is used.

If a relationship is bidirectional relationship, only one side of
the relationship may be of type `java.util.Map`.

==== Map Keys

If the map key type is a basic type, the
`MapKeyColumn` annotation can be used to specify the column mapping for
the map key. If the `MapKeyColumn` annotation is not specified, the
default values of the `MapKeyColumn` annotation apply as described in <<a15367>>.

If the map key type is an embeddable class,
the mappings for the map key columns are defaulted according to the
default column mappings for the embeddable class. (See <<a14330>>). The
`AttributeOverride` and `AttributeOverrides` annotations can be used to
override these mappings, as described in <<a14084>> and <<a14178>>. If an
embeddable class is used as a map key, the embeddable class must
implement the `hashCode` and `equals` methods consistently with the
database columns to which the embeddable is
mappedfootnote:[Note that when an
embeddable instance is used as a map key, these attributes represent its
identity. Changes to embeddable instances used as map keys have
undefined behaviour and should be avoided.].

If the map key type is an entity, the
`MapKeyJoinColumn` and `MapKeyJoinColumns` annotations are used to
specify the column mappings for the map key. If the primary key of the
referenced entity is a simple primary key and the `MapKeyJoinColumn`
annotation is not specified, the default values of the
`MapKeyJoinColumn` annotation apply as described in <<a15450>>.

If Java generic types are not used in the
declaration of a relationship attribute of type `java.util.Map`, the
`MapKeyClass` annotation must be used to specify the type of the key of
the map.

The `MapKey` annotation is used to specify
the special case where the map key is itself the primary key or a
persistent field or property of the entity that is the value of the map.
The `MapKeyClass` annotation is not used when `MapKey` is specified.

==== Map Values

When the value type of the map is a basic
type or an embeddable class, a collection table is used to map the map.
If Java generic types are not used, the `targetClass` element of the
`ElementCollection` annotation must be used to specify the value type
for the map. The default column mappings for the map value are derived
according to the default mapping rules for the `CollectionTable`
annotation defined in <<a14250>>. The `Column` annotation is used to override
these defaults for a map value of basic type. The `AttributeOverride(s)` and `AssociationOverride(s)` annotations are used to override
the mappings for a map value that is an embeddable class.

When the value type of the map is an entity,
a join table is used to map the map for a many-to-many relationship or,
by default, for a one-to-many unidirectional relationship. If the
relationship is a bidirectional one-to-many/many-to-one relationship, by
default the map is mapped in the table of the entity that is the value
of the map. If Java generic types are not used, the `targetEntity`
element of the `OneToMany` or `ManyToMany` annotation must be used to
specify the value type for the map. Default mappings are described in
<<a538>>.

=== Mapping Defaults for Non-Relationship Fields or Properties [[a511]]

If a persistent field or property other than a relationship property is
_not_ annotated with one of the mapping annotations defined in <<a13915>>
(and no equivalent mapping information is specified in any XML descriptor),
the following default mapping rules are applied in order:

- If the type of the field or property is a class annotated with the
  `Embeddable` annotation, the field or property is mapped as if it were
  annotated with the `Embedded` annotation. See <<a14634>> and <<a14672>>.
- Otherwise, if the type of the field or property is one of the one of
  the basic types listed in <<a486>>, it is mapped in the same way as if
  it were annotated as `Basic`. See <<a14205>>, <<a14719>>, <<a15087>>,
  and <<a16361>>.

It is an error if no annotation is present and neither of the above rules
apply.

=== Entity Relationships [[a516]]

Relationships among entities may be
one-to-one, one-to-many, many-to-one, or many-to-many. Relationships are
polymorphic.

If there is an association between two
entities, one of the following relationship modeling annotations must be
applied to the corresponding persistent property or field of the
referencing entity: `OneToOne`, `OneToMany`, `ManyToOne`,
`ManyToMany`. For associations that do not specify the target type
(e.g., where Java generic types are not used for collections), it is
necessary to specify the entity that is the target of the
relationship.footnote:[For associations of
type `java.util.Map`, _target type_ refers to the type that is the Map
`value`.] Equivalent XML elements may be used
as an alternative to these mapping annotations.

_These annotations mirror common practice in
relational database schema modeling. The use of the relationship
modeling annotations allows the object/relationship mapping of
associations to the relational database schema to be fully defaulted, to
provide an ease-of-development facility. This is described in <<a538>>._

Relationships may be bidirectional or
unidirectional. A bidirectional relationship has both an owning side and
an inverse (non-owning) side. A unidirectional relationship has only an
owning side. The owning side of a relationship determines the updates to
the relationship in the database, as described in <<a1955>>.

The following rules apply to bidirectional
relationships:

The inverse side of a bidirectional
relationship must refer to its owning side by use of the `mappedBy`
element of the `OneToOne`, `OneToMany`, or `ManyToMany` annotation.
The `mappedBy` element designates the property or field in the entity
that is the owner of the relationship.

* The many side of one-to-many / many-to-one
bidirectional relationships must be the owning side, hence the
`mappedBy` element cannot be specified on the `ManyToOne` annotation.
* For one-to-one bidirectional relationships,
the owning side corresponds to the side that contains the corresponding
foreign key.
* For many-to-many bidirectional relationships
either side may be the owning side.

The relationship modeling annotation
constrains the use of the `cascade=REMOVE` specification. The
`cascade=REMOVE` specification should only be applied to associations
that are specified as `OneToOne` or `OneToMany`. Applications that
apply `cascade=REMOVE` to other associations are not portable.

Associations that are specified as `OneToOne`
or `OneToMany` support use of the `orphanRemoval` option. The following
behaviors apply when `orphanRemoval` is in effect:

* If an entity that is the target of the
relationship is removed from the relationship (by setting the
relationship to null or removing the entity from the relationship
collection), the remove operation will be applied to the entity being
orphaned. The remove operation is applied at the time of the flush
operation. The `orphanRemoval` functionality is intended for entities
that are privately “owned” by their parent entity. Portable applications
must otherwise not depend upon a specific order of removal, and must not
reassign an entity that has been orphaned to another relationship or
otherwise attempt to persist it. If the entity being orphaned is a
detached, new, or removed entity, the semantics of `orphanRemoval` do
not apply.
* If the remove operation is applied to a
managed source entity, the remove operation will be cascaded to the
relationship target in accordance with the rules of <<a1946>>,
(and hence it is not necessary to specify `cascade=REMOVE` for the
relationship)footnote:[If the parent is
detached or new or was previously removed before the orphan was
associated with it, the remove operation is not applied to the entity
being orphaned.].

<<a538>>, defines relationship mapping defaults
for entity relationships. Additional mapping annotations (e.g., column
and table mapping annotations) may be specified to override or further
refine the default mappings and mapping strategies described in <<a538>>.

In addition, this specification also requires
support for the following alternative mapping strategies:

* The mapping of unidirectional one-to-many
relationships by means of foreign key mappings. The `JoinColumn`
annotation or corresponding XML element must be used to specify such
non-default mappings. See <<a14922>>.
* The mapping of unidirectional and
bidirectional one-to-one relationships, bidirectional
many-to-one/one-to-many relationships, and unidirectional many-to-one
relationships by means of join table mappings. The `JoinTable`
annotation or corresponding XML element must be used to specify such
non-default mappings. See <<a15022>>.

Such mapping annotations must be specified on
the owning side of the relationship. Any overriding of mapping defaults
must be consistent with the relationship modeling annotation that is
specified. For example, if a many-to-one relationship mapping is
specified, it is not permitted to specify a unique key constraint on the
foreign key for the relationship.

The persistence provider handles the
object/relational mapping of the relationships, including their loading
and storing to the database as specified in the metadata of the entity
class, and the referential integrity of the relationships as specified
in the database (e.g., by foreign key constraints).

[NOTE]
====
Note that it is the application that bears
responsibility for maintaining the consistency of runtime
relationships—for example, for insuring that the “one” and the “many”
sides of a bidirectional relationship are consistent with one another
when the application updates the relationship at runtime.
====

If there are no associated entities for a
multi-valued relationship of an entity fetched from the database, the
persistence provider is responsible for returning an empty collection as
the value of the relationship.

=== Relationship Mapping Defaults [[a538]]

This section defines the mapping defaults
that apply to the use of the `OneToOne`, `OneToMany`, `ManyToOne`,
and `ManyToMany` relationship modeling annotations. The same mapping
defaults apply when the XML descriptor is used to denote the
relationship cardinalities.

==== Bidirectional OneToOne Relationships

Assuming that:

* Entity A references a single instance of Entity B.
* Entity B references a single instance of Entity A.
* Entity A is specified as the owner of the relationship.

The following mapping defaults apply:

* Entity A is mapped to a table named `A`.
* Entity B is mapped to a table named `B`.
* Table `A` contains a foreign key to table `B`.
The foreign key column name is formed as the concatenation of the
following: the name of the relationship property or field of entity A; "
`_` "; the name of the primary key column in table `B`. The foreign key
column has the same type as the primary key of table `B` and there is a
unique key constraint on it.

*Example:*

[source,java]
----
@Entity
public class Employee {
    private Cubicle assignedCubicle;

    @OneToOne
    public Cubicle getAssignedCubicle() {
        return assignedCubicle;
    }

    public void setAssignedCubicle(Cubicle cubicle) {
        this.assignedCubicle = cubicle;
    }

    // ...
}

@Entity
public class Cubicle {
    private Employee residentEmployee;

    @OneToOne(mappedBy="assignedCubicle")
    public Employee getResidentEmployee() {
        return residentEmployee;
    }

    public void setResidentEmployee(Employee employee) {
        this.residentEmployee = employee;
    }

    // ...
}
----

In this example:

* Entity `Employee` references a single instance of Entity `Cubicle`.
* Entity `Cubicle` references a single instance of Entity `Employee`.
* Entity `Employee` is the owner of the relationship.

The following mapping defaults apply:

* Entity `Employee` is mapped to a table named `EMPLOYEE`.
* Entity `Cubicle` is mapped to a table named `CUBICLE`.
* Table `EMPLOYEE` contains a foreign key to table `CUBICLE`.
The foreign key column is named `ASSIGNEDCUBICLE_<PK of CUBICLE>`,
where `<PK of CUBICLE>` denotes the name of the primary key column
of table `CUBICLE`. The foreign key column has the same type as the
primary key of `CUBICLE`, and there is a unique key constraint on it.

==== Bidirectional ManyToOne / OneToMany Relationships

Assuming that:

* Entity A references a single instance of Entity B.
* Entity B references a collection of Entity Afootnote:[When the relationship
is modeled as a `java.util.Map`, “Entity B references a collection of
Entity A” means that Entity B references a map collection in which the
type of the Map `value` is Entity A. The map key may be a basic type,
embeddable class, or an entity.
].
* Entity A must be the owner of the relationship.

The following mapping defaults apply:

* Entity A is mapped to a table named `A`.
* Entity B is mapped to a table named `B`.
* Table `A` contains a foreign key to table `B`.
The foreign key column name is formed as the concatenation of the
following: the name of the relationship property or field of entity A; "
`_` "; the name of the primary key column in table `B`. The foreign key
column has the same type as the primary key of table `B`.

*Example:*

[source,java]
----
@Entity
public class Employee {
    private Department department;

    @ManyToOne
    public Department getDepartment() {
        return department;
    }

    public void setDepartment(Department department) {
        this.department = department;
    }

    // ...
}

@Entity
public class Department {
    private Collection<Employee> employees = new HashSet();

    @OneToMany(mappedBy="department")
    public Collection<Employee> getEmployees() {
        return employees;
    }

    public void setEmployees(Collection<Employee> employees) {
        this.employees = employees;
    }

    // ...
}
----

In this example:

* Entity `Employee` references a single instance of Entity `Department`.
* Entity `Department` references a collection of Entity `Employee`.
* Entity `Employee` is the owner of the relationship.

The following mapping defaults apply:

* Entity `Employee` is mapped to a table named `EMPLOYEE`.
* Entity `Department` is mapped to a table named `DEPARTMENT`.
* Table `EMPLOYEE` contains a foreign key to table `DEPARTMENT`.
The foreign key column is named `DEPARTMENT_<PK of DEPARTMENT>`,
where `<PK of DEPARTMENT>` denotes the name of the primary key
column of table `DEPARTMENT`. The foreign key column has the same
type as the primary key of `DEPARTMENT`.

==== Unidirectional Single-Valued Relationships

Assuming that:

* Entity A references a single instance of Entity B.
* Entity B does not reference Entity A.

A unidirectional relationship has only an owning side, which in this case must be Entity A.

The unidirectional single-valued relationship
modeling case can be specified as either a unidirectional `OneToOne` or
as a unidirectional `ManyToOne` relationship.

===== Unidirectional OneToOne Relationships [[a640]]

The following mapping defaults apply:

* Entity A is mapped to a table named `A`.
* Entity B is mapped to a table named `B`.
* Table `A` contains a foreign key to table `B`.
The foreign key column name is formed as the concatenation of the
following: the name of the relationship property or field of entity A; "
`_` "; the name of the primary key column in table `B`. The foreign key
column has the same type as the primary key of table `B` and there is a
unique key constraint on it.

*Example:*

[source,java]
----
@Entity
public class Employee {
    private TravelProfile profile;

    @OneToOne
    public TravelProfile getProfile() {
        return profile;
    }

    public void setProfile(TravelProfile profile) {
        this.profile = profile;
    }

    // ...
}

@Entity
public class TravelProfile {
    // ...
}
----

In this example:

* Entity `Employee` references a single instance of Entity `TravelProfile`.
* Entity `TravelProfile` does not reference Entity `Employee`.
* Entity `Employee` is the owner of the relationship.

The following mapping defaults apply:

* Entity `Employee` is mapped to a table named `EMPLOYEE`.
* Entity `TravelProfile` is mapped to a table named `TRAVELPROFILE`.
* Table `EMPLOYEE` contains a foreign key to table `TRAVELPROFILE`.
The foreign key column is named `PROFILE_<PK of TRAVELPROFILE>`,
where `<PK of TRAVELPROFILE>` denotes the name of the primary key
column of table `TRAVELPROFILE`. The foreign key column has the
same type as the primary key of `TRAVELPROFILE`, and there is a
unique key constraint on it.

===== Unidirectional ManyToOne Relationships

The following mapping defaults apply:

* Entity A is mapped to a table named `A`.
* Entity B is mapped to a table named `B`.
* Table `A` contains a foreign key to table `B`. The foreign key column name is formed as the concatenation of the following: the name of the relationship property or field of entity A; "_"; the name of the primary key column in table `B`. The foreign key column has the same type as the primary key of table `B`.

*Example:*

[source,java]
----
@Entity
public class Employee {
    private Address address;

    @ManyToOne
    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    // ...
}

@Entity
public class Address {
    // ...
}
----

In this example:

* Entity `Employee` references a single instance of Entity `Address`.
* Entity `Address` does not reference Entity `Employee`.
* Entity `Employee` is the owner of the relationship.

The following mapping defaults apply:

* Entity `Employee` is mapped to a table named `EMPLOYEE`.
* Entity `Address` is mapped to a table named `ADDRESS`.
* Table `EMPLOYEE` contains a foreign key to table `ADDRESS`.
The foreign key column is named `ADDRESS_<PK of ADDRESS>`,
where `<PK of ADDRESS>` denotes the name of the primary key
column of table `ADDRESS`. The foreign key column has the same
type as the primary key of `ADDRESS`.

==== Bidirectional ManyToMany Relationships [[a708]]

Assuming that:

* Entity A references a collection of Entity B.
* Entity B references a collection of Entity A.
* Entity A is the owner of the relationship.

The following mapping defaults apply:

* Entity A is mapped to a table named `A`.
* Entity B is mapped to a table named `B`.
* There is a join table that is named `A_B`
(owner name first). This join table has two foreign key columns. One
foreign key column refers to table `A` and has the same type as the
primary key of table `A`. The name of this foreign key column is formed
as the concatenation of the following: the name of the relationship
property or field of entity B; " `\_` "; the name of the primary key
column in table `A`. The other foreign key column refers to table `B`
and has the same type as the primary key of table `B`. The name of this
foreign key column is formed as the concatenation of the following: the
name of the relationship property or field of entity A; " `_` "; the
name of the primary key column in table `B`.

*Example:*

[source,java]
----
@Entity
public class Project {
    private Collection<Employee> employees;

    @ManyToMany
    public Collection<Employee> getEmployees() {
        return employees;
    }

    public void setEmployees(Collection<Employee> employees) {
        this.employees = employees;
    }

    // ...
}

@Entity
public class Employee {
    private Collection<Project> projects;

    @ManyToMany(mappedBy="employees")
    public Collection<Project> getProjects() {
        return projects;
    }

    public void setProjects(Collection<Project> projects) {
        this.projects = projects;
    }

    // ...
}
----

In this example:

* Entity `Project` references a collection of Entity `Employee`.
* Entity `Employee` references a collection of Entity `Project`.
* Entity `Project` is the owner of the relationship.

The following mapping defaults apply:

* Entity `Project` is mapped to a table named `PROJECT`.
* Entity `Employee` is mapped to a table named `EMPLOYEE`.
* There is a join table that is named
`PROJECT_EMPLOYEE` (owner name first). This join table has two foreign
key columns. One foreign key column refers to table `PROJECT` and has
the same type as the primary key of `PROJECT`. The name of this foreign
key column is `PROJECTS_<PK of PROJECT>`, where `<PK of PROJECT>` denotes
the name of the primary key column of table `PROJECT`. The other
foreign key column refers to table `EMPLOYEE` and has the same type as
the primary key of `EMPLOYEE`. The name of this foreign key column is
`EMPLOYEES_<PK of EMPLOYEE>`, where `<PK of EMPLOYEE>` denotes the name
of the primary key column of table `EMPLOYEE`.

==== Unidirectional Multi-Valued Relationships [[a758]]

Assuming that:

* Entity A references a collection of Entity B.
* Entity B does not reference Entity A.

A unidirectional relationship has only an owning side, which in this case must be Entity A.

The unidirectional multi-valued relationship
modeling case can be specified as either a unidirectional `OneToMany` or
as a unidirectional `ManyToMany` relationship.

===== Unidirectional OneToMany Relationships [[a764]]

The following mapping defaults apply:

* Entity A is mapped to a table named `A`.
* Entity B is mapped to a table named `B`.
* There is a join table that is named `A_B`
(owner name first). This join table has two foreign key columns. One
foreign key column refers to table `A` and has the same type as the
primary key of table `A`. The name of this foreign key column is formed
as the concatenation of the following: the name of entity A; " `\_` ";
the name of the primary key column in table `A`. The other foreign key
column refers to table `B` and has the same type as the primary key of
table `B` and there is a unique key constraint on it. The name of this
foreign key column is formed as the concatenation of the following: the
name of the relationship property or field of entity A; " `_` "; the
name of the primary key column in table `B`.

*Example:*

[source,java]
----
@Entity
public class Employee {
    private Collection<AnnualReview> annualReviews;

    @OneToMany
    public Collection<AnnualReview> getAnnualReviews() {
        return annualReviews;
    }

    public void setAnnualReviews(Collection<AnnualReview> annualReviews) {
        this.annualReviews = annualReviews;
    }

    // ...
}

@Entity
public class AnnualReview {
    // ...
}
----

In this example:

* Entity `Employee` references a collection of Entity `AnnualReview`.
* Entity `AnnualReview` does not reference Entity `Employee`.
* Entity `Employee` is the owner of the relationship.

The following mapping defaults apply:

* Entity `Employee` is mapped to a table named `EMPLOYEE`.
* Entity `AnnualReview` is mapped to a table named `ANNUALREVIEW`.
* There is a join table that is named
`EMPLOYEE_ANNUALREVIEW` (owner name first). This join table has two
foreign key columns. One foreign key column refers to table `EMPLOYEE`
and has the same type as the primary key of `EMPLOYEE`. This foreign
key column is named `EMPLOYEE_<PK of EMPLOYEE>`, where `<PK of EMPLOYEE>`
denotes the name of the primary key column of table `EMPLOYEE`. The
other foreign key column refers to table `ANNUALREVIEW` and has the same
type as the primary key of `ANNUALREVIEW`. This foreign key column is
named `ANNUALREVIEWS_<PK of ANNUALREVIEW>`, where `<PK of ANNUALREVIEW>`
denotes the name of the primary key column of table `ANNUALREVIEW`.
There is a unique key constraint on the foreign key that refers to table
`ANNUALREVIEW`.

===== Unidirectional ManyToMany Relationships [[a800]]

The following mapping defaults apply:

* Entity `A` is mapped to a table named `A`.
* Entity `B` is mapped to a table named `B`.
* There is a join table that is named `A_B`
(owner name first). This join table has two foreign key columns. One
foreign key column refers to table `A` and has the same type as the
primary key of table A. The name of this foreign key column is formed as
the concatenation of the following: the name of entity `A`; " `\_` ";
the name of the primary key column in table `A`. The other foreign key
column refers to table `B` and has the same type as the primary key of
table `B`. The name of this foreign key column is formed as the
concatenation of the following: the name of the relationship property or
field of entity `A`; " `_` "; the name of the primary key column in
table `B`.

*Example:*

[source,java]
----
@Entity
public class Employee {
    private Collection<Patent> patents;

    @ManyToMany
    public Collection<Patent> getPatents() {
        return patents;
    }

    public void setPatents(Collection<Patent> patents) {
        this.patents = patents;
    }

    // ...
}

@Entity
public class Patent {
    //...
}
----

In this example:

* Entity `Employee` references a collection of Entity `Patent`.
* Entity `Patent` does not reference Entity `Employee`.
* Entity `Employee` is the owner of the relationship.

The following mapping defaults apply:

* Entity `Employee` is mapped to a table named `EMPLOYEE`.
* Entity `Patent` is mapped to a table named `PATENT`.
* There is a join table that is named
`EMPLOYEE_PATENT` (owner name first). This join table has two foreign
key columns. One foreign key column refers to table `EMPLOYEE` and has
the same type as the primary key of `EMPLOYEE`. This foreign key column
is named `EMPLOYEE_<PK of EMPLOYEE>`, where `<PK of EMPLOYEE>` denotes
the name of the primary key column of table `EMPLOYEE`. The other
foreign key column refers to table `PATENT` and has the same type as the
primary key of `PATENT`. This foreign key column is named
`PATENTS_<PK of PATENT>`, where `<PK of PATENT>` denotes the name of the
primary key column of table `PATENT`.

=== Inheritance [[a765]]

An entity may inherit from another entity
class. Entities support inheritance, polymorphic associations, and
polymorphic queries.

Both abstract and concrete classes can be
entities. Both abstract and concrete classes can be annotated with the
`Entity` annotation, mapped as entities, and queried for as entities.

Entities can extend non-entity classes and
non-entity classes can extend entity classes.

These concepts are described further in the
following sections.

==== Abstract Entity Classes

An abstract class can be specified as an
entity. An abstract entity differs from a concrete entity only in that
it cannot be directly instantiated. An abstract entity is mapped as an
entity and can be the target of queries (which will operate over and/or
retrieve instances of its concrete subclasses).

An abstract entity class is annotated with
the `Entity` annotation or denoted in the XML descriptor as an entity.

The following example shows the use of an
abstract entity class in the entity inheritance hierarchy.

*Example: Abstract class as an Entity*

[source,java]
----
@Entity
@Table(name="EMP")
@Inheritance(strategy=JOINED)
public abstract class Employee {
    @Id
    protected Integer empId;

    @Version
    protected Integer version;

    @ManyToOne
    protected Address address;

    // ...
}

@Entity
@Table(name="FT_EMP")
@DiscriminatorValue("FT")
@PrimaryKeyJoinColumn(name="FT_EMPID")
public class FullTimeEmployee extends Employee {
    // Inherit empId, but mapped in this class to FT_EMP.FT_EMPID
    // Inherit version mapped to EMP.VERSION
    // Inherit address mapped to EMP.ADDRESS fk

    // Defaults to FT_EMP.SALARY
    protected Integer salary;

    // ...
}

@Entity
@Table(name="PT_EMP")
@DiscriminatorValue("PT")
// PK column is PT_EMP.EMPID due to `PrimaryKeyJoinColumn` default
public class PartTimeEmployee extends Employee {
    protected Float hourlyWage;

    // ...
}
----

==== Mapped Superclasses

An entity may inherit from a superclass that
provides persistent entity state and mapping information, but which is
not itself an entity. Typically, the purpose of such a mapped superclass
is to define state and mapping information that is common to multiple
entity classes.

A mapped superclass, unlike an entity, is not
queryable and must not be passed as an argument to `EntityManager`, `EntityAgent`, or
`Query` operations. Persistent relationships defined by a mapped
superclass must be unidirectional.

Both abstract and concrete classes may be
specified as mapped superclasses. The `MappedSuperclass` annotation (or
`mapped-superclass` XML descriptor element) is used to designate a
mapped superclass.

A class designated as a mapped superclass has
no separate table defined for it. Its mapping information is applied to
the entities that inherit from it.

The persistent attributes of a mapped superclass may be mapped in the same
way as the attributes of an entity class. Such mappings apply only to the
entity subclasses of the mapped superclass, since no table exists for the
mapped superclass itself. When applied to a subclass, the inherited mappings
are interpreted in the context of the tables mapped by subclass. Mapping
information inherited from a mapped superclass can be overridden in such
subclasses using the `AttributeOverride` and `AssociationOverride`
annotations or corresponding XML elements.

All other entity mapping defaults apply
equally to a class designated as a mapped superclass.

The following example illustrates the
definition of a concrete class as a mapped superclass.

*Example: Concrete class as a mapped superclass*

[source,java]
----
@MappedSuperclass
public class Employee {
    @Id
    protected Integer empId;

    @Version
    protected Integer version;

    @ManyToOne
    @JoinColumn(name="ADDR")
    protected Address address;

    public Integer getEmpId() { ... }

    public void setEmpId(Integer id) { ... }

    public Address getAddress() { ... }

    public void setAddress(Address addr) { ... }
}

// Default table is FTEMPLOYEE table
@Entity
public class FTEmployee extends Employee {
    // Inherited empId field mapped to FTEMPLOYEE.EMPID
    // Inherited version field mapped to FTEMPLOYEE.VERSION
    // Inherited address field mapped to FTEMPLOYEE.ADDR fk

    // Defaults to FTEMPLOYEE.SALARY
    protected Integer salary;

    public FTEmployee() {}

    public Integer getSalary() { ... }

    public void setSalary(Integer salary) { ... }
}

@Entity
@Table(name="PT_EMP")
@AssociationOverride(name="address", joincolumns=@JoinColumn(name="ADDR_ID"))
public class PartTimeEmployee extends Employee {
    // Inherited empId field mapped to PT_EMP.EMPID
    // Inherited version field mapped to PT_EMP.VERSION
    // address field mapping overridden to PT_EMP.ADDR_ID fk
    @Column(name="WAGE")
    protected Float hourlyWage;

    public PartTimeEmployee() {}

    public Float getHourlyWage() { ... }

    public void setHourlyWage(Float wage) { ... }
}
----

==== Non-Entity Classes in the Entity Inheritance Hierarchy

An entity can have a non-entity
superclass, which may be either a concrete or abstract
class.footnote:[The superclass must
not be an embeddable class or id class.]

The non-entity superclass serves for
inheritance of behavior only. The state of a non-entity superclass is
not persistent. Any state inherited from non-entity superclasses is
non-persistent in an inheriting entity class. This non-persistent state
is not managed by the entity managerfootnote:[If a
transaction-scoped persistence context is used, it is not required to be
retained across transactions.]. Any
annotations on such superclasses are ignored.

Non-entity classes cannot be passed as
arguments to methods of the `EntityManager`, `EntityAgent`, or `Query`
interfacesfootnote:[This includes
instances of a non-entity class that extends an entity class.] and cannot bear mapping information.

The following example illustrates the use of
a non-entity class as a superclass of an entity.

*Example: Non-entity superclass*

[source,java]
----
public class Cart {
    protected Integer operationCount; // transient state

    public Cart() {
        operationCount = 0;
    }

    public Integer getOperationCount() {
        return operationCount;
    }

    public void incrementOperationCount() {
        operationCount++;
    }
}

@Entity
public class ShoppingCart extends Cart {
    Collection<Item> items = new Vector<Item>();

    public ShoppingCart() {
        super();
    }

    // ...

    @OneToMany
    public Collection<Item> getItems() {
        return items;
    }

    public void addItem(Item item) {
        items.add(item);
        incrementOperationCount();
    }
}
----

=== Inheritance Mapping Strategies [[a966]]

The mapping of class hierarchies is specified through metadata.

There are three basic strategies which may be used when mapping an
entity class hierarchy to tables in a relational database.

* With a _single table per class hierarchy_, every field declared by
  any class in the hierarchy maps to a column of the same table.
  A subclass shares the table of its superclasses.
* With a _table per concrete entity class_, every field declared or
  inherited by a given subclass is mapped to the same table, but each
  concrete class in the hierarchy has its own separate table.
* For the _joined subclass_ strategy, any field which is declared by
  a subclass is mapped to a separate table from the fields which are
  declared by its superclass. Table joins may be used to retrieve all
  fields declared and inherited by the subclass.

An implementation is required to support the single table per class
hierarchy inheritance mapping strategy and the joined subclass strategy.

[NOTE]
====
Support for the table per concrete class inheritance mapping strategy
is optional in this release. Applications that use this mapping strategy
are not portable between all providers.

Support for the combination of inheritance strategies within a single entity
inheritance hierarchy is not required by this specification.
====

==== Single Table per Class Hierarchy Strategy

In this strategy, all the classes in a
hierarchy are mapped to a single table. The table has a column that
serves as a “discriminator column”, that is, a column whose value
identifies the specific subclass to which the instance that is
represented by the row belongs.

This mapping strategy provides good support
for polymorphic relationships between entities and for queries that
range over the class hierarchy.

It has the drawback, however, that it
requires that the columns that correspond to state specific to the
subclasses be nullable.

==== Joined Subclass Strategy

In the joined subclass strategy, the root of
the class hierarchy is represented by a single table. Each subclass is
represented by a separate table that contains those fields that are
specific to the subclass (not inherited from its superclass), as well as
the column(s) that represent its primary key. The primary key column(s)
of the subclass table serves as a foreign key to the primary key of the
superclass table.

This strategy provides support for
polymorphic relationships between entities.

It has the drawback that it requires that one
or more join operations be performed to instantiate instances of a
subclass. In deep class hierarchies, this may lead to unacceptable
performance. Queries that range over the class hierarchy likewise
require joins.

==== Table per Concrete Class Strategy

In this mapping strategy, each class is
mapped to a separate table. All properties of the class, including
inherited properties, are mapped to columns of the table for the class.

This strategy has the following drawbacks:

* It provides poor support for polymorphic relationships.
* It typically requires that SQL `UNION` queries
(or a separate SQL query per subclass) be issued for queries that are
intended to range over the class hierarchy.

=== Naming of Database Objects [[a988]]

Many annotations and annotation elements
contain names of database objects or assume default names for database
objects.

This specification requires the following
with regard to the interpretation of the names referencing database
objects. These names include the names of tables, columns, and other
database elements. Such names also include names that result from
defaulting (e.g., a table name that is defaulted from an entity name or
a column name that is defaulted from a field or property name).

By default, the names of database objects
must be treated as undelimited identifiers and passed to the database as
such.

For example, assuming the use of an English
locale, the following must be passed to the database as undelimited
identifiers so that they will be treated as equivalent for all databases
that comply with the SQL Standard's requirements for the treatment of
“regular identifiers” (undelimited identifiers) and “delimited
identifiers” <<a19494>>:

[source,java]
----
@Table(name="Customer")
@Table(name="customer")
@Table(name="cUsTomer")
----

Similarly, the following must be treated as equivalent:

[source,java]
----
@JoinColumn(name="CUSTOMER")
@ManyToOne Customer customer;

@JoinColumn(name="customer")
@ManyToOne Customer customer;

@ManyToOne Customer customer;
----

To specify delimited identifiers, one of the
following approaches must be used:

* It is possible to specify that all database
identifiers in use for a persistence unit be treated as delimited
identifiers by specifying the `<delimited-identifiers/>` element within
the `<persistence-unit-defaults>` element of the object/relational XML
mapping file. If the `<delimited-identifiers/>` element is specified, it
cannot be overridden.
* It is possible to specify on a per-name basis
that a name for a database object is to be interpreted as a delimited
identifier as follows:
** Using annotations, a name is specified as a
delimited identifier by enclosing the name within double quotes, whereby
the inner quotes are escaped, e.g., `@Table(name="\"customer\"")`.
** When using XML, a name is specified as
a delimited identifier by use of double quotes, e.g., `<table name="\&quot;customer\&quot;"/>` footnote:[If
<delimited-identifiers> is specified and individual annotations or XML
elements or attributes use escaped double quotes, the double-quotes
appear in the name of the database identifier.]

The following annotations contain elements
whose values correspond to names of database identifiers and for which
the above rules apply, including when their use is nested within that of
other annotations:

* `EntityResult(discriminatorColumn *element*)`
* `FieldResult(column *element*)`
* `ColumnResult(name *element*)`
* `CollectionTable(name, catalog, schema *elements*)`
* `Column(name, table *elements*)`
* `DiscriminatorColumn(name *elements*)`
* `ForeignKey(name, foreignKeyDefinition *elements*)`
* `Index(name, columnList *elements*)`
* `JoinColumn(name, referencedColumnName, table *elements*)`
* `JoinTable(name, catalog, schema *elements*)`
* `MapKeyColumn(name, table *elements*)`
* `MapKeyJoinColumn(name, referencedColumnName, table *elements*)`
* `NamedStoredProcedureQuery(procedureName *element*)`
* `OrderColumn(name *elements*)`
* `PrimaryKeyJoinColumn(name, referencedColumnName *elements*)`
* `SecondaryTable(name, catalog, schema *elements*)`
* `SequenceGenerator(sequenceName, catalog, schema *elements*)`
* `StoredProcedureParameter(name *element*)`
* `Table(name, catalog, schema *elements*)`
* `TableGenerator(table, catalog, schema, pkColumnName, valueColumnName *elements*)`
* `UniqueConstraint(name, columnNames *elements*)`
* `CheckConstraint(name *elements*)`

The following XML elements and types contain
elements or attributes whose values correspond to names of database
identifiers and for which the above rules apply:

* `entity-mappings(schema, catalog *elements*)`
* `persistence-unit-defaults(schema, catalog *elements*)`
* `collection-table(name, catalog, schema *attributes*)`
* `column(name, table *attributes*)`
* `column-result(name *attribute*)`
* `discriminator-column(name *attributes*)`
* `entity-result(discriminator-column *attribute*)`
* `field-result(column *attribute*)`
* `foreign-key(name, foreign-key-definition *attributes*)`
* `index(name *attribute*, column-list *element*)`
* `join-column(name, referenced-column-name, table *attributes*)`
* `join-table(name, catalog, schema *attributes*)`
* `map-key-column(name, table *attributes*)`
* `map-key-join-column(name, referenced-column-name, table *attributes*)`
* `named-stored-procedure-query(procedure-name *attribute*)`
* `order-column(name *attributes*)`
* `primary-key-join-column(name, referenced-column-name *attributes*)`
* `secondary-table(name, catalog, schema *attributes*)`
* `sequence-generator(sequence-name, catalog, schema *attributes*)`
* `stored-procedure-parameter(name *attribute*)`
* `table(name, catalog, schema *attributes*)`
* `table-generator(table, catalog, schema, pk-column-name, value-column-name *attributes*)`
* `unique-constraint(name *attribute*, column-name *element*)`
