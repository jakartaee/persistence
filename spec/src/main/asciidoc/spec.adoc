:sectnums:
= Jakarta Persistence Specification, Version 2.2

Copyright (c) 2017, 2019 Oracle and/or its affiliates. All rights reserved.

Oracle and Java are registered trademarks of Oracle and/or its
affiliates. Other names may be trademarks of their respective owners.

== Introduction

This document is the specification of the
Java API for the management of persistence and object/relational mapping
with Java EE and Java SE. The technical objective of this work is to
provide an object/relational mapping facility for the Java application
developer using a Java domain model to manage a relational database.

The Java Persistence 2.2 specification
enhances the Java Persistence API with support for repeating
annotations; injection into attribute converters; support for mapping of
the java.time.LocalDate, java.time.LocalTime, java.time.LocalDateTime,
java.time.OffsetTime, and java.time.OffsetDateTime types; and methods to
retrieve the results of Query and TypedQuery as streams.

The Java Persistence 2.1 specification added
support for schema generation, type conversion methods, use of entity
graphs in queries and find operations, unsynchronized persistence
contexts, stored procedure invocation, and injection into entity
listener classes. It also includes enhancements to the Java Persistence
query language, the Criteria API, and to the mapping of native queries.

=== Expert Group

image:Per-4.png[image]

This revision to the JPA specification is
based on JPA 2.1, whose work was conducted as part of JSR 338 under the
Java Community Process Program. This specification is the result of the
collaborative work of the members of the JSR 338 Expert Group: akquinet
tech@Spree: Michael Bouschen; Ericsson: Nicolas Seyvet; IBM: Kevin
Sutter, Pinaki Poddar; OW2: Florent Benoit; Oracle: Linda DeMichiel,
Gordon Yorke, Michael Keith; Pramati Technologies: Deepak Anupalli; Red
Hat, Inc.: Emmanuel Bernard, Steve Ebersole, Scott Marlow; SAP AG:
Rainer Schweigkoffer; Sybase: Evan Ireland; Tmax Soft Inc.: Miju Byon;
Versant: Christian von Kutzleben; VMware: Oliver Gierke; individual
members: Matthew Adams; Adam Bien; Bernd Mueller; Werner Keil.

The work of the JSR 338 Expert Group was
conducted using the jpa-spec.java.net project.

=== Document Conventions

image:Per-4.png[image]

The regular Times font is used for
information that is prescriptive by this specification.

The italic Times font is used for paragraphs
that contain descriptive information, such as notes describing typical
use, or notes clarifying the text with prescriptive specification.

The Courier font is used for code examples.

The Helvetica font is used to specify the BNF
of the Java Persistence query language.

 _This document is written in terms of the
use of Java language metadata annotations. An XML descriptor (as
specified in Chapter link:Per.html#a16944[See XML
Object/Relational Mapping Descriptor]) may be used as an alternative to
annotations or to augment or override annotations. The elements of this
descriptor mirror the annotations and have the same semantics. When
semantic requirements are written in terms of annotations, it should be
understood that the same semantics apply when the XML descriptor is used
as an alternative._

== Entities

An entity is a lightweight persistent domain
object.

The primary programming artifact is the
entity class. An entity class may make use of auxiliary classes that
serve as helper classes or that are used to represent the state of the
entity.

This chapter describes requirements on entity
classes and instances.

=== [[a18]]The Entity Class

image:Per-4.png[image]

The entity class must be annotated with the
_Entity_ annotation or denoted in the XML descriptor as an entity.

The entity class must have a no-arg
constructor. The entity class may have other constructors as well. The
no-arg constructor must be public or protected.

The entity class must be a top-level class.
An enum or interface must not be designated as an entity.

The entity class must not be final. No
methods or persistent instance variables of the entity class may be
final.

If an entity instance is to be passed by
value as a detached object (e.g., through a remote interface), the
entity class must implement the _Serializable_ interface.

Entities support inheritance, polymorphic
associations, and polymorphic queries.

Both abstract and concrete classes can be
entities. Entities may extend non-entity classes as well as entity
classes, and non-entity classes may extend entity classes.

The persistent state of an entity is
represented by instance variables, which may correspond to JavaBeans
properties. An instance variable must be directly accessed only from
within the methods of the entity by the entity instance itself. Instance
variables must not be accessed by clients of the entity. The state of
the entity is available to clients only through the entity’s
methods—i.e., accessor methods (getter/setter methods) or other business
methods.

=== Persistent Fields and Properties

image:Per-4.png[image]

The persistent state of an entity is accessed
by the persistence provider runtimelink:#a19537[1] either via
JavaBeans style property accessors (“property access”) or via instance
variables (“field access”). Whether persistent properties or persistent
fields or a combination of the two is used for the provider’s access to
a given class or entity hierarchy is determined as described in Section
link:Per.html#a113[See Access Type].

Terminology Note: The persistent fields and
properties of an entity class are generically referred to in this
document as the “attributes” of the class.

The instance variables of a class must be
private, protected, or package visibility independent of whether field
access or property access is used. When property access is used, the
property accessor methods must be public or protected.

It is required that the entity class follow
the method signature conventions for JavaBeans read/write properties (as
defined by the JavaBeans Introspector class) for persistent properties
when property access is used.

{empty}In this case, for every persistent
property _property_ of type _T_ of the entity, there is a getter method,
_getProperty_ , and setter method _setProperty_ . For boolean
properties, _isProperty_ may be used as an alternative name for the
getter method.link:#a19538[2]

For single-valued persistent properties,
these method signatures are:

T getProperty()

void setProperty(T t)

Collection-valued persistent fields and
properties must be defined in terms of one of the following
collection-valued interfaces regardless of whether the entity class
otherwise adheres to the JavaBeans method conventions noted above and
whether field or property access is used: _java.util.Collection_ ,
_java.util.Set_ , _java.util.Listlink:#a19539[3]_ ,
_java.util.Map_ . The collection implementation type may be used by the
application to initialize fields or properties before the entity is made
persistent. Once the entity becomes managed (or detached), subsequent
access must be through the interface type.

Terminology Note: The terms “collection” and
“collection-valued” are used in this specification to denote any of the
above types unless further qualified. In cases where a
_java.util.Collection_ type (or one of its subtypes) is to be
distinguished, the type is identified as such. The terms “map” and “map
collection” are used to apply to a collection of type _java.util.Map_
when a collection of type _java.util.Map_ needs to be distinguished as
such.

For collection-valued persistent properties,
type _T_ must be one of these collection interface types in the method
signatures above. Use of the generic variants of these collection types
is encouraged (for example, _Set<Order>_ ).

In addition to returning and setting the
persistent state of the instance, property accessor methods may contain
other business logic as well, for example, to perform validation. The
persistence provider runtime executes this logic when property-based
access is used.

Caution should be exercised in adding
business logic to the accessor methods when property access is used. The
order in which the persistence provider runtime calls these methods when
loading or storing persistent state is not defined. Logic contained in
such methods therefore should not rely upon a specific invocation order.

{empty}If property access is used and lazy
fetching is specified, portable applications should not directly access
the entity state underlying the property methods of managed instances
until after it has been fetched by the persistence
provider.link:#a19540[4]

If a persistence context is joined to a
transaction, runtime exceptions thrown by property accessor methods
cause the current transaction to be marked for rollback; exceptions
thrown by such methods when used by the persistence runtime to load or
store persistent state cause the persistence runtime to mark the current
transaction for rollback and to throw a _PersistenceException_ that
wraps the application exception.

Entity subclasses may override the property
accessor methods. However, portable applications must not override the
object/relational mapping metadata that applies to the persistent fields
or properties of entity superclasses.

The persistent fields or properties of an
entity may be of the following types: Java primitive types,
_java.lang.String_ , other Java serializable types (including wrappers
of the primitive types, _java.math.BigInteger_ , _java.math.BigDecimal_
, _java.util.Date_ , _java.util.Calendarlink:#a19541[5]_ ,
_java.sql.Date_ , _java.sql.Time_ , _java.sql.Timestamp_ , _byte[]_ ,
_Byte[]_ , _char[]_ , _Character[]_ , _java.time.LocalDate_ ,
_java.time.LocalTime_ , _java.time.LocalDateTime_ ,
_java.time.OffsetTime_ , _java.time.OffsetDateTime_ , and user-defined
types that implement the _Serializable_ interface _)_ ; enums; entity
types; collections of entity types; embeddable classes (see Section
link:Per.html#a487[See Embeddable Classes]); collections of
basic and embeddable types (see Section link:Per.html#a494[See
Collections of Embeddable Classes and Basic Types]).

Object/relational mapping metadata may be
specified to customize the object/relational mapping and the loading and
storing of the entity state and relationships. See Chapter
link:Per.html#a13915[See Metadata for Object/Relational Mapping].

==== Example

@Entity

public class Customer implements Serializable
\{



 private Long id;



 private String name;



 private Address address;



 private Collection<Order> orders = new
HashSet();



 private Set<PhoneNumber> phones = new
HashSet();



 // No-arg constructor

 public Customer() \{}



 @Id // property access is used

 public Long getId() \{

 return id;

 }



 public void setId(Long id) \{

 this.id = id;

 }



 public String getName() \{

 return name;

 }



 public void setName(String name) \{

 this.name = name;

 }



 public Address getAddress() \{

 return address;

 }



 public void setAddress(Address address) \{

 this.address = address;

 }



 @OneToMany

 public Collection<Order> getOrders() \{

 return orders;

 }



 public void setOrders(Collection<Order>
orders) \{

 this.orders = orders;

 }



 @ManyToMany

 public Set<PhoneNumber> getPhones() \{

 return phones;

 }



 public void setPhones(Set<PhoneNumber>
phones) \{

 this.phones = phones;

 }



 // Business method to add a phone number to
the customer

 public void addPhone(PhoneNumber phone) \{

 this.getPhones().add(phone);

 // Update the phone entity instance to refer
to this customer

 phone.addCustomer(this);

 }

}

=== [[a113]]Access Type

image:Per-4.png[image]

==== Default Access Type

By default, a single access type (field or
property access) applies to an entity hierarchy. The default access type
of an entity hierarchy is determined by the placement of mapping
annotations on the attributes of the entity classes and mapped
superclasses of the entity hierarchy that do not explicitly specify an
access type. An access type is explicitly specified by means of the
_Access_ annotationlink:#a19542[6], as described in section
link:Per.html#a122[See Explicit Access Type].

When annotations are used to define a default
access type, the placement of the mapping annotations on either the
persistent fields or persistent properties of the entity class specifies
the access type as being either field- or property-based access
respectively.

When field-based access is used, the
object/relational mapping annotations for the entity class annotate the
instance variables, and the persistence provider runtime accesses
instance variables directly. All non- _transient_ instance variables
that are not annotated with the _Transient_ annotation are persistent.

When property-based access is used, the
object/relational mapping annotations for the entity class annotate the
getter property accessorslink:#a19543[7], and the persistence
provider runtime accesses persistent state via the property accessor
methods. All properties not annotated with the _Transient_ annotation
are persistent.

Mapping annotations must not be applied to
fields or properties that are _transient_ or _Transient_ .

All such classes in the entity hierarchy
whose access type is defaulted in this way must be consistent in their
placement of annotations on either fields or properties, such that a
single, consistent default access type applies within the hierarchy. Any
embeddable classes used by such classes will have the same access type
as the default access type of the hierarchy unless the _Access_
annotation is specified as defined below.

It is an error if a default access type
cannot be determined and an access type is not explicitly specified by
means of annotations or the XML descriptor. The behavior of applications
that mix the placement of annotations on fields and properties within an
entity hierarchy without explicitly specifying the _Access_ annotation
is undefined.

==== [[a122]]Explicit Access Type

An access type for an individual entity
class, mapped superclass, or embeddable class can be specified for that
class independent of the default for the entity hierarchy by means of
the _Access_ annotation applied to the class. This explicit access type
specification does not affect the access type of other entity classes or
mapped superclasses in the entity hierarchy. The following rules apply:

When _Access(FIELD)_ is applied to an entity
class, mapped superclass, or embeddable class, mapping annotations may
be placed on the instance variables of that class, and the persistence
provider runtime accesses persistent state via the instance variables
defined by the class. All non-transient instance variables that are not
annotated with the _Transient_ annotation are persistent. When
_Access(FIELD)_ is applied to such a class, it is possible to
selectively designate individual attributes within the class for
property access. To specify a persistent property for access by the
persistence provider runtime, that property must be designated
_Access(PROPERTY)_ .link:#a19544[8] The behavior is undefined if
mapping annotations are placed on any properties defined by the class
for which _Access(PROPERTY)_ is not specified. Persistent state
inherited from superclasses is accessed in accordance with the access
types of those superclasses.

When _Access(PROPERTY)_ is applied to an
entity class, mapped superclass, or embeddable class, mapping
annotations may be placed on the properties of that class, and the
persistence provider runtime accesses persistent state via the
properties defined by that class. All properties that are not annotated
with the _Transient_ annotation are persistent. When _Access(PROPERTY)_
is applied to such a class, it is possible to selectively designate
individual attributes within the class for instance variable access. To
specify a persistent instance variable for access by the persistence
provider runtime, that instance variable must be designated
_Access(FIELD_ ). The behavior is undefined if mapping annotations are
placed on any instance variables defined by the class for which
_Access(FIELD)_ is not specified. Persistent state inherited from
superclasses is accessed in accordance with the access types of those
superclasses.

Note that when access types are combined
within a class, the _Transient_ annotation should be used to avoid
duplicate persistent mappings.

==== Access Type of an Embeddable Class

The access type of an embeddable class is
determined by the access type of the entity class, mapped superclass, or
embeddable class in which it is embedded (including as a member of an
element collection) independent of whether the access type of the
containing class has been explicitly specified or defaulted. A different
access type for an embeddable class can be specified for that embeddable
class by means of the _Access_ annotation as described above.

==== Defaulted Access Types of Embeddable Classes and Mapped Superclasses

Care must be exercised when defining an
embeddable class or mapped superclass which is used both in a context of
field access and in a context of property access and whose access type
is not explicitly specified by means of the _Access_ annotation or XML
mapping file.

Such classes should be defined so that the
number, names, and types of the resulting persistent attributes are
identical, independent of the access type in use. The behavior of such
classes whose attributes are not independent of access type is otherwise
undefined with regard to use with the metamodel API if they occur in
contexts of differing access types within the same persistence unit.

=== [[a132]]Primary Keys and Entity Identity

image:Per-4.png[image]

Every entity must have a primary key.

The primary key must be defined on the entity
class that is the root of the entity hierarchy or on a mapped superclass
that is a (direct or indirect) superclass of all entity classes in the
entity hierarchy. The primary key must be defined exactly once in an
entity hierarchy.

A primary key corresponds to one or more
fields or properties (“attributes”) of the entity class.

A simple (i.e., non-composite) primary key
must correspond to a single persistent field or property of the entity
class. The _Id_ annotation or _id_ XML element must be used to denote a
simple primary key. See Section link:Per.html#a14827[See Id
Annotation].

A composite primary key must correspond to
either a single persistent field or property or to a set of such fields
or properties as described below. A primary key class must be defined to
represent a composite primary key. Composite primary keys typically
arise when mapping from legacy databases when the database key is
comprised of several columns. The _EmbeddedId_ or _IdClass_ annotation
is used to denote a composite primary key. See Sections
link:Per.html#a14687[See EmbeddedId Annotation] and
link:Per.html#a14836[See IdClass Annotation].

A simple primary key or a field or property
of a composite primary key should be one of the following types: any
Java primitive type; any primitive wrapper type; _java.lang.String_ ;
_java.util.Date_ ; _java.sql.Date_ ; _java.math.BigDecimal_ ;
_java.math.BigInteger_ .link:#a19545[9] If the primary key is a
composite primary key derived from the primary key of another entity,
the primary key may contain an attribute whose type is that of the
primary key of the referenced entity as described in Section
link:Per.html#a149[See Primary Keys Corresponding to Derived
Identities]. Entities whose primary keys use types other than these will
not be portable. If generated primary keys are used, only integral types
will be portable. If _java.util.Date_ is used as a primary key field or
property, the temporal type should be specified as _DATE_ .

The following rules apply for composite
primary keys:

The primary key class must be public and must
have a public no-arg constructor.

The access type (field- or property-based
access) of a primary key class is determined by the access type of the
entity for which it is the primary key unless the primary key is a
embedded id and a different access type is specified. See Section
link:Per.html#a113[See Access Type].

If property-based access is used, the
properties of the primary key class must be public or protected.

The primary key class must be serializable.

The primary key class must define _equals_
and _hashCode_ methods. The semantics of value equality for these
methods must be consistent with the database equality for the database
types to which the key is mapped.

A composite primary key must either be
represented and mapped as an embeddable class (see Section
link:Per.html#a14687[See EmbeddedId Annotation]) or must be
represented as an id class and mapped to multiple fields or properties
of the entity class (see Section link:Per.html#a14836[See IdClass
Annotation]).

If the composite primary key class is
represented as an id class, the names of primary key fields or
properties in the primary key class and those of the entity class to
which the id class is mapped must correspond and their types must be the
same.

A primary key that corresponds to a derived
identity must conform to the rules of Section
link:Per.html#a149[See Primary Keys Corresponding to Derived
Identities].

{empty}The value of its primary key uniquely
identifies an entity instance within a persistence context and to
_EntityManager_ operations as described in
link:Per.html#a1060[See Entity Operations]. The application must
not change the value of the primary keylink:#a19546[10]. The
behavior is undefined if this occurs.link:#a19547[11]

==== [[a149]]Primary Keys Corresponding to Derived Identities

The identity of an entity may be derived from
the identity of another entity (the “parent” entity) when the former
entity (the “dependent” entity) is the owner of a many-to-one or
one-to-one relationship to the parent entity and a foreign key maps the
relationship from dependent to parent.

{empty}If a many-to-one or one-to-one entity
relationship corresponds to a primary key attribute, the entity
containing this relationship cannot be persisted without the
relationship having been assigned an entity since the identity of the
entity containing the relationship is derived from the referenced
entity.link:#a19548[12]

Derived identities may be captured by means
of simple primary keys or by means of composite primary keys as
described in subsection link:Per.html#a155[See Specification of
Derived Identities] below.

If the dependent entity class has primary key
attributes in addition to those corresponding to the parent's primary
key or if the parent has a composite primary key, an embedded id or id
class must be used to specify the primary key of the dependent entity.
It is not necessary that parent entity and dependent entity both use
embedded ids or both use id classes to represent composite primary keys
when the parent has a composite key.

A dependent entity may have more than one
parent entity.

===== [[a155]]Specification of Derived Identities

If the dependent entity uses an id class to
represent its primary key, one of the two following rules must be
observed:

The names of the attributes of the id class
and the _Id_ attributes of the dependent entity class must correspond as
follows:

The _Id_ attribute in the entity class and
the corresponding attribute in the id class must have the same name.

If an _Id_ attribute in the entity class is
of basic type, the corresponding attribute in the id class must have the
same type.

If an _Id_ attribute in the entity is a
many-to-one or one-to-one relationship to a parent entity, the
corresponding attribute in the id class must be of the same Java type as
the id class or embedded id of the parent entity (if the parent entity
has a composite primary key) or the type of the _Id_ attribute of the
parent entity (if the parent entity has a simple primary key).

{empty}If the dependent entity has a single
primary key attribute (i.e., the relationship attribute), the id class
specified by the dependent entity must be the same as the primary key
class of the parent entity. The _Id_ annotation is applied to the
relationship to the parent entity.link:#a19549[13]

{empty}If the dependent entity uses an
embedded id to represent its primary key, the attribute in the embedded
id corresponding to the relationship attribute must be of the same type
as the primary key of the parent entity and must be designated by the
_MapsId_ annotation applied to the relationship attribute. The _value_
element of the _MapsId_ annotation must be used to specify the name of
the attribute within the embedded id to which the relationship attribute
corresponds. If the embedded id of the dependent entity is of the same
Java type as the primary key of the parent entity, the relationship
attribute maps both the relationship to the parent and the primary key
of the dependent entity, and in this case the _MapsId_ annotation is
specified without the _value_ element.link:#a19550[14]

If the dependent entity has a single primary
key attribute (i.e, the relationship attribute or an attribute that
corresponds to the relationship attribute) and the primary key of the
parent entity is a simple primary key, the primary key of the dependent
entity is a simple primary key of the same type as that of the parent
entity (and neither _EmbeddedId_ nor _IdClass_ is specified). In this
case, either (1) the relationship attribute is annotated _Id_ , or (2) a
separate _Id_ attribute is specified and the relationship attribute is
annotated _MapsId_ (and the _value_ element of the _MapsId_ annotation
is not specified).

===== Mapping of Derived Identities

A primary key attribute that is derived from
the identity of a parent entity is mapped by the corresponding
relationship attribute. The default mapping for this relationship is as
specified in section link:Per.html#a538[See Relationship
Mapping Defaults]. In the case where a default mapping does not apply or
where a default mapping is to be overridden, the _JoinColumn_ or
_JoinColumns_ annotation is used on the relationship attribute.

If the dependent entity uses an embedded id
to represent its primary key, the _AttributeOverride_ annotation may be
used to override the default mapping of embedded id attributes that do
not correspond to the relationship attributes mapping the derived
identity. The embedded id attributes that correspond to the relationship
are treated by the provider as “read only”—that is, any updates to them
on the part of the application are not propagated to the database.

If the dependent uses an id class, the
_Column_ annotation may be used to override the default mapping of _Id_
attributes that are not relationship attributes.

===== Examples of Derived Identities

 __

 _Example 1:_

The parent entity has a simple primary key:

@Entity

public class Employee \{

 @Id long empId;

 String empName;

 ...

}

 _Case (a):_ The dependent entity uses
_IdClass_ to represent a composite key:

public class DependentId \{

 String name; // matches name of @Id
attribute

 long emp; // matches name of @Id attribute
and type of Employee PK

}



@Entity

@IdClass(DependentId.class)

public class Dependent \{

 @Id String name;



 // id attribute mapped by join column
default

 @Id @ManyToOne Employee emp;

 ...

}

Sample query:

SELECT d

FROM Dependent d

WHERE d.name = 'Joe' AND d.emp.empName =
'Sam'



 _Case(b):_ The dependent entity uses
_EmbeddedId_ to represent a composite key:

@Embeddable

public class DependentId \{

 String name;

 long empPK; // corresponds to PK type of
Employee

}



@Entity

public class Dependent \{

 @EmbeddedId DependentId id;

 ...

 // id attribute mapped by join column
default

 @MapsId("empPK") // maps empPK attribute of
embedded id

 @ManyToOne Employee emp;

}

Sample query:

SELECT d

FROM Dependent d

WHERE d.id.name = 'Joe' AND d.emp.empName =
'Sam'





 _Example 2:_

The parent entity uses _IdClass_ :

public class EmployeeId \{

 String firstName;

 String lastName;

 ...

}



@Entity

@IdClass(EmployeeId.class)

public class Employee \{

 @Id String firstName

 @Id String lastName

 ...

}

 _Case (a):_ The dependent entity uses
_IdClass_ :

public class DependentId \{

 String name; // matches name of attribute

 EmployeeId emp; //matches name of attribute
and type of Employee PK

}



@Entity

@IdClass(DependentId.class)

public class Dependent \{

 @Id String name;



 @Id

 @JoinColumns(\{

 @JoinColumn(name="FK1",
referencedColumnName="firstName"),

 @JoinColumn(name="FK2",
referencedColumnName="lastName")

 })

 @ManyToOne Employee emp;

}

Sample query:

SELECT d

FROM Dependent d

WHERE d.name = 'Joe' AND d.emp.firstName =
'Sam'



 _Case (b):_ The dependent entity uses
_EmbeddedId_ . The type of the _empPK_ attribute is the same as that of
the primary key of _Employee_ . The _EmployeeId_ class needs to be
annotated _Embeddable_ or denoted as an embeddable class in the XML
descriptor.

@Embeddable

public class DependentId \{

 String name;

 EmployeeId empPK;

}

@Entity

public class Dependent \{

 @EmbeddedId DependentId id;

 ...

 @MapsId("empPK")

 @JoinColumns(\{

 @JoinColumn(name="FK1",
referencedColumnName="firstName"),

 @JoinColumn(name="FK2",
referencedColumnName="lastName")

 })

 @ManyToOne Employee emp;

}

Sample query:

SELECT d

FROM Dependent d

WHERE d.id.name = 'Joe' AND d.emp.firstName =
'Sam'

Note that the following alternative query
will yield the same result:

SELECT d

FROM Dependent d

WHERE d.id.name = 'Joe' AND
d.id.empPK.firstName = 'Sam'





 _Example 3:_

The parent entity uses _EmbeddedId_ :

@Embeddable

public class EmployeeId \{

 String firstName;

 String lastName;

 ...

}



@Entity

public class Employee \{

 @EmbeddedId EmployeeId empId;

 ...

}

 _Case (a):_ The dependent entity uses
_IdClass_ :

public class DependentId \{

 String name; // matches name of @Id
attribute

 EmployeeId emp; // matches name of @Id
attribute and type of embedded id of Employee



@Entity

@IdClass(DependentId.class)

public class Dependent \{

 @Id

 @Column(name="dep_name") // default column
name is overridden

 String name;



 @Id

 @JoinColumns(\{

 @JoinColumn(name="FK1",
referencedColumnName="firstName"),

 @JoinColumn(name="FK2",
referencedColumnName="lastName")

 })

 @ManyToOne Employee emp;

}

Sample query:

SELECT d

FROM Dependent d

WHERE d.name = 'Joe' and
d.emp.empId.firstName = 'Sam'



 _Case (b):_ The dependent entity uses
_EmbeddedId_ :

@Embeddable

public class DependentId \{

 String name;

 EmployeeId empPK; // corresponds to PK type
of Employee

}



@Entity

public class Dependent \{

 // default column name for "name" attribute
is overridden

 @AttributeOverride(name="name",
column=@Column(name="dep_name"))

 @EmbeddedId DependentId id;

 ...

 @MapsId("empPK")

 @JoinColumns(\{

 @JoinColumn(name="FK1",
referencedColumnName="firstName"),

 @JoinColumn(name="FK2",
referencedColumnName="lastName")

 })

 @ManyToOne Employee emp;

}

Sample query:

SELECT d

FROM Dependent d

WHERE d.id.name = 'Joe' and
d.emp.empId.firstName = 'Sam'



Note that the following alternative query
will yield the same result:

SELECT d

FROM Dependent d

WHERE d.id.name = 'Joe' AND
d.id.empPK.firstName = 'Sam'



 _Example 4:_

The parent entity has a simple primary key:

@Entity

public class Person \{

 @Id String ssn;

 ...

}

 _Case (a):_ The dependent entity has a
single primary key attribute which is mapped by the relationship
attribute. The primary key of _MedicalHistory_ is of type _String_ .

@Entity

public class MedicalHistory \{

 // default join column name is overridden

 @Id

 @OneToOne

 @JoinColumn(name="FK")

 Person patient;

 ...

}

Sample query:

SELECT m

FROM MedicalHistory m

WHERE m.patient.ssn = '123-45-6789'



{empty} _Case (b):_ The dependent entity has
a single primary key attribute corresponding to the relationship
attribute. The primary key attribute is of the same basic type as the
primary key of the parent entity. The _MapsId_ annotation applied to the
relationship attribute indicates that the primary key is mapped by the
relationship attribute. link:#a19551[15]

@Entity

public class MedicalHistory \{

 @Id String id; // overriding not allowed

 ...

 // default join column name is overridden

 @MapsId

 @JoinColumn(name="FK")

 @OneToOne Person patient;

 ...

}

Sample query:

SELECT m

FROM MedicalHistory m WHERE m.patient.ssn =
'123-45-6789'



 _Example 5:_

The parent entity uses _IdClass_ . The
dependent's primary key class is of same type as that of the parent
entity.

public class PersonId \{

 String firstName;

 String lastName;

}



@Entity

@IdClass(PersonId.class)

public class Person \{

 @Id String firstName;

 @Id String lastName;

 ...

}

 _Case (a):_ The dependent entity uses
_IdClass_ :

@Entity

@IdClass(PersonId.class)

public class MedicalHistory \{

 @Id

 @JoinColumns(\{

 @JoinColumn(name="FK1",
referencedColumnName="firstName"),

 @JoinColumn(name="FK2",
referencedColumnName="lastName")

 })

 @OneToOne

 Person patient;

 ...

}

Sample query:

SELECT m

FROM MedicalHistory m

WHERE m.patient.firstName = 'Charles'

 _Case (b):_ The dependent entity uses the
_EmbeddedId_ and _MapsId_ annotations. The _PersonId_ class needs to be
annotated _Embeddable_ or denoted as an embeddable class in the XML
descriptor.

@Entity

public class MedicalHistory \{

 //all attributes map to relationship:
AttributeOverride not allowed

 @EmbeddedId PersonId id;

 ...

 @MapsId

 @JoinColumns(\{

 @JoinColumn(name="FK1",
referencedColumnName="firstName"),

 @JoinColumn(name="FK2",
referencedColumnName="lastName")

 })

 @OneToOne Person patient;

 ...

}

Sample query:

SELECT m

FROM MedicalHistory m

WHERE m.patient.firstName = 'Charles'



Note that the following alternative query
will yield the same result:

SELECT m

FROM MedicalHistory m

WHERE m.id.firstName = 'Charles'





 _Example 6:_

The parent entity uses _EmbeddedId_ . The
dependent's primary key is of the same type as that of the parent.

@Embeddable

public class PersonId \{

 String firstName;

 String lastName;

}



@Entity

public class Person \{

 @EmbeddedId PersonId id;

 ...

}

 _Case (a):_ The dependent class uses
_IdClass_ :

@Entity

@IdClass(PersonId.class)

public class MedicalHistory \{

 @Id

 @OneToOne

 @JoinColumns(\{

 @JoinColumn(name="FK1",
referencedColumnName="firstName"),

 @JoinColumn(name="FK2",
referencedColumnName="lastName")

 })

 Person patient;

 ...

}

 _Case (b):_ The dependent class uses
_EmbeddedId_ :

@Entity

public class MedicalHistory \{

 // All attributes are mapped by the
relationship:

 // AttributeOverride is not allowed

 @EmbeddedId PersonId id;

 ...

 @MapsId

 @JoinColumns(\{

 @JoinColumn(name="FK1",
referencedColumnName="firstName"),

 @JoinColumn(name="FK2",
referencedColumnName="lastName")

 })

 @OneToOne

 Person patient;

 ...

}

=== [[a487]]Embeddable Classes

image:Per-4.png[image]

An entity may use other fine-grained classes
to represent entity state. Instances of these classes, unlike entity
instances, do not have persistent identity of their own. Instead, they
exist only as part of the state of the entity to which they belong. An
entity may have collections of embeddables as well as single-valued
embeddable attributes. Embeddables may also be used as map keys and map
values. Embedded objects belong strictly to their owning entity, and are
not sharable across persistent entities. Attempting to share an embedded
object across entities has undefined semantics.

Embeddable classes must adhere to the
requirements specified in Section link:Per.html#a18[See The
Entity Class] for entities with the exception that embeddable classes
are not annotated as _Entity_ . Embeddable classes must be annotated as
_Embeddable_ or denoted in the XML descriptor as such. The access type
for an embedded object is determined as described in Section
link:Per.html#a113[See Access Type].

An embeddable class may be used to represent
the state of another embeddable class.

{empty}An embeddable class (including an
embeddable class within another embeddable class) may contain a
collection of a basic type or other embeddable
class.link:#a19552[16]

An embeddable class may contain a
relationship to an entity or collection of entities. Since instances of
embeddable classes themselves have no persistent identity, the
relationship _from_ the referenced entity is to the _entity_ that
contains the embeddable instance(s) and not to the embeddable
itself.link:#a19553[17] An embeddable class that is used as an
embedded id or as a map key must not contain such a relationship.

Additional requirements and restrictions on
embeddable classes are described in Section
link:Per.html#a494[See Collections of Embeddable Classes and
Basic Types].

=== [[a494]]Collections of Embeddable Classes and Basic Types

image:Per-4.png[image]

A persistent field or property of an entity
or embeddable class may correspond to a collection of a basic type or
embeddable class (“element collection”). Such a collection, when
specified as such by the _ElementCollection_ annotation, is mapped by
means of a collection table, as defined in Section
link:Per.html#a14250[See CollectionTable Annotation]. If the
_ElementCollection_ annotation (or XML equivalent) is not specified for
the collection-valued field or property, the rules of Section
link:Per.html#a511[See Mapping Defaults for Non-Relationship
Fields or Properties] apply.

An embeddable class (including an embeddable
class within another embeddable class) that is contained within an
element collection must not contain an element collection, nor may it
contain a relationship to an entity other than a many-to-one or
one-to-one relationship. The embeddable class must be on the owning side
of such a relationship and the relationship must be mapped by a foreign
key mapping. (See Section link:Per.html#a516[See Entity
Relationships].)

=== Map Collections

image:Per-4.png[image]

Collections of elements and entity
relationships can be represented as _java.util.Map_ collections.

The map key and the map value independently
can each be a basic type, an embeddable class, or an entity.

The _ElementCollection_ , _OneToMany_ , and
_ManyToMany_ annotations are used to specify the map as an element
collection or entity relationship as follows: when the map value is a
basic type or embeddable class, the _ElementCollection_ annotation is
used; when the map value is an entity, the _OneToMany_ or _ManyToMany_
annotation is used.

Bidirectional relationships represented as
_java.util.Map_ collections support the use of the _Map_ datatype on one
side of the relationship only.

==== Map Keys

If the map key type is a basic type, the
_MapKeyColumn_ annotation can be used to specify the column mapping for
the map key. If the _MapKeyColumn_ annotation is not specified, the
default values of the _MapKeyColumn_ annotation apply as described in
section link:Per.html#a15367[See MapKeyColumn Annotation].

If the map key type is an embeddable class,
the mappings for the map key columns are defaulted according to the
default column mappings for the embeddable class. (See Section
link:Per.html#a14330[See Column Annotation]). The
_AttributeOverride_ and _AttributeOverrides_ annotations can be used to
override these mappings, as described in sections
link:Per.html#a14084[See AttributeOverride Annotation] and
link:Per.html#a14178[See AttributeOverrides Annotation]. If an
embeddable class is used as a map key, the embeddable class must
implement the _hashCode_ and _equals_ methods consistently with the
database columns to which the embeddable is
mappedlink:#a19554[18].

If the map key type is an entity, the
_MapKeyJoinColumn_ and _MapKeyJoinColumns_ annotations are used to
specify the column mappings for the map key. If the primary key of the
referenced entity is a simple primary key and the _MapKeyJoinColumn_
annotation is not specified, the default values of the
_MapKeyJoinColumn_ annotation apply as described in section
link:Per.html#a15450[See MapKeyJoinColumn Annotation].

If Java generic types are not used in the
declaration of a relationship attribute of type _java.util.Map_ , the
_MapKeyClass_ annotation must be used to specify the type of the key of
the map.

The _MapKey_ annotation is used to specify
the special case where the map key is itself the primary key or a
persistent field or property of the entity that is the value of the map.
The _MapKeyClass_ annotation is not used when _MapKey_ is specified.

==== Map Values

When the value type of the map is a basic
type or an embeddable class, a collection table is used to map the map.
If Java generic types are not used, the _targetClass_ element of the
_ElementCollection_ annotation must be used to specify the value type
for the map. The default column mappings for the map value are derived
according to the default mapping rules for the _CollectionTable_
annotation defined in section link:Per.html#a14250[See
CollectionTable Annotation]. The _Column_ annotation is used to override
these defaults for a map value of basic type. The _AttributeOverride_ (
_s_ ) and _AssociationOverride_ ( _s_ ) annotations are used to override
the mappings for a map value that is an embeddable class.

When the value type of the map is an entity,
a join table is used to map the map for a many-to-many relationship or,
by default, for a one-to-many unidirectional relationship. If the
relationship is a bidirectional one-to-many/many-to-one relationship, by
default the map is mapped in the table of the entity that is the value
of the map. If Java generic types are not used, the _targetEntity_
element of the _OneToMany_ or _ManyToMany_ annotation must be used to
specify the value type for the map. Default mappings are described in
Section link:Per.html#a538[See Relationship Mapping Defaults].

=== [[a511]]Mapping Defaults for Non-Relationship Fields or Properties

image:Per-4.png[image]

If a persistent field or property other than
a relationship property is _not_ annotated with one of the mapping
annotations defined in Chapter link:Per.html#a13915[See Metadata
for Object/Relational Mapping] (or equivalent mapping information is not
specified in the XML descriptor), the following default mapping rules
are applied in order:

If the type is a class that is annotated with
the _Embeddable_ annotation, it is mapped in the same way as if the
field or property were annotated with the _Embedded_ annotation. See
Sections link:Per.html#a14634[See Embeddable Annotation] and
link:Per.html#a14672[See Embedded Annotation].

If the type of the field or property is one
of the following, it is mapped in the same way as it would if it were
annotated as _Basic_ : Java primitive types, wrappers of the primitive
types, _java.lang.String_ , _java.math.BigInteger_ ,
_java.math.BigDecimal_ , _java.util.Date_ , _java.util.Calendar_ ,
_java.sql.Date_ , _java.sql.Time_ , _java.sql.Timestamp_ ,
_java.time.LocalDate_ , _java.time.LocalTime_ ,
_java.time.LocalDateTime_ , _java.time.OffsetTime_ ,
_java.time.OffsetDateTime_ , _byte[]_ , _Byte[]_ , _char[]_ ,
_Character[]_ , enums, any other type that implements _Serializable_ .
See Sections link:Per.html#a14205[See Basic Annotation],
link:Per.html#a14719[See Enumerated Annotation],
link:Per.html#a15087[See Lob Annotation], and
link:Per.html#a16361[See Temporal Annotation].

It is an error if no annotation is present
and none of the above rules apply.

=== [[a516]]Entity Relationships

image:Per-4.png[image]

Relationships among entities may be
one-to-one, one-to-many, many-to-one, or many-to-many. Relationships are
polymorphic.

If there is an association between two
entities, one of the following relationship modeling annotations must be
applied to the corresponding persistent property or field of the
referencing entity: _OneToOne_ , _OneToMany_ , _ManyToOne_ ,
_ManyToMany_ . For associations that do not specify the target type
(e.g., where Java generic types are not used for collections), it is
necessary to specify the entity that is the target of the
relationship.link:#a19555[19] Equivalent XML elements may be used
as an alternative to these mapping annotations.

 _These annotations mirror common practice in
relational database schema modeling. The use of the relationship
modeling annotations allows the object/relationship mapping of
associations to the relational database schema to be fully defaulted, to
provide an ease-of-development facility. This is described in Section
link:Per.html#a538[See Relationship Mapping Defaults]._

Relationships may be bidirectional or
unidirectional. A bidirectional relationship has both an owning side and
an inverse (non-owning) side. A unidirectional relationship has only an
owning side. The owning side of a relationship determines the updates to
the relationship in the database, as described in section
link:Per.html#a1955[See Synchronization to the Database].

The following rules apply to bidirectional
relationships:

The inverse side of a bidirectional
relationship must refer to its owning side by use of the _mappedBy_
element of the _OneToOne_ , _OneToMany_ , or _ManyToMany_ annotation.
The _mappedBy_ element designates the property or field in the entity
that is the owner of the relationship.

The many side of one-to-many / many-to-one
bidirectional relationships must be the owning side, hence the
_mappedBy_ element cannot be specified on the _ManyToOne_ annotation.

For one-to-one bidirectional relationships,
the owning side corresponds to the side that contains the corresponding
foreign key.

For many-to-many bidirectional relationships
either side may be the owning side.

The relationship modeling annotation
constrains the use of the _cascade=REMOVE_ specification. The
_cascade=REMOVE_ specification should only be applied to associations
that are specified as _OneToOne_ or _OneToMany_ . Applications that
apply _cascade=REMOVE_ to other associations are not portable.

Associations that are specified as _OneToOne_
or _OneToMany_ support use of the _orphanRemoval_ option. The following
behaviors apply when _orphanRemoval_ is in effect:

If an entity that is the target of the
relationship is removed from the relationship (by setting the
relationship to null or removing the entity from the relationship
collection), the remove operation will be applied to the entity being
orphaned. The remove operation is applied at the time of the flush
operation. The _orphanRemoval_ functionality is intended for entities
that are privately “owned” by their parent entity. Portable applications
must otherwise not depend upon a specific order of removal, and must not
reassign an entity that has been orphaned to another relationship or
otherwise attempt to persist it. If the entity being orphaned is a
detached, new, or removed entity, the semantics of _orphanRemoval_ do
not apply.

If the remove operation is applied to a
managed source entity, the remove operation will be cascaded to the
relationship target in accordance with the rules of section
link:Per.html#a1946[See Removal], (and hence it is not necessary
to specify _cascade=REMOVE_ for the
relationship)link:#a19556[20].

Section link:Per.html#a538[See
Relationship Mapping Defaults], defines relationship mapping defaults
for entity relationships. Additional mapping annotations (e.g., column
and table mapping annotations) may be specified to override or further
refine the default mappings and mapping strategies described in
link:Per.html#a538[See Relationship Mapping Defaults].

In addition, this specification also requires
support for the following alternative mapping strategies:

The mapping of unidirectional one-to-many
relationships by means of foreign key mappings. The _JoinColumn_
annotation or corresponding XML element must be used to specify such
non-default mappings. See section link:Per.html#a14922[See
JoinColumn Annotation].

The mapping of unidirectional and
bidirectional one-to-one relationships, bidirectional
many-to-one/one-to-many relationships, and unidirectional many-to-one
relationships by means of join table mappings. The _JoinTable_
annotation or corresponding XML element must be used to specify such
non-default mappings. See section link:Per.html#a15022[See
JoinTable Annotation].

Such mapping annotations must be specified on
the owning side of the relationship. Any overriding of mapping defaults
must be consistent with the relationship modeling annotation that is
specified. For example, if a many-to-one relationship mapping is
specified, it is not permitted to specify a unique key constraint on the
foreign key for the relationship.

The persistence provider handles the
object/relational mapping of the relationships, including their loading
and storing to the database as specified in the metadata of the entity
class, and the referential integrity of the relationships as specified
in the database (e.g., by foreign key constraints).

Note that it is the application that bears
responsibility for maintaining the consistency of runtime
relationships—for example, for insuring that the “one” and the “many”
sides of a bidirectional relationship are consistent with one another
when the application updates the relationship at runtime.

If there are no associated entities for a
multi-valued relationship of an entity fetched from the database, the
persistence provider is responsible for returning an empty collection as
the value of the relationship.

=== [[a538]]Relationship Mapping Defaults

image:Per-4.png[image]

This section defines the mapping defaults
that apply to the use of the _OneToOne_ , _OneToMany_ , _ManyToOne_ ,
and _ManyToMany_ relationship modeling annotations. The same mapping
defaults apply when the XML descriptor is used to denote the
relationship cardinalities.

==== Bidirectional OneToOne Relationships

Assuming that:

Entity A references a single instance of
Entity B.

Entity B references a single instance of
Entity A.

Entity A is specified as the owner of the
relationship.

The following mapping defaults apply:

Entity A is mapped to a table named _A_ .

Entity B is mapped to a table named _B_ .

Table _A_ contains a foreign key to table _B_
. The foreign key column name is formed as the concatenation of the
following: the name of the relationship property or field of entity A; "
___ "; the name of the primary key column in table _B_ . The foreign key
column has the same type as the primary key of table _B_ and there is a
unique key constraint on it.

 _Example:_

@Entity

public class Employee \{

 private Cubicle assignedCubicle;



 @OneToOne

 public Cubicle getAssignedCubicle() \{

 return assignedCubicle;

 }

 public void setAssignedCubicle(Cubicle
cubicle) \{

 this.assignedCubicle = cubicle;

 }

 ...

}



@Entity

public class Cubicle \{

 private Employee residentEmployee;



 @OneToOne(mappedBy="assignedCubicle")

 public Employee getResidentEmployee() \{

 return residentEmployee;

 }

 public void setResidentEmployee(Employee
employee) \{

 this.residentEmployee = employee;

 }

 ...

}

In this example:

Entity _Employee_ references a single
instance of Entity _Cubicle_ .

Entity _Cubicle_ references a single instance
of Entity _Employee_ .

Entity _Employee_ is the owner of the
relationship.

The following mapping defaults apply:

Entity _Employee_ is mapped to a table named
_EMPLOYEE_ .

Entity _Cubicle_ is mapped to a table named
_CUBICLE_ .

Table _EMPLOYEE_ contains a foreign key to
table _CUBICLE_ . The foreign key column is named _ASSIGNEDCUBICLE__ <PK
of CUBICLE>, where <PK of CUBICLE> denotes the name of the primary key
column of table _CUBICLE_ . The foreign key column has the same type as
the primary key of _CUBICLE_ , and there is a unique key constraint on
it.

[discrete]
=== Bidirectional ManyToOne _/_ OneToMany Relationships

Assuming that:

Entity A references a single instance of
Entity B.

Entity B references a collection of Entity
Alink:#a19557[21].

Entity A must be the owner of the
relationship.

The following mapping defaults apply:

Entity A is mapped to a table named _A_ .

Entity B is mapped to a table named _B_ .

Table _A_ contains a foreign key to table _B_
. The foreign key column name is formed as the concatenation of the
following: the name of the relationship property or field of entity A; "
___ "; the name of the primary key column in table _B_ . The foreign key
column has the same type as the primary key of table _B_ .

 _Example:_

@Entity

public class Employee \{

 private Department department;



 @ManyToOne

 public Department getDepartment() \{

 return department;

 }

 public void setDepartment(Department
department) \{

 this.department = department;

 }

 ...

}





@Entity

public class Department \{

 private Collection<Employee> employees = new
HashSet();



 @OneToMany(mappedBy="department")

 public Collection<Employee> getEmployees()
\{

 return employees;

 }



 public void
setEmployees(Collection<Employee> employees) \{

 this.employees = employees;

 }

 ...

}





In this example:

Entity _Employee_ references a single
instance of Entity _Department_ .

Entity _Department_ references a collection
of Entity _Employee_ .

Entity _Employee_ is the owner of the
relationship.

The following mapping defaults apply:

Entity _Employee_ is mapped to a table named
_EMPLOYEE_ .

Entity _Department_ is mapped to a table
named _DEPARTMENT_ .

Table _EMPLOYEE_ contains a foreign key to
table _DEPARTMENT_ . The foreign key column is named _DEPARTMENT__ <PK
of DEPARTMENT>, where <PK of DEPARTMENT> denotes the name of the primary
key column of table _DEPARTMENT_ . The foreign key column has the same
type as the primary key of _DEPARTMENT_ .

==== Unidirectional Single-Valued Relationships

Assuming that:

Entity A references a single instance of
Entity B.

Entity B does not reference Entity A.

A unidirectional relationship has only an
owning side, which in this case must be Entity A.

The unidirectional single-valued relationship
modeling case can be specified as either a unidirectional _OneToOne_ or
as a unidirectional _ManyToOne_ relationship.

===== [[a640]]Unidirectional OneToOne Relationships

The following mapping defaults apply:

Entity A is mapped to a table named _A_ .

Entity B is mapped to a table named _B_ .

Table _A_ contains a foreign key to table _B_
. The foreign key column name is formed as the concatenation of the
following: the name of the relationship property or field of entity A; "
___ "; the name of the primary key column in table _B_ . The foreign key
column has the same type as the primary key of table _B_ and there is a
unique key constraint on it.

 _Example:_

@Entity

public class Employee \{

 private TravelProfile profile;



 @OneToOne

 public TravelProfile getProfile() \{

 return profile;

 }

 public void setProfile(TravelProfile
profile) \{

 this.profile = profile;

 }

 ...

}





@Entity

public class TravelProfile \{

 ...

}



In this example:

Entity _Employee_ references a single
instance of Entity _TravelProfile_ .

Entity _TravelProfile_ does not reference
Entity _Employee_ .

Entity _Employee_ is the owner of the
relationship.

The following mapping defaults apply:

Entity _Employee_ is mapped to a table named
_EMPLOYEE_ .

Entity _TravelProfile_ is mapped to a table
named _TRAVELPROFILE_ .

Table _EMPLOYEE_ contains a foreign key to
table _TRAVELPROFILE_ . The foreign key column is named _PROFILE__ <PK
of TRAVELPROFILE>, where <PK of TRAVELPROFILE> denotes the name of the
primary key column of table _TRAVELPROFILE_ . The foreign key column has
the same type as the primary key of _TRAVELPROFILE_ , and there is a
unique key constraint on it.

===== Unidirectional ManyToOne Relationships

The following mapping defaults apply:

Entity A is mapped to a table named _A_ .

Entity B is mapped to a table named _B_ .

Table _A_ contains a foreign key to table _B_
. The foreign key column name is formed as the concatenation of the
following: the name of the relationship property or field of entity A; "
___ "; the name of the primary key column in table _B_ . The foreign key
column has the same type as the primary key of table _B_ .

 _Example:_

@Entity

public class Employee \{

 private Address address;



 @ManyToOne

 public Address getAddress() \{

 return address;

 }

 public void setAddress(Address address) \{

 this.address = address;

 }

 ...

}



@Entity

public class Address \{

 ...

}





In this example:

Entity _Employee_ references a single
instance of Entity _Address_ .

Entity _Address_ does not reference Entity
_Employee_ .

Entity _Employee_ is the owner of the
relationship.

The following mapping defaults apply:

Entity _Employee_ is mapped to a table named
_EMPLOYEE_ .

Entity _Address_ is mapped to a table named
_ADDRESS_ .

Table _EMPLOYEE_ contains a foreign key to
table _ADDRESS_ . The foreign key column is named _ADDRESS__ <PK of
ADDRESS>, where <PK of ADDRESS> denotes the name of the primary key
column of table _ADDRESS_ . The foreign key column has the same type as
the primary key of _ADDRESS_ .

==== [[a708]]Bidirectional ManyToMany Relationships

Assuming that:

Entity A references a collection of Entity B.

Entity B references a collection of Entity A.

Entity A is the owner of the relationship.

The following mapping defaults apply:

Entity A is mapped to a table named _A_ .

Entity B is mapped to a table named _B_ .

There is a join table that is named _A_B_
(owner name first). This join table has two foreign key columns. One
foreign key column refers to table _A_ and has the same type as the
primary key of table _A_ . The name of this foreign key column is formed
as the concatenation of the following: the name of the relationship
property or field of entity B; " ___ "; the name of the primary key
column in table _A_ . The other foreign key column refers to table _B_
and has the same type as the primary key of table _B_ . The name of this
foreign key column is formed as the concatenation of the following: the
name of the relationship property or field of entity A; " ___ "; the
name of the primary key column in table _B_ .

 _Example:_

@Entity

public class Project \{

 private Collection<Employee> employees;



 @ManyToMany

 public Collection<Employee> getEmployees()
\{

 return employees;

 }



 public void
setEmployees(Collection<Employee> employees) \{

 this.employees = employees;

 }

 ...

}



@Entity

public class Employee \{

 private Collection<Project> projects;



 @ManyToMany(mappedBy="employees")

 public Collection<Project> getProjects() \{

 return projects;

 }



 public void setProjects(Collection<Project>
projects) \{

 this.projects = projects;

 }

 ...

}





In this example:

Entity _Project_ references a collection of
Entity _Employee_ .

Entity _Employee_ references a collection of
Entity _Project_ .

Entity _Project_ is the owner of the
relationship.

The following mapping defaults apply:

Entity _Project_ is mapped to a table named
_PROJECT_ .

Entity _Employee_ is mapped to a table named
_EMPLOYEE_ .

There is a join table that is named
_PROJECT_EMPLOYEE_ (owner name first). This join table has two foreign
key columns. One foreign key column refers to table _PROJECT_ and has
the same type as the primary key of _PROJECT_ . The name of this foreign
key column is _PROJECTS__ <PK of PROJECT>, where <PK of PROJECT> denotes
the name of the primary key column of table _PROJECT_ . The other
foreign key column refers to table _EMPLOYEE_ and has the same type as
the primary key of _EMPLOYEE_ . The name of this foreign key column is
_EMPLOYEES__ <PK of EMPLOYEE>, where <PK of EMPLOYEE> denotes the name
of the primary key column of table _EMPLOYEE_ .



==== [[a758]]Unidirectional Multi-Valued Relationships

Assuming that:

Entity A references a collection of Entity B.

Entity B does not reference Entity A.

A unidirectional relationship has only an
owning side, which in this case must be Entity A.

The unidirectional multi-valued relationship
modeling case can be specified as either a unidirectional _OneToMany_ or
as a unidirectional _ManyToMany_ relationship.

===== [[a764]]Unidirectional OneToMany Relationships

The following mapping defaults apply:

Entity A is mapped to a table named _A_ .

Entity B is mapped to a table named _B_ .

There is a join table that is named _A_B_
(owner name first). This join table has two foreign key columns. One
foreign key column refers to table _A_ and has the same type as the
primary key of table _A_ . The name of this foreign key column is formed
as the concatenation of the following: the name of entity A; " ___ ";
the name of the primary key column in table _A_ . The other foreign key
column refers to table _B_ and has the same type as the primary key of
table _B_ and there is a unique key constraint on it. The name of this
foreign key column is formed as the concatenation of the following: the
name of the relationship property or field of entity A; " ___ "; the
name of the primary key column in table _B_ .

 _Example:_

@Entity

public class Employee \{

 private Collection<AnnualReview>
annualReviews;



 @OneToMany

 public Collection<AnnualReview>
getAnnualReviews() \{

 return annualReviews;

 }



 public void
setAnnualReviews(Collection<AnnualReview> annualReviews) \{

 this.annualReviews = annualReviews;

 }

 ...

}





@Entity

public class AnnualReview \{

 ...

}





In this example:

Entity _Employee_ references a collection of
Entity _AnnualReview_ .

Entity _AnnualReview_ does not reference
Entity _Employee_ .

Entity _Employee_ is the owner of the
relationship.

The following mapping defaults apply:

Entity _Employee_ is mapped to a table named
_EMPLOYEE_ .

Entity _AnnualReview_ is mapped to a table
named _ANNUALREVIEW_ .

There is a join table that is named
_EMPLOYEE_ANNUALREVIEW_ (owner name first). This join table has two
foreign key columns. One foreign key column refers to table _EMPLOYEE_
and has the same type as the primary key of _EMPLOYEE_ . This foreign
key column is named _EMPLOYEE__ <PK of EMPLOYEE>, where <PK of EMPLOYEE>
denotes the name of the primary key column of table _EMPLOYEE_ . The
other foreign key column refers to table _ANNUALREVIEW_ and has the same
type as the primary key of _ANNUALREVIEW_ . This foreign key column is
named _ANNUALREVIEWS__ <PK of ANNUALREVIEW>, where <PK of ANNUALREVIEW>
denotes the name of the primary key column of table _ANNUALREVIEW_ .
There is a unique key constraint on the foreign key that refers to table
_ANNUALREVIEW_ .

===== [[a800]]Unidirectional ManyToMany Relationships

The following mapping defaults apply:

Entity _A_ is mapped to a table named _A_ .

Entity _B_ is mapped to a table named _B_ .

There is a join table that is named _A_B_
(owner name first). This join table has two foreign key columns. One
foreign key column refers to table _A_ and has the same type as the
primary key of table A. The name of this foreign key column is formed as
the concatenation of the following: the name of entity _A_ ; " ___ ";
the name of the primary key column in table _A_ . The other foreign key
column refers to table _B_ and has the same type as the primary key of
table _B_ . The name of this foreign key column is formed as the
concatenation of the following: the name of the relationship property or
field of entity _A_ ; " ___ "; the name of the primary key column in
table _B_ .

 _Example:_

@Entity

public class Employee \{

 private Collection<Patent> patents;



 @ManyToMany

 public Collection<Patent> getPatents() \{

 return patents;

 }



 public void setPatents(Collection<Patent>
patents) \{

 this.patents = patents;

 }

 ...

}





@Entity

public class Patent \{

 ...

}





In this example:

Entity _Employee_ references a collection of
Entity _Patent_ .

Entity _Patent_ does not reference Entity
_Employee_ .

Entity _Employee_ is the owner of the
relationship.

The following mapping defaults apply:

Entity _Employee_ is mapped to a table named
_EMPLOYEE_ .

Entity _Patent_ is mapped to a table named
_PATENT_ .

There is a join table that is named
_EMPLOYEE_PATENT_ (owner name first). This join table has two foreign
key columns. One foreign key column refers to table _EMPLOYEE_ and has
the same type as the primary key of _EMPLOYEE_ . This foreign key column
is named _EMPLOYEE__ <PK of EMPLOYEE>, where <PK of EMPLOYEE> denotes
the name of the primary key column of table _EMPLOYEE_ . The other
foreign key column refers to table _PATENT_ and has the same type as the
primary key of _PATENT_ . This foreign key column is named _PATENTS__
<PK of PATENT>, where <PK of PATENT> denotes the name of the primary key
column of table _PATENT_ .

=== Inheritance

image:Per-4.png[image]

An entity may inherit from another entity
class. Entities support inheritance, polymorphic associations, and
polymorphic queries.

Both abstract and concrete classes can be
entities. Both abstract and concrete classes can be annotated with the
_Entity_ annotation, mapped as entities, and queried for as entities.

Entities can extend non-entity classes and
non-entity classes can extend entity classes.

These concepts are described further in the
following sections.

==== Abstract Entity Classes

An abstract class can be specified as an
entity. An abstract entity differs from a concrete entity only in that
it cannot be directly instantiated. An abstract entity is mapped as an
entity and can be the target of queries (which will operate over and/or
retrieve instances of its concrete subclasses).

An abstract entity class is annotated with
the _Entity_ annotation or denoted in the XML descriptor as an entity.

The following example shows the use of an
abstract entity class in the entity inheritance hierarchy.

 _Example: Abstract class as an Entity_

@Entity

@Table(name="EMP")

@Inheritance(strategy=JOINED)

public abstract class Employee \{

 @Id protected Integer empId;

 @Version protected Integer version;

 @ManyToOne protected Address address;

 ...

}





@Entity

@Table(name="FT_EMP")

@DiscriminatorValue("FT")

@ _PrimaryKeyJoinColumn_ (name="FT_EMPID")

public class FullTimeEmployee extends
Employee \{



 // Inherit empId, but mapped in this class
to FT_EMP.FT_EMPID

 // Inherit version mapped to EMP.VERSION

 // Inherit address mapped to EMP.ADDRESS fk



 // Defaults to FT_EMP.SALARY

 protected Integer salary;

 ...

}





@Entity

@Table(name="PT_EMP")

@DiscriminatorValue("PT")

// PK column is PT_EMP.EMPID due to
_PrimaryKeyJoinColumn_ default

public class PartTimeEmployee extends
Employee \{

 protected Float hourlyWage;

 ...

}





==== Mapped Superclasses

An entity may inherit from a superclass that
provides persistent entity state and mapping information, but which is
not itself an entity. Typically, the purpose of such a mapped superclass
is to define state and mapping information that is common to multiple
entity classes.

A mapped superclass, unlike an entity, is not
queryable and must not be passed as an argument to _EntityManager_ or
_Query_ operations. Persistent relationships defined by a mapped
superclass must be unidirectional.

Both abstract and concrete classes may be
specified as mapped superclasses. The _MappedSuperclass_ annotation (or
_mapped-superclass_ XML descriptor element) is used to designate a
mapped superclass.

A class designated as a mapped superclass has
no separate table defined for it. Its mapping information is applied to
the entities that inherit from it.

A class designated as a mapped superclass can
be mapped in the same way as an entity except that the mappings will
apply only to its subclasses since no table exists for the mapped
superclass itself. When applied to the subclasses, the inherited
mappings will apply in the context of the subclass tables. Mapping
information can be overridden in such subclasses by using the
_AttributeOverride_ and _AssociationOverride_ annotations or
corresponding XML elements.

All other entity mapping defaults apply
equally to a class designated as a mapped superclass.

The following example illustrates the
definition of a concrete class as a mapped superclass.

 _Example: Concrete class as a mapped
superclass_

@MappedSuperclass

public class Employee \{



 @Id protected Integer empId;

 @Version protected Integer version;

 @ManyToOne @JoinColumn(name="ADDR")

 protected Address address;



 public Integer getEmpId() \{ ... }

 public void setEmpId(Integer id) \{ ... }

 public Address getAddress() \{ ... }

 public void setAddress(Address addr) \{ ...
}

}



// Default table is FTEMPLOYEE table

@Entity

public class FTEmployee extends Employee \{



 // Inherited empId field mapped to
FTEMPLOYEE.EMPID

 // Inherited version field mapped to
FTEMPLOYEE.VERSION

 // Inherited address field mapped to
FTEMPLOYEE.ADDR fk



 // Defaults to FTEMPLOYEE.SALARY

 protected Integer salary;



 public FTEmployee() \{}



 public Integer getSalary() \{ ... }

 public void setSalary(Integer salary) \{ ...
}

}



@Entity

@Table(name="PT_EMP")

@AssociationOverride(name="address",

 joincolumns=@JoinColumn(name="ADDR_ID"))

public class PartTimeEmployee extends
Employee \{



 // Inherited empId field mapped to
PT_EMP.EMPID

 // Inherited version field mapped to
PT_EMP.VERSION

 // address field mapping overridden to
PT_EMP.ADDR_ID fk

 @Column(name="WAGE")

 protected Float hourlyWage;



 public PartTimeEmployee() \{}



 public Float getHourlyWage() \{ ... }

 public void setHourlyWage(Float wage) \{ ...
}

}

==== Non-Entity Classes in the Entity Inheritance Hierarchy

{empty}An entity can have a non-entity
superclass, which may be either a concrete or abstract
class.link:#a19558[22]

The non-entity superclass serves for
inheritance of behavior only. The state of a non-entity superclass is
not persistent. Any state inherited from non-entity superclasses is
non-persistent in an inheriting entity class. This non-persistent state
is not managed by the entity managerlink:#a19559[23]. Any
annotations on such superclasses are ignored.

Non-entity classes cannot be passed as
arguments to methods of the _EntityManager_ or _Query_
interfaceslink:#a19560[24] and cannot bear mapping information.

The following example illustrates the use of
a non-entity class as a superclass of an entity.

 _Example: Non-entity superclass_

public class Cart \{

 protected Integer operationCount; //
transient state

 public Cart() \{ operationCount = 0; }

 public Integer getOperationCount() \{ return
operationCount; }

 public void incrementOperationCount() \{
operationCount++; }

}



@Entity

public class ShoppingCart extends Cart \{

 Collection<Item> items = new Vector<Item>();

 public ShoppingCart() \{ super(); }

 ...

 @OneToMany

 public Collection<Item> getItems() \{ return
items; }



 public void addItem(Item item) \{

 items.add(item);

 incrementOperationCount();

 }

}

=== [[a966]]Inheritance Mapping Strategies

image:Per-4.png[image]

The mapping of class hierarchies is specified
through metadata.

There are three basic strategies that are
used when mapping a class or class hierarchy to a relational database:

a single table per class hierarchy

a joined subclass strategy, in which fields
that are specific to a subclass are mapped to a separate table than the
fields that are common to the parent class, and a join is performed to
instantiate the subclass.

a table per concrete entity class

An implementation is required to support the
single table per class hierarchy inheritance mapping strategy and the
joined subclass strategy.

Support for the table per concrete class
inheritance mapping strategy is optional in this release. Applications
that use this mapping strategy will not be portable.

Support for the combination of inheritance
strategies within a single entity inheritance hierarchy is not required
by this specification.

==== Single Table per Class Hierarchy Strategy

In this strategy, all the classes in a
hierarchy are mapped to a single table. The table has a column that
serves as a “discriminator column”, that is, a column whose value
identifies the specific subclass to which the instance that is
represented by the row belongs.

This mapping strategy provides good support
for polymorphic relationships between entities and for queries that
range over the class hierarchy.

It has the drawback, however, that it
requires that the columns that correspond to state specific to the
subclasses be nullable.

==== Joined Subclass Strategy

In the joined subclass strategy, the root of
the class hierarchy is represented by a single table. Each subclass is
represented by a separate table that contains those fields that are
specific to the subclass (not inherited from its superclass), as well as
the column(s) that represent its primary key. The primary key column(s)
of the subclass table serves as a foreign key to the primary key of the
superclass table.

This strategy provides support for
polymorphic relationships between entities.

It has the drawback that it requires that one
or more join operations be performed to instantiate instances of a
subclass. In deep class hierarchies, this may lead to unacceptable
performance. Queries that range over the class hierarchy likewise
require joins.

==== Table per Concrete Class Strategy

In this mapping strategy, each class is
mapped to a separate table. All properties of the class, including
inherited properties, are mapped to columns of the table for the class.

This strategy has the following drawbacks:

It provides poor support for polymorphic
relationships.

It typically requires that SQL UNION queries
(or a separate SQL query per subclass) be issued for queries that are
intended to range over the class hierarchy.

=== [[a988]]Naming of Database Objects

image:Per-4.png[image]

Many annotations and annotation elements
contain names of database objects or assume default names for database
objects.

This specification requires the following
with regard to the interpretation of the names referencing database
objects. These names include the names of tables, columns, and other
database elements. Such names also include names that result from
defaulting (e.g., a table name that is defaulted from an entity name or
a column name that is defaulted from a field or property name).

By default, the names of database objects
must be treated as undelimited identifiers and passed to the database as
such.

For example, assuming the use of an English
locale, the following must be passed to the database as undelimited
identifers so that they will be treated as equivalent for all databases
that comply with the SQL Standard’s requirements for the treatment of
“regular identifiers” (undelimited identifiers) and “delimited
identifiers” link:Per.html#a19494[See SQL 2003, Part 2,
Foundation (SQL/Foundation). ISO/IEC 9075-2:2003.]:

 _@Table(name="Customer")_

 _@Table(name="customer")_

 _@Table(name="cUsTomer")_

Similarly, the following must be treated as
equivalent:

@JoinColumn(name= _"_ CUSTOMER _"_ )

@ManyToOne Customer customer;



@JoinColumn(name= _"_ customer _"_ )

@ManyToOne Customer customer;



@ManyToOne Customer customer;







To specify delimited identifiers, one of the
following approaches must be used:

It is possible to specify that all database
identifiers in use for a persistence unit be treated as delimited
identifiers by specifying the _<delimited-identifiers/>_ element within
the _persistence-unit-defaults_ element of the object/relational xml
mapping file. If the _<delimited-identifiers/>_ element is specified, it
cannot be overridden.

It is possible to specify on a per-name basis
that a name for a database object is to be interpreted as a delimited
identifier as follows:

Using annotations, a name is specified as a
delimited identifier by enclosing the name within double quotes, whereby
the inner quotes are escaped, e.g., _@Table(name="\"customer\"")_ _._

{empty}When using XML, a name is specified as
a delimited identifier by use of double quotes, e.g., _<table
name="&quot;customer&quot;"/>_ link:#a19561[25]



The following annotations contain elements
whose values correspond to names of database identifiers and for which
the above rules apply, including when their use is nested within that of
other annotations:

 _EntityResult_ ( _discriminatorColumn_
element)

 _FieldResult_ ( _column_ element)

 _ColumnResult_ ( _name_ element)

 _CollectionTable_ ( _name_ , _catalog_ ,
_schema_ elements)

 _Column_ ( _name_ , _columnDefinition_ ,
_table_ elements)

 _DiscriminatorColumn_ ( _name_ ,
_columnDefinition_ elements)

 _ForeignKey_ ( _name_ ,
_foreignKeyDefinition_ elements)

 _Index_ ( _name_ , _columnList_ elements)

 _JoinColumn_ ( _name_ ,
_referencedColumnName_ , _columnDefinition_ , _table_ elements)

 _JoinTable_ ( _name_ , _catalog_ , _schema_
elements)

 _MapKeyColumn_ ( _name_ , _columnDefinition_
, _table_ elements)

 _MapKeyJoinColumn_ ( _name_ ,
_referencedColumnName_ , _columnDefinition_ , _table_ elements)

 _NamedStoredProcedureQuery_ (
_procedureName_ element)

 _OrderColumn_ ( _name_ , _columnDefinition_
elements)

 _PrimaryKeyJoinColumn_ ( _name_ ,
_referencedColumnName_ , _columnDefinition_ elements)

 _SecondaryTable_ ( _name_ , _catalog_ ,
_schema_ elements)

 _SequenceGenerator_ ( _sequenceName_ ,
_catalog_ , _schema_ elements)

 _StoredProcedureParameter_ ( _name_ element)

 _Table_ ( _name_ , _catalog_ , _schema_
elements)

 _TableGenerator_ ( _table_ , _catalog_ ,
_schema_ , _pkColumnName_ , _valueColumnName_ elements)

 _UniqueConstraint_ ( _name_ , _columnNames_
elements)



The following XML elements and types contain
elements or attributes whose values correspond to names of database
identifiers and for which the above rules apply:

 _entity-mappings_ ( _schema_ , _catalog_
elements)

 _persistence-unit-defaults_ ( _schema_ ,
_catalog_ elements)

 _collection-table_ ( _name_ , _catalog_ ,
_schema_ attributes)

 _column_ ( _name_ , _table_ ,
_column-definition_ attributes)

 _column-result_ ( _name_ attribute)

 _discriminator-column_ ( _name_ ,
_column-definition_ attributes)

 _entity-result_ ( _discriminator-column_
attribute)

 _field-result_ ( _column_ attribute)

 _foreign-key_ ( _name_ ,
_foreign-key-definition_ attributes)

 _index_ ( _name_ attribute, _column-list_
element)

 _join-column_ ( _name_ ,
_referenced-column-name_ , _column-definition_ , _table_ attributes)

 _join-table_ ( _name_ , _catalog_ , _schema_
attributes)

 _map-key-column_ ( _name_ ,
_column-definition_ , _table_ attributes)

 _map-key-join-column_ ( _name_ ,
_referenced-column-name_ , _column-definition_ , _table_ attributes)

 _named-stored-procedure-query_ (
_procedure-name_ attribute)

 _order-column_ ( _name_ ,
_column-definition_ attributes)

 _primary-key-join-column_ ( _name_ ,
_referenced-column-name_ , _column-definition_ attributes)

 _secondary-table_ ( _name_ , _catalog_ ,
_schema_ attributes)

 _sequence-generator_ ( _sequence-name_ ,
_catalog,_ _schema_ attributes)

 _stored-procedure-parameter_ ( _name_
attribute)

 _table_ ( _name_ , _catalog_ , _schema_
attributes)

 _table-generator_ ( _table_ , _catalog_ ,
_schema_ , _pk-column-name_ , _value-column-name_ attributes)

 _unique-constraint_ ( _name_ attribute,
_column-name_ element)

== [[a1060]]Entity Operations

This chapter describes the use of the
_EntityManager_ API to manage the entity instance lifecycle and the use
of the _Query_ API to retrieve and query entities and their persistent
state.

=== [[a1062]]EntityManager

image:Per-4.png[image]

An EntityManager instance is associated with
a persistence context. A persistence context is a set of entity
instances in which for any persistent entity identity there is a unique
entity instance. Within the persistence context, the entity instances
and their lifecycle are managed. The _EntityManager_ interface defines
the methods that are used to interact with the persistence context. The
_EntityManager_ API is used to create and remove persistent entity
instances, to find persistent entities by primary key, and to query over
persistent entities.

The set of entities that can be managed by a
given _EntityManager_ instance is defined by a persistence unit. A
persistence unit defines the set of all classes that are related or
grouped by the application, and which must be colocated in their mapping
to a single database.

Section link:Per.html#a1062[See
EntityManager] defines the _EntityManager_ interface. The entity
instance lifecycle is described in Section
link:Per.html#a1929[See Entity Instance’s Life Cycle]. The
relationships between entity managers and persistence contexts are
described in section link:Per.html#a2027[See Persistence Context
Lifetime and Synchronization Type] and in further detail in Chapter
link:Per.html#a11431[See Entity Managers and Persistence
Contexts]. Section link:Per.html#a2052[See Locking and
Concurrency] describes mechanisms for concurrency control and locking.
Section link:Per.html#a2153[See Entity Listeners and Callback
Methods] describes entity listeners and lifecycle callback methods for
entities. Section link:Per.html#a2366[See Bean Validation]
describes support for automatic use of Bean Validation.
link:Per.html#a2397[See Entity Graphs] describes the use of
entity graphs to control the path and boundaries of find and query
operations. link:Per.html#a2999[See Type Conversion of Basic
Attributes] describes mechanisms for defining conversions between entity
and database representations for attributes of basic types. Section
link:Per.html#a3061[See Caching] describes mechanisms for
portable second-level cache configuration. The _Query_ , _TypedQuery_ ,
_StoredProcedureQuery_ , and related interfaces are described in Section
link:Per.html#a3125[See Query APIs]. Section
link:Per.html#a4639[See Summary of Exceptions] provides a
summary of exceptions. The Java Persistence query language is defined in
Chapter link:Per.html#a4665[See Query Language] and the APIs for
the construction of Criteria queries in Chapter
link:Per.html#a6925[See Criteria API]. The definition of
persistence units is described in Chapter
link:Per.html#a12229[See Entity Packaging].

==== [[a1066]]EntityManager Interface

package javax.persistence;



import java.util.Map;

import java.util.List;

import javax.persistence.metamodel.Metamodel;

import
javax.persistence.criteria.CriteriaBuilder;

import
javax.persistence.criteria.CriteriaQuery;

import
javax.persistence.criteria.CriteriaUpdate;

import
javax.persistence.criteria.CriteriaDelete;



/**

 * Interface used to interact with the
persistence context and to

 * create executable query objects.

 */

public interface EntityManager \{



 /**

 * Make an instance managed and persistent.

 * @param entity

 * @throws EntityExistsException if the
entity already exists.

 * (If the entity already exists, the
EntityExistsException may

 * be thrown when the persist operation is
invoked, or the

 * EntityExistsException or another
PersistenceException may be

 * thrown at flush or commit time.)

 * @throws IllegalArgumentException if the
instance is not an

 * entity

 * @throws TransactionRequiredException if
there is no

 * transaction when invoked on a
container-managed

 * entity manager that is of type

 * PersistenceContextType.TRANSACTION.

 */

 public void persist(Object entity);



 /**

 * Merge the state of the given entity into
the

 * current persistence context.

 * @param entity

 * @return the managed instance that the
state was merged to

 * @throws IllegalArgumentException if
instance is not an

 * entity or is a removed entity

 * @throws TransactionRequiredException if
there is no

 * transaction when invoked on a
container-managed

 * entity manager that is of type

 * PersistenceContextType.TRANSACTION.

 */

 public <T> T merge(T entity);



 /**

 * Remove the entity instance.

 * @param entity

 * @throws IllegalArgumentException if the
instance is not an

 * entity or is a detached entity

 * @throws TransactionRequiredException if
there is no

 * transaction when invoked on a
container-managed

 * entity manager that is of type

 * PersistenceContextType.TRANSACTION.

 */

 public void remove(Object entity);



 /**

 * Find by primary key.

 * Search for an entity of the specified
class and primary key.

 * If the entity instance is contained in the
persistence context

 * it is returned from there.

 * @param entityClass

 * @param primaryKey

 * @return the found entity instance or null
if the entity does

 * not exist

 * @throws IllegalArgumentException if the
first argument does

 * not denote an entity type or the second
argument is

 * is not a valid type for that entity’s
primary key or

 * is null

 */

 public <T> T find(Class<T> entityClass,
Object primaryKey);



 /**

 * Find by primary key, using the specified
properties.

 * Search for an entity of the specified
class and primary key.

 * If the entity instance is contained in the
persistence context

 * it is returned from there.

 * If a vendor-specific property or hint is
not recognized,

 * it is silently ignored.

 * @param entityClass

 * @param primaryKey

 * @param properties standard and
vendor-specific properties

 * and hints

 * @return the found entity instance or null
if the entity does

 * not exist

 * @throws IllegalArgumentException if the
first argument does

 * not denote an entity type or the second
argument is

 * is not a valid type for that entity’s
primary key or

 * is null

 */

 public <T> T find(Class<T> entityClass,

 Object primaryKey,

 Map<String, Object> properties);



 /**

 * Find by primary key and lock.

 * Search for an entity of the specified
class and primary key

 * and lock it with respect to the specified
lock type.

 * If the entity instance is contained in the
persistence context

 * it is returned from there, and the effect
of this method is

 * the same as if the lock method had been
called on the entity.

 * If the entity is found within the
persistence context and the

 * lock mode type is pessimistic and the
entity has a version

 * attribute, the persistence provider must
perform optimistic

 * version checks when obtaining the database
lock. If these

 * checks fail, the OptimisticLockException
will be thrown.

 * If the lock mode type is pessimistic and
the entity instance

 * is found but cannot be locked:

 * - the PessimisticLockException will be
thrown if the database

 * locking failure causes transaction-level
rollback

 * - the LockTimeoutException will be thrown
if the database

 * locking failure causes only
statement-level rollback

 * @param entityClass

 * @param primaryKey

 * @param lockMode

 * @return the found entity instance or null
if the entity does

 * not exist

 * @throws IllegalArgumentException if the
first argument does

 * not denote an entity type or the second
argument is

 * not a valid type for that entity's primary
key or

 * is null

 * @throws TransactionRequiredException if
there is no

 * transaction and a lock mode other than
NONE is

 * specified or if invoked on an entity
manager which has

 * not been joined to the current transaction
and a lock

 * mode other than NONE is specified

 * @throws OptimisticLockException if the
optimistic version

 * check fails

 * @throws PessimisticLockException if
pessimistic locking

 * fails and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking fails and

 * only the statement is rolled back

 * @throws PersistenceException if an
unsupported lock call

 * is made

 */

 public <T> T find(Class<T> entityClass,

 Object primaryKey,

 LockModeType lockMode);



 /**

 * Find by primary key and lock, using the
specified properties.

 * Search for an entity of the specified
class and primary key

 * and lock it with respect to the specified
lock type.

 * If the entity instance is contained in the
persistence context

 * it is returned from there. If the entity
is found

 * within the persistence context and the
lock mode type

 * is pessimistic and the entity has a
version attribute, the

 * persistence provider must perform
optimistic version checks

 * when obtaining the database lock. If these
checks fail,

 * the OptimisticLockException will be
thrown.

 * If the lock mode type is pessimistic and
the entity instance

 * is found but cannot be locked:

 * - the PessimisticLockException will be
thrown if the database

 * locking failure causes transaction-level
rollback

 * - the LockTimeoutException will be thrown
if the database

 * locking failure causes only
statement-level rollback

 * If a vendor-specific property or hint is
not recognized,

 * it is silently ignored.

 * Portable applications should not rely on
the standard timeout

 * hint. Depending on the database in use and
the locking

 * mechanisms used by the provider, the hint
may or may not

 * be observed.

 * @param entityClass

 * @param primaryKey

 * @param lockMode

 * @param properties standard and
vendor-specific properties

 * and hints

 * @return the found entity instance or null
if the entity does

 * not exist

 * @throws IllegalArgumentException if the
first argument does

 * not denote an entity type or the second
argument is

 * not a valid type for that entity's primary
key or

 * is null

 * @throws TransactionRequiredException if
there is no

 * transaction and a lock mode other than
NONE is

 * specified or if invoked on an entity
manager which has

 * not been joined to the current transaction
and a lock

 * mode other than NONE is specified

 * @throws OptimisticLockException if the
optimistic version

 * check fails

 * @throws PessimisticLockException if
pessimistic locking

 * fails and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking fails and

 * only the statement is rolled back

 * @throws PersistenceException if an
unsupported lock call

 * is made

 */

 public <T> T find(Class<T> entityClass,

 Object primaryKey,

 LockModeType lockMode,

 Map<String, Object> properties);



 /**

 * Get an instance, whose state may be lazily
fetched.

 * If the requested instance does not exist
in the database,

 * the EntityNotFoundException is thrown when
the instance

 * state is first accessed. (The persistence
provider runtime is

 * permitted to throw the
EntityNotFoundException when

 * getReference is called.)

 * The application should not expect that the
instance state will

 * be available upon detachment, unless it
was accessed by the

 * application while the entity manager was
open.

 * @param entityClass

 * @param primaryKey

 * @return the found entity instance

 * @throws IllegalArgumentException if the
first argument does

 * not denote an entity type or the second
argument is

 * not a valid type for that entity’s primary
key or

 * is null

 * @throws EntityNotFoundException if the
entity state

 * cannot be accessed

 */

 public <T> T getReference(Class<T>
entityClass,

 Object primaryKey);



 /**

 * Synchronize the persistence context to the

 * underlying database.

 * @throws TransactionRequiredException if
there is

 * no transaction or if the entity manager
has not been

 * joined to the current transaction

 * @throws PersistenceException if the flush
fails

 */

 public void flush();



 /**

 * Set the flush mode that applies to all
objects contained

 * in the persistence context.

 * @param flushMode

 */

 public void setFlushMode(FlushModeType
flushMode);





 /**

 * Get the flush mode that applies to all
objects contained

 * in the persistence context.

 * @return flushMode

 */

 public FlushModeType getFlushMode();



 /**

 * Lock an entity instance that is contained
in the persistence

 * context with the specified lock mode type.

 * If a pessimistic lock mode type is
specified and the entity

 * contains a version attribute, the
persistence provider must

 * also perform optimistic version checks
when obtaining the

 * database lock. If these checks fail, the

 * OptimisticLockException will be thrown.

 * If the lock mode type is pessimistic and
the entity instance

 * is found but cannot be locked:

 * - the PessimisticLockException will be
thrown if the database

 * locking failure causes transaction-level
rollback

 * - the LockTimeoutException will be thrown
if the database

 * locking failure causes only
statement-level rollback

 * @param entity

 * @param lockMode

 * @throws IllegalArgumentException if the
instance is not an

 * entity or is a detached entity

 * @throws TransactionRequiredException if
there is no

 * transaction or if invoked on an entity
manager which

 * has not been joined to the current
transaction

 * @throws EntityNotFoundException if the
entity does not exist

 * in the database when pessimistic locking
is

 * performed

 * @throws OptimisticLockException if the
optimistic version

 * check fails

 * @throws PessimisticLockException if
pessimistic locking fails

 * and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking fails and

 * only the statement is rolled back

 * @throws PersistenceException if an
unsupported lock call

 * is made

 */

 public void lock(Object entity, LockModeType
lockMode);



 /**

 * Lock an entity instance that is contained
in the persistence

 * context with the specified lock mode type
and with specified

 * properties.

 * If a pessimistic lock mode type is
specified and the entity

 * contains a version attribute, the
persistence provider must

 * also perform optimistic version checks
when obtaining the

 * database lock. If these checks fail, the

 * OptimisticLockException will be thrown.

 * If the lock mode type is pessimistic and
the entity instance

 * is found but cannot be locked:

 * - the PessimisticLockException will be
thrown if the database

 * locking failure causes transaction-level
rollback

 * - the LockTimeoutException will be thrown
if the database

 * locking failure causes only
statement-level rollback

 * If a vendor-specific property or hint is
not recognized,

 * it is silently ignored.

 * Portable applications should not rely on
the standard timeout

 * hint. Depending on the database in use and
the locking

 * mechanisms used by the provider, the hint
may or may not

 * be observed.

 * @param entity

 * @param lockMode

 * @param properties standard and
vendor-specific properties

 * and hints

 * @throws IllegalArgumentException if the
instance is not an

 * entity or is a detached entity

 * @throws TransactionRequiredException if
there is no

 * transaction or if invoked on an entity
manager which

 * has not been joined to the current
transaction

 * @throws EntityNotFoundException if the
entity does not exist

 * in the database when pessimistic locking
is

 * performed

 * @throws OptimisticLockException if the
optimistic version

 * check fails

 * @throws PessimisticLockException if
pessimistic locking fails

 * and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking fails and

 * only the statement is rolled back

 * @throws PersistenceException if an
unsupported lock call

 * is made

 */

 public void lock(Object entity,

 LockModeType lockMode,

 Map<String, Object> properties);



 /**

 * Refresh the state of the instance from the
database,

 * overwriting changes made to the entity, if
any.

 * @param entity

 * @throws IllegalArgumentException if the
instance is not

 * an entity or the entity is not managed

 * @throws TransactionRequiredException if
there is no

 * transaction when invoked on a
container-managed

 * entity manager that is of type

 * PersistenceContextType.TRANSACTION.

 * @throws EntityNotFoundException if the
entity no longer

 * exists in the database

 */

 public void refresh(Object entity);



 /**

 * Refresh the state of the instance from the
database, using

 * the specified properties, and overwriting
changes made to

 * the entity, if any.

 * If a vendor-specific property or hint is
not recognized,

 * it is silently ignored.

 * @param entity

 * @param properties standard and
vendor-specific properties

 * and hints

 * @throws IllegalArgumentException if the
instance is not

 * an entity or the entity is not managed

 * @throws TransactionRequiredException if
there is no

 * transaction when invoked on a
container-managed

 * entity manager that is of type

 * PersistenceContextType.TRANSACTION.

 * @throws EntityNotFoundException if the
entity no longer

 * exists in the database

 */

 public void refresh(Object entity,

 Map<String, Object> properties);



 /**

 * Refresh the state of the instance from the
database,

 * overwriting changes made to the entity, if
any, and

 * lock it with respect to given lock mode
type.

 * If the lock mode type is pessimistic and
the entity instance

 * is found but cannot be locked:

 * - the PessimisticLockException will be
thrown if the database

 * locking failure causes transaction-level
rollback

 * - the LockTimeoutException will be thrown
if the

 * database locking failure causes only
statement-level

 * rollback.

 * @param entity

 * @param lockMode

 * @throws IllegalArgumentException if the
instance is not

 * an entity or the entity is not managed

 * @throws TransactionRequiredException if
invoked on an entity

 * manager of type
PersistenceContextType.TRANSACTION

 * when there is no transaction; if invoked
on an

 * extended entity manager when there is no
transaction

 * and a lock mode other than NONE has been
specified;

 * or if invoked on an extended entity
manager that has

 * not been joined to the current transaction
and a lock

 * mode other than NONE has been specified

 * @throws EntityNotFoundException if the
entity no longer exists

 * in the database

 * @throws PessimisticLockException if
pessimistic locking fails

 * and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking fails and

 * only the statement is rolled back

 * @throws PersistenceException if an
unsupported lock call

 * is made

 */

 public void refresh(Object entity,
LockModeType lockMode);



 /**

 * Refresh the state of the instance from the
database,

 * overwriting changes made to the entity, if
any, and

 * lock it with respect to given lock mode
type and with

 * specified properties.

 * If the lock mode type is pessimistic and
the entity instance

 * is found but cannot be locked:

 * - the PessimisticLockException will be
thrown if the database

 * locking failure causes transaction-level
rollback

 * - the LockTimeoutException will be thrown
if the database

 * locking failure causes only
statement-level rollback

 * If a vendor-specific property or hint is
not recognized,

 * it is silently ignored.

 * Portable applications should not rely on
the standard timeout

 * hint. Depending on the database in use and
the locking

 * mechanisms used by the provider, the hint
may or may not

 * be observed.

 * @param entity

 * @param lockMode

 * @param properties standard and
vendor-specific properties

 * and hints

 * @throws IllegalArgumentException if the
instance is not

 * an entity or the entity is not managed

 * @throws TransactionRequiredException if
invoked on an entity

 * manager of type
PersistenceContextType.TRANSACTION

 * when there is no transaction; if invoked
on an

 * extended entity manager when there is no
transaction

 * and a lock mode other than NONE has been
specified;

 * or if invoked on an extended entity
manager that has

 * not been joined to the current transaction
and a lock

 * mode other than NONE has been specified

 * @throws EntityNotFoundException if the
entity no longer exists

 * in the database

 * @throws PessimisticLockException if
pessimistic locking fails

 * and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking fails and

 * only the statement is rolled back

 * @throws PersistenceException if an
unsupported lock call

 * is made

 */

 public void refresh(Object entity,

 LockModeType lockMode,

 Map<String, Object> properties);



 /**

 * Clear the persistence context, causing all
managed

 * entities to become detached. Changes made
to entities that

 * have not been flushed to the database will
not be

 * persisted.

 */

 public void clear();



 /**

 * Remove the given entity from the
persistence context, causing

 * a managed entity to become detached.
Unflushed changes made

 * to the entity if any (including removal of
the entity),

 * will not be synchronized to the database.
Entities which

 * previously referenced the detached entity
will continue to

 * reference it.

 * @param entity

 * @throws IllegalArgumentException if the
instance is not an

 * entity

 */

 public void detach(Object entity);



 /**

 * Check if the instance is a managed entity
instance belonging

 * to the current persistence context.

 * @param entity

 * @return boolean indicating if entity is in
persistence context

 * @throws IllegalArgumentException if not an
entity

 */

 public boolean contains(Object entity);









 /**

 * Get the current lock mode for the entity
instance.

 * @param entity

 * @return lock mode

 * @throws TransactionRequiredException if
there is no

 * transaction or if the entity manager has
not been

 * joined to the current transaction

 * @throws IllegalArgumentException if the
instance is not a

 * managed entity and a transaction is active

 */

 public LockModeType getLockMode(Object
entity);



 /**

 * Set an entity manager property or hint. If
a vendor-specific

 * property or hint is not recognized, it is
silently ignored.

 * @param propertyName name of property or
hint

 * @param value

 * @throws IllegalArgumentException if the
second argument is

 * not valid for the implementation

 */

 public void setProperty(String propertyName,
Object value);



 /**

 * Get the properties and hints and
associated values that are

 * in effect for the entity manager. Changing
the contents of

 * the map does not change the configuration
in effect.

 * @return map of properties and hints in
effect

 */

 public Map<String, Object> getProperties();



 /**

 * Create an instance of Query for executing
a

 * Java Persistence query language statement.

 * @param qlString a Java Persistence query
string

 * @return the new query instance

 * @throws IllegalArgumentException if the
query string is

 * found to be invalid

 */

 public Query createQuery(String qlString);



 /**

 * Create an instance of TypedQuery for
executing a

 * criteria query.

 * @param criteriaQuery a criteria query
object

 * @return the new query instance

 * @throws IllegalArgumentException if the
criteria query is

 * found to be invalid

 */

 public <T> TypedQuery<T> createQuery(

 CriteriaQuery<T> criteriaQuery);

 /**

 * Create an instance of Query for executing
a criteria

 * update query.

 * @param updateQuery a criteria update query
object

 * @return the new query instance

 * @throws IllegalArgumentException if the
update query is

 * found to be invalid

 */

 public Query createQuery(CriteriaUpdate
updateQuery);

 /**

 * Create an instance of Query for executing
a criteria

 * delete query.

 * @param deleteQuery a criteria delete query
object

 * @return the new query instance

 * @throws IllegalArgumentException if the
delete query is

 * found to be invalid

 */

 public Query createQuery(CriteriaDelete
deleteQuery);



 /**

 * Create an instance of TypedQuery for
executing a

 * Java Persistence query language statement.

 * The select list of the query must contain
only a single

 * item, which must be assignable to the type
specified by

{empty} * the resultClass
argument.link:#a19562[26]

 * @param qlString a Java Persistence query
string

 * @param resultClass the type of the query
result

 * @return the new query instance

 * @throws IllegalArgumentException if the
query string is found

 * to be invalid or if the query result is
found to

 * not be assignable to the specified type

 */

 public <T> TypedQuery<T> createQuery(String
qlString,

 Class<T> resultClass);



 /**

 * Create an instance of Query for executing
a named query

 * (in the Java Persistence query language or
in native SQL).

 * @param name the name of a query defined in
metadata

 * @return the new query instance

 * @throws IllegalArgumentException if a
query has not been

 * defined with the given name or if the
query string is

 * found to be invalid

 */

 public Query createNamedQuery(String name);



 /**

 * Create an instance of TypedQuery for
executing a

 * Java Persistence query language named
query.

 * The select list of the query must contain
only a single

 * item, which must be assignable to the type
specified by

{empty} * the resultClass
argument.link:#a19563[27]

 * @param name the name of a query defined in
metadata

 * @param resultClass the type of the query
result

 * @return the new query instance

 * @throws IllegalArgumentException if a
query has not been

 * defined with the given name or if the
query string is

 * found to be invalid or if the query result
is found to

 * not be assignable to the specified type

 */

 public <T> TypedQuery<T>
createNamedQuery(String name,

 Class<T> resultClass);

 /**

 * Create an instance of Query for executing
a native SQL

 * statement, e.g., for update or delete.

 * If the query is not an update or delete
query, query

 * execution will result in each row of the
SQL result

 * being returned as a result of type
Object[] (or a result

 * of type Object if there is only one column
in the select

 * list.) Column values are returned in the
order of their

 * appearance in the select list and default
JDBC type

 * mappings are applied.

 * @param sqlString a native SQL query string

 * @return the new query instance

 */

 public Query createNativeQuery(String
sqlString);



 /**

 * Create an instance of Query for executing

 * a native SQL query.

 * @param sqlString a native SQL query string

 * @param resultClass the class of the
resulting instance(s)

 * @return the new query instance

 */

 public Query createNativeQuery(String
sqlString,

 Class resultClass);



 /**

 * Create an instance of Query for executing

 * a native SQL query.

 * @param sqlString a native SQL query string

 * @param resultSetMapping the name of the
result set mapping

 * @return the new query instance

 */

 public Query createNativeQuery(String
sqlString,

 String resultSetMapping);



 /**

 * Create an instance of StoredProcedureQuery
for executing a

 * stored procedure in the database.

 * @param name name assigned to the stored
procedure query

 * in metadata

 * @return the new stored procedure query
instance

 * @throws IllegalArgumentException if a
query has not been

 * defined with the given name

 */

 public StoredProcedureQuery
createNamedStoredProcedureQuery(

 String name);



 /**

 * Create an instance of StoredProcedureQuery
for executing a

 * stored procedure in the database.

 * Parameters must be registered before the
stored procedure can

 * be executed.

 * If the stored procedure returns one or
more result sets,

 * any result set will be returned as a list
of type Object[].

 * @param procedureName name of the stored
procedure in the

 * database

 * @return the new stored procedure query
instance

 * @throws IllegalArgumentException if a
stored procedure of the

 * given name does not exist (or the query
execution

 * will fail)

 */

 public StoredProcedureQuery
createStoredProcedureQuery(

 String procedureName);



 /**

 * Create an instance of StoredProcedureQuery
for executing a

 * stored procedure in the database.

 * Parameters must be registered before the
stored procedure can

 * be executed.

 * The resultClass arguments must be
specified in the order in

 * which the result sets will be returned by
the stored procedure

 * invocation.

 * @param procedureName name of the stored
procedure in the

 * database

 * @param resultClasses classes to which the
result sets

 * produced by the stored procedure are to

 * be mapped

 * @return the new stored procedure query
instance

 * @throws IllegalArgumentException if a
stored procedure of the

 * given name does not exist (or the query
execution

 * will fail)

 */

 public StoredProcedureQuery
createStoredProcedureQuery(

 String procedureName, Class...
resultClasses);



 /**

 * Create an instance of StoredProcedureQuery
for executing a

 * stored procedure in the database.

 * Parameters must be registered before the
stored procedure can

 * be executed.

 * The resultSetMapping arguments must be
specified in the order

 * in which the result sets will be returned
by the stored

 * procedure invocation.

 * @param procedureName name of the stored
procedure in the

 * database

 * @param resultSetMappings the names of the
result set mappings

 * to be used in mapping result sets

 * returned by the stored procedure

 * @return the new stored procedure query
instance

 * @throws IllegalArgumentException if a
stored procedure or

 * result set mapping of the given name does
not exist

 * (or the query execution will fail)

 */

 public StoredProcedureQuery
createStoredProcedureQuery(

 String procedureName, String...
resultSetMappings);



 /**

 * Indicate to the entity manager that a JTA
transaction is

 * active. This method should be called on a
JTA application

 * managed entity manager that was created
outside the scope

 * of the active transaction or on an entity
manager of type

 * SynchronizationType.UNSYNCHRONIZED to
associate it with the

 * current JTA transaction.

 * @throws TransactionRequiredException if
there is

 * no transaction

 */

 public void joinTransaction();



 /**

 * Determine whether the entity manager is
joined to the

 * current transaction. Returns false if the
entity manager

 * is not joined to the current transaction
or if no

 * transaction is active

 * @return boolean

 */

 public boolean isJoinedToTransaction();





 /**

 * Return an object of the specified type to
allow access to the

 * provider-specific API. If the provider's
EntityManager

 * implementation does not support the
specified class, the

 * PersistenceException is thrown.

 * @param cls the class of the object to be
returned. This is

 * normally either the underlying
EntityManager implementation

 * class or an interface that it implements.

 * @return an instance of the specified class

 * @throws PersistenceException if the
provider does not

 * support the call

 */

 public <T> T unwrap(Class<T> cls);



 /**

 * Return the underlying provider object for
the EntityManager,

 * if available. The result of this method is
implementation

 * specific. The unwrap method is to be
preferred for new

 * applications.

 * @return underlying provider object for
EntityManager

 */

 public Object getDelegate();



 /**

 * Close an application-managed entity
manager.

 * After the close method has been invoked,
all methods

 * on the EntityManager instance and any
Query, TypedQuery, and

 * StoredProcedureQuery objects obtained from
it will throw the

 * IllegalStateException except for
getProperties,

 * getTransaction, and isOpen (which will
return false).

 * If this method is called when the entity
manager is

 * joined to an active transaction, the
persistence

 * context remains managed until the
transaction completes.

 * @throws IllegalStateException if the
entity manager

 * is container-managed

 */

 public void close();



 /**

 * Determine whether the entity manager is
open.

 * @return true until the entity manager has
been closed

 */

 public boolean isOpen();













 /**

 * Return the resource-level
EntityTransaction object.

 * The EntityTransaction instance may be used
serially to

 * begin and commit multiple transactions.

 * @return EntityTransaction instance

 * @throws IllegalStateException if invoked
on a JTA

 * entity manager

 */

 public EntityTransaction getTransaction();



 /**

 * Return the entity manager factory for the
entity manager.

 * @return EntityManagerFactory instance

 * @throws IllegalStateException if the
entity manager has

 * been closed

 */

 public EntityManagerFactory
getEntityManagerFactory();



 /**

 * Return an instance of CriteriaBuilder for
the creation of

 * CriteriaQuery objects.

 * @return CriteriaBuilder instance

 * @throws IllegalStateException if the
entity manager has

 * been closed

 */

 public CriteriaBuilder getCriteriaBuilder();



 /**

 * Return an instance of Metamodel interface
for access to the

 * metamodel of the persistence unit.

 * @return Metamodel instance

 * @throws IllegalStateException if the
entity manager has

 * been closed

 */

 public Metamodel getMetamodel();



 /**

 * Return a mutable EntityGraph that can be
used to dynamically

 * create an EntityGraph.

 * @param rootType class of entity graph

 * @return entity graph

 */

 public <T> EntityGraph<T>
createEntityGraph(Class<T> rootType);



 /**

 * Return a mutable copy of the named
EntityGraph. If there

 * is no entity graph with the specified
name, null is returned.

 * @param graphName name of an entity graph

 * @return entity graph

 */

 public EntityGraph<?>
createEntityGraph(String graphName);

















 /**

 * Return a named EntityGraph. The returned
EntityGraph

 * should be considered immutable.

 * @param graphName name of an existing
entity graph

 * @return named entity graph

 * @throws IllegalArgumentException if there
is no EntityGraph of

 * the given name

 */

 public EntityGraph<?> getEntityGraph(String
graphName);



 /**

 * Return all named EntityGraphs that have
been defined for the

 * provided class type.

 * @param entityClass entity class

 * @return list of all entity graphs defined
for the entity

 * @throws IllegalArgumentException if the
class is not an entity

 */

 public <T> List<EntityGraph<? super T>>

 getEntityGraphs(Class<T> entityClass);

}

The _persist_ , _merge_ , _remove_ , and
_refresh_ methods must be invoked within a transaction context when an
entity manager with a transaction-scoped persistence context is used. If
there is no transaction context, the
_javax.persistence.TransactionRequiredException_ is thrown.

Methods that specify a lock mode other than
_LockModeType.NONE_ must be invoked within a transaction. If there is no
transaction or if the entity manager has not been joined to the
transaction, the _javax.persistence.TransactionRequiredException_ is
thrown.

The _find_ method (provided it is invoked
without a lock or invoked with _LockModeType.NONE_ ) and the
_getReference_ method are not required to be invoked within a
transaction. If an entity manager with transaction-scoped persistence
context is in use, the resulting entities will be detached; if an entity
manager with an extended persistence context is used, they will be
managed. See section link:Per.html#a2027[See Persistence Context
Lifetime and Synchronization Type] for entity manager use outside a
transaction.

The _Query_ , _TypedQuery_ ,
_StoredProcedureQuery_ , _CriteriaBuilder_ , _Metamodel_ , and
_EntityTransaction_ objects obtained from an entity manager are valid
while that entity manager is open.

If the argument to the _createQuery_ method
is not a valid Java Persistence query string or a valid _CriteriaQuery_
object, the _IllegalArgumentException_ may be thrown or the query
execution will fail and a _PersistenceException_ will be thrown. If the
result class specification of a Java Persistence query language query is
incompatible with the result of the query, the
_IllegalArgumentException_ may be thrown when the _createQuery_ method
is invoked or the query execution will fail and a _PersistenceException_
will be thrown when the query is executed. If a native query is not a
valid query for the database in use or if the result set specification
is incompatible with the result of the query, the query execution will
fail and a _PersistenceException_ will be thrown when the query is
executed. The _PersistenceException_ should wrap the underlying database
exception when possible.

Runtime exceptions thrown by the methods of
the _EntityManager_ interface other than the _LockTimeoutException_ will
cause the current transaction to be marked for rollback if the
persistence context is joined to that transaction.

The methods _close_ , _isOpen_ ,
_joinTransaction_ , and _getTransaction_ are used to manage
application-managed entity managers and their lifecycle. See Section
link:Per.html#a11465[See Obtaining an Application-managed Entity
Manager].

The _EntityManager_ interface and other
interfaces defined by this specification contain methods that take
properties and/or hints as arguments. This specification distinguishes
between _properties_ and _hints_ as follows:

A property defined by this specification must
be observed by the provider unless otherwise explicitly stated.

A hint specifies a preference on the part of
the application. While a hint defined by this specification should be
observed by the provider if possible, a hint may or may not always be
observed. A portable application must not depend on the observance of a
hint.

==== Example of Use of EntityManager API



@Stateless public class OrderEntryBean
implements OrderEntry \{



 @PersistenceContext EntityManager em;



 public void enterOrder(int custID, Order
newOrder) \{

 Customer cust = em.find(Customer.class,
custID);

 cust.getOrders().add(newOrder);

 newOrder.setCustomer(cust);

 em.persist(newOrder);

 }

}

=== [[a1929]]Entity Instance’s Life Cycle

image:Per-4.png[image]

This section describes the _EntityManager_
operations for managing an entity instance’s lifecycle. An entity
instance can be characterized as being new, managed, detached, or
removed.

A new entity instance has no persistent
identity, and is not yet associated with a persistence context.

A managed entity instance is an instance with
a persistent identity that is currently associated with a persistence
context.

A detached entity instance is an instance
with a persistent identity that is not (or no longer) associated with a
persistence context.

A removed entity instance is an instance with
a persistent identity, associated with a persistence context, that will
be removed from the database upon transaction commit.

The following subsections describe the effect
of lifecycle operations upon entities. Use of the _cascade_ annotation
element may be used to propagate the effect of an operation to
associated entities. The cascade functionality is most typically used in
parent-child relationships.

==== Entity Instance Creation

Entity instances are created by means of the
_new_ operation. An entity instance, when first created by _new_ is not
yet persistent. An instance becomes persistent by means of the
_EntityManager_ API.

==== Persisting an Entity Instance

A new entity instance becomes both managed
and persistent by invoking the _persist_ method on it or by cascading
the persist operation.

The semantics of the persist operation,
applied to an entity _X_ are as follows:

If X is a new entity, it becomes managed. The
entity X will be entered into the database at or before transaction
commit or as a result of the flush operation.

If X is a preexisting managed entity, it is
ignored by the persist operation. However, the persist operation is
cascaded to entities referenced by X, if the relationships from X to
these other entities are annotated with the _cascade=PERSIST_ or
_cascade=ALL_ annotation element value or specified with the equivalent
XML descriptor element.

If X is a removed entity, it becomes managed.

If X is a detached object, the
_EntityExistsException_ may be thrown when the persist operation is
invoked, or the _EntityExistsException_ or another
_PersistenceException_ _may_ be thrown at flush or commit time.

For all entities Y referenced by a
relationship from X, if the relationship to Y has been annotated with
the _cascade_ element value _cascade=PERSIST_ or _cascade=ALL_ , the
persist operation is applied to Y.

==== [[a1946]]Removal

A managed entity instance becomes removed by
invoking the _remove_ method on it or by cascading the remove operation.

The semantics of the remove operation,
applied to an entity X are as follows:

If X is a new entity, it is ignored by the
remove operation. However, the remove operation is cascaded to entities
referenced by X, if the relationship from X to these other entities is
annotated with the _cascade=REMOVE_ or _cascade=ALL_ annotation element
value.

If X is a managed entity, the remove
operation causes it to become removed. The remove operation is cascaded
to entities referenced by X, if the relationships from X to these other
entities is annotated with the _cascade=REMOVE_ or _cascade=ALL_
annotation element value.

If X is a detached entity, an
_IllegalArgumentException_ will be thrown by the remove operation (or
the transaction commit will fail).

If X is a removed entity, it is ignored by
the remove operation.

A removed entity X will be removed from the
database at or before transaction commit or as a result of the flush
operation.

After an entity has been removed, its state
(except for generated state) will be that of the entity at the point at
which the remove operation was called.

==== [[a1955]]Synchronization to the Database

In general, a persistence context will be
synchronized to the database as described below. However, a persistence
context of type _SynchronizationType.UNSYNCHRONIZED_ or an
application-managed persistence context that has been created outside
the scope of the current transaction will only be synchronized to the
database if it has been joined to the current transaction by the
application’s use of the _EntityManager_ _joinTransaction_ method.

The state of persistent entities is
synchronized to the database at transaction commit. This synchronization
involves writing to the database any updates to persistent entities and
their relationships as specified above.

An update to the state of an entity includes
both the assignment of a new value to a persistent property or field of
the entity as well as the modification of a mutable value of a
persistent property or fieldlink:#a19564[28].

Synchronization to the database does not
involve a refresh of any managed entities unless the _refresh_ operation
is explicitly invoked on those entities or cascaded to them as a result
of the specification of the _cascade=REFRESH_ or _cascade=ALL_
annotation element value.

{empty}Bidirectional relationships between
managed entities will be persisted based on references held by the
owning side of the relationship. It is the developer’s responsibility to
keep the in-memory references held on the owning side and those held on
the inverse side consistent with each other when they change. In the
case of unidirectional one-to-one and one-to-many relationships, it is
the developer’s responsibility to insure that the semantics of the
relationships are adhered to.link:#a19565[29]

It is particularly important to ensure that
changes to the inverse side of a relationship result in appropriate
updates on the owning side, so as to ensure the changes are not lost
when they are synchronized to the database.

The persistence provider runtime is permitted
to perform synchronization to the database at other times as well when a
transaction is active and the persistence context is joined to the
transaction. The _flush_ method can be used by the application to force
synchronization. It applies to entities associated with the persistence
context. The _setFlushMode_ methods of the _EntityManager_ , _Query_ ,
_TypedQuery_ , and _StoredProcedureQuery_ interfaces can be used to
control synchronization semantics. The effect of _FlushModeType.AUTO_ is
defined in section link:Per.html#a4374[See Queries and Flush
Mode]. If _FlushModeType.COMMIT_ is specified, flushing will occur at
transaction commit; the persistence provider is permitted, but not
required, to perform to flush at other times. If there is no transaction
active or if the persistence context has not been joined to the current
transaction, the persistence provider must not flush to the database.

The semantics of the flush operation, applied
to an entity _X_ are as follows:

If X is a managed entity, it is synchronized
to the database.

For all entities Y referenced by a
relationship from X, if the relationship to Y has been annotated with
the _cascade_ element value _cascade=PERSIST_ or _cascade=ALL_ , the
persist operation is applied to Y.

For any entity Y referenced by a relationship
from X, where the relationship to Y has not been annotated with the
_cascade_ element value _cascade=PERSIST_ or _cascade=ALL_ :

If Y is new or removed, an
_IllegalStateException_ will be thrown by the flush operation (and the
transaction marked for rollback) or the transaction commit will fail.

If Y is detached, the semantics depend upon
the ownership of the relationship. If X owns the relationship, any
changes to the relationship are synchronized with the database;
otherwise, if Y owns the relationships, the behavior is undefined.

If X is a removed entity, it is removed from
the database. No cascade options are relevant.

==== Refreshing an Entity Instance

The state of a managed entity instance is
refreshed from the database by invoking the _refresh_ method on it or by
cascading the refresh operation.

The semantics of the refresh operation,
applied to an entity X are as follows:

If X is a managed entity, the state of X is
refreshed from the database, overwriting changes made to the entity, if
any. The refresh operation is cascaded to entities referenced by X if
the relationship from X to these other entities is annotated with the
_cascade=REFRESH_ or _cascade=ALL_ annotation element value.

If X is a new, detached, or removed entity,
the _IllegalArgumentException_ is thrown.

==== Evicting an Entity Instance from the Persistence Context

An entity instance is removed from the
persistence context by invoking the _detach_ method on it or cascading
the detach operation. Changes made to the entity, if any (including
removal of the entity), will not be synchronized to the database after
such eviction has taken place.

Applications must use the _flush_ method
prior to the _detach_ method to ensure portable semantics if changes
have been made to the entity (including removal of the entity). Because
the persistence provider may write to the database at times other than
the explicit invocation of the _flush_ method, portable applications
must not assume that changes have not been written to the database if
the _flush_ method has not been called prior to detach.

The semantics of the detach operation,
applied to an entity X are as follows:

If X is a managed entity, the detach
operation causes it to become detached. The detach operation is cascaded
to entities referenced by X if the relationships from X to these other
entities is annotated with the _cascade=DETACH_ or _cascade=ALL_
annotation element value. Entities which previously referenced X will
continue to reference X.

If X is a new or detached entity, it is
ignored by the detach operation.

If X is a removed entity, the detach
operation causes it to become detached. The detach operation is cascaded
to entities referenced by X if the relationships from X to these other
entities is annotated with the _cascade=DETACH_ or c _ascade=ALL_
annotation element value. Entities which previously referenced X will
continue to reference X. Portable applications should not pass removed
entities that have been detached from the persistence context to further
EntityManager operations.

==== [[a1982]]Detached Entities

A detached entity results from transaction
commit if a transaction-scoped persistence context is used (see section
link:Per.html#a2027[See Persistence Context Lifetime and
Synchronization Type]); from transaction rollback (see section
link:Per.html#a2049[See Transaction Rollback]); from detaching
the entity from the persistence context; from clearing the persistence
context; from closing an entity manager; or from serializing an entity
or otherwise passing an entity by value—e.g., to a separate application
tier, through a remote interface, etc.

Detached entity instances continue to live
outside of the persistence context in which they were persisted or
retrieved. Their state is no longer guaranteed to be synchronized with
the database state.

The application may access the available
state of available detached entity instances after the persistence
context ends. The available state includes:

Any persistent field or property not marked
_fetch=LAZY_

Any persistent field or property that was
accessed by the application or fetched by means of an entity graph

If the persistent field or property is an
association, the available state of an associated instance may only be
safely accessed if the associated instance is available. The available
instances include:

Any entity instance retrieved using _find()_
.

Any entity instances retrieved using a query
or explicitly requested in a fetch join.

Any entity instance for which an instance
variable holding non-primary-key persistent state was accessed by the
application.

Any entity instance that can be reached from
another available instance by navigating associations marked
_fetch=EAGER_ .

===== Merging Detached Entity State

The merge operation allows for the
propagation of state from detached entities onto persistent entities
managed by the entity manager.

The semantics of the merge operation applied
to an entity X are as follows:

If X is a detached entity, the state of X is
copied onto a pre-existing managed entity instance X' of the same
identity or a new managed copy X' of X is created.

If X is a new entity instance, a new managed
entity instance X' is created and the state of X is _copied_ into the
new managed entity instance X'.

If X is a removed entity instance, an
_IllegalArgumentException_ will be thrown by the merge operation (or the
transaction commit will fail).

If X is a managed entity, it is ignored by
the merge operation, however, the merge operation is cascaded to
entities referenced by relationships from X if these relationships have
been annotated with the _cascade_ element value _cascade=MERGE_ or
_cascade=ALL_ annotation.

For all entities Y referenced by
relationships from X having the _cascade_ element value _cascade=MERGE_
or _cascade=ALL_ , Y is merged recursively as Y'. For all such Y
referenced by X, X' is set to reference Y'. (Note that if X is managed
then X is the same object as X'.)

If X is an entity merged to X', with a
reference to another entity Y, where _cascade=MERGE_ or _cascade=ALL_ is
not specified, then navigation of the same association from X' yields a
reference to a managed object Y' with the same persistent identity as Y.

The persistence provider must not merge
fields marked LAZY that have not been fetched: it must ignore such
fields when merging.

Any _Version_ columns used by the entity must
be checked by the persistence runtime implementation during the merge
operation and/or at flush or commit time. In the absence of _Version_
columns there is no additional version checking done by the persistence
provider runtime during the merge operation.

===== Detached Entities and Lazy Loading

Serializing entities and merging those
entities back into a persistence context may not be interoperable across
vendors when lazy properties or fields and/or relationships are used.

A vendor is required to support the
serialization and subsequent deserialization and merging of detached
entity instances (which may contain lazy properties or fields and/or
relationships that have not been fetched) back into a separate JVM
instance of that vendor's runtime, where both runtime instances have
access to the entity classes and any required vendor persistence
implementation classes.

When interoperability across vendors is
required, the application must not use lazy loading.

==== Managed Instances

It is the responsibility of the application
to insure that an instance is managed in only a single persistence
context. The behavior is undefined if the same Java instance is made
managed in more than one persistence context.

The _contains()_ method can be used to
determine whether an entity instance is managed in the current
persistence context.

The _contains_ method returns true:

If the entity has been retrieved from the
database or has been returned by _getReference_ , and has not been
removed or detached.

If the entity instance is new, and the
_persist_ method has been called on the entity or the persist operation
has been cascaded to it.

The _contains_ method returns false:

If the instance is detached.

If the _remove_ method has been called on the
entity, or the remove operation has been cascaded to it.

If the instance is new, and the _persist_
method has not been called on the entity or the persist operation has
not been cascaded to it.

Note that the effect of the cascading of
persist, merge, remove, or detach is immediately visible to the
_contains_ method, whereas the actual insertion, modification, or
deletion of the database representation for the entity may be deferred
until the end of the transaction.

==== [[a2019]]Load State

An entity is considered to be loaded if all
attributes with _FetchType.EAGER_ —whether explictly specified or by
default—(including relationship and other collection-valued attributes)
have been loaded from the database or assigned by the application.
Attributes with _FetchType.LAZY_ may or may not have been loaded. The
available state of the entity instance and associated instances is as
described in section link:Per.html#a1982[See Detached Entities].

An attribute that is an embeddable is
considered to be loaded if the embeddable attribute was loaded from the
database or assigned by the application, and, if the attribute
references an embeddable instance (i.e., is not null), the embeddable
instance state is known to be loaded (i.e., all attributes of the
embeddable with _FetchType.EAGER_ have been loaded from the database or
assigned by the application).

A collection-valued attribute is considered
to be loaded if the collection was loaded from the database or the value
of the attribute was assigned by the application, and, if the attribute
references a collection instance (i.e., is not null), each element of
the collection (e.g. entity or embeddable) is considered to be loaded.

A single-valued relationship attribute is
considered to be loaded if the relationship attribute was loaded from
the database or assigned by the application, and, if the attribute
references an entity instance (i.e., is not null), the entity instance
state is known to be loaded.

A basic attribute is considered to be loaded
if its state has been loaded from the database or assigned by the
application.

The _PersistenceUtil.isLoaded_ methods can be
used to determine the load state of an entity and its attributes
regardless of the persistence unit with which the entity is associated.
The _PersistenceUtil.isLoaded_ methods return true if the above
conditions hold, and false otherwise. If the persistence unit is known,
the _PersistenceUnitUtil.isLoaded_ methods can be used instead. See
section link:Per.html#a12177[See PersistenceUnitUtil Interface].

Persistence provider contracts for
determining the load state of an entity or entity attribute are
described in section link:Per.html#a13592[See Contracts for
Determining the Load State of an Entity or Entity Attribute].

=== [[a2027]]Persistence Context Lifetime and Synchronization Type

image:Per-4.png[image]

The lifetime of a container-managed
persistence context can either be scoped to a transaction
(transaction-scoped persistence context), or have a lifetime scope that
extends beyond that of a single transaction (extended persistence
context). The enum _PersistenceContextType_ is used to define the
persistence context lifetime scope for container-managed entity
managers. The persistence context lifetime scope is defined when the
EntityManager instance is created (whether explicitly, or in conjunction
with injection or JNDI lookup). See link:Per.html#a11791[See
Container-managed Persistence Contexts].

package javax.persistence;



public enum PersistenceContextType \{

 TRANSACTION,

 EXTENDED

}



By default, the lifetime of the persistence
context of a container-managed entity manager corresponds to the scope
of a transaction (i.e., it is of type
_PersistenceContextType.TRANSACTION_ ).

When an extended persistence context is used,
the extended persistence context exists from the time the EntityManager
instance is created until it is closed. This persistence context might
span multiple transactions and non-transactional invocations of the
EntityManager.

An EntityManager with an extended persistence
context maintains its references to the entity objects after a
transaction has committed. Those objects remain managed by the
EntityManager, and they can be updated as managed objects between
transactions.link:#a19566[30] Navigation from a managed object in
an extended persistence context results in one or more other managed
objects regardless of whether a transaction is active.

When an EntityManager with an extended
persistence context is used, the persist, remove, merge, and refresh
operations can be called regardless of whether a transaction is active.
The effects of these operations will be committed to the database when
the extended persistence context is enlisted in a transaction and the
transaction commits.

The scope of the persistence context of an
application-managed entity manager is extended. It is the responsibility
of the application to manage the lifecycle of the persistence context.

Container-managed persistence contexts are
described further in section link:Per.html#a11791[See
Container-managed Persistence Contexts]. Persistence contexts managed by
the application are described further in section
link:Per.html#a11894[See Application-managed Persistence
Contexts].

==== Synchronization with the Current Transaction

By default, a container-managed persistence
context is of _SynchronizationType.SYNCHRONIZED_ and is automatically
joined to the current transaction. A persistence context of
_SynchronizationType.UNSYNCHRONIZED_ will not be enlisted in the current
transaction, unless the _EntityManager_ _joinTransaction_ method is
invoked.

By default, an application-managed
persistence context that is associated with a JTA entity manager and
that is created within the scope of an active transaction is
automatically joined to that transaction. An application-managed JTA
persistence context that is created outside the scope of a transaction
or an application-managed persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ will not be joined to that
transaction unless the _EntityManager_ _joinTransaction_ method is
invoked.

An application-managed persistence context
associated with a resource-local entity manager is always automatically
joined to any resource-local transaction that is begun for that entity
manager.

Persistence context synchronization type is
described further in section link:Per.html#a11797[See Persistence
Context Synchronization Type].

==== Transaction Commit

The managed entities of a transaction-scoped
persistence context become detached when the transaction commits; the
managed entities of an extended persistence context remain managed.

==== [[a2049]]Transaction Rollback

{empty}For both transaction-scoped
persistence contexts and for extended persistence contexts that are
joined to the current transaction, transaction rollback causes all
_pre-existing_ managed instances and removed
instanceslink:#a19567[31] to become detached. The instances’
state will be the state of the instances at the point at which the
transaction was rolled back. Transaction rollback typically causes the
persistence context to be in an inconsistent state at the point of
rollback. In particular, the state of version attributes and generated
state (e.g., generated primary keys) may be inconsistent. Instances that
were formerly managed by the persistence context (including new
instances that were made persistent in that transaction) may therefore
not be reusable in the same manner as other detached objects—for
example, they may fail when passed to the merge
operation.link:#a19568[32]

NOTE: Because a transaction-scoped
persistence context’s lifetime is scoped to a transaction regardless of
whether it is joined to that transaction, the container closes the
persistence context upon transaction rollback. However, an extended
persistence context that is not joined to a transaction is unaffected by
transaction rollback.

=== [[a2052]]Locking and Concurrency

image:Per-4.png[image]

This specification assumes the use of
optimistic concurrency control. It assumes that the databases to which
persistence units are mapped will be accessed by the implementation
using read-committed isolation (or a vendor equivalent in which
long-term read locks are not held), and that writes to the database will
typically occur only when the _flush_ method has been invoked—whether
explicitly by the application, or by the persistence provider runtime in
accordance with the flush mode setting.

{empty}If a transaction is active and the
persistence context is joined to the transaction, a compliant
implementation of this specification is permitted to write to the
database immediately (i.e., whenever a managed entity is updated,
created, and/or removed), however, the configuration of an
implementation to require such non-deferred database writes is outside
the scope of this specification. link:#a19569[33]

In addition, both pessimistic and optimistic
locking are supported for selected entities by means of specified lock
modes. Optimistic locking is described in sections
link:Per.html#a2056[See Optimistic Locking] and
link:Per.html#a2059[See Version Attributes]; pessimistic locking
in section link:Per.html#a2066[See Pessimistic Locking]. Section
link:Per.html#a2084[See Lock Modes] describes the setting of
optimistic and pessimistic lock modes. The configuration of the setting
of optimistic lock modes is described in section
link:Per.html#a2100[See OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT],
and the configuration of the setting of pessimistic lock modes is
described in section link:Per.html#a2113[See PESSIMISTIC_READ,
PESSIMISTIC_WRITE, PESSIMISTIC_FORCE_INCREMENT].

==== [[a2056]]Optimistic Locking

Optimistic locking is a technique that is
used to insure that updates to the database data corresponding to the
state of an entity are made only when no intervening transaction has
updated that data since the entity state was read. This insures that
updates or deletes to that data are consistent with the current state of
the database and that intervening updates are not lost. Transactions
that would cause this constraint to be violated result in an
_OptimisticLockException_ being thrown and the transaction marked for
rollback.

Portable applications that wish to enable
optimistic locking for entities must specify _Version_ attributes for
those entities—i.e., persistent properties or fields annotated with the
_Version_ annotation or specified in the XML descriptor as version
attributes. Applications are strongly encouraged to enable optimistic
locking for all entities that may be concurrently accessed or that may
be merged from a disconnected state. Failure to use optimistic locking
may lead to inconsistent entity state, lost updates and other state
irregularities. If optimistic locking is not defined as part of the
entity state, the application must bear the burden of maintaining data
consistency.

==== [[a2059]]Version Attributes

The _Version_ field or property is used by
the persistence provider to perform optimistic locking. It is accessed
and/or set by the persistence provider in the course of performing
lifecycle operations on the entity instance. An entity is automatically
enabled for optimistic locking if it has a property or field mapped with
a _Version_ mapping.

An entity may access the state of its version
field or property or export a method for use by the application to
access the version, but must not modify the version
valuelink:#a19570[34]. With the exception noted in section
link:Per.html#a5636[See Bulk Update and Delete Operations], only
the persistence provider is permitted to set or update the value of the
version attribute in the object.

The version attribute is updated by the
persistence provider runtime when the object is written to the database.
All non-relationship fields and properties and all relationships owned
by the entity are included in version checkslink:#a19571[35].

The persistence provider's implementation of
the merge operation must examine the version attribute when an entity is
being merged and throw an _OptimisticLockException_ if it is discovered
that the object being merged is a stale copy of the entity—i.e. that the
entity has been updated since the entity became detached. Depending on
the implementation strategy used, it is possible that this exception may
not be thrown until _flush_ is called or commit time, whichever happens
first.

{empty}The persistence provider runtime is
required to use only the version attribute when performing optimistic
lock checking. Persistence provider implementations may provide
additional mechanisms beside version attributes to enable optimistic
lock checking. However, support for such mechanisms is not required of
an implementation of this specification.link:#a19572[36]

If only some entities contain version
attributes, the persistence provider runtime is required to check those
entities for which version attributes have been specified. The
consistency of the object graph is not guaranteed, but the absence of
version attributes on some of the entities will not stop operations from
completing.

==== [[a2066]]Pessimistic Locking

{empty}While optimistic locking is typically
appropriate in dealing with moderate contention among concurrent
transactions, in some applications it may be useful to immediately
obtain long-term database locks for selected entities because of the
often late failure of optimistic transactions. Such immediately obtained
long-term database locks are referred to here as “pessimistic”
locks.link:#a19573[37]

Pessimistic locking guarantees that once a
transaction has obtained a pessimistic lock on an entity instance:

no other transaction (whether a transaction
of an application using the Java Persistence API or any other
transaction using the underlying resource) may successfully modify or
delete that instance until the transaction holding the lock has ended.

if the pessimistic lock is an exclusive
locklink:#a19574[38], that same transaction may modify or delete
that entity instance.

When an entity instance is locked using
pessimistic locking, the persistence provider must lock the database
row(s) that correspond to the non-collection-valued persistent state of
that instance. If a joined inheritance strategy is used, or if the
entity is otherwise mapped to a secondary table, this entails locking
the row(s) for the entity instance in the additional table(s). Entity
relationships for which the locked entity contains the foreign key will
also be locked, but not the state of the referenced entities (unless
those entities are explicitly locked). Element collections and
relationships for which the entity does not contain the foreign key
(such as relationships that are mapped to join tables or unidirectional
one-to-many relationships for which the target entity contains the
foreign key) will not be locked by default.

Element collections and relationships owned
by the entity that are contained in join tables will be locked if the
_javax.persistence.lock.scope_ property is specified with a value of
_PessimisticLockScope.EXTENDED_ . The state of entities referenced by
such relationships will not be locked (unless those entities are
explicitly locked). This property may be passed as an argument to the
methods of the _EntityManager_ , _Query_ , and _TypedQuery_ interfaces
that allow lock modes to be specified or used with the _NamedQuery_
annotation.

Locking such a relationship or element
collection generally locks only the rows in the join table or collection
table for that relationship or collection. This means that phantoms will
be possible.

The values of the
_javax.persistence.lock.scope_ property are defined by the
_PessimisticLockScope_ enum.

package javax.persistence;



public enum PessimisticLockScope \{

 NORMAL,

 EXTENDED

}

This specification does not define the
mechanisms a persistence provider uses to obtain database locks, and a
portable application should not rely on how pessimistic locking is
achieved on the database.link:#a19575[39] In particular, a
persistence provider or the underlying database management system may
lock more rows than the ones selected by the application.

Whenever a pessimistically locked entity
containing a version attribute is updated on the database, the
persistence provider must also update (increment) the entity's version
column to enable correct interaction with applications using optimistic
locking. See sections link:Per.html#a2059[See Version
Attributes] and link:Per.html#a2084[See Lock Modes].

Pessimistic locking may be applied to
entities that do not contain version attributes. However, in this case
correct interaction with applications using optimistic locking cannot be
ensured.

==== [[a2084]]Lock Modes

Lock modes are intended to provide a facility
that enables the effect of “repeatable read” semantics for the items
read, whether “optimistically” (as described in section
link:Per.html#a2100[See OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT])
or “pessimistically” (as described in section
link:Per.html#a2113[See PESSIMISTIC_READ, PESSIMISTIC_WRITE,
PESSIMISTIC_FORCE_INCREMENT]).

Lock modes can be specified by means of the
EntityManager _lock_ method, the methods of the _EntityManager_ ,
_Query_ , and _TypedQuery_ interfaces that allow lock modes to be
specified, and the _NamedQuery_ annotation.

Lock mode values are defined by the
_LockModeType_ enum. Six distinct lock modes are defined. The lock mode
type values _READ_ and _WRITE_ are synonyms of _OPTIMISTIC_ and
_OPTIMISTIC_FORCE_INCREMENT_ respectively.link:#a19576[40] The
latter are to be preferred for new applications.

package javax.persistence;



public enum LockModeType \{

 READ,

 WRITE,

 OPTIMISTIC,

 OPTIMISTIC_FORCE_INCREMENT,

 PESSIMISTIC_READ,

 PESSIMISTIC_WRITE,

 PESSIMISTIC_FORCE_INCREMENT,

 NONE

}

===== [[a2100]]OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT

The lock modes _OPTIMISTIC_ and
_OPTIMISTIC_FORCE_INCREMENT_ are used for optimistic locking. The lock
mode type values _READ_ and _WRITE_ are synonymous with _OPTIMISTIC_ and
_OPTIMISTIC_FORCE_INCREMENT_ respectively.

The semantics of requesting locks of type
_LockModeType.OPTIMISTIC_ and _LockModeType.OPTIMISTIC_FORCE_INCREMENT_
are the following.

If transaction T1 calls _lock(entity,_
_LockModeType.OPTIMISTIC)_ on a versioned object, the entity manager
must ensure that neither of the following phenomena can occur:

P1 (Dirty read): Transaction T1 modifies a
row. Another transaction T2 then reads that row and obtains the modified
value, before T1 has committed or rolled back. Transaction T2 eventually
commits successfully; it does not matter whether T1 commits or rolls
back and whether it does so before or after T2 commits.

P2 (Non-repeatable read): Transaction T1
reads a row. Another transaction T2 then modifies or deletes that row,
before T1 has committed. Both transactions eventually commit
successfully.

This will generally be achieved by the entity
manager acquiring a lock on the underlying database row. While with
optimistic concurrency concurrency, long-term database read locks are
typically not obtained immediately, a compliant implementation is
permitted to obtain an immediate lock (so long as it is retained until
commit completes). If the lock is deferred until commit time, it must be
retained until the commit completes. Any implementation that supports
repeatable reads in a way that prevents the above phenomena is
permissible.

The persistence implementation is not
required to support calling _lock(entity,_ _LockModeType.OPTIMISTIC)_ on
a non-versioned object. When it cannot support such a lock call, it must
throw the _PersistenceException_ . When supported, whether for versioned
or non-versioned objects, _LockModeType.OPTIMISTIC_ must always prevent
the phenomena P1 and P2. Applications that call _lock(entity,
LockModeType.OPTIMISTIC)_ on non-versioned objects will not be portable.

If transaction T1 calls _lock(entity,_
_LockModeType.OPTIMISTIC_FORCE_INCREMENT)_ on a versioned object, the
entity manager must avoid the phenomena P1 and P2 (as with
_LockModeType.OPTIMISTIC_ ) and must also force an update (increment) to
the entity's version column. A forced version update may be performed
immediately, or may be deferred until a flush or commit. If an entity is
removed before a deferred version update was to have been applied, the
forced version update is omitted.

The persistence implementation is not
required to support calling _lock(entity,_
_LockModeType.OPTIMISTIC_FORCE_INCREMENT)_ on a non-versioned object.
When it cannot support such a lock call, it must throw the
_PersistenceException_ . When supported, whether for versioned or
non-versioned objects, _LockModeType.OPTIMISTIC_FORCE_INCREMENT_ must
always prevent the phenomena P1 and P2. For non-versioned objects,
whether or not _LockModeType.OPTIMISTIC_FORCE_INCREMENT_ has any
additional behavior is vendor-specific. Applications that call
_lock(entity, LockModeType.OPTIMISTIC_FORCE_INCREMENT)_ on non-versioned
objects will not be portable.

For versioned objects, it is permissible for
an implementation to use _LockModeType.OPTIMISTIC_FORCE_INCREMENT_ where
_LockModeType.OPTIMISTIC_ was requested, but not vice versa.

If a versioned object is otherwise updated or
removed, then the implementation must ensure that the requirements of
_LockModeType.OPTIMISTIC_FORCE_INCREMENT_ are met, even if no explicit
call to _EntityManager.lock_ was made.

For portability, an application should not
depend on vendor-specific hints or configuration to ensure repeatable
read for objects that are not updated or removed via any mechanism other
than the use of version attributes and the EntityManager _lock_ method.
However, it should be noted that if an implementation has acquired
up-front pessimistic locks on some database rows, then it is free to
ignore _lock(entity, LockModeType.OPTIMISTIC)_ calls on the entity
objects representing those rows.

===== [[a2113]]PESSIMISTIC_READ, PESSIMISTIC_WRITE, PESSIMISTIC_FORCE_INCREMENT

{empty}The lock modes _PESSIMISTIC_READ_ ,
_PESSIMISTIC_WRITE_ , and _PESSIMISTIC_FORCE_INCREMENT_ are used to
immediately obtain long-term database locks.link:#a19577[41]

The semantics of requesting locks of type
_LockModeType.PESSIMISTIC_READ_ , _LockModeType.PESSIMISTIC_WRITE_ , and
_LockModeType.PESSIMISTIC_FORCE_INCREMENT_ are the following.

If transaction T1 calls _lock(entity,
LockModeType.PESSIMISTIC_READ)_ or _lock(entity,
LockModeType.PESSIMISTIC_WRITE)_ on an object, the entity manager must
ensure that neither of the following phenomena can occur:

P1 (Dirty read): Transaction T1 modifies a
row. Another transaction T2 then reads that row and obtains the modified
value, before T1 has committed or rolled back.

P2 (Non-repeatable read): Transaction T1
reads a row. Another transaction T2 then modifies or deletes that row,
before T1 has committed or rolled back.

Any such lock must be obtained immediately
and retained until transaction T1 completes (commits or rolls back).

Avoidance of phenomena P1 and P2 is generally
achieved by the entity manager acquiring a long-term lock on the
underlying database row(s). Any implementation that supports pessimistic
repeatable reads as described above is permissible.

A lock with _LockModeType.PESSIMISTIC_WRITE_
can be obtained on an entity instance to force serialization among
transactions attempting to update the entity data. A lock with
_LockModeType.PESSIMISTIC_READ_ can be used to query data using
repeatable-read semantics without the need to reread the data at the end
of the transaction to obtain a lock, and without blocking other
transactions reading the data. A lock with
_LockModeType.PESSIMISTIC_WRITE_ can be used when querying data and
there is a high likelihood of deadlock or update failure among
concurrent updating transactions.

The persistence implementation must support
calling _lock(entity, LockModeType.PESSIMISTIC_READ_ ) and _lock(entity,
LockModeType.PESSIMISTIC_WRITE)_ on a non-versioned entity as well as on
a versioned entity.

It is permissible for an implementation to
use _LockModeType.PESSIMISTIC_WRITE_ where
_LockModeType.PESSIMISTIC_READ_ was requested, but not vice versa.

When the lock cannot be obtained, and the
database locking failure results in transaction-level rollback, the
provider must throw the _PessimisticLockException_ and ensure that the
JTA transaction or EntityTransaction has been marked for rollback.

When the lock cannot be obtained, and the
database locking failure results in only statement-level rollback, the
provider must throw the _LockTimeoutException_ (and must not __ mark the
transaction for rollback).

When an application locks an entity with
_LockModeType.PESSIMISTIC_READ_ and later updates that entity, the lock
must be converted to an exclusive lock when the entity is flushed to the
databaselink:#a19578[42]. If the lock conversion fails, and the
database locking failure results in transaction-level rollback, the
provider must throw the _PessimisticLockException_ and ensure that the
JTA transaction or EntityTransaction has been marked for rollback. When
the lock conversion fails, and the database locking failure results in
only statement-level rollback, the provider must throw the
_LockTimeoutException_ (and must not __ mark the transaction for
rollback).

When _lock(entity,
LockModeType.PESSIMISTIC_READ)_ , _lock(entity,
LockModeType.PESSIMISTIC_WRITE)_ , or _lock(entity,
LockModeType.PESSIMISTIC_FORCE_INCREMENT)_ is invoked on a versioned
entity that is already in the persistence context, the provider must
also perform optimistic version checks when obtaining the lock. An
_OptimisticLockException_ must be thrown if the version checks fail.
Depending on the implementation strategy used by the provider, it is
possible that this exception may not be thrown until flush is called or
commit time, whichever occurs first.

If transaction T1 calls _lock(entity,
LockModeType.PESSIMISTIC_FORCE_INCREMENT)_ on a versioned object, the
entity manager must avoid the phenomenon P1 and P2 (as with
_LockModeType.PESSIMISTIC_READ_ and _LockModeType.PESSIMISTIC_WRITE_ )
and must also force an update (increment) to the entity's version
column.

The persistence implementation is not
required to support calling _lock(entity,_
_LockModeType.PESSIMISTIC_FORCE_INCREMENT)_ on a non-versioned object.
When it cannot support such a lock call, it must throw the
_PersistenceException_ . When supported, whether for versioned or
non-versioned objects, _LockModeType.PESSIMISTIC_FORCE_INCREMENT_ must
always prevent the phenomena P1 and P2. For non-versioned objects,
whether or not _LockModeType.PESSIMISTIC_FORCE_INCREMENT_ has any
additional behavior is vendor-specific. Applications that call
_lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)_ on
non-versioned objects will not be portable.

For versioned objects, it is permissible for
an implementation to use _LockModeType.PESSIMISTIC_FORCE_INCREMENT_
where _LockModeType.PESSIMISTIC_READ_ or
_LockModeType.PESSIMISTIC_WRITE_ was requested, but not vice versa.

If a versioned object locked with
_LockModeType.PESSIMISTIC_READ_ or _LockModeType.PESSIMISTIC_WRITE_ is
updated, then the implementation must ensure that the requirements of
_LockModeType.PESSIMISTIC_FORCE_INCREMENT_ are met.

===== [[a2132]]Lock Mode Properties and Uses

The following property is defined by this
specification for use in pessimistic locking, as described in section
link:Per.html#a2066[See Pessimistic Locking]:

 _javax.persistence.lock.scope_

This property may be used with the methods of
the _EntityManager_ interface that allow lock modes to be specified, the
_Query_ and _TypedQuery_ _setLockMode_ methods, and the _NamedQuery_
annotation. When specified, this property must be observed. The provider
is permitted to lock more (but not fewer) rows than requested.

The following hint is defined by this
specification for use in pessimistic locking.

 javax.persistence.lock.timeout // time in
milliseconds

This hint may be used with the methods of the
_EntityManager_ interface that allow lock modes to be specified, the
_Query.setLockMode_ method and the _NamedQuery_ annotation. It may also
be passed as a property to the _Persistence.createEntityManagerFactory_
method and used in the _properties_ element of the _persistence.xml_
file. See sections link:Per.html#a1066[See EntityManager
Interface], link:Per.html#a4385[See Queries and Lock Mode],
link:Per.html#a12384[See properties],
link:Per.html#a13443[See javax.persistence.Persistence Class],
and link:Per.html#a13711[See NamedQuery Annotation]. When used in
the _createEntityManagerFactory_ method, the _persistence.xml_ file, and
the _NamedQuery_ annotation, the timeout hint serves as a default value
which can be selectively overridden by use in the methods of the
_EntityManager_ , _Query_ , and _TypedQuery_ interfaces as specified
above. When this hint is not specified, database timeout values are
assumed to apply.

A timeout value of _0_ is used to specify “no
wait” locking.

Portable applications should not rely on this
hint. Depending on the database in use and the locking mechanisms used
by the persistence provider, the hint may or may not be observed.

Vendors are permitted to support the use of
additional, vendor-specific locking hints. Vendor-specific hints must
not use the _javax.persistence_ namespace. Vendor-specific hints must be
ignored if they are not understood.

If the same property or hint is specified
more than once, the following order of overriding applies, in order of
decreasing precedence:

argument to method of _EntityManager_ ,
_Query_ , or _TypedQuery_ interface

specification to _NamedQuery_ (annotation or
XML)

argument to _createEntityManagerFactory_
method

specification in _persistence.xml_

==== OptimisticLockException

Provider implementations may defer writing to
the database until the end of the transaction, when consistent with the
lock mode and flush mode settings in effect. In this case, an optimistic
lock check may not occur until commit time, and the
_OptimisticLockException_ may be thrown in the “before completion” phase
of the commit. If the _OptimisticLockException_ must be caught or
handled by the application, the _flush_ method should be used by the
application to force the database writes to occur. This will allow the
application to catch and handle optimistic lock exceptions.

The _OptimisticLockException_ provides an API
to return the object that caused the exception to be thrown. The object
reference is not guaranteed to be present every time the exception is
thrown but should be provided whenever the persistence provider can
supply it. Applications cannot rely upon this object being available.

In some cases an _OptimisticLockException_
will be thrown and wrapped by another exception, such as a
_RemoteException_ , when VM boundaries are crossed. Entities that may be
referenced in wrapped exceptions should implement _Serializable_ so that
marshalling will not fail.

An _OptimisticLockException_ always causes
the transaction to be marked for rollback.

Refreshing objects or reloading objects in a
new transaction context and then retrying the transaction is a potential
response to an _OptimisticLockException_ .

=== [[a2153]]Entity Listeners and Callback Methods

image:Per-4.png[image]

A method may be designated as a lifecycle
callback method to receive notification of entity lifecycle events. A
lifecycle callback method can be defined on an entity class, a mapped
superclass, or an entity listener class associated with an entity or
mapped superclass. An entity listener class is a class whose methods are
invoked in response to lifecycle events on an entity. Any number of
entity listener classes can be defined for an entity class or mapped
superclass.

Default entity listeners—entity listener
classes whose callback methods apply to all entities in the persistence
unit—can be specified by means of the XML descriptor.

Lifecycle callback methods and entity
listener classes are defined by means of metadata annotations or the XML
descriptor. When annotations are used, one or more entity listener
classes are denoted using the _EntityListeners_ annotation on the entity
class or mapped superclass. If multiple entity listeners are defined,
the order in which they are invoked is determined by the order in which
they are specified in the _EntityListeners_ annotation. The XML
descriptor may be used as an alternative to specify the invocation order
of entity listeners or to override the order specified in metadata
annotations.

Any subset or combination of annotations may
be specified on an entity class, mapped superclass, or listener class. A
single class must not have more than one lifecycle callback method for
the same lifecycle event. The same method may be used for multiple
callback events.

Multiple entity classes and mapped
superclasses in an inheritance hierarchy may define listener classes
and/or lifecycle callback methods directly on the class. Section
link:Per.html#a2251[See Multiple Lifecycle Callback Methods for
an Entity Lifecycle Event] describes the rules that apply to method
invocation order in this case.

==== Entity Listeners

The entity listener class must have a public
no-arg constructor.

Entity listener classes in Java EE
environments support dependency injection through the Contexts and
Dependency Injection API (CDI) link:Per.html#a19500[See JSR-365:
Context and Dependency Injection for Java EE, v 2.0.
http://jcp.org/en/jsr/detail?id=365.] when CDI is
enabledlink:#a19579[43]. An entity listener class that makes use
of CDI injection may also define lifecycle callback methods annotated
with the _PostConstruct_ and _PreDestroy_ annotations. These methods
will be invoked after injection has taken place and before the entity
listener instance is destroyed respectively.

The persistence provider is responsible for
using the CDI SPI to create instances of the entity listener class; to
perform injection upon such instances; to invoke their _PostConstruct_
and _PreDestroy_ methods, if any; and to dispose of the entity listener
instances.

The persistence provider is only required to
support CDI injection into entity listeners in Java EE container
environmentslink:#a19580[44]. If the CDI is not enabled, the
persistence provider must not invoke entity listeners that depend upon
CDI injection.

An entity listener is a noncontextual object.
In supporting injection into entity listeners, the persistence provider
must behave as if it carries out the following steps involving the use
of the CDI SPI. (See link:Per.html#a19500[See JSR-365: Context
and Dependency Injection for Java EE, v 2.0.
http://jcp.org/en/jsr/detail?id=365.]).

Obtain a _BeanManager_ instance. (See section
link:Per.html#a12802[See Java EE Deployment].)

Create an _AnnotatedType_ instance for the
entity listener class.

Create an _InjectionTarget_ instance for the
annotated type.

Create a _CreationalContext_ .

Instantiate the listener by calling the
_InjectionTarget_ _produce_ method.

Inject the listener instance by calling the
_InjectionTarget_ _inject_ method on the instance.

Invoke the _PostConstruct_ callback, if any,
by calling the _InjectionTarget_ _postConstruct_ method on the instance.

When the listener instance is to be
destroyed, the persistence provider must behave as if it carries out the
following steps.

Call the _InjectionTarget_ _preDestroy_
method on the instance.

Call the _InjectionTarget_ _dispose_ method
on the instance

Call the _CreationalContext_ _release_
method.

Persistence providers may optimize the steps
above, e.g. by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

Entity listeners that do not make use of CDI
injection are stateless. The lifecycle of such entity listeners is
unspecified.

{empty}When invoked from within a Java EE
environment, the callback listeners for an entity share the enterprise
naming context of the invoking component, and the entity callback
methods are invoked in the transaction and security contexts of the
calling component at the time at which the callback method is invoked.
link:#a19581[45]

==== Lifecycle Callback Methods

Entity lifecycle callback methods can be
defined on an entity listener class and/or directly on an entity class
or mapped superclass.

Lifecycle callback methods are annotated with
annotations designating the callback events for which they are invoked
or are mapped to the callback event using the XML descriptor.

The annotations (and XML elements) used for
callback methods on the entity class or mapped superclass and for
callback methods on the entity listener class are the same. The
signatures of individual methods, however, differ.

Callback methods defined on an entity class
or mapped superclass have the following signature:

 _void <METHOD>()_

Callback methods defined on an entity
listener class have the following signature:

 _void <METHOD>(Object)_

The _Object_ argument is the entity instance
for which the callback method is invoked. It may be declared as the
actual entity type.

The callback methods can have public,
private, protected, or package level access, but must not be _static_ or
_final_ .

The following annotations designate lifecycle
event callback methods of the corresponding types.

 _PrePersist_

 _PostPersist_

 _PreRemove_

 _PostRemove_

 _PreUpdate_

 _PostUpdate_

 _PostLoad_



The following rules apply to lifecycle
callback methods:

Lifecycle callback methods may throw
unchecked/runtime exceptions. A runtime exception thrown by a callback
method that executes within a transaction causes that transaction to be
marked for rollback if the persistence context is joined to the
transaction.

Lifecycle callbacks can invoke JNDI, JDBC,
JMS, and enterprise beans.

In general, the lifecycle method of a
portable application should not invoke _EntityManager_ or query
operations, access other entity instances, or modify relationships
within the same persistence
contextlink:#a19583[46].link:#pgfId-1645929[47] A lifecycle
callback method may modify the non-relationship state of the entity on
which it is invoked.

==== [[a2202]]Semantics of the Life Cycle Callback Methods for Entities

The _PrePersist_ and _PreRemove_ callback
methods are invoked for a given entity before the respective
EntityManager persist and remove operations for that entity are
executed. For entities to which the merge operation has been applied and
causes the creation of newly managed instances, the _PrePersist_
callback methods will be invoked for the managed instance after the
entity state has been copied to it. These _PrePersist_ and _PreRemove_
callbacks will also be invoked on all entities to which these operations
are cascaded. The _PrePersist_ and _PreRemove_ methods will always be
invoked as part of the synchronous persist, merge, and remove
operations.

The _PostPersist_ and _PostRemove_ callback
methods are invoked for an entity after the entity has been made
persistent or removed. These callbacks will also be invoked on all
entities to which these operations are cascaded. The _PostPersist_ and
_PostRemove_ methods will be invoked after the database insert and
delete operations respectively. These database operations may occur
directly after the persist, merge, or remove operations have been
invoked or they may occur directly after a flush operation has occurred
(which may be at the end of the transaction). Generated primary key
values are available in the _PostPersist_ method.

The _PreUpdate_ and _PostUpdate_ callbacks
occur before and after the database update operations to entity data
respectively. These database operations may occur at the time the entity
state is updated or they may occur at the time state is flushed to the
database (which may be at the end of the transaction).

Note that it is implementation-dependent as
to whether _PreUpdate_ and _PostUpdate_ callbacks occur when an entity
is persisted and subsequently modified in a single transaction or when
an entity is modified and subsequently removed within a single
transaction. Portable applications should not rely on such behavior.

The _PostLoad_ method for an entity is
invoked after the entity has been loaded into the current persistence
context from the database or after the refresh operation has been
applied to it. The _PostLoad_ method is invoked before a query result is
returned or accessed or before an association is traversed.

It is implementation-dependent as to whether
callback methods are invoked before or after the cascading of the
lifecycle events to related entities. Applications should not depend on
this ordering.

==== Example

@Entity

@EntityListeners(com.acme.AlertMonitor.class)

public class Account \{



 Long accountId;

 Integer balance;

 boolean preferred;



 @Id

 public Long getAccountId() \{ ... }

 ...

 public Integer getBalance() \{ ... }

 ...

 @Transient // because status depends upon
non-persistent context

 public boolean isPreferred() \{ ... }

 ...



 public void deposit(Integer amount) \{ ... }



 public Integer withdraw(Integer amount)
throws NSFException \{... }



 @PrePersist

 protected void validateCreate() \{

 if (getBalance() < MIN_REQUIRED_BALANCE)

 throw new AccountException("Insufficient
balance to open an account");

 }



 @PostLoad

 protected void adjustPreferredStatus() \{

 preferred =

 (getBalance() >=
AccountManager.getPreferredStatusLevel());

 }

}



public class AlertMonitor \{



 @PostPersist

 public void newAccountAlert(Account acct) \{


Alerts.sendMarketingInfo(acct.getAccountId(), acct.getBalance());

 }

}

==== [[a2251]]Multiple Lifecycle Callback Methods for an Entity Lifecycle Event

If multiple callback methods are defined for
an entity lifecycle event, the ordering of the invocation of these
methods is as follows.

Default listeners, if any, are invoked first,
in the order specified in the XML descriptor. Default listeners apply to
all entities in the persistence unit, unless explicitly excluded by
means of the _ExcludeDefaultListeners_ annotation or
_exclude-default-listeners_ XML element.

The lifecycle callback methods defined on the
entity listener classes for an entity class or mapped superclass are
invoked in the same order as the specification of the entity listener
classes in the _EntityListeners_ annotation.

If multiple classes in an inheritance
hierarchy—entity classes and/or mapped superclasses—define entity
listeners, the listeners defined for a superclass are invoked before the
listeners defined for its subclasses in this order. The
_ExcludeSuperclassListeners_ annotation or
_exclude-superclass-listeners_ XML element may be applied to an entity
class or mapped superclass to exclude the invocation of the listeners
defined by the entity listener classes for the superclasses of the
entity or mapped superclass. The excluded listeners are excluded from
the class to which the _ExcludeSuperclassListeners_ annotation or
element has been specified and its subclasses.link:#a19584[48]
The _ExcludeSuperclassListeners_ annotation (or
_exclude-superclass-listeners_ XML element) does not cause default
entity listeners to be excluded from invocation.

{empty}If a lifecycle callback method for the
same lifecycle event is also specified on the entity class and/or one or
more of its entity or mapped superclasses, the callback methods on the
entity class and/or superclasses are invoked after the other lifecycle
callback methods, most general superclass first. A class is permitted to
override an inherited callback method of the same callback type, and in
this case, the overridden method is not invoked.link:#a19585[49]

Callback methods are invoked by the
persistence provider runtime in the order specified. If the callback
method execution terminates normally, the persistence provider runtime
then invokes the next callback method, if any.

The XML descriptor may be used to override
the lifecycle callback method invocation order specified in annotations.

==== Example

There are several entity classes and
listeners for animals:

@Entity

public class Animal \{

 ....

 @PostPersist

 protected void postPersistAnimal() \{

 ....

 }

}



@Entity

@EntityListeners(PetListener.class)

public class Pet extends Animal \{

 ....

}



@Entity

@EntityListeners(\{CatListener.class,
CatListener2.class})

public class Cat extends Pet \{

 ....

}



public class PetListener \{

 @PostPersist

 protected void
postPersistPetListenerMethod(Object pet) \{

 ....

 }

}



public class CatListener \{

 @PostPersist

 protected void
postPersistCatListenerMethod(Object cat) \{

 ....

 }

}



public class CatListener2 \{

 @PostPersist

 protected void
postPersistCatListener2Method(Object cat) \{

 ....

 }

}



If a _PostPersist_ event occurs on an
instance of _Cat_ , the following methods are called in order:

 postPersistPetListenerMethod

 postPersistCatListenerMethod

 postPersistCatListener2Method

 postPersistAnimal



Assume that _SiameseCat_ is defined as a
subclass of _Cat_ :

@EntityListeners(SiameseCatListener.class)

@Entity

public class SiameseCat extends Cat \{

 ...

 @PostPersist

 protected void postPersistSiameseCat() \{

 ...

 }

}



public class SiameseCatListener \{

 @PostPersist

 protected void
postPersistSiameseCatListenerMethod(Object cat) \{

 ....

 }

}



If a _PostPersist_ event occurs on an
instance of _SiameseCat_ , the following methods are called in order:

 postPersistPetListenerMethod

 postPersistCatListenerMethod

 postPersistCatListener2Method

 postPersistSiameseCatListenerMethod

 postPersistAnimal

 postPersistSiameseCat



Assume the definition of _SiameseCat_ were
instead:

@EntityListeners(SiameseCatListener.class)

@Entity

public class SiameseCat extends Cat \{

 ...

 @PostPersist

 protected void postPersistAnimal() \{

 ...

 }

}

In this case, the following methods would be
called in order, where _postPersistAnimal_ is the _PostPersist_ method
defined in the _SiameseCat_ class:

 postPersistPetListenerMethod

 postPersistCatListenerMethod

 postPersistCatListener2Method

 postPersistSiameseCatListenerMethod

 postPersistAnimal

==== Exceptions

Lifecycle callback methods may throw runtime
exceptions. A runtime exception thrown by a callback method that
executes within a transaction causes that transaction to be marked for
rollback if the persistence context is joined to the transaction. No
further lifecycle callback methods will be invoked after a runtime
exception is thrown.

==== Specification of Callback Listener Classes and Lifecycle Methods in the XML Descriptor

The XML descriptor can be used as an
alternative to metadata annotations to specify entity listener classes
and their binding to entities or to override the invocation order of
lifecycle callback methods as specified in annotations.

===== Specification of Callback Listeners

The _entity-listener_ XML descriptor element
is used to specify the lifecycle listener methods of an entity listener
class. The lifecycle listener methods are specified by using the
_pre-persist_ , _post-persist_ , _pre-remove_ , _post-remove_ ,
_pre-update_ , _post-update_ , and/or _post-load_ elements.

An entity listener class can define multiple
callback methods. However, at most one method of an entity listener
class can be designated as a pre-persist method, post-persist method,
pre-remove method, post-remove method, pre-update method, post-update
method, and/or post-load method, regardless of whether the XML
descriptor is used to define entity listeners or whether some
combination of annotations and XML descriptor elements is used.

===== Specification of the Binding of Entity Listener Classes to Entities

The _entity-listeners_ subelement of the
_persistence-unit-defaults_ element is used to specify the default
entity listeners for the persistence unit.

The _entity-listeners_ subelement of the
_entity_ or _mapped-superclass_ element is used to specify the entity
listener classes for the respective entity or mapped superclass and its
subclasses.

The binding of entity listeners to entity
classes is additive. The entity listener classes bound to the
superclasses of an entity or mapped superclass are applied to it as
well.

The _exclude-superclass-listeners_ element
specifies that the listener methods for superclasses are not to be
invoked for an entity class (or mapped superclass) and its subclasses.

The _exclude-default-listeners_ element
specifies that default entity listeners are not to be invoked for an
entity class (or mapped superclass) and its subclasses.

Explicitly listing an excluded default or
superclass listener for a given entity class or mapped superclass causes
it to be applied to that entity or mapped superclass and its subclasses.

In the case of multiple callback methods for
a single lifecycle event, the invocation order rules described in
section link:Per.html#a2251[See Multiple Lifecycle Callback
Methods for an Entity Lifecycle Event] apply.

=== [[a2366]]Bean Validation

image:Per-4.png[image]

This specification defines support for use of
Bean Validationlink:Per.html#a19498[See JSR-380: Bean Validation,
v. 2.0. http://jcp.org/en/jsr/detail?id=380.] within Java Persistence
applications.

Managed classes (entities, mapped
superclasses, and embeddable classes) may be configured to include Bean
Validation constraints.

Automatic validation using these constraints
is achieved by specifying that Java Persistence delegate validation to
the Bean Validation implementation upon the pre-persist, pre-update, and
pre-remove entity lifecycle events described in Section
link:Per.html#a2202[See Semantics of the Life Cycle Callback
Methods for Entities].

Validation can also be achieved by the
application calling the _validate_ method of a _Validator_ instance upon
an instance of a managed class, as described in the Bean Validation
specification link:Per.html#a19498[See JSR-380: Bean Validation,
v. 2.0. http://jcp.org/en/jsr/detail?id=380.].

==== Automatic Validation Upon Lifecycle Events

This specification supports the use of bean
validation for the automatic validation of entities upon the
pre-persist, pre-update, and pre-remove lifecycle validation events.
These lifecycle validation events occur immediately after the point at
which all the _PrePersist_ , _PreUpdate_ , and _PreRemove_ lifecycle
callback method invocations respectively have been completed, or
immediately after the point at which such lifecycle callback methods
would have been completed (in the event that such callback methods are
not present).

In the case where an entity is persisted and
subsequently modified in a single transaction or when an entity is
modified and subsequently removed in a single transaction, it is
implementation dependent as to whether the pre-update validation event
occurs. Portable applications should not rely on this behavior.

===== [[a2374]]Enabling Automatic Validation

The _validation-mode_ element of the
_persistence.xml_ file determines whether the automatic lifecycle event
validation is in effect. The values of the _validation-mode_ element are
_AUTO_ , _CALLBACK_ , _NONE_ . The default validation mode is _AUTO_ .

If the application creates the entity manager
factory using the _Persistence.createEntityManagerFactory_ method, the
validation mode can be specified using the
_javax.persistence.validation.mode_ map key, which will override the
value specified (or defaulted) in the _persistence.xml_ file. The map
values for this key are _"auto"_ , _"callback"_ , _"none"_ .

If the auto validation mode is specified by
the _validation-mode_ element or the _javax.persistence.validation.mode_
property, or if neither the _validation-mode_ element nor the
_javax.persistence.validation.mode_ property is specified, and a Bean
Validation provider is present in the environment, the persistence
provider must perform the automatic validation of entities as described
in section link:Per.html#a2380[See Requirements for Automatic
Validation upon Lifecycle Events]. If no Bean Validation provider is
present in the environment, no lifecycle event validation takes place.

If the callback validation mode is specified
by the _validation-mode_ element or the
_javax.persistence.validation.mode_ property, the persistence provider
must perform the lifecycle event validation as described in section
link:Per.html#a2380[See Requirements for Automatic Validation
upon Lifecycle Events]. It is an error if there is no Bean Validation
provider present in the environment, and the provider must throw the
_PersistenceException_ if the _javax.persistence.validation.mode_
property value _"callback"_ has been passed to the
_Persistence.createEntityManagerFactory_ method.

If the none validation mode is specified by
the _validation-mode_ element or the _javax.persistence.validation.mode_
property, the persistence provider must not perform lifecycle event
validation.

===== [[a2380]]Requirements for Automatic Validation upon Lifecycle Events

For each event type, a list of groups is
targeted for validation. By default, the default Bean Validation group
(the group _Default_ ) will be validated upon the pre-persist and
pre-update lifecycle validation events, and no group will be validated
upon the pre-remove event.

This default validation behavior can be
overridden by specifying the target groups using the following
validation properties in the _persistence.xml_ file or by passing these
properties in the configuration of the entity manager factory through
the _createEntityManagerFactory_ method:


_javax.persistence.validation.group.pre-persist_


_javax.persistence.validation.group.pre-update_


_javax.persistence.validation.group.pre-remove_

The value of a validation property must be a
list of the targeted groups. A targeted group must be specified by its
fully qualified class name. Names must be separated by a comma.

When one of the above events occurs for an
entity, the persistence provider must validate that entity by obtaining
a _Validator_ instance from the validator factory in use (see section
link:Per.html#a2394[See Providing the ValidatorFactory]) and
invoking its _validate_ method with the targeted groups. If the list of
targeted groups is empty, no validation is performed. If the set of
_ConstraintViolation_ objects returned by the _validate_ method is not
empty, the persistence provider must throw the
_javax.validation.ConstraintViolationException_ containing a reference
to the returned set of _ConstraintViolation_ objects, and must mark the
transaction for rollback if the persistence context is joined to the
transaction.

The validator instance that is used for
automatic validation upon lifecycle events must use a
_TraversableResolver_ that has the following behavior:

Attributes that have not been loaded must not
be loaded.

Validation cascade ( _@Valid_ ) must not
occur for entity associations (single- or multi-valued).

These requirements guarantee that no unloaded
attribute or association will be loaded by side effect and that no
entity will be validated more than once during a given flush cycle.

Embeddable attributes must be validated only
if the _Valid_ annotation has been specified on them.

It is the responsibility of the persistence
provider to pass an instance implementing the
_javax.validation.TraversableResolver_ interface to the Bean Validation
provider by calling
_ValidatorFactory.usingContext().traversableResolver(tr).getValidator()_
, where _tr_ is the resolver having the behavior described above.

==== [[a2394]]Providing the ValidatorFactory

In Java EE environments, a _ValidatorFactory_
instance is made available by the Java EE container. The container is
responsible for passing this validator factory to the persistence
provider via the map that is passed as an argument to the
_createContainerEntityManagerFactory_ call. The map key used by the
container must be the standard property name
_javax.persistence.validation.factory_ .

In Java SE environments, the application can
pass the _ValidatorFactory_ instance via the map that is passed as an
argument to the _Persistence.createEntityManagerFactory_ call. The map
key used must be the standard property name
_javax.persistence.validation.factory_ . If no _ValidatorFactory_
instance is provided by the application, and if a Bean Validation
provider is present in the classpath, the persistence provider must
instantiate the _ValidatorFactory_ using the default bootstrapping
approach defined by the Bean Validation specification
link:Per.html#a19498[See JSR-380: Bean Validation, v. 2.0.
http://jcp.org/en/jsr/detail?id=380.], namely
_Validation.buildDefaultValidatorFactory()_ .

=== [[a2397]]Entity Graphs

image:Per-4.png[image]

An entity graph is a template that captures
the path and boundaries for an operation or query. It is defined in the
form of metadata or an object created by the dynamic _EntityGraph_ API.

Entity graphs are used in the specification
of “fetch plans” for query or _find_ operations.

The _EntityGraph_ , _AttributeNode_ , and
_Subgraph_ interfaces are used to dynamically construct entity graphs.
The annotations to statically define entity graphs, namely
_NamedEntityGraph_ , _NamedAttributeNode_ , and _NamedSubgraph_ , are
described in link:Per.html#a13662[See EntityGraph Annotations].
The _named-entity-graph_ XML element and its subelements may be used to
override these annotations or to define additional named entity graphs.

The semantics of entity graphs with regard to
find and query operations are described in section
link:Per.html#a2814[See Use of Entity Graphs in find and query
operations].

==== EntityGraph Interface

package javax.persistence;



import javax.persistence.metamodel.Attribute;

import java.util.List;



/**

 * This type represents the root of an entity
graph that will be used

 * as a template to define the attribute
nodes and boundaries of a

 * graph of entities and entity
relationships. The root must be an

 * entity type.

 *

 * The methods to add subgraphs implicitly
create the corresponding

 * attribute nodes as well; such attribute
nodes should not be

 * redundantly specified.

 *

 * @param <T> The type of the root entity.

 */

public interface EntityGraph<T> \{



 /**

 * Return the name of a named EntityGraph (an
entity graph

 * defined by means of the NamedEntityGraph
annotation,

 * XML descriptor element, or added by means
of the

 * addNamedEntityGraph method. Returns null
if the EntityGraph

 * is not a named EntityGraph.

 */

 public String getName();



 /**

 * Add one or more attribute nodes to the
entity graph.

 * @param attributeName name of the attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this entity.

 * @throws IllegalStateException if the
EntityGraph has been

 * statically defined

 */

 public void addAttributeNodes(String ...
attributeName);



 /**

 * Add one or more attribute nodes to the
entity graph.

 * @param attribute attribute

 * @throws IllegalStateException if the
EntityGraph has been

 * statically defined

 */

 public void addAttributeNodes(Attribute<T,
?> ... attribute);



 /**

 * Add a node to the graph that corresponds
to a managed

 * type. This allows for construction of
multi-node entity graphs

 * that include related managed types.

 * @param attribute attribute

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if the
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X>
addSubgraph(Attribute<T, X> attribute);



 /**

 * Add a node to the graph that corresponds
to a managed

 * type with inheritance. This allows for
multiple subclass

 * subgraphs to be defined for this node of
the entity

 * graph. Subclass subgraphs will
automatically include the

 * specified attributes of superclass
subgraphs.

 * @param attribute attribute

 * @param type entity subclass

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if the
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<? extends X>

 addSubgraph(Attribute<T, X> attribute,
Class<? extends X> type);



 /**

 * Add a node to the graph that corresponds
to a managed

 * type. This allows for construction of
multi-node entity graphs

 * that include related managed types.

 * @param attributeName name of the attribute

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this entity.

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if the
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X> addSubgraph(String
attributeName);



 /**

 * Add a node to the graph that corresponds
to a managed

 * type with inheritance. This allows for
multiple subclass

 * subgraphs to be defined for this node of
the entity graph.

 * Subclass subgraphs will automatically
include the specified

 * attributes of superclass subgraphs.

 * @param attributeName name of the attribute

 * @param type entity subclass

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this managed type.

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X> addSubgraph(String
attributeName,

 Class<X> type);



 /**

 * Add a node to the graph that corresponds
to a map key

 * that is a managed type. This allows for
construction of

 * multi-node entity graphs that include
related managed types.

 * @param attribute attribute

 * @return subgraph for the key attribute

 * @throws IllegalArgumentException if the
attribute's target

 * type is not an entity

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X>
addKeySubgraph(Attribute<T, X> attribute);



 /**

 * Add a node to the graph that corresponds
to a map key

 * that is a managed type with inheritance.
This allows for

 * construction of multi-node entity graphs
that include related

 * managed types. Subclass subgraphs will
include the specified

 * attributes of superclass subgraphs.

 * @param attribute attribute

 * @param type entity subclass

 * @return subgraph for the key attribute

 * @throws IllegalArgumentException if the
attribute's target

 * type is not an entity

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<? extends X>

 addKeySubgraph(Attribute<T, X> attribute,

 Class<? extends X> type);



 /**

 * Add a node to the graph that corresponds
to a map key

 * that is a managed type. This allows for
construction of

 * multi-node entity graphs that include
related managed types.

 * @param attributeName name of the attribute

 * @return subgraph for the key attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this entity.

 * @throws IllegalArgumentException if the
attribute's target

 * type is not an entity

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X> addKeySubgraph(String
attributeName);



 /**

 * Add a node to the graph that corresponds
to a map key

 * that is a managed type with inheritance.
This allows for

 * construction of multi-node entity graphs
that include related

 * managed types. Subclass subgraphs will
automatically include

 * the specified attributes of superclass
subgraphs

 * @param attributeName name of the attribute

 * @param type entity subclass

 * @return subgraph for the key attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this entity.

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X> addKeySubgraph(String
attributeName,

 Class<X> type);





 /**

 * Add additional attributes to this entity
graph that

 * correspond to attributes of subclasses of
this EntityGraph's

 * entity type. Subclass subgraphs will
automatically include

 * the specified attributes of superclass
subgraphs.

 * @param type entity subclass

 * @return subgraph for the subclass

 * @throws IllegalArgumentException if the
type is not an entity

 type

 * @throws IllegalStateException if the
EntityGraph has been

 * statically defined

 */

 public <T> Subgraph<? extends T>

 addSubclassSubgraph(Class<? extends T>
type);



 /**

 * Return the attribute nodes of this entity
that are included

 * in the entity graph.

 * @return attribute nodes for the annotated
entity type or

 * empty list if none have been defined

 */

 public List<AttributeNode<?>>
getAttributeNodes();

}

==== AttributeNode Interface



package javax.persistence;



import java.util.Map;



/**

 * Represents an attribute node of an entity
graph.

 *

 * @param <T> The type of the attribute.

 */

public interface AttributeNode<T> \{



 /**

 * Return the name of the attribute
corresponding to the

 * attribute node.

 * @return name of the attribute

 */

 public String getAttributeName();



 /**

 * Return the Map<Class, Subgraph> of
subgraphs associated

 * with this attribute node.

 * @return Map of subgraphs associated with
this attribute node

 * or empty Map if none have been defined

 */

 public Map<Class, Subgraph> getSubgraphs();



 /**

 * Return the Map<Class, Subgraph> of
subgraphs associated

 * with this attribute node's map key.

 * @return Map of subgraphs associated with
this attribute

 * node's map key or empty Map if none have
been defined

 */

 public Map<Class, Subgraph>
getKeySubgraphs();

}

==== Subgraph Interface



package javax.persistence;



import javax.persistence.metamodel.Attribute;

import java.util.List;



/**

 * This type represents a subgraph for an
attribute node that

 * corresponds to a Managed Type. Using this
class, an entity

 * subgraph can be embedded within an
EntityGraph.

 *

 * @param <T> The type of the attribute.

 */

public interface Subgraph<T> \{



 /**

 * Add one or more attribute nodes to the
entity graph.

 * @param attributeName name of the attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this managed type.

 * @throws IllegalStateException if the
EntityGraph has been

 * statically defined

 */

 public void addAttributeNodes(String ...
attributeName);



 /**

 * Add one or more attribute nodes to the
entity graph.

 * @param attribute attribute

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public void addAttributeNodes(Attribute<T,
?> ... attribute);



 /**

 * Add a node to the graph that corresponds
to a managed

 * type. This allows for construction of
multi-node entity

 * graphs that include related managed types.

 * @param attribute attribute

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if the
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X>
addSubgraph(Attribute<T, X> attribute);



 /**

 * Add a node to the graph that corresponds
to a managed

 * type with inheritance. This allows for
multiple subclass

 * subgraphs to be defined for this node of
the entity

 * graph. Subclass subgraphs will
automatically include the

 * specified attributes of superclass
subgraphs

 * @param attribute attribute

 * @param type entity subclass

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<? extends X>

 addSubgraph(Attribute<T, X> attribute,
Class<? extends X> type);



 /**

 * Add a node to the graph that corresponds
to a managed

 * type. This allows for construction of
multi-node entity

 * graphs that include related managed types.

 * @param attributeName name of the attribute

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this managed type.

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X> addSubgraph(String
attributeName);



 /**

 * Add a node to the graph that corresponds
to a managed

 * type with inheritance. This allows for
multiple subclass

 * subgraphs to be defined for this node of
the entity

 * graph. Subclass subgraphs will
automatically include the

 * specified attributes of superclass
subgraphs

 * @param attributeName name of the attribute

 * @param type entity subclass

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute is not

 * an attribute of this managed type.

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X> addSubgraph(String
attributeName,

 Class<X> type);



 /**

 * Add a node to the graph that corresponds
to a map key

 * that is a managed type. This allows for
construction of

 * multinode entity graphs that include
related managed types.

 * @param attribute attribute

 * @return subgraph for the key attribute

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type entity

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X>
addKeySubgraph(Attribute<T, X> attribute);



 /**

 * Add a node to the graph that corresponds
to a map key

 * that is a managed type with inheritance.
This allows for

 * construction of multi-node entity graphs
that include related

 * managed types. Subclass subgraphs will
automatically include

 * the specified attributes of superclass
subgraphs

 * @param attribute attribute

 * @param type entity subclass

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type entity

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<? extends X>

 addKeySubgraph(Attribute<T, X> attribute,
Class<? extends X> type);



 /**

 * Add a node to the graph that corresponds
to a map key

 * that is a managed type. This allows for
construction of

 * multi-node entity graphs that include
related managed types.

 * @param attributeName name of the attribute

 * @return subgraph for the key attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this entity.

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X> addKeySubgraph(String
attributeName);



 /**

 * Add a node to the graph that corresponds
to a map key

 * that is a managed type with inheritance.
This allows for

 * construction of multi-node entity graphs
that include related

 * managed types. Subclass subgraphs will
include the specified

 * attributes of superclass subgraphs

 * @param attributeName name of the attribute

 * @param type entity subclass

 * @return subgraph for the attribute

 * @throws IllegalArgumentException if the
attribute is not an

 * attribute of this entity.

 * @throws IllegalArgumentException if the
attribute's target

 * type is not a managed type

 * @throws IllegalStateException if this
EntityGraph has been

 * statically defined

 */

 public <X> Subgraph<X> addKeySubgraph(String
attributeName,

 Class<X> type);



 /**

 * Return the attribute nodes corresponding
to the attributes of

 * this managed type that are included in the
subgraph.

 * @return list of attribute nodes included
in the subgraph

 * or empty list if none have been defined

 */

 public List<AttributeNode<?>>
getAttributeNodes();



 /**

 * Return the type for which this subgraph
was defined.

 * @return managed type referenced by the
subgraph

 */

 public Class<T> getClassType();

}

==== [[a2814]]Use of Entity Graphs in find and query operations

An entity graph can be used with the _find_
method or as a query hint to override or augment _FetchType_ semantics.

The standard properties
_javax.persistence.fetchgraph_ and _javax.persistence.loadgraph_ are
used to specify such graphs to queries and _find_ operations.

The default fetch graph for an entity or
embeddable is defined to consist of the transitive closure of all of its
attributes that are specified as _FetchType.EAGER_ (or defaulted as
such).

The persistence provider is permitted to
fetch additional entity state beyond that specified by a fetch graph or
load graph. It is required, however, that the persistence provider fetch
all state specified by the fetch or load graph.

===== Fetch Graph Semantics

When the _javax.persistence.fetchgraph_
property is used to specify an entity graph, attributes that are
specified by attribute nodes of the entity graph are treated as
_FetchType.EAGER_ and attributes that are not specified are treated as
_FetchType.LAZY_ .

The following rules apply, depending on
attribute type. The rules of this section are applied recursively.

A primary key or version attribute never
needs to be specified in an attribute node of a fetch graph. (This
applies to composite primary keys as well, including embedded id primary
keys.) When an entity is fetched, its primary key and version attributes
are always fetched. It is not incorrect, however, to specify primary key
attributes or version attributes.

Attributes other than primary key and version
attributes are assumed not to be fetched unless the attribute is
specified. The following rules apply to the specification of attributes.

If the attribute is an embedded attribute,
and the attribute is specified in an attribute node, but a subgraph is
not specified for the attribute, the default fetch graph for the
embeddable is fetched. If a subgraph is specified for the attribute, the
attributes of the embeddable are fetched according to their
specification in the corresponding subgraph.

If the attribute is an element collection of
basic type, and the attribute is specified in an attribute node, the
element collection together with its basic elements is fetched.

If the attribute is an element collection of
embeddables, and the attribute is specified in an attribute node, but a
subgraph is not specified for the attribute, the element collection
together with the default fetch graph of its embeddable elements is
fetched. If a subgraph is specified for the attribute, the attributes of
the embeddable elements are fetched according to the corresponding
subgraph specification.

If the attribute is a one-to-one or
many-to-one relationship, and the attribute is specified in an attribute
node, but a subgraph is not specified for the attribute, the default
fetch graph of the target entity is fetched. If a subgraph is specified
for the attribute, the attributes of the target entity are fetched
according to the corresponding subgraph specification.

If the attribute is a one-to-many or
many-to-many relationship, and the attribute is specified in an
attribute node, but a subgraph is not specified, the collection is
fetched and the default fetch graphs of the referenced entities are
fetched. If a subgraph is specified for the attribute, the entities in
the collection are fetched according to the corresponding subgraph
specification.

If the key of a map which has been specified
in an attribute node is a basic type, it is fetched. If the key of a map
which has been specified in an attribute node is an embedded type, the
default fetch graph is fetched for the embeddable. Otherwise, if the key
of the map is an entity, and a map key subgraph is not specified for the
attribute node, the map key is fetched according to its default fetch
graph. If a key subgraph is specified for the map key attribute, the map
key attribute is fetched according to the map key subgraph
specification.

 __

 _Examples:_

@NamedEntityGraph

@Entity

public class Phonenumber\{

 @Id

 protected String number;



 protected PhoneTypeEnum type;

 ...

}



In the above example, only the _number_
attribute would be eagerly fetched.

@NamedEntityGraph(


attributeNodes=\{@NamedAttributeNode("projects")}

)

@Entity

public class Employee\{



 @Id

 @GeneratedValue

 protected long id;



 @Basic

 protected String name;



 @Basic

 protected String employeeNumber;



 @OneToMany()

 protected List<Dependents> dependents;



 @OneToMany()

 protected List<Project> projects;



 @OneToMany()

 protected List<PhoneNumber> phoneNumbers;

 ...

}





@Entity

@Inheritance

public class Project\{

 @Id

 @GeneratedValue

 protected long id;



 String name;



 @OneToOne(fetch=FetchType.EAGER)

 protected Requirements doc;

 ...

}





@Entity

public class LargeProject extends Project\{



 @OneToOne(fetch=FetchType.LAZY)

 protected Employee approver;

 ...

}





@Entity

public class Requirements\{

 @Id

 protected long id;



 @Lob

 protected String description;



 @OneToOne(fetch=FetchType.LAZY)

 protected Approval approval

 ...

}



In the above example, the _Employee_ entity's
primary key will be fetched as well as the related _Project_ instances,
whose default fetch graph ( _id_ , _name_ , and _doc_ attributes) will
be fetched. The related _Requirements_ object will be fetched according
to its default fetch graph.

If the _approver_ attribute of _LargeProject_
were _FetchType.EAGER_ , and if any of the projects were instances of
_LargeProject_ , their _approver_ attributes would also be fetched.
Since the type of the _approver_ attribute is _Employee_ , the
approver's default fetch graph ( _id_ , _name_ , and _employeeNumber_
attributes) would also be fetched.

===== Load Graph Semantics

When the _javax.persistence.loadgraph_
property is used to specify an entity graph, attributes that are
specified by attribute nodes of the entity graph are treated as
_FetchType.EAGER_ and attributes that are not specified are treated
according to their specified or default FetchType.

The following rules apply. The rules of this
section are applied recursively.

A primary key or version attribute never
needs to be specified in an attribute node of a load graph. (This
applies to composite primary keys as well, including embedded id primary
keys.) When an entity is fetched, its primary key and version attributes
are always fetched. It is not incorrect, however, to specify primary key
attributes or version attributes.

If the attribute is an embedded attribute,
and the attribute is specified in an attribute node, but a subgraph is
not specified for the attribute, the default fetch graph for the
embeddable is fetched. If a subgraph is specified for the attribute,
attributes that are specified by the subgraph are also fetched.

If the attribute is an element collection of
basic type, and the attribute is specified in an attribute node, the
element collection together with its basic elements is fetched.

If the attribute is an element collection of
embeddables, and the attribute is specified in an attribute node, the
element collection together with the default fetch graph of its
embeddable elements is fetched. If a subgraph is specified for the
attribute, attributes that are specified by the subgraph are also
fetched.

If the attribute is a one-to-one or
many-to-one relationship, and the attribute is specified in an attribute
node, the default fetch graph of the target entity is fetched. If a
subgraph is specified for the attribute, attributes that are specified
by the subgraph are also fetched.

If the attribute is a one-to-many or
many-to-many relationship, and the attribute is specified in an
attribute node, the collection is fetched and the default fetch graphs
of the referenced entities are fetched. If a subgraph is specified for
the attribute, attributes that are specified by the subgraph are also
fetched.

If the key of a map which has been specified
in an attribute node is a basic type, it is fetched. If the key of a map
which has been specified in an attribute node is an embedded type, the
default fetch graph is fetched for the embeddable. Otherwise, if the key
of the map is an entity, the map key is fetched according to its default
fetch graph. If a key subgraph is specified for the map key attribute,
additional attributes are fetched as specified in the key subgraph.

 _Examples:_

@NamedEntityGraph

@Entity

public class Phonenumber\{

 @Id

 protected String number;



 protected PhoneTypeEnum type;

 ...

}



In the above example, the _number_ and _type_
attributes are fetched.



@NamedEntityGraph(


attributeNodes=\{@NamedAttributeNode("projects")}

)

@Entity

public class Employee\{



 @Id

 @GeneratedValue

 protected long id;



 @Basic

 protected String name;



 @Basic

 protected String employeeNumber;



 @OneToMany()

 protected List<Dependents> dependents;



 @OneToMany()

 protected List<Project> projects;



 @OneToMany()

 protected List<PhoneNumber> phoneNumbers;

 ...

}





@Entity

@Inheritance

public class Project\{

 @Id

 @GeneratedValue

 protected long id;



 String name;



 @OneToOne(fetch=FetchType.EAGER)

 protected Requirements doc;

 ...

}





@Entity

public class LargeProject extends Project\{



 @OneToOne(fetch=FetchType.LAZY)

 protected Employee approver;

 ...

}





@Entity

public class Requirements\{

 @Id

 protected long id;



 @Lob

 protected String description;



 @OneToOne(fetch=FetchType.LAZY)

 protected Approval approval

 ...

}



In the above example, the default fetch graph
( _id_ , _name_ , _employeeNumber_ attributes) of _Employee_ is fetched.
The default fetch graphs of the related _Project_ instances ( _id_ ,
_name_ , and _doc_ attributes) and their _Requirements_ instances ( _id_
and _description_ attributes) are also fetched.

=== [[a2999]]Type Conversion of Basic Attributes

image:Per-4.png[image]

{empty}The attribute conversion facility
allows the developer to specify methods to convert between the entity
attribute representation and the database representation for attributes
of basic types. Converters can be used to convert basic attributes
defined by entity classes, mapped superclasses, or embeddable
classes.link:#a19586[50]

An attribute converter must implement the
_javax.persistence.AttributeConverter_ interface. A converter
implementation class must be annotated with the _Converter_ annotation
or defined in the XML descriptor as a converter. If the value of the
_autoApply_ element of the _Converter_ annotation is _true_ , the
converter will be applied to all attributes of the target type,
including to basic attribute values that are contained within other,
more complex attribute types. See Section
link:Per.html#a13903[See Annotations for Type Converter Classes].

/**

 * A class that implements this interface can
be used to convert

 * entity attribute state into database
column representation

 * and back again.

 * Note that the X and Y types may be the
same Java type.

 *

 * @param X the type of the entity attribute

 * @param Y the type of the database column

 */

public interface AttributeConverter<X,Y> \{



 /**

 * Converts the value stored in the entity
attribute into the

 * data representation to be stored in the
database.

 *

 * @param attribute the entity attribute
value to be converted

 * @return the converted data to be stored in
the database

 * column

 */

 public Y convertToDatabaseColumn (X
attribute);



 /**

 * Converts the data stored in the database
column into the

 * value to be stored in the entity
attribute.

 * Note that it is the responsibility of the
converter writer to

 * specify the correct dbData type for the
corresponding column

 * for use by the JDBC driver: i.e.,
persistence providers are

 * not expected to do such type conversion.

 *

 * @param dbData the data from the database
column to be

 * converted

 * @return the converted value to be stored
in the entity

 * attribute

 */

 public X convertToEntityAttribute (Y
dbData);

}



Attribute converter classes in Java EE
environments support dependency injection through the Contexts and
Dependency Injection API (CDI) link:Per.html#a19500[See JSR-365:
Context and Dependency Injection for Java EE, v 2.0.
http://jcp.org/en/jsr/detail?id=365.] when CDI is
enabledlink:#a19587[51]. An attribute converter class that makes
use of CDI injection may also define lifecycle callback methods
annotated with the _PostConstruct_ and _PreDestroy_ annotations. These
methods will be invoked after injection has taken place and before the
attribute converter instance is destroyed respectively.

The persistence provider is responsible for
using the CDI SPI to create instances of the attribute converter class;
to perform injection upon such instances; to invoke their
_PostConstruct_ and _PreDestroy_ methods, if any; and to dispose of the
attribute converter instances.

The persistence provider is only required to
support CDI injection into attribute converters in Java EE container
environmentslink:#a19588[52]. If CDI is not enabled, the
persistence provider must not invoke attribute converters that depend
upon CDI injection.

An attribute converter is a noncontextual
object. In supporting injection into attribute converters, the
persistence provider must behave as if it carries out the following
steps involving the use of the CDI SPI. (See
link:Per.html#a19500[See JSR-365: Context and Dependency
Injection for Java EE, v 2.0. http://jcp.org/en/jsr/detail?id=365.]).

Obtain a _BeanManager_ instance. (See section
link:Per.html#a12802[See Java EE Deployment].)

Create an _AnnotatedType_ instance for the
attribute converter class.

Create an _InjectionTarget_ instance for the
annotated type.

Create a _CreationalContext_ .

Instantiate the listener by calling the
_InjectionTarget_ _produce_ method.

Inject the listener instance by calling the
_InjectionTarget_ _inject_ method on the instance.

Invoke the _PostConstruct_ callback, if any,
by calling the _InjectionTarget_ _postConstruct_ method on the instance.

When the listener instance is to be
destroyed, the persistence provider must behave as if it carries out the
following steps.

Call the _InjectionTarget_ _preDestroy_
method on the instance.

Call the _InjectionTarget_ _dispose_ method
on the instance

Call the _CreationalContext_ _release_
method.

Persistence providers may optimize the steps
above, e.g. by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

Attribute converters that do not make use of
CDI injection are stateless. The lifecycle of such attribute converters
is unspecified.

The conversion of all basic types is
supported except for the following: Id attributes (including the
attributes of embedded ids and derived identities), version attributes,
relationship attributes, and attributes explicitly annotated as
_Enumerated_ or _Temporal_ or designated as such in the XML descriptor.
Auto-apply converters will not be applied to such attributes, and
applications that apply converters to such attributes through use of the
_Convert_ annotation will not be portable.

Type conversion may be specified at the level
of individual attributes by means of the _Convert_ annotation. The
_Convert_ annotation may also be used to override or disable an
auto-apply conversion. See section link:Per.html#a14398[See
Convert Annotation].

The _Convert_ annotation may be applied
directly to an attribute of an entity, mapped superclass, or embeddable
class to specify conversion of the attribute or to override the use of a
converter that has been specified as _autoApply=true_ . When persistent
properties are used, the _Convert_ annotation is applied to the getter
method.

The _Convert_ annotation may be applied to an
entity that extends a mapped superclass to specify or override the
conversion mapping for an inherited basic or embedded attribute.

The persistence provider runtime is
responsible for invoking the specified conversion methods for the target
attribute type when loading the entity attribute from the database and
before storing the entity attribute state to the database. The
persistence provider must apply any conversion methods to instances of
attribute values in path expressions used within Java Persistence query
language queries or criteria queries (such as in comparisons, bulk
updates, etc.) before sending them to the database for the query
execution. When such converted attributes are used in comparison
operations with literals or parameters, the value of the literal or
parameter to which they are compared must also be converted. If the
result of a Java Persistence query language query or criteria query
includes one or more entity attributes for which conversion mappings
have been specified, the persistence provider must apply the specified
conversions to the corresponding values in the query result before
returning them to the application. The use of functions, including
aggregates, on converted attributes is undefined. If an exception is
thrown from a conversion method, the persistence provider must wrap the
exception in a PersistenceException and, if the persistence context is
joined to a transaction, mark the transaction for rollback.

=== [[a3061]]Caching

image:Per-4.png[image]

This specification supports the use of a
second-level cache by the persistence provider. The second-level cache,
if used, underlies the persistence context, and is largely transparent
to the application.

A second-level cache is typically used to
enhance performance. Use of a cache, however, may have consequences in
terms of the up-to-dateness of the data seen by the application,
resulting in “stale reads”. A stale read is defined as the reading of
entities or entity state that is older than the point at which the
persistence context was started.

This specification defines the following
portable configuration options that can be used by the application
developer to control caching behavior. Persistence providers may support
additional provider-specific options, but must observe all
specification-defined options.

==== [[a3065]]The shared-cache-mode Element

Whether the entities and entity-related state
of a persistence unit will be cached is determined by the value of the
_shared-cache-mode_ element of the _persistence.xml_ file.

The _shared-cache-mode_ element has five
possible values: _ALL_ , _NONE_ , _ENABLE_SELECTIVE_ ,
_DISABLE_SELECTIVE_ , _UNSPECIFIED_ .

A value of _ALL_ causes all entities and
entity-related state and data to be cached.

A value of _NONE_ causes caching to be
disabled for the persistence unit. Persistence providers must not cache
if _NONE_ is specified.

The values _ENABLE_SELECTIVE_ and
_DISABLE_SELECTIVE_ are used in conjunction with the _Cacheable_
annotation (or XML element). The _Cacheable_ annotation specifies
whether an entity should be cached if such selective caching is enabled
by the _persistence.xml_ _shared-cache-mode_ element. The _Cacheable_
element is specified on the entity class. It applies to the given entity
and its subclasses unless subsequently overridden by a subclass.

 _Cacheable(false)_ means that the entity and
its state must not be cached by the provider.

A value of _ENABLE_SELECTIVE_ enables the
cache and causes entities for which _Cacheable(true)_ (or its XML
equivalent) is specified to be cached. Entities for which
_Cacheable(true)_ is not specified or for which _Cacheable(false)_ is
specified must not be cached.

A value of _DISABLE_SELECTIVE_ enables the
cache and causes all entities to be cached except those for which
_Cacheable(false)_ is specified. Entities for which _Cacheable(false)_
is specified must not be cached.

If either the _shared-cache-mode_ element is
not specified in the _persistence.xml_ file or the value of the
_shared-cache-mode_ element is _UNSPECIFIED_ , and the
_javax.persistence.sharedCache.mode_ property is not specified, the
behavior is not defined, and provider-specific defaults may apply. If
the _shared-cache-mode_ element and the
_javax.persistence.sharedCache.mode_ property are not specified, the
semantics of the _Cacheable_ annotation (and XML equivalent) are
undefined.

The persistence provider is not required to
support use of a second-level cache. If the persistence provider does
not support use of a second-level cache or a second-level cache is not
installed, this element will be ignored and no caching will occur.

Further control over the second-level cache
is described in section link:Per.html#a12124[See Cache
Interface].

==== Cache Retrieve Mode and Cache Store Mode Properties

Cache retrieve mode and cache store mode
properties may be specified at the level of the persistence context by
means of the EntityManager _setProperty_ method. These properties may be
specified for the _EntityManager_ _find_ and _refresh_ methods and the
_Query_ , _TypedQuery_ , _and_ _StoredProcedureQuery_ _setHint_ methods.
Cache retrieve mode and/or cache store mode properties specified for the
_find_ , _refresh_ , and _Query_ , _TypedQuery_ , and
_StoredProcedureQuery setHint_ methods override those specified for the
persistence context for the specified _find_ and _refresh_ invocations,
and for the execution of the specified queries respectively.

If caching is disabled by the _NONE_ value of
the _shared-cache-mode_ element, cache retrieve mode and cache store
mode properties must be ignored. Otherwise, if the _ENABLE_SELECTIVE_
value is specified, but _Cacheable(true)_ is not specified for a
particular entity, they are ignored for that entity; if the
_DISABLE_SELECTIVE_ value is specified, they are ignored for any
entities for which _Cacheable(false)_ is specified.

Cache retrieve mode and cache store mode
properties must be observed when caching is enabled, regardless of
whether caching is enabled due to the specification of the
_shared-cache-mode_ element or enabled due to provider-specific options.
Applications that make use of cache retrieve mode or cache store mode
properties but which do not specify the _shared-cache-mode_ element will
not be portable.

The cache retrieve mode and cache store mode
properties are _javax.persistence.cache.retrieveMode_ and
_javax.persistence.cache.storeMode_ respectively. These properties have
the semantics defined below.

The _retrieveMode_ property specifies the
behavior when data is retrieved by the _find_ methods and by the
execution of queries. The _retrieveMode_ property is ignored for the
_refresh_ method, which always causes data to be retrieved from the
database, not the cache.

package javax.persistence;



public enum CacheRetrieveMode \{



 /**

 * Read entity data from the cache: this is

 * the default behavior.

 */

 USE,



 /**

 * Bypass the cache: get data directly from

 * the database.

 */

 BYPASS

}



The _storeMode_ property specifies the
behavior when data is read from the database and when data is committed
into the database.

package javax.persistence;



public enum CacheStoreMode \{



 /**

 * Insert entity data into cache when read
from database

 * and insert/update entity data when
committed into database:

 * this is the default behavior. Does not
force refresh of

 * already cached items when reading from
database.

 */

 USE,



 /**

 * Don't insert into cache.

 */

 BYPASS,



 /**

 * Insert/update entity data into cache when
read

 * from database and when committed into
database.

 * Forces refresh of cache for items read
from database.

 */

 REFRESH

}

=== [[a3125]]Query APIs

image:Per-4.png[image]

The _Query_ and _TypedQuery_ APIs are used
for the execution of both static queries and dynamic queries. These APIs
also support parameter binding and pagination control. The
_StoredProcedureQuery_ API is used for the execution of queries that
invoke stored procedures defined in the database.

==== [[a3127]]Query Interface

package javax.persistence;



import java.util.Calendar;

import java.util.Date;

import java.util.List;

import java.util.Set;

import java.util.Map;

import java.util.Stream;



/**

 * Interface used to control query execution.

 */

public interface Query \{



 /**

 * Execute a SELECT query and return the
query results

 * as an untyped List.

 * @return a list of the results

 * @throws IllegalStateException if called
for a Java

 * Persistence query language UPDATE or
DELETE statement

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws TransactionRequiredException if a
lock mode other

 * than NONE has been been set and there is
no

 * transaction or the persistence context has
not been

 * joined to the transaction

 * @throws PessimisticLockException if
pessimistic locking

 * fails and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking

 * fails and only the statement is rolled
back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 List getResultList();



 /**

 * Execute a SELECT query that returns a
single untyped result.

 * @return the result

 * @throws NoResultException if there is no
result

 * @throws NonUniqueResultException if more
than one result

 * @throws IllegalStateException if called
for a Java

 * Persistence query language UPDATE or
DELETE statement

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws TransactionRequiredException if a
lock mode other

 * than NONE has been been set and there is
no

 * transaction or the persistence context has
not been

 * joined to the transaction

 * @throws PessimisticLockException if
pessimistic locking

 * fails and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking

 * fails and only the statement is rolled
back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 Object getSingleResult();



 /**

 * Execute an update or delete statement.

 * @return the number of entities updated or
deleted

 * @throws IllegalStateException if called
for a Java

 * Persistence query language SELECT
statement or for

 * a criteria query

 * @throws TransactionRequiredException if
there is

 * no transaction or the persistence context
has not

 * been joined to the transaction

 * @throws QueryTimeoutException if the
statement execution

 * exceeds the query timeout value set and
only the

 * statement is rolled back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 int executeUpdate();



 /**

 * Set the maximum number of results to
retrieve.

 * @param maxResult

 * @return the same query instance

 * @throws IllegalArgumentException if the
argument is negative

 */

 Query setMaxResults(int maxResult);



 /**

 * The maximum number of results the query
object was set to

 * retrieve. Returns Integer.MAX_VALUE if
setMaxResults was not

 * applied to the query object.

 * @return maximum number of results

 */

 int getMaxResults();



 /**

 * Set the position of the first result to
retrieve.

 * @param startPosition position of the first
result,

 * numbered from 0

 * @return the same query instance

 * @throws IllegalArgumentException if the
argument is negative

 */

 Query setFirstResult(int startPosition);









 /**

 * The position of the first result the query
object was set to

 * retrieve. Returns 0 if setFirstResult was
not applied to the

 * query object.

 * @return position of the first result

 */

 int getFirstResult();



 /**

 * Set a query property or hint. The hints
elements may be used

 * to specify query properties and hints.
Properties defined by

 * this specification must be observed by the
provider.

 * Vendor-specific hints that are not
recognized by a provider

 * must be silently ignored. Portable
applications should not

 * rely on the standard timeout hint.
Depending on the database

 * in use and the locking mechanisms used by
the provider,

 * this hint may or may not be observed.

 * @param hintName name of the property or
hint

 * @param value

 * @return the same query instance

 * @throws IllegalArgumentException if the
second argument is not

 * valid for the implementation

 */

 Query setHint(String hintName, Object
value);



 /**

 * Get the properties and hints and
associated values that are

 * in effect for the query instance.

 * @return query properties and hints

 */

 Map<String, Object> getHints();



 /**

 * Bind the value of a Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter

 * does not correspond to a parameter of the
query

 */

 <T> Query setParameter(Parameter<T> param, T
value);



 /**

 * Bind an instance of java.util.Calendar to
a Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter does not

 * correspond to a parameter of the query

 */

 Query setParameter(Parameter<Calendar>
param,

 Calendar value,

 TemporalType temporalType);











 /**

 * Bind an instance of java.util.Date to a
Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter does not

 * correspond to a parameter of the query

 */

 Query setParameter(Parameter<Date> param,

 Date value,

 TemporalType temporalType);



 /**

 * Bind an argument value to a named
parameter.

 * @param name parameter name

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if

 * the argument is of incorrect type

 */

 Query setParameter(String name, Object
value);



 /**

 * Bind an instance of java.util.Calendar to
a named parameter.

 * @param name parameter name

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if

 * the value argument is of incorrect type

 */

 Query setParameter(String name,

 Calendar value,

 TemporalType temporalType);



 /**

 * Bind an instance of java.util.Date to a
named parameter.

 * @param name parameter name

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if

 * the value argument is of incorrect type

 */

 Query setParameter(String name,

 Date value,

 TemporalType temporalType);

















 /**

 * Bind an argument value to a positional
parameter.

 * @param position

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the

 * query or if the argument is of incorrect
type

 */

 Query setParameter(int position, Object
value);



 /**

 * Bind an instance of java.util.Calendar to
a positional

 * parameter.

 * @param position

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the query or

 * if the value argument is of incorrect type

 */

 Query setParameter(int position,

 Calendar value,

 TemporalType temporalType);



 /**

 * Bind an instance of java.util.Date to a
positional parameter.

 * @param position

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the query or

 * if the value argument is of incorrect type

 */

 Query setParameter(int position,

 Date value,

 TemporalType temporalType);



 /**

 * Get the parameter objects corresponding to
the declared

 * parameters of the query.

 * Returns empty set if the query has no
parameters.

 * This method is not required to be
supported for native

 * queries.

 * @return set of the parameter objects

 * @throws IllegalStateException if invoked
on a native

 * query when the implementation does not
support

 * this use

 */

 Set<Parameter<?>> getParameters();



 /**

 * Get the parameter object corresponding to
the declared

 * parameter of the given name.

 * This method is not required to be
supported for native

 * queries.

 * @param name

 * @return parameter object

 * @throws IllegalArgumentException if the
parameter of the

 * specified name does not exist

 * @throws IllegalStateException if invoked
on a native

 * query when the implementation does not
support

 * this use

 */

 Parameter<?> getParameter(String name);



 /**

 * Get the parameter object corresponding to
the declared

 * parameter of the given name and type.

 * This method is required to be supported
for criteria queries

 * only.

 * @param name parameter name

 * @param type

 * @return parameter object

 * @throws IllegalArgumentException if the
parameter of the

 * specified name does not exist or is not
assignable

 * to the type

 * @throws IllegalStateException if invoked
on a native

 * query or Java Persistence query language
query when

 * the implementation does not support this
use

 */

 <T> Parameter<T> getParameter(String name,
Class<T> type);



 /**

 * Get the parameter object corresponding to
the declared

 * positional parameter with the given
position.

 * This method is not required to be
supported for native

 * queries.

 * @param position

 * @return parameter object

 * @throws IllegalArgumentException if the
parameter with the

 * specified position does not exist

 * @throws IllegalStateException if invoked
on a native

 * query when the implementation does not
support

 * this use

 */

 Parameter<?> getParameter(int position);



 /**

 * Get the parameter object corresponding to
the declared

 * positional parameter with the given
position and type.

 * This method is not required to be
supported by the provider.

 * @param position

 * @param type

 * @return parameter object

 * @throws IllegalArgumentException if the
parameter with the

 * specified position does not exist or is
not assignable

 * to the type

 * @throws IllegalStateException if invoked
on a native

 * query or Java Persistence query language
query when

 * the implementation does not support this
use

 */

 <T> Parameter<T> getParameter(int position,
Class<T> type);







 /**

 * Return a boolean indicating whether a
value has been bound

 * to the parameter.

 * @param param parameter object

 * @return boolean indicating whether
parameter has been bound

 */

 boolean isBound(Parameter<?> param);



 /**

 * Return the input value bound to the
parameter.

 * (Note that OUT parameters are unbound.)

 * @param param parameter object

 * @return parameter value

 * @throws IllegalArgumentException if the
parameter is not

 * a parameter of the query

 * @throws IllegalStateException if the
parameter has not been

 * been bound

 */

 <T> T getParameterValue(Parameter<T> param);



 /**

 * Return the input value bound to the named
parameter.

 * (Note that OUT parameters are unbound.)

 * @param name parameter name

 * @return parameter value

 * @throws IllegalStateException if the
parameter has not been

 * been bound

 * @throws IllegalArgumentException if the
parameter of the

 * specified name does not exist

 */

 Object getParameterValue(String name);



 /**

 * Return the input value bound to the
positional parameter.

 * (Note that OUT parameters are unbound.)

 * @param position

 * @return parameter value

 * @throws IllegalStateException if the
parameter has not been

 * been bound

 * @throws IllegalArgumentException if the
parameter with the

 * specified position does not exist

 */

 Object getParameterValue(int position);



 /**

 * Set the flush mode type to be used for the
query execution.

 * The flush mode type applies to the query
regardless of the

 * flush mode type in use for the entity
manager.

 * @param flushMode

 * @return the same query instance

 */

 Query setFlushMode(FlushModeType flushMode);















 /**

 * Get the flush mode in effect for the query
execution.

 * If a flush mode has not been set for the
query object,

 * returns the flush mode in effect for the
entity manager.

 * @return flush mode

 */

 FlushModeType getFlushMode();



 /**

 * Set the lock mode type to be used for the
query execution.

 * @param lockMode

 * @return the same query instance

 * @throws IllegalStateException if the query
is found not to be

 * a Java Persistence query language SELECT
query

 * or a CriteriaQuery query

 */

 Query setLockMode(LockModeType lockMode);



 /**

 * Get the current lock mode for the query.
Returns null if a

 * lock mode has not been set on the query
object.

 * @return lock mode

 * @throws IllegalStateException if the query
is found not to be

 * a Java Persistence query language SELECT
query or

 * a Criteria API query

 */

 LockModeType getLockMode();



 /**

 * Return an object of the specified type to
allow access to

 * the provider-specific API. If the
provider's query

 * implementation does not support the
specified class, the

 * PersistenceException is thrown.

 * @param cls the class of the object to be
returned. This is

 * normally either the underlying query

 * implementation class or an interface that
it

 * implements.

 * @return an instance of the specified class

 * @throws PersistenceException if the
provider does not support

 * the call

 */

 <T> T unwrap(Class<T> cls);



 /**

 * Execute a SELECT query and return the
query results

 * as an untyped java.util.Stream.

 * By default this method delegates to
getResultList().stream(),

 * however the persistence provider may
choose to override this

 * method to provide additional capabilities.

 *

 * @return a stream of the results

 * @throws IllegalStateException if called
for a Java

 * Persistence query language UPDATE or
DELETE statement

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws TransactionRequiredException if a
lock mode other than

 * NONE has been set and there is no
transaction

 * or the persistence context has not been
joined to

 * the transaction

 * @throws PessimisticLockException if
pessimistic locking

 * fails and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking

 * fails and only the statement is rolled
back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 default Stream getResultStream() \{

 return getResultList().stream();

 }

}

==== TypedQuery Interface

package javax.persistence;



import java.util.List;

import java.util.Date;

import java.util.Calendar;

import java.util.Stream;



/**

 * Interface used to control the execution of
typed queries.

 * @param <X> query result type

 */

public interface TypedQuery<X> extends Query
\{

 /**

 * Execute a SELECT query and return the
query results

 * as a typed List.

 * @return a list of the results

 * @throws IllegalStateException if called
for a Java

 * Persistence query language UPDATE or
DELETE statement

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws TransactionRequiredException if a
lock mode other

 * than NONE has been been set and there is
no

 * transaction or the persistence context has
not been

 * joined to the transaction

 * @throws PessimisticLockException if
pessimistic locking

 * fails and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking

 * fails and only the statement is rolled
back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 List<X> getResultList();



 /**

 * Execute a SELECT query that returns a
single result.

 * @return the result

 * @throws NoResultException if there is no
result

 * @throws NonUniqueResultException if more
than one result

 * @throws IllegalStateException if called
for a Java

 * Persistence query language UPDATE or
DELETE statement

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws TransactionRequiredException if a
lock mode other

 * than NONE has been been set and there is
no

 * transaction or the persistence context has
not been

 * joined to the transaction

 * @throws PessimisticLockException if
pessimistic locking

 * fails and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking

 * fails and only the statement is rolled
back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 X getSingleResult();



 /**

 * Set the maximum number of results to
retrieve.

 * @param maxResult

 * @return the same query instance

 * @throws IllegalArgumentException if the
argument is negative

 */

 TypedQuery<X> setMaxResults(int maxResult);



 /**

 * Set the position of the first result to
retrieve.

 * @param startPosition position of the first
result,

 * numbered from 0

 * @return the same query instance

 * @throws IllegalArgumentException if the
argument is negative

 */

 TypedQuery<X> setFirstResult(int
startPosition);



 /**

 * Set a query property or hint. The hints
elements may be used

 * to specify query properties and hints.
Properties defined by

 * this specification must be observed by the
provider.

 * Vendor-specific hints that are not
recognized by a provider

 * must be silently ignored. Portable
applications should not

 * rely on the standard timeout hint.
Depending on the database

 * in use and the locking mechanisms used by
the provider,

 * this hint may or may not be observed.

 * @param hintName name of property or hint

 * @param value

 * @return the same query instance

 * @throws IllegalArgumentException if the
second argument is not

 * valid for the implementation

 */

 TypedQuery<X> setHint(String hintName,
Object value);



 /**

 * Bind the value of a Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter

 * does not correspond to a parameter of the

 * query

 */

 <T> TypedQuery<X> setParameter(Parameter<T>
param, T value);



 /**

 * Bind an instance of java.util.Calendar to
a Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter does not

 * correspond to a parameter of the query

 */

 TypedQuery<X>
setParameter(Parameter<Calendar> param,

 Calendar value,

 TemporalType temporalType);



 /**

 * Bind an instance of java.util.Date to a
Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter does not

 * correspond to a parameter of the query

 */

 TypedQuery<X> setParameter(Parameter<Date>
param,

 Date value,

 TemporalType temporalType);



 /**

 * Bind an argument value to a named
parameter.

 * @param name parameter name

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if

 * the argument is of incorrect type

 */

 TypedQuery<X> setParameter(String name,
Object value);



 /**

 * Bind an instance of java.util.Calendar to
a named parameter.

 * @param name parameter name

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if

 * the value argument is of incorrect type

 */

 TypedQuery<X> setParameter(String name,

 Calendar value,

 TemporalType temporalType);



 /**

 * Bind an instance of java.util.Date to a
named parameter.

 * @param name parameter name

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if

 * the value argument is of incorrect type

 */

 TypedQuery<X> setParameter(String name,

 Date value,

 TemporalType temporalType);

















 /**

 * Bind an argument value to a positional
parameter.

 * @param position

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the

 * query or if the argument is of incorrect
type

 */

 TypedQuery<X> setParameter(int position,
Object value);



 /**

 * Bind an instance of java.util.Calendar to
a positional

 * parameter.

 * @param position

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the query

 * or if the value argument is of incorrect
type

 */

 TypedQuery<X> setParameter(int position,

 Calendar value,

 TemporalType temporalType);



 /**

 * Bind an instance of java.util.Date to a
positional parameter.

 * @param position

 * @param value parameter value

 * @param temporalType

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the query

 * or if the value argument is of incorrect
type

 */

 TypedQuery<X> setParameter(int position,

 Date value,

 TemporalType temporalType);



 /**

 * Set the flush mode type to be used for the
query execution.

 * The flush mode type applies to the query
regardless of the

 * flush mode type in use for the entity
manager.

 * @param flushMode

 * @return the same query instance

 */

 TypedQuery<X> setFlushMode(FlushModeType
flushMode);



 /**

 * Set the lock mode type to be used for the
query execution.

 * @param lockMode

 * @return the same query instance

 * @throws IllegalStateException if the query
is found not to

 * be a Java Persistence query language
SELECT query

 * or a CriteriaQuery query

 */

 TypedQuery<X> setLockMode(LockModeType
lockMode);



 /**

 * Execute a SELECT query and return the
query results

 * as a typed java.util.Stream.

 * By default this method delegates to
getResultList().stream(),

 * however persistence provider may choose to
override this

 * method to provide additional capabilities.

 *

 * @return a stream of the results

 * @throws IllegalStateException if called
for a Java

 * Persistence query language UPDATE or
DELETE statement

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws TransactionRequiredException if a
lock mode other than

 * NONE has been set and there is no
transaction

 * or the persistence context has not been
joined to the

 * transaction

 * @throws PessimisticLockException if
pessimistic locking

 * fails and the transaction is rolled back

 * @throws LockTimeoutException if
pessimistic locking

 * fails and only the statement is rolled
back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 default Stream<X> getResultStream() \{

 return getResultList().stream();

 }



}

==== [[a3868]]Tuple Interface



package javax.persistence;



import java.util.List;



/**

 * Interface for extracting the elements of a
query result tuple.

 */

public interface Tuple \{



 /**

 * Get the value of the specified tuple
element.

 * @param tupleElement tuple element

 * @return value of tuple element

 * @throws IllegalArgumentException if tuple
element

 * does not correspond to an element in the

 * query result tuple

 */

 <X> X get(TupleElement<X> tupleElement);



 /**

 * Get the value of the tuple element to
which the

 * specified alias has been assigned.

 * @param alias alias assigned to tuple
element

 * @param type of the tuple element

 * @return value of the tuple element

 * @throws IllegalArgumentException if alias

 * does not correspond to an element in the

 * query result tuple or element cannot be

 * assigned to the specified type

 */

 <X> X get(String alias, Class<X> type);



 /**

 * Get the value of the tuple element to
which the

 * specified alias has been assigned.

 * @param alias alias assigned to tuple
element

 * @return value of the tuple element

 * @throws IllegalArgumentException if alias

 * does not correspond to an element in the

 * query result tuple

 */

 Object get(String alias);



 /**

 * Get the value of the element at the
specified

 * position in the result tuple. The first
position is 0.

 * @param i position in result tuple

 * @param type type of the tuple element

 * @return value of the tuple element

 * @throws IllegalArgumentException if i
exceeds

 * length of result tuple or element cannot
be

 * assigned to the specified type

 */

 <X> X get(int i, Class<X> type);







 /**

 * Get the value of the element at the
specified

 * position in the result tuple. The first
position is 0.

 * @param i position in result tuple

 * @return value of the tuple element

 * @throws IllegalArgumentException if i
exceeds

 * length of result tuple

 */

 Object get(int i);



 /**

 * Return the values of the result tuple
elements as an array.

 * @return tuple element values

 */

 Object[] toArray();



 /**

 * Return the tuple elements.

 * @return tuple elements

 */

 List<TupleElement<?>> getElements();

}

==== [[a3949]]TupleElement Interface



package javax.persistence;



/**

 * The TupleElement interface defines an
element that is returned in

 * a query result tuple.

 * @param <X> the type of the element

 */

public interface TupleElement<X> \{



 /**

 * Return the runtime Java type of the tuple
element.

 * @return the runtime Java type of the tuple
element

 */

 Class<? extends X> getJavaType();



 /**

 * Return the alias assigned to the tuple
element or null,

 * if no alias has been assigned.

 * @return alias

 */

 String getAlias();

}

==== Parameter Interface



package javax.persistence;



/**

 * Type for query parameter objects.

 * @param <T> the type of the parameter

 */

public interface Parameter<T> \{



 /**

 * Return the parameter name, or null if the
parameter is

 * not a named parameter or no name has been
assigned.

 * @return parameter name

 */

 String getName();



 /**

 * Return the parameter position, or null if
the parameter is

 * not a positional parameter.

 * @return position of parameter

 */

 Integer getPosition();



 /**

 * Return the Java type of the parameter.
Values bound to the

 * parameter must be assignable to this type.

 * This method is required to be supported
for criteria queries

 * only. Applications that use this method
for Java

 * Persistence query language queries and
native queries will

 * not be portable.

 * @return the Java type of the parameter

 * @throws IllegalStateException if invoked
on a parameter

 * obtained from a Java persistence query
language

 * query or native query when the
implementation does

 * not support this use

 */

 Class<T> getParameterType();

}

==== StoredProcedureQuery Interface

package javax.persistence;



import java.util.Calendar;

import java.util.Date;

import java.util.List;



/**

 * Interface used to control stored procedure
query execution.*

 */

public interface StoredProcedureQuery extends
Query \{



 /**

 * Set a query property or hint. The hints
elements may be used

 * to specify query properties and hints.
Properties defined by

 * this specification must be observed by the
provider.

 * Vendor-specific hints that are not
recognized by a provider

 * must be silently ignored. Portable
applications should not

 * rely on the standard timeout hint.
Depending on the database

 * in use, this hint may or may not be
observed.

 * @param hintName name of the property or
hint

 * @param value value for the property or
hint

 * @return the same query instance

 * @throws IllegalArgumentException if the
second argument is not

 * valid for the implementation

 */

 StoredProcedureQuery setHint(String
hintName, Object value);



 /**

 * Bind the value of a Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter does not

 * correspond to a parameter of the query

 */

 <T> StoredProcedureQuery
setParameter(Parameter<T> param,

 T value);



 /**

 * Bind an instance of java.util.Calendar to
a Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @param temporalType temporal type

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter does not

 * correspond to a parameter of the query

 */

 StoredProcedureQuery
setParameter(Parameter<Calendar> param,

 Calendar value,

 TemporalType temporalType);

















 /**

 * Bind an instance of java.util.Date to a
Parameter object.

 * @param param parameter object

 * @param value parameter value

 * @param temporalType temporal type

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter does not

 * correspond to a parameter of the query

 */

 StoredProcedureQuery
setParameter(Parameter<Date> param,

 Date value,

 TemporalType temporalType);



 /**

 * Bind an argument to a named parameter.

 * @param name parameter name

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if the

 * argument is of incorrect type

 */

 StoredProcedureQuery setParameter(String
name, Object value);



 /**

 * Bind an instance of java.util.Calendar to
a named parameter.

 * @param name parameter name

 * @param value parameter value

 * @param temporalType temporal type

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if the

 * value argument is of incorrect type

 */

 StoredProcedureQuery setParameter(String
name,

 Calendar value,

 TemporalType temporalType);



 /**

 * Bind an instance of java.util.Date to a
named parameter.

 * @param name parameter name

 * @param value parameter value

 * @param temporalType temporal type

 * @return the same query instance

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or if the

 * value argument is of incorrect type

 */

 StoredProcedureQuery setParameter(String
name,

 Date value,

 TemporalType temporalType);

















 /**

 * Bind an argument to a positional
parameter.

 * @param position position

 * @param value parameter value

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the query

 * or if the argument is of incorrect type

 */

 StoredProcedureQuery setParameter(int
position, Object value);



 /**

 * Bind an instance of java.util.Calendar to
a positional

 * parameter.

 * @param position position

 * @param value parameter value

 * @param temporalType temporal type

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the query or

 * if the value argument is of incorrect type

 */

 StoredProcedureQuery setParameter(int
position,

 Calendar value,

 TemporalType temporalType);



 /**

 * Bind an instance of java.util.Date to a
positional parameter.

 * @param position position

 * @param value parameter value

 * @param temporalType temporal type

 * @return the same query instance

 * @throws IllegalArgumentException if
position does not

 * correspond to a positional parameter of
the query or

 * if the value argument is of incorrect type

 */

 StoredProcedureQuery setParameter(int
position,

 Date value,

 TemporalType temporalType);



 /**

 * Set the flush mode type to be used for the
query execution.

 * The flush mode type applies to the query
regardless of the

 * flush mode type in use for the entity
manager.

 * @param flushMode flush mode

 * @return the same query instance

 */

 StoredProcedureQuery
setFlushMode(FlushModeType flushMode);























 /**

 * Register a positional parameter.

 * All positional parameters must be
registered.

 * @param position parameter position

 * @param type type of the parameter

 * @param mode parameter mode

 * @return the same query instance

 */

 StoredProcedureQuery
registerStoredProcedureParameter(

 int position,

 Class type,

 ParameterMode mode);



 /**

 * Register a named parameter.

 * @param parameterName name of the parameter
as registered or

 * specified in metadata

 * @param type type of the parameter

 * @param mode parameter mode

 * @return the same query instance

 */

 StoredProcedureQuery
registerStoredProcedureParameter(

 String parameterName,

 Class type,

 ParameterMode mode);



 /**

 * Retrieve a value passed back from the
procedure through an

 * INOUT or OUT parameter.

 * For portability, all results corresponding
to result sets

 * and update counts must be retrieved before
the values of

 * output parameters.

 * @param position parameter position

 * @return the result that is passed back
through the parameter

 * @throws IllegalArgumentException if the
position does

 * not correspond to a parameter of the query
or is

 * not an INOUT or OUT parameter

 */

 Object getOutputParameterValue(int
position);



 /**

 * Retrieve a value passed back from the
procedure through an

 * INOUT or OUT parameter.

 * For portability, all results corresponding
to result sets

 * and update counts must be retrieved before
the values of

 * output parameters.

 * @param parameterName name of the parameter
as registered or

 * specified in metadata

 * @return the result that is passed back
through the parameter

 * @throws IllegalArgumentException if the
parameter name does

 * not correspond to a parameter of the query
or is

 * not an INOUT or OUT parameter

 */

 Object getOutputParameterValue(String
parameterName);











 /**

 * Return true if the first result
corresponds to a result set,

 * and false if it is an update count or if
there are no results

 * other than through INOUT and OUT
parameters, if any.

 * @return true if first result corresponds
to result set

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 boolean execute();



 /**

 * Return the update count of -1 if there is
no pending result or

 * if the first result is not an update
count. The provider

 * will call execute on the query if needed.

 * @return the update count or -1 if there is
no pending result

 * or if the next result is not an update
count.

 * @throws TransactionRequiredException if
there is

 * no transaction or the persistence context
has not

 * been joined to the transaction

 * @throws QueryTimeoutException if the
statement execution

 * exceeds the query timeout value set and
only

 * the statement is rolled back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 int executeUpdate();



 /**

 * Retrieve the list of results from the next
result set.

 * The provider will call execute on the
query if needed.

 * A REF_CURSOR result set, if any, will be
retrieved in the

 * order the REF_CURSOR parameter was
registered with the query.

 * @return a list of the results or null is
the next item is not

 * a result set

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 List getResultList();

























 /**

 * Retrieve a single result from the next
result set.

 * The provider will call execute on the
query if needed.

 * A REF_CURSOR result set, if any, will be
retrieved in the

 * order the REF_CURSOR parameter was
registered with the query.

 * @return the result or null if the next
item is not a result set

 * @throws NoResultException if there is no
result in the next

 * result set

 * @throws NonUniqueResultException if more
than one result

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 Object getSingleResult();



 /**

 * Return true if the next result corresponds
to a result set,

 * and false if it is an update count or if
there are no results

 * other than through INOUT and OUT
parameters, if any.

 * @return true if next result corresponds to
result set

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 boolean hasMoreResults();



 /**

 * Return the update count or -1 if there is
no pending result

 * or if the next result is not an update
count.

 * @return update count or -1 if there is no
pending result or

 * if the next result is not an update count

 * @throws QueryTimeoutException if the query
execution exceeds

 * the query timeout value set and only the
statement is

 * rolled back

 * @throws PersistenceException if the query
execution exceeds

 * the query timeout value set and the
transaction

 * is rolled back

 */

 int getUpdateCount();

}

==== Query Execution

Java Persistence query language, Criteria
API, and native SQL select queries are executed using the
_getResultList_ and _getSingleResult_ methods. Update and delete
operations (update and delete “queries”) are executed using the
_executeUpdate_ method.

For _TypedQuery_ instances, the query result
type is determined in the case of criteria queries by the type of the
query specified when the _CriteriaQuery_ object is created, as described
in section link:Per.html#a10621[See CriteriaQuery Creation]. In
the case of Java Persistence query language queries, the type of the
result is determined by the _resultClass_ argument to the _createQuery_
or _createNamedQuery_ method, and the select list of the query must
contain only a single item which must be assignable to the specified
type.

For _Query_ instances, the elements of a
query result whose select list consists of more than one select
expression are of type _Object[]_ . If the select list consists of only
one select expression, the elements of the query result are of type
_Object_ . When native SQL queries are used, the SQL result set mapping
(see section link:Per.html#a4427[See SQL Queries]), determines
how many items (entities, scalar values, etc.) are returned. If multiple
items are returned, the elements of the query result are of type
_Object[]_ . If only a single item is returned as a result of the SQL
result set mapping or if a result class is specified, the elements of
the query result are of type _Object_ .

Stored procedure queries can be executed
using the _getResultList_ , _getSingleResult_ , and _execute_ methods.
Stored procedures that perform only updates or deletes can be executed
using the _executeUpdate_ method. Stored procedure query execution is
described in detail in section link:Per.html#a4625[See Stored
Procedure Query Execution].

An _IllegalArgumentException_ is thrown if a
parameter instance is specified that does not correspond to a parameter
of the query, if a parameter name is specified that does not correspond
to a named parameter of the query, if a positional value is specified
that does not correspond to a positional parameter of the query, or if
the type of the parameter is not valid for the query. This exception may
be thrown when the parameter is bound, or the execution of the query may
fail. See sections link:Per.html#a4397[See Parameter Objects],
link:Per.html#a4401[See Named Parameters], and
link:Per.html#a4405[See Positional Parameters] for supported
parameter usage.

The effect of applying _setMaxResults_ or
_setFirstResult_ to a query involving fetch joins over collections is
undefined. The use of _setMaxResults_ and _setFirstResult_ is not
supported for stored procedure queries.

 _Query_ and _TypedQuery_ methods other than
the _executeUpdate_ method are not required to be invoked within a
transaction context, unless a lock mode other than _LockModeType.NONE_
has been specified for the query. In particular, the _getResultList_ and
_getSingleResult_ methods are not required to be invoked within a
transaction context unless such a lock mode has been specified for the
query.link:#a19589[53] If an entity manager with
transaction-scoped persistence context is in use, the resulting entities
will be detached; if an entity manager with an extended persistence
context is used, they will be managed. See Chapter
link:Per.html#a11431[See Entity Managers and Persistence
Contexts] for further discussion of entity manager use outside a
transaction and persistence context types.

Whether a _StoredProcedureQuery_ should be
invoked in a transaction context should be determined by the
transactional semantics and/or requirements of the stored procedure
implementation and the database in use. In particular, problems may
occur if the stored procedure initiates a transaction and a transaction
is already in effect. The state of any entities returned by the stored
procedure query invocation is determined as decribed above.

Runtime exceptions other than the
_NoResultException_ , _NonUniqueResultException_ ,
_QueryTimeoutException_ , and _LockTimeoutException_ thrown by the
methods of the _Query_ , _TypedQuery_ , and _StoredProcedureQuery_
interfaces other than those methods specified below cause the current
transaction to be marked for rollback if the persistence context is
joined to the transaction. On database platforms on which a query
timeout causes transaction rollback, the persistence provider must throw
the _PersistenceException_ instead of the _QueryTimeoutException_ .

Runtime exceptions thrown by the following
methods of the _Query_ , _TypedQuery_ , and _StoredProcedureQuery_
interfaces do not cause the current transaction to be marked for
rollback: _getParameters_ , _getParameter_ , _getParameterValue_ ,
_getOutputParameterValue_ , _getLockMode_ .

Runtime exceptions thrown by the methods of
the _Tuple_ , _TupleElement_ , and _Parameter_ interfaces do not cause
the current transaction to be marked for rollback.

===== Example



public List findWithName(String name) \{

 return em.createQuery(

 "SELECT c FROM Customer c WHERE c.name LIKE
:custName")

 .setParameter("custName", name)

 .setMaxResults(10)

 .getResultList();

}

==== [[a4374]]Queries and Flush Mode

The flush mode setting affects the result of
a query as follows.

When queries are executed within a
transaction, if _FlushModeType.AUTO_ is set on the _Query_ ,
_TypedQuery_ , or _StoredProcedureQuery_ object, or if the flush mode
setting for the persistence context is _AUTO_ (the default) and a flush
mode setting has not been specified for the query object, the
persistence provider is responsible for ensuring that all updates to the
state of all entities in the persistence context which could potentially
affect the result of the query are visible to the processing of the
query. The persistence provider implementation may achieve this by
flushing those entities to the database or by some other means. If
_FlushModeType.COMMIT_ is set, the effect of updates made to entities in
the persistence context upon queries is unspecified.

If the persistence context has not been
joined to the current transaction, the persistence provider must not
flush to the database regardless of the flush mode setting.

package javax.persistence;



public enum FlushModeType \{

 COMMIT,

 AUTO

}

If there is no transaction active, the
persistence provider must not flush to the database.

==== [[a4385]]Queries and Lock Mode

{empty}The _setLockMode_ method of the
_Query_ or _TypedQuery_ interface or the _lockMode_ element of the
_NamedQuery_ annotation may be used to lock the results of a query. A
lock is obtained for each entity specified in the query result
(including entities passed to constructors in the query SELECT
clause).link:#a19590[54]

If the lock mode type is _PESSIMISTIC_READ_ ,
_PESSIMISTIC_WRITE_ , or _PESSIMISTIC_FORCE_INCREMENT_ , and the query
returns scalar data (e.g., the values of entity field or properties,
including scalar data passed to constructors in the query SELECT
clause), the underlying database rows will be
lockedlink:#a19591[55], but the version columns (if any) for any
entities corresponding to such scalar data will not be updated unless
the entities themselves are also otherwise retrieved and updated.

If the lock mode type is _OPTIMISTIC_ or
_OPTIMISTIC_FORCE_INCREMENT_ , and the query returns scalar data, any
entities returned by the query will be locked, but no locking will occur
for scalar data that does not correspond to the state of any entity
instance in the query result.

If a lock mode other than _NONE_ is specified
for a query, the query must be executed within a transaction (and the
persistence context must be joined to the transaction) or the
_TransactionRequiredException_ will be thrown.

Locking is supported for Java Persistence
query language queries and criteria queries only. If the _setLockMode_
or _getLockMode_ method is invoked on a query that is not a Java
Persistence query language select query or a criteria query, the
_IllegalStateException_ may be thrown or the query execution will fail.

==== [[a4391]]Query Hints

The following hint is defined by this
specification for use in query configuration.

 javax.persistence.query.timeout // time in
milliseconds

This hint may be used with the _Query_ ,
_TypedQuery_ , or _StoredProcedureQuery_ _setHint_ method or the
_NamedQuery_ , _NamedNativeQuery_ , and _NamedStoredProcedureQuery_
annotations. It may also be passed as a property to the
_Persistence.createEntityManagerFactory_ method and used in the
_properties_ element of the _persistence.xml_ file. See sections
link:Per.html#a3127[See Query Interface],
link:Per.html#a12384[See properties],
link:Per.html#a13443[See javax.persistence.Persistence Class],
link:Per.html#a13710[See Annotations for Queries]. When used in
the _createEntityManagerFactory_ method, the _persistence.xml_ file, and
annotations, the _timeout_ hint serves as a default value which can be
selectively overridden by use in the _setHint_ method.

Portable applications should not rely on this
hint. Depending on the persistence provider and database in use, the
hint may or may not be observed.

Vendors are permitted to support the use of
additional, vendor-specific hints. Vendor-specific hints must not use
the _javax.persistence_ namespace. Vendor-specific hints must be ignored
if they are not understood.

==== [[a4397]]Parameter Objects

 _Parameter_ objects can be used for criteria
queries and for Java Persistence query language queries.

Implementations may support the use of
_Parameter_ objects for native queries, however support for _Parameter_
objects with native queries is not required by this specification. The
use of _Parameter_ objects for native queries will not be portable. The
mixing of parameter objects with named or positional parameters is
undefined.

Portable applications should not attempt to
reuse a _Parameter_ object obtained from a _Query_ or _TypedQuery_
instance in the context of a different _Query_ or _TypedQuery_ instance.

==== [[a4401]]Named Parameters

Named parameters can be used for Java
Persistence query language queries, for criteria queries (although use
of _Parameter_ objects is to be preferred), and for stored procedure
queries that support named parameters.

Named parameters follow the rules for
identifiers defined in link:Per.html#a4760[See Identifiers].
Named parameters are case-sensitive. The mixing of named and positional
parameters is undefined.

A named parameter of a Java Persistence query
language query is an identifier that is prefixed by the " _:_ " symbol.
The parameter names passed to the _setParameter_ methods of the _Query_
and _TypedQuery_ interfaces do not include this " _:_ " prefix.

==== [[a4405]]Positional Parameters

Only positional parameter binding and
positional access to result items may be portably used for native
queries, except for stored procedure queries for which named parameters
have been defined. When binding the values of positional parameters, the
numbering starts as “ _1_ ”. It is assumed that for native queries the
parameters themselves use the SQL syntax (i.e., “ _?_ ”, rather than “
_?1_ ”).

The use of positional parameters is not
supported for criteria queries.

==== Named Queries

Named queries are static queries expressed in
metadata or queries registered by means of the EntityManagerFactory
_addNamedQuery_ method. Named queries can be defined in the Java
Persistence query language or in SQL. Query names are scoped to the
persistence unit.

The following is an example of the definition
of a named query defined in metadata:

@NamedQuery(

 name="findAllCustomersWithName",

 query="SELECT c FROM Customer c WHERE c.name
LIKE :custName"

)

The following is an example of the use of a
named query:

@PersistenceContext

public EntityManager em;

...

customers =
em.createNamedQuery("findAllCustomersWithName")

 .setParameter("custName", "Smith")

 .getResultList();

==== Polymorphic Queries

By default, all queries are polymorphic. That
is, the FROM clause of a query designates not only instances of the
specific entity class(es) to which it explicitly refers, but subclasses
as well. The instances returned by a query include instances of the
subclasses that satisfy the query conditions.

For example, the following query returns the
average salary of all employees, including subtypes of _Employee_ , such
as _Manager_ and _Exempt_ .

 _select avg(e.salary) from Employee e where
e.salary > 80000_

Entity type expressions, described in section
link:Per.html#a5381[See Entity Type Expressions], as well as the
use of downcasting, described in section link:Per.html#a4965[See
Downcasting], can be used to restrict query polymorphism.

==== [[a4427]]SQL Queries

Queries may be expressed in native SQL. The
result of a native SQL query may consist of entities, unmanaged
instances created via constructors, scalar values, or some combination
of these.

The SQL query facility is intended to provide
support for those cases where it is necessary to use the native SQL of
the target database in use (and/or where the Java Persistence query
language cannot be used). Native SQL queries are not expected to be
portable across databases.

===== Returning Managed Entities from Native Queries

The persistence provider is responsible for
performing the mapping between the values returned by the SQL query and
entity attributes in accordance with the object/relational mapping
metadata for the entity or entities. In particular, the names of the
columns in the SQL result are used to map to the entity attributes as
defined by this metadata. This mapping includes the mapping of the
attributes of any embeddable classes that are part of the
non-collection-valued entity state and attributes corresponding to
foreign keys contained as part of the entity
statelink:#a19592[56].

When an entity is to be returned from a
native query, the SQL statement should select all of the columns that
are mapped to the entity object. This should include foreign key columns
to related entities. The results obtained when insufficient data is
available are undefined.

In the simplest case—i.e., when the results
of the query are limited to entities of a single entity class and the
mapping information can be derived from the columns of the SQL result
and the object/relational mapping metadata—it is sufficient to specify
only the expected class of the entity result.

The following example illustrates the case
where a native SQL query is created dynamically using the
_createNativeQuery_ method and the entity class that specifies the type
of the result is passed in as an argument.

Query q = em.createNativeQuery(

 "SELECT o.id, o.quantity, o.item " +

 "FROM Order o, Item i " +

 "WHERE (o.item = i.id) AND (i.name =
'widget')",

 com.acme.Order.class);

When executed, this query will return a
collection of all _Order_ entities for items named “widget”.

The _SqlResultSetMapping_ metadata
annotation—which is designed to handle more complex cases—can be used as
an alternative here. See section link:Per.html#a13797[See
Annotations for SQL Result Set Mappings] for the definition of the
_SqlResultSetMapping_ metadata annotation and related annotations.

For the query shown above, the
_SqlResultSetMapping_ metadata for the query result type might be
specified as follows:

@SqlResultSetMapping(

 name="WidgetOrderResults",


entities=@EntityResult(entityClass=com.acme.Order.class))

The same results as produced by the query
above can then obtained by the following:

Query q = em.createNativeQuery(

 "SELECT o.id, o.quantity, o.item " +

 "FROM Order o, Item i " +

 "WHERE (o.item = i.id) AND (i.name =
'widget')",

 "WidgetOrderResults");

When multiple entities are returned by a SQL
query or when the column names of the SQL result do not correspond to
those of the object/relational mapping metadata, a _SqlResultSetMapping_
metadata definition must be provided to specify the entity mapping.

The following query and _SqlResultSetMapping_
metadata illustrates the return of multiple entity types. It assumes
default metadata and column name defaults.

Query q = em.createNativeQuery(

 "SELECT o.id, o.quantity, o.item, i.id,
i.name, i.description "+

 "FROM Order o, Item i " +

 "WHERE (o.quantity > 25) AND (o.item =
i.id)",

 "OrderItemResults");





@SqlResultSetMapping(name="OrderItemResults",

 entities=\{


@EntityResult(entityClass=com.acme.Order.class),


@EntityResult(entityClass=com.acme.Item.class)

 })

When the column names of the SQL result do
not correspond to those of the object/relational mapping metadata, more
explicit SQL result mapping metadata must be provided to enable the
persistence provider runtime to map the JDBC results into the expected
objects. This might arise, for example, when column aliases must be used
in the SQL SELECT clause when the SQL result would otherwise contain
multiple columns of the same name or when columns in the SQL result are
the results of operators or functions. The _FieldResult_ annotation
element within the _EntityResult_ annotation is used to specify the
mapping of such columns to entity attributes.

The following example combining multiple
entity types includes aliases in the SQL statement. This requires that
the column names be explicitly mapped to the entity fields corresponding
to those columns. The _FieldResult_ annotation is used for this purpose.

Query q = em.createNativeQuery(

 "SELECT o.id AS order_id, " +

 "o.quantity AS order_quantity, " +

 "o.item AS order_item, " +

 "i.id, i.name, i.description " +

 "FROM Order o, Item i " +

 "WHERE (order_quantity > 25) AND (order_item
= i.id)",

 "OrderItemResults");




@SqlResultSetMapping(name="OrderItemResults",

 entities=\{


@EntityResult(entityClass=com.acme.Order.class, fields=\{

 @FieldResult(name="id", column="order_id"),

 @FieldResult(name="quantity",
column="order_quantity"),

 @FieldResult(name="item",
column="order_item")}),


@EntityResult(entityClass=com.acme.Item.class)

 })



When the returned entity type contains an
embeddable class, the _FieldResult_ element must use a dot (“ _._ ”)
notation to indicate which column maps to which field or property of the
contained embeddable.

 _Example:_

Query q = em.createNativeQuery(

 "SELECT c.id AS customer_id, " +

 "c.street AS customer_street, " +

 "c.city AS customer_city, " +

 "c.state AS customer_state, " +

 "c.status AS customer_status " +

 "FROM Customer c " +

 "WHERE c.status = 'GOLD' " ,

 "CustomerResults");



@SqlResultSetMapping(name=”CustomerResults”,

 entities=\{


@EntityResult(entityClass=com.acme.Customer.class,

 fields=\{

 @FieldResult(name="id",

 column="customer_id"),

 @FieldResult(name="address.street",

 column="customer_street"),

 @FieldResult(name="address.city",

 column="customer_city"),

 @FieldResult(name="address.state",

 column="customer_state"),

 @FieldResult(name="status",

 column="customer_status")})

})

When the returned entity type is the owner of
a single-valued relationship and the foreign key is a composite foreign
key (composed of multiple columns), a _FieldResult_ element should be
used for each of the foreign key columns. The _FieldResult_ element must
use the dot (“ _._ ”) notation form to indicate the column that maps to
each property or field of the target entity primary key.

If the target entity has a primary key of
type _IdClass_ , this specification takes the form of the name of the
field or property for the relationship, followed by a dot (“ _._ ”),
followed by the name of the field or property of the primary key in the
target entity. The latter will be annotated with _Id_ , as specified in
section link:Per.html#a14836[See IdClass Annotation].

 _Example:_

Query q = em.createNativeQuery(

 "SELECT o.id AS order_id, " +

 "o.quantity AS order_quantity, " +

 "o.item_id AS order_item_id, " +

 "o.item_name AS order_item_name, " +

 "i.id, i.name, i.description " +

 "FROM Order o, Item i " +

 "WHERE (order_quantity > 25) AND
(order_item_id = i.id) " +

 "AND (order_item_name = i.name)",

 "OrderItemResults");



@SqlResultSetMapping(name="OrderItemResults",

 entities=\{


@EntityResult(entityClass=com.acme.Order.class, fields=\{

 @FieldResult(name="id", column="order_id"),

 @FieldResult(name="quantity",
column="order_quantity"),

 @FieldResult(name="item.id",
column="order_item_id")}),

 @FieldResult(name="item.name",

 column="order_item_name")}),


@EntityResult(entityClass=com.acme.Item.class)

})

If the target entity has a primary key of
type _EmbeddedId_ , this specification is composed of the name of the
field or property for the relationship, followed by a dot (“ _._ ”),
followed by the name or the field or property of the primary key (i.e.,
the name of the field or property annotated as _EmbeddedId_ ), followed
by the name of the corresponding field or property of the embedded
primary key class.

 _Example:_

Query q = em.createNativeQuery(

 "SELECT o.id AS order_id, " +

 "o.quantity AS order_quantity, " +

 "o.item_id AS order_item_id, " +

 "o.item_name AS order_item_name, " +

 "i.id, i.name, i.description " +

 "FROM Order o, Item i " +

 "WHERE (order_quantity > 25) AND
(order_item_id = i.id) AND (order_item_name = i.name)",

 "OrderItemResults");



@SqlResultSetMapping(name="OrderItemResults",

 entities=\{


@EntityResult(entityClass=com.acme.Order.class, fields=\{

 @FieldResult(name="id", column="order_id"),

 @FieldResult(name="quantity",
column="order_quantity"),

 @FieldResult(name="item.itemPk.id",

 column="order_item_id")}),

 @FieldResult(name="item.itemPk.name",

 column="order_item_name")}),


@EntityResult(entityClass=com.acme.Item.class)

})



The _FieldResult_ elements for the composite
foreign key are combined to form the primary key _EmbeddedId_ class for
the target entity. This may then be used to subsequently retrieve the
entity if the relationship is to be eagerly loaded.

The dot-notation form is not required to be
supported for any usage other than for embeddables, composite foreign
keys, or composite primary keys.

===== Returning Unmanaged Instances

Instances of other classes (including
non-managed entity instances) as well as scalar results can be returned
by a native query. These can be used singly, or in combination,
including with entity results.

====== Scalar Results

Scalar results can be included in the query
result by specifying the _ColumnResult_ annotation element of the
_SqlResultSetMapping_ annotation. The intended type of the result can be
specified using the _type_ element of the _ColumnResult_ annotation.

Query q = em.createNativeQuery(

 "SELECT o.id AS order_id, " +

 "o.quantity AS order_quantity, " +

 "o.item AS order_item, " +

 "i.name AS item_name, " +

 "i.availabilityDate AS item_shipdate " +

 "FROM Order o, Item i " +

 "WHERE (order_quantity > 25) AND (order_item
= i.id)",

 "OrderResults");



@SqlResultSetMapping(name="OrderResults",

 entities=\{


@EntityResult(entityClass=com.acme.Order.class, fields=\{

 @FieldResult(name="id", column="order_id"),

 @FieldResult(name="quantity",
column="order_quantity"),

 @FieldResult(name="item",
column="order_item")})},

 columns=\{

 @ColumnResult(name="item_name"),

 @ColumnResult(name="item_shipdate",

 type=java.util.Date.class)}

 )



====== Constructor Results

The mapping to constructors is specified
using the _ConstructorResult_ annotation element of the
_SqlResultSetMapping_ annotation. The _targetClass_ element of the
_ConstructorResult_ annotation specifies the class whose constructor
corresponds to the specified columns. All columns corresponding to
arguments of the intended constructor must be specified using the
_columns_ element of the _ConstructorResult_ annotation in the same
order as that of the argument list of the constructor. Any entities
returned as constructor results will be in either the new or the
detached state, depending on whether a primary key is retrieved for the
constructed object.

 _Example:_

Query q = em.createNativeQuery(

 "SELECT c.id, c.name, COUNT(o) as
orderCount, AVG(o.price) AS avgOrder " +

 "FROM Customer c, Orders o " +

 "WHERE o.cid = c.id " +

 "GROUP BY c.id, c.name",

 "CustomerDetailsResult");



@SqlResultSetMapping(name="CustomerDetailsResult",

 classes=\{


@ConstructorResult(targetClass=com.acme.CustomerDetails.class,

 columns=\{

 @ColumnResult(name="id"),

 @ColumnResult(name="name"),

 @ColumnResult(name="orderCount"),

 @ColumnResult(name="avgOrder",
type=Double.class)})

})



===== Combinations of Result Types

When a _SqlResultSetMapping_ specifies more
than one mapping type (i.e., more than one of _EntityResult_ ,
_ConstructorResult_ , _ColumnResult_ ), then for each row in the SQL
result, the query execution will result in an _Object[]_ instance whose
elements are as follows, in order: any entity results (in the order in
which they are defined in the _entities_ element); any instances of
classes corresponding to constructor results (in the order defined in
the _classes_ element); and any instances corresponding to column
results (in the order defined in the _columns_ element). If there are
any columns whose result mappings have not been specified, they are
ignored.

===== Restrictions

When an entity is being returned, the SQL
statement should select all of the columns that are mapped to the entity
object. This should include foreign key columns to related entities. The
results obtained when insufficient data is available are undefined. A
SQL result set mapping must not be used to map results to the
non-persistent state of an entity.

The use of named parameters is not defined
for native SQL queries. Only positional parameter binding for SQL
queries may be used by portable applications.

==== Stored Procedures

The _StoredProcedureQuery_ interface supports
the use of database stored procedures.

Stored procedures can be specified either by
means of the _NamedStoredProcedureQuery_ annotation or dynamically.
Annotations for the specification of stored procedures are described in
section link:Per.html#a13759[See NamedStoredProcedureQuery
Annotation].

===== Named Stored Procedure Queries

Unlike in the case of a named native query,
the _NamedStoredProcedureQuery_ annotation names a stored procedure that
exists in the database rather than providing a stored procedure
definition. The _NamedStoredProcedureQuery_ annotation specifies the
types of all parameters to the stored procedure, their corresponding
parameter modes (IN, OUT, INOUT, REF_CURSORlink:#a19593[57]), and
how result sets, if any, are to be mapped. The name that is assigned to
the stored procedure in the _NamedStoredProcedureQuery_ annotation is
passed as an argument to the _createNamedStoredProcedureQuery_ method to
create an executable _StoredProcedureQuery_ object.

A stored procedure may return more than one
result set. As with native queries, the mapping of result sets can be
specified either in terms of a _resultClasses_ or as a
_resultSetMappings_ annotation element. If there are multiple result
sets, it is assumed that they will be mapped using the same mechanism —
e.g., all via a set of result class mappings or all via a set of result
set mappings. The order of the specification of these mappings must be
the same as the order in which the result sets will be returned by the
stored procedure invocation. If the stored procedure returns one or more
result sets and no _resultClasses_ or _resultSetMappings_ element has
been specified, any result set will be returned as a list of type
_Object[]_ . The combining of different strategies for the mapping of
stored procedure result sets is undefined.

 _StoredProcedureParameter_ metadata needs to
be provided for all parameters. Parameters must be specified in the
order in which they occur in the parameter list of the stored procedure.
If parameter names are used, the parameter name is used to bind the
parameter value and to extract the output value (if the parameter is an
INOUT or OUT parameter). If parameter names are not specified, it is
assumed that positional parameters are used. The mixing of named and
positional parameters is undefined.

===== Dynamically-specified Stored Procedure Queries

If the stored procedure is not defined using
metadata, parameter and result set information must be provided
dynamically.

All parameters of a dynamically-specified
stored procedure query must be registered using the
_registerStoredProcedureParameter_ method of the _StoredProcedureQuery_
interface.

Result set mapping information can be
provided by means of the _createStoredProcedureQuery_ method.

===== [[a4625]]Stored Procedure Query Execution

Stored procedure query execution can be
controlled as described below.

The _setParameter_ methods are used to set
the values of all required IN and INOUT parameters. It is not required
to set the values of stored procedure parameters for which default
values have been defined by the stored procedure.

When _getResultList_ and _getSingleResult_
are called on a _StoredProcedureQuery_ object, the persistence provider
will call _execute_ on an unexecuted stored procedure query before
processing _getResultList_ or _getSingleResult_ .

When _executeUpdate_ is called on a
_StoredProcedureQuery_ object, the persistence provider will call
_execute_ on an unexecuted stored procedure query followed by
_getUpdateCount_ . The results of _executeUpdate_ will be those of
_getUpdateCount_ .

The _execute_ method supports both the simple
case where scalar results are passed back only via INOUT and OUT
parameters as well as the most general case (multiple result sets and/or
update counts, possibly also in combination with output parameter
values).

The _execute_ method returns _true_ if the
first result is a result set, and _false_ if it is an update count or
there are no results other than through INOUT and OUT parameters, if
any.

If the _execute_ method returns _true_ , the
pending result set can be obtained by calling _getResultList_ or
_getSingleResult_ . The _hasMoreResults_ method can then be used to test
for further results.

If _execute_ or _hasMoreResults_ returns
_false_ , the _getUpdateCount_ method can be called to obtain the
pending result if it is an update count. The _getUpdateCount_ method
will return either the update count (zero or greater) or -1 if there is
no update count (i.e., either the next result is a result set or there
is no next update count).

For portability, results that correspond to
JDBC result sets and update counts need to be processed before the
values of any INOUT or OUT parameters are extracted.

After results returned through
_getResultList_ and _getUpdateCount_ have been exhausted, results
returned through INOUT and OUT parameters can be retrieved.

The _getOutputParameterValue_ methods are
used to retrieve the values passed back from the procedure through INOUT
and OUT parameters.

When using _REF_CURSOR_ parameters for result
sets, the update counts should be exhausted before calling
_getResultList_ to retrieve the result set. Alternatively, the
_REF_CURSOR_ result set can be retrieved through
_getOutputParameterValue_ . Result set mappings will be applied to
results corresponding to _REF_CURSOR_ parameters in the order the
_REF_CURSOR_ parameters were registered with the query.

In the simplest case, where results are
returned only via INOUT and OUT parameters, _execute_ can be followed
immediately by calls to _getOutputParameterValue_ .

=== [[a4639]]Summary of Exceptions

image:Per-4.png[image]

The following is a summary of the exceptions
defined by this specification:

 _PersistenceException_

The _PersistenceException_ is thrown by the
persistence provider when a problem occurs. It may be thrown to report
that the invoked operation could not complete because of an unexpected
error (e.g., failure of the persistence provider to open a database
connection).

All other exceptions defined by this
specification are subclasses of the _PersistenceException_ . All
instances of _PersistenceException_ except for instances of
_NoResultException_ , _NonUniqueResultException,_ _LockTimeoutException_
, and _QueryTimeoutException_ will cause the current transaction, if one
is active and the persistence context has been joined to it, to be
marked for rollback.

 _TransactionRequiredException_

The _TransactionRequiredException_ is thrown
by the persistence provider when a transaction is required but is not
active.

 _OptimisticLockException_

The _OptimisticLockException_ is thrown by
the persistence provider when an optimistic locking conflict occurs.
This exception may be thrown as part of an API call, at flush, or at
commit time. The current transaction, if one is active, will be marked
for rollback.

 _PessimisticLockException_

The _PessimisticLockException_ is thrown by
the persistence provider when a pessimistic locking conflict occurs. The
current transaction will be marked for rollback. Typically the
_PessimisticLockException_ occurs because the database transaction has
been rolled back due to deadlock or because the database uses
transaction-level rollback when a pessimistic lock cannot be granted.

 _LockTimeoutException_

The _LockTimeoutException_ is thrown by the
persistence provider when a pessimistic locking conflict occurs that
does not result in transaction rollback. Typically this occurs because
the database uses statement-level rollback when a pessimistic lock
cannot be granted (and there is no deadlock). The _LockTimeoutException_
does not cause the current transaction to be marked for rollback.

 _RollbackException_

The _RollbackException_ is thrown by the
persistence provider when _EntityTransaction.commit_ fails. __

 _EntityExistsException_

The _EntityExistsException_ may thrown by the
persistence provider when the _persist_ operation is invoked and the
entity already exists. The _EntityExistsException_ may be thrown when
the persist operation is invoked, or the _EntityExistsException_ or
another _PersistenceException_ may be thrown at commit time. The current
transaction, if one is active and the persistence context has been
joined to it, will be marked for rollback.

 _EntityNotFoundException_

The _EntityNotFoundException_ is thrown by
the persistence provider when an entity reference obtained by
_getReference_ is accessed but the entity does not exist. It is thrown
by the _refresh_ operation when the entity no longer exists in the
database. It is also thrown by the _lock_ operation when pessimistic
locking is used and the entity no longer exists in the database. The
current transaction, if one is active and the persistence context has
been joined to it, will be marked for rollback.

 _NoResultException_

The _NoResultException_ is thrown by the
persistence provider when _Query.getSingleResult_ or
_TypedQuery.getSingleResult_ is invoked and there is no result to
return. This exception will not cause the current transaction, if one is
active, to be marked for rollback.

 _NonUniqueResultException_

The _NonUniqueResultException_ is thrown by
the persistence provider when _Query.getSingleResult_ or
_TypedQuery.getSingleResult_ is invoked and there is more than one
result from the query. This exception will not cause the current
transaction, if one is active, to be marked for rollback.

 _QueryTimeoutException_

The _QueryTimeoutException_ is thrown by the
persistence provider when a query times out and only the statement is
rolled back. The _QueryTimeoutException_ does not cause the current
transaction, if one is active, to be marked for rollback.



== [[a4665]]Query Language

The Java Persistence query language is a
string-based query language used to define queries over entities and
their persistent state. It enables the application developer to specify
the semantics of queries in a portable way, independent of the
particular database schema in use in an enterprise environment. The full
range of the language may be used in both static and dynamic queries.

This chapter provides the full definition of
the Java Persistence query language.

=== Overview

image:Per-4.png[image]

The Java Persistence query language is a
query specification language for string-based dynamic queries and static
queries expressed through metadata. It is used to define queries over
the persistent entities defined by this specification and their
persistent state and relationships.

The Java Persistence query language can be
compiled to a target language, such as SQL, of a database or other
persistent store. This allows the execution of queries to be shifted to
the native language facilities provided by the database, instead of
requiring queries to be executed on the runtime representation of the
entity state. As a result, query methods can be optimizable as well as
portable.

The query language uses the abstract
persistence schema of entities, including their embedded objects and
relationships, for its data model, and it defines operators and
expressions based on this data model. It uses a SQL-like syntax to
select objects or values based on abstract schema types and
relationships. It is possible to parse and validate queries before
entities are deployed.

The term abstract persistence schema refers
to the persistent schema abstraction (persistent entities, their state,
and their relationships) over which Java Persistence queries operate.
Queries over this persistent schema abstraction are translated into
queries that are executed over the database schema to which entities are
mapped.

Queries may be defined in metadata
annotations or the XML descriptor. The abstract schema types of a set of
entities can be used in a query if the entities are defined in the same
persistence unit as the query. Path expressions allow for navigation
over relationships defined in the persistence unit.

A persistence unit defines the set of all
classes that are related or grouped by the application and which must be
colocated in their mapping to a single database.

=== Statement Types

image:Per-4.png[image]

A Java Persistence query language statement
may be either a select statement, an update statement, or a delete
statement.

This chapter refers to all such statements as
“queries”. Where it is important to distinguish among statement types,
the specific statement type is referenced.

In BNF syntax, a query language statement is
defined as:

QL_statement :: = select_statement |
update_statement | delete_statement

Any Java Persistence query language statement
may be constructed dynamically or may be statically defined in a
metadata annotation or XML descriptor element.

All statement types may have parameters.

==== Select Statements

A select statement is a string which consists
of the following clauses:

a SELECT clause, which determines the type of
the objects or values to be selected.

a FROM clause, which provides declarations
that designate the domain to which the expressions specified in the
other clauses of the query apply.

an optional WHERE clause, which may be used
to restrict the results that are returned by the query.

an optional GROUP BY clause, which allows
query results to be aggregated in terms of groups.

an optional HAVING clause, which allows
filtering over aggregated groups.

an optional ORDER BY clause, which may be
used to order the results that are returned by the query.

In BNF syntax, a select statement is defined
as:

{empty}select_statement :: = select_clause
from_clause [where_clause] [groupby_clause]

{empty} [having_clause] [orderby_clause]

A select statement must always have a SELECT
and a FROM clause. The square brackets [] indicate that the other
clauses are optional.

==== Update and Delete Statements

Update and delete statements provide bulk
operations over sets of entities.

In BNF syntax, these operations are defined
as:

{empty}update_statement :: = update_clause
[where_clause]



{empty}delete_statement :: = delete_clause
[where_clause]

The update and delete clauses determine the
type of the entities to be updated or deleted. The WHERE clause may be
used to restrict the scope of the update or delete operation.

Update and delete statements are described
further in link:Per.html#a5636[See Bulk Update and Delete
Operations].

=== Abstract Schema Types and Query Domains

image:Per-4.png[image]

The Java Persistence query language is a
typed language, and every expression has a type. The type of an
expression is derived from the structure of the expression, the abstract
schema types of the identification variable declarations, the types to
which the persistent attributes evaluate, and the types of literals.

The abstract schema type of an entity or
embeddable is derived from its class and the metadata information
provided by Java language annotations or in the XML descriptor.

Informally, the abstract schema type of an
entity or embeddable can be characterized as follows:

 _For every non-relationship persistent field
or get accessor method (for a persistent property) of the class, there
is a field (“state field”) whose abstract schema type corresponds to
that of the field or the result type of the accessor method._

 _For every persistent relationship field or
get accessor method (for a persistent relationship property) of the
class, there is a field (“association field”) whose type is the abstract
schema type of the related entity (or, if the relationship is a
one-to-many or many-to-many, a collection of such)._

Abstract schema types are specific to the
query language data model. The persistence provider is not required to
implement or otherwise materialize an abstract schema type.

The domain of a query consists of the
abstract schema types of all entities and embeddables that are defined
in the same persistence unit.

The domain of a query may be restricted by
the _navigability_ of the relationships of the entity and associated
embeddable classes on which it is based. The association fields of an
entity’s or embeddable’s abstract schema type determine navigability.
Using the association fields and their values, a query can select
related entities and use their abstract schema types in the query.

==== Naming

Entities are designated in query strings by
their entity names. The entity name is defined by the _name_ element of
the _Entity_ annotation (or the _entity-name_ XML descriptor element),
and defaults to the unqualified name of the entity class. Entity names
are scoped within the persistence unit and must be unique within the
persistence unit.

==== [[a4713]]Example

This example assumes that the application
developer provides several entity classes, representing orders,
products, and line items, and an embeddable address class representing
shipping addresses and billing addresses. The abstract schema types for
the entities are _Order_ , _Product_ , and _LineItem_ respectively.
There is a one-to-many relationship between _Order_ and _LineItem_ . The
entity _LineItem_ is related to _Product_ in a many-to-one relationship.
The classes are logically in the same persistence unit, as shown in
link:Per.html#a4724[See Abstract Persistence Schema of Several
Entities with Defined in the Same Persistence Unit.].

Queries to select orders can be defined by
navigating over the association fields and state fields defined by
_Order_ and _LineItem_ . A query to find all orders with pending line
items might be written as follows:

 SELECT DISTINCT o

 _FROM Order AS o JOIN o.lineItems AS l_

 _WHERE l.shipped = FALSE_









===

image:Per-5.png[image]

[[a4724]]Abstract Persistence Schema of Several Entities with
Defined in the Same Persistence Unit.

image:Per-6.png[image]

This query navigates over the association
field _lineItems_ of the abstract schema type _Order_ to find line
items, and uses the state field _shipped_ of _LineItem_ to select those
orders that have at least one line item that has not yet shipped. (Note
that this query does not select orders that have no line items.)

{empty}Although reserved identifiers, such as
DISTINCT, FROM, AS, JOIN, WHERE, and FALSE appear in upper case in this
example, reserved identifiers are case
insensitive.link:#a19594[58]

The SELECT clause of this example designates
the return type of this query to be of type Order.

Because the same persistence unit defines the
abstract persistence schema of the related entities, the developer can
also specify a query over orders that utilizes the abstract schema type
for products, and hence the state fields and association fields of both
the abstract schema types _Order_ and _Product_ . For example, if the
abstract schema type _Product_ has a state field named _productType_ , a
query over orders can be specified using this state field. Such a query
might be to find all orders for products with product type office
supplies. A query for this might be as follows.

 SELECT DISTINCT o

 FROM Order o JOIN o.lineItems l JOIN
l.product p

 WHERE p.productType = _‘_ office_supplies’

Because _Order_ is related to _Product_ by
means of the relationships between _Order_ and _LineItem_ and between
_LineItem_ and _Product_ , navigation using the association fields
_lineItems_ and _product_ is used to express the query. This query is
specified by using the entity name _Order_ , which designates the
abstract schema type over which the query ranges. The basis for the
navigation is provided by the association fields _lineItems_ and
_product_ of the abstract schema types Order and LineItem respectively.

=== The FROM Clause and Navigational Declarations

image:Per-4.png[image]

The FROM clause of a query defines the domain
of the query by declaring identification
variables. An identification variable is an identifier declared in the
FROM clause of a query. The domain of the
query may be constrained by path expressions. (See section
link:Per.html#a4792[See Path Expressions].)

Identification variables designate instances
of a particular abstract schema type. The FROM clause can contain
multiple identification variable declarations separated by a comma ( _,_
).

from_clause ::=

 _FROM_ identification_variable_declaration

 \{, \{identification_variable_declaration |
collection_member_declaration}}*

identification_variable_declaration ::=
range_variable_declaration \{ join | fetch_join }*

range_variable_declaration ::= entity_name [
_AS_ ] identification_variable

join ::= join_spec
join_association_path_expression [AS] identification_variable

{empty} _[join_condition_ ]

fetch_join ::= join_spec _FETCH_
join_association_path_expression

join_association_path_expression ::=

 join_collection_valued_path_expression |

 join_single_valued_path_expression |

 _TREAT(_
join_collection_valued_path_expression _AS_ subtype _)_ |

 _TREAT(_ join_single_valued_path_expression
_AS_ subtype _)_

join_collection_valued_path_expression::=

 identification_variable _._
_\{single_valued_embeddable_object_field_ _._ _}*_
collection_valued_field

join_single_valued_path_expression::=

 identification_variable _._
_\{single_valued_embeddable_object_field_ _._ _}*_
single_valued_object_field

join_spec ::= [ _LEFT_ [ _OUTER_ ] __ |
_INNER_ ] _JOIN_

join_condition ::= _ON_
conditional_expression

collection_member_declaration ::=

 _IN (_ collection_valued_path_expression _)_
[AS] identification_variable

The following subsections discuss the
constructs used in the FROM clause.

==== [[a4760]]Identifiers

An identifier is a character sequence of
unlimited length. The character sequence must begin with a Java
identifier start character, and all other characters must be Java
identifier part characters. An identifier start character is any
character for which the method _Character.isJavaIdentifierStart_ returns
true. This includes the underscore ( ___ ) character and the dollar sign
( _$_ ) character. An identifier part character is any character for
which the method _Character.isJavaIdentifierPart_ returns true. The
question mark ( _?_ ) character is reserved for use by the Java
Persistence query language.

The following are reserved identifiers: ABS,
ALL, AND, ANY, AS, ASC, AVG, BETWEEN, BIT_LENGTHlink:#a19595[59],
BOTH, BY, CASE, CHAR_LENGTH, CHARACTER_LENGTH, CLASS, COALESCE, CONCAT,
COUNT, CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, DELETE, DESC,
DISTINCT, ELSE, EMPTY, END, ENTRY, ESCAPE, EXISTS, FALSE, FETCH, FROM,
FUNCTION, GROUP, HAVING, IN, INDEX, INNER, IS, JOIN, KEY, LEADING, LEFT,
LENGTH, LIKE, LOCATE, LOWER, MAX, MEMBER, MIN, MOD, NEW, NOT, NULL,
NULLIF, OBJECT, OF, ON, OR, ORDER, OUTER, POSITION, SELECT, SET, SIZE,
SOME, SQRT, SUBSTRING, SUM, THEN, TRAILING, TREAT, TRIM, TRUE, TYPE,
UNKNOWN, UPDATE, UPPER, VALUE, WHEN, WHERE.

Reserved identifiers are case insensitive.
Reserved identifiers must not be used as identification variables or
result variables (see section link:Per.html#a5438[See SELECT
Clause]).

It is recommended that SQL key words other
than those listed above not be used as identification variables in
queries because they may be used as reserved identifiers in future
releases of this specification.

==== [[a4765]]Identification Variables

An identification
variable is a valid identifier declared in the FROM clause of a query.

All identification variables must be declared
in the FROM clause. Identification variables cannot be declared in other
clauses.

An identification variable must not be a
reserved identifier or have the same name as any entity in the same
persistence unit.

Identification variables are case
insensitive.

An identification variable evaluates to a
value of the type of the expression used in declaring the variable. For
example, consider the previous query:

SELECT DISTINCT o

FROM Order o JOIN o.lineItems l JOIN
l.product p

WHERE p.productType = ‘office_supplies’

In the FROM clause declaration _o.lineItems_
_l_ , the identification variable _l_ evaluates to any LineItem value
directly reachable from Order. The association field _lineItems_ is a
collection of instances of the abstract schema type LineItem and the
identification variable _l_ refers to an element of this collection. The
type of _l_ is the abstract schema type of _LineItem_ .

An identification variable can range over an
entity, embeddable, or basic abstract schema type. An identification
variable designates an instance of an abstract schema type or an element
of a collection of abstract schema type instances.

Note that for identification variables
referring to an instance of an association or collection represented as
a _java.util.Map_ , the identification variable is of the abstract
schema type of the map _value_ .

An identification variable always designates
a reference to a single value. It is declared in one of three ways: in a
range variable declaration, in a join clause, or in a collection member
declaration. The identification variable declarations are evaluated from
left to right in the FROM clause, and an identification variable
declaration can use the result of a preceding identification variable
declaration of the query string.

All identification variables used in the
SELECT, WHERE, ORDER BY, GROUP BY, or HAVING clause of a SELECT or
DELETE statement must be declared in the FROM clause. The identification
variables used in the WHERE clause of an UPDATE statement must be
declared in the UPDATE clause.

Identification variables are existentially
quantified in these clauses. This means that an identification variable
represents a member of a collection or an instance of an entity’s
abstract schema type. An identification variable never designates a
collection in its entirety.

An identification variable is scoped to the
query (or subquery) in which it is defined and is also visible to any
subqueries within that query scope that do not define an identification
variable of the same name.

==== Range Variable Declarations

{empty}The syntax for declaring an
identification variable as a range variable is similar to that of SQL;
optionally, it uses the AS keyword. A range variable designates an
entity abstract schema type.link:#a19596[60]

range_variable_declaration ::= entity_name [
_AS_ ] identification_variable

Range variable declarations allow the
developer to designate a “root” for objects which may not be reachable
by navigation.

In order to select values by comparing more
than one instance of an entity abstract schema type, more than one
identification variable ranging over the abstract schema type is needed
in the FROM clause.

The following query returns orders whose
quantity is greater than the order quantity for John Smith. This example
illustrates the use of two different identification variables in the
FROM clause, both of the abstract schema type Order. The SELECT clause
of this query determines that it is the orders with quantities larger
than John Smith’s that are returned.

SELECT DISTINCT o1

FROM Order o1, Order o2

WHERE o1.quantity > o2.quantity AND

 o2.customer.lastname = ‘Smith’ AND

 o2.customer.firstname= ‘John’

==== [[a4792]]Path Expressions

An identification variable followed by the
navigation operator ( _._ ) and a state field or association field is a
path expression. The type of the path expression is the type computed as
the result of navigation; that is, the type of the state field or
association field to which the expression navigates. The type of a path
expression that navigates to an association field may be specified as a
subtype of the declared type of the association field by means of the
TREAT operator. See section link:Per.html#a4965[See
Downcasting].

{empty}An identification variable qualified
by the KEY, VALUE, or ENTRY operator is a path expression. The KEY,
VALUE, and ENTRY operators may only be applied to identification
variables that correspond to map-valued associations or map-valued
element collections. The type of the path expression is the type
computed as the result of the operation; that is, the abstract schema
type of the field that is the value of the KEY, VALUE, or ENTRY operator
(the map key, map value, or map entry
respectively).link:#a19597[61]

In the following query, photos is a map from
photo label to filename.

SELECT i.name, VALUE(p)

FROM Item i JOIN i.photos p

WHERE KEY(p) LIKE ‘%egret’

In the above query the identification
variable _p_ designates an abstract schema type corresponding to the map
_value_ . The results of _VALUE(p)_ and _KEY(p)_ are the map value and
the map key associated with _p_ , respectively. The following query is
equivalent:

SELECT i.name, p

FROM Item i JOIN i.photos p

WHERE KEY(p) LIKE ‘%egret’

A path expression using the KEY or VALUE
operator can be further composed. A path expression using the ENTRY
operator is terminal. It cannot be further composed and can only appear
in the SELECT list of a query.

The syntax for qualified identification
variables is as follows.

qualified_identification_variable :: =

 map_field_identification_variable |

 _ENTRY(_ identification_variable _)_



map_field_identification_variable :: =

 _KEY(_ identification_variable _)_ |

 _VALUE(_ identification_variable _)_

Depending on navigability, a path expression
that leads to an association field or to a field whose type is an
embeddable class may be further composed. Path expressions can be
composed from other path expressions if the original path expression
evaluates to a single-valued type (not a collection).

In the following example, _contactInfo_
denotes an embeddable class consisting of an address and set of phones.
_Phone_ is an entity.

SELECT p.vendor

FROM Employee e JOIN e.contactInfo.phones p

WHERE e.contactInfo.address.zipcode = '95054'

Path expression navigability is composed
using “inner join” semantics. That is, if the value of a non-terminal
field in the path expression is null, the path is considered to have no
value, and does not participate in the determination of the result.

The following query is equivalent to the
query above:

SELECT p.vendor

FROM Employee e JOIN e.contactInfo c JOIN
c.phones p

WHERE e.contactInfo.address.zipcode = '95054'

===== Path Expression Syntax

The syntax for single-valued path expressions
and collection-valued path expressions is as follows.

An identification variable used in a
_single_valued_object_path_expression_ or in a
_collection_valued_path_expression_ may be an unqualified identification
variable or an identification variable to which the KEY or VALUE
function has been applied.

general_identification_variable ::=

 identification_variable |

 map_field_identification_variable

The type of an entity-valued path expression
or an entity-valued subpath of a path expression used in a WHERE clause
may be specified as a subtype of the corresponding declared type by
means of the TREAT operator. See section link:Per.html#a4965[See
Downcasting].

general_subpath ::= simple_subpath |
treated_subpath\{ _._ single_valued_object_field}*



simple_subpath ::=

 general_identification_variable |

 general_identification_variable\{ _._
single_valued_object_field}*



treated_subpath ::= _TREAT(_ general_subpath
_AS_ subtype _)_



single_valued_path_expression ::=

 qualified_identification_variable |

 _TREAT(_ qualified_identification_variable
_AS_ subtype _)_ |

 state_field_path_expression |

 single_valued_object_path_expression



state_field_path_expression ::=
general_subpath.state_field





state_valued_path_expression ::=

 state_field_path_expression |
general_identification_variable



single_valued_object_path_expression ::=
general_subpath _._ single_valued_object_field



collection_valued_path_expression ::=
general_subpath _._ collection_valued_field

A _single_valued_object_field_
 is designated by the name of an association
field in a one-to-one or many-to-one relationship or a field of
embeddable class type. The type of a _single_valued_object_field_
 is the abstract schema type of the related
entity or embeddable class.

A _state _field_ is designated by the name of
an entity or embeddable class state field that corresponds to a basic
type.

A _collection_valued_field_
 is designated by the name of an association
field in a one-to-many or a many-to-many relationship or by the name of
an element collection field. The type of a _collection_valued_field_ is
a collection of values of the abstract schema type of the related entity
or element type.

It is syntactically illegal to compose a path
expression from a path expression that evaluates to a collection. For
example, if o designates Order, the path expression o.lineItems.product
is illegal since navigation to _lineItems_ results in a collection. This
case should produce an error when the query string is verified. To
handle such a navigation, an identification variable must be declared in
the FROM clause to range over the elements of the _lineItems_
collection. Another path expression must be used to navigate over each
such element in the WHERE clause of the query, as in the following:

SELECT DISTINCT l.product

FROM Order AS o JOIN o.lineItems l



It is illegal to use a
_collection_valued_path_expression_ other than in the FROM clause of a
query except in an _empty_collection_comparison_expression,_ in a
_collection_member_expression_ , or as an argument to the SIZE operator.
See Sections link:Per.html#a5139[See Empty Collection Comparison
Expressions], link:Per.html#a5150[See Collection Member
Expressions], and link:Per.html#a5284[See Arithmetic Functions].

==== Joins

An inner join may be implicitly specified by
the use of a cartesian product in the FROM clause and a join condition
in the WHERE clause. In the absence of a join condition, this reduces to
the cartesian product.

The main use case for this generalized style
of join is when a join condition does not involve a foreign key
relationship that is mapped to an entity relationship.

Example:

SELECT c FROM Customer c, Employee e WHERE
c.hatsize = e.shoesize

In general, use of this style of inner join
(also referred to as theta-join) is less typical than explicitly defined
joins over relationships.

The syntax for explicit join operations is as
follows:

{empty}join::= join_spec
join_association_path_expression [AS] identification_variable
[join_condition]

fetch_join ::= join_spec _FETCH_
join_association_path_expression

join_association_path_expression ::=

 join_collection_valued_path_expression |

 join_single_valued_path_expression |

 _TREAT(_
join_collection_valued_path_expression _AS_ subtype _)_ |

 _TREAT(_ join_single_valued_path_expression
_AS_ subtype _)_

join_collection_valued_path_expression::=

 identification_variable _._
_\{single_valued_embeddable_object_field_ _._ _}*_
collection_valued_field

join_single_valued_path_expression::=

 identification_variable _._
_\{single_valued_embeddable_object_field_ _._ _}*_
single_valued_object_field

join_spec::= [ _LEFT_ [ _OUTER_ ] __ |
_INNER_ ] _JOIN_

join_condition ::= _ON_
conditional_expression

The inner and outer join operation types
described in sections link:Per.html#a4884[See Inner Joins
(Relationship Joins)], link:Per.html#a4898[See Left Outer
Joins], and link:Per.html#a4931[See Fetch Joins] are supported.

===== [[a4884]]Inner Joins (Relationship Joins)

The syntax for the inner join operation is

{empty}[ _INNER_ ] _JOIN_
join_association_path_expression [AS] identification_variable
[join_condition]

For example, the query below joins over the
relationship between customers and orders. This type of join typically
equates to a join over a foreign key relationship in the database.

SELECT c FROM Customer c JOIN c.orders o
WHERE c.status = 1

The keyword INNER may optionally be used:

SELECT c FROM Customer c INNER JOIN c.orders
o WHERE c.status = 1

This is equivalent to the following query
using the earlier IN construct, defined in
link:Per.html#a19497[See Enterprise JavaBeans, v. 2.1.
http://jcp.org/en/jsr/detail?id=153.]. It selects those customers of
status 1 for which at least one order exists:

SELECT OBJECT(c) FROM Customer c,
IN(c.orders) o WHERE c.status = 1

The query below joins over _Employee_ ,
_ContactInfo_ and _Phone_ . _ContactInfo_ is an embeddable class that
consists of an address and set of phones. _Phone_ is an entity.

SELECT p.vendor

FROM Employee e JOIN e.contactInfo c JOIN
c.phones p

WHERE c.address.zipcode = '95054'

A join condition may be specified for an
inner join. This is equivalent to specification of the same condition in
the WHERE clause.

===== [[a4898]]Left Outer Joins

LEFT JOIN and LEFT OUTER JOIN are synonymous.
They enable the retrieval of a set of entities where matching values in
the join condition may be absent.

The syntax for a left outer join is

 _LEFT_ [ _OUTER_ ] _JOIN_
join_association_path_expression [AS] identification_variable

{empty} [join_condition]

An outer join without a specified join
condition has an implicit join condition over the foreign key
relationship corresponding to the join_association_path_expression. It
would typically be mapped to a SQL outer join with an ON condition on
the foreign key relationship as in the queries below:

Java Persistence query language:

SELECT s.name, COUNT(p)

FROM Suppliers s LEFT JOIN s.products p

GROUP BY s.name

SQL:

SELECT s.name, COUNT(p.id)

FROM Suppliers s LEFT JOIN Products p

 ON s.id = p.supplierId

GROUP By s.name

An outer join with an explicit ON condition
would cause an additional specified join condition to be added to the
generated SQL:

Java Persistence query language:

SELECT s.name, COUNT(p)

FROM Suppliers s LEFT JOIN s.products p

 ON p.status = 'inStock'

GROUP BY s.name

SQL:

SELECT s.name, COUNT(p.id)

FROM Suppliers s LEFT JOIN Products p

 ON s.id = p.supplierId AND p.status =
'inStock'

GROUP BY s.name

Note that the result of this query will be
different from that of the following query:

SELECT s.name, COUNT(p)

FROM Suppliers s LEFT JOIN s.products p

WHERE p.status = 'inStock'

GROUP BY s.name

The result of the latter query will exclude
suppliers who have no products in stock whereas the former query will
include them.

An important use case for LEFT JOIN is in
enabling the prefetching of related data items as a side effect of a
query. This is accomplished by specifying the LEFT JOIN as a FETCH JOIN
as described below.

===== [[a4931]]Fetch Joins

A FETCH JOIN enables the fetching of an
association or element collection as a side effect of the execution of a
query.

The syntax for a fetch join is

fetch_join ::= [ _LEFT_ [ _OUTER_ ] __ |
_INNER_ ] _JOIN FETCH_ join_association_path_expression

The association referenced by the right side
of the FETCH JOIN clause must be an association or element collection
that is referenced from an entity or embeddable that is returned as a
result of the query. It is not permitted to specify an identification
variable for the objects referenced by the right side of the FETCH JOIN
clause, and hence references to the implicitly fetched entities or
elements cannot appear elsewhere in the query.

The following query returns a set of
departments. As a side effect, the associated employees for those
departments are also retrieved, even though they are not part of the
explicit query result. The initialization of the persistent state or
relationship fields or properties of the objects that are retrieved as a
result of a fetch join is determined by the metadata for that class—in
this example, the _Employee_ entity class.

SELECT d

FROM Department d LEFT JOIN FETCH d.employees

WHERE d.deptno = 1

A fetch join has the same join semantics as
the corresponding inner or outer join, except that the related objects
specified on the right-hand side of the join operation are not returned
in the query result or otherwise referenced in the query. Hence, for
example, if department 1 has five employees, the above query returns
five references to the department 1 entity.

The FETCH JOIN construct must not be used in
the FROM clause of a subquery.

==== Collection Member Declarations

An identification variable declared by a
collection_member_declaration ranges over values of a collection
obtained by navigation using a path expression.

An identification variable of a collection
member declaration is declared using a special operator, the reserved
identifier IN. The argument to the IN operator is a collection-valued
path expression. The path expression evaluates to a collection type
specified as a result of navigation to a collection-valued association
field of an entity or embeddable class abstract schema type.

The syntax for declaring a collection member
identification variable is as follows:

collection_member_declaration ::=

 _IN (_ collection_valued_path_expression _)_
[AS] identification_variable

For example, the query

SELECT DISTINCT o

FROM Order o JOIN o.lineItems l

WHERE l.product.productType =
‘office_supplies’

can equivalently be expressed as follows,
using the IN operator:

SELECT DISTINCT o

FROM Order o, IN(o.lineItems) l

WHERE l.product.productType =
‘office_supplies’

In this example, lineItems is the name of an
association field whose value is a collection of instances of the
abstract schema type LineItem. The identification variable _l_
designates a member of this collection, a single LineItem abstract
schema type instance. In this example, _o_ is an identification variable
of the abstract schema type Order.

==== [[a4957]]FROM Clause and SQL

The Java Persistence query language treats
the FROM clause similarly to SQL in that the declared identification
variables affect the results of the query even if they are not used in
the WHERE clause. Application developers should use caution in defining
identification variables because the domain of the query can depend on
whether there are any values of the declared type.

For example, the FROM clause below defines a
query over all orders that have line items and existing products. If
there are no _Product_ instances in the database, the domain of the
query is empty and no order is selected.

SELECT o

FROM Order AS o JOIN o.lineItems l JOIN
l.product p

==== Polymorphism

Java Persistence queries are automatically
polymorphic. The FROM clause of a query designates not only instances of
the specific entity class(es) to which it explicitly refers but
instances of subclasses of those classes as well. The instances returned
by a query thus include instances of the subclasses that satisfy the
query criteria.

Non-polymorphic queries or queries whose
polymorphism is restricted can be specified using entity type
expressions in the WHERE clause to restrict the domain of the query. See
section link:Per.html#a5381[See Entity Type Expressions].

==== [[a4965]]Downcasting

The use of the TREAT operator is supported
for downcasting within path expressions in the FROM and WHERE clauses.
Use of the TREAT operator allows access to subclass-specific state.

If during query execution the first argument
to the TREAT operator is not a subtype (proper or improper) of the
target type, the path is considered to have no value, and does not
participate in the determination of the result. That is, in the case of
a join, the referenced object does not participate in the result, and in
the case of a restriction, the associated predicate is false. Use of the
TREAT operator therefore also has the effect of filtering on the
specified type (and its subtypes) as well as performing the downcast. If
the target type is not a subtype (proper or improper) of the static type
of the first argument, the query is invalid.

Examples:

SELECT b.name, b.ISBN

FROM Order o JOIN TREAT(o.product AS Book) b



SELECT e FROM Employee e JOIN
TREAT(e.projects AS LargeProject) lp

WHERE lp.budget > 1000



SELECT e FROM Employee e JOIN e.projects p

WHERE TREAT(p AS LargeProject).budget > 1000

 OR

 TREAT(p AS SmallProject).name LIKE
'Persist%'

 OR

 p.description LIKE "cost overrun"



SELECT e FROM Employee e

WHERE TREAT(e AS Exempt).vacationDays > 10

 OR TREAT(e AS Contractor).hours > 100

=== [[a4985]]WHERE Clause

image:Per-4.png[image]

The WHERE clause of a query consists of a
conditional expression used to select objects or values that satisfy the
expression. The WHERE clause restricts the result of a select statement
or the scope of an update or delete operation.

A WHERE clause is defined as follows:

where_clause ::= _WHERE_
conditional_expression



The GROUP BY construct enables the
aggregation of values according to the properties of an entity class.
The HAVING construct enables conditions to be specified that further
restrict the query result as restrictions upon the groups.

The syntax of the HAVING clause is as
follows:

having_clause ::= _HAVING_
conditional_expression

The GROUP BY and HAVING constructs are
further discussed in Section link:Per.html#a5410[See GROUP BY,
HAVING].

=== [[a4994]]Conditional Expressions

image:Per-4.png[image]

The following sections describe language
constructs that can be used in a conditional expression of the WHERE
clause, the HAVING clause, or in an ON condition.

State fields that are mapped in serialized
form or as lobs cannot be portably used in conditional
expressionslink:#a19598[62].

==== Literals

A string literal is enclosed in single
quotes—for example: ‘literal’. A string literal that includes a single
quote is represented by two single quotes—for example: ‘literal’’s’.
String literals in queries, like Java _String_ literals, use unicode
character encoding. The use of Java escape notation is not supported in
query string literals.

Exact numeric literals support the use of
Java integer literal syntax as well as SQL exact numeric literal syntax.

Approximate literals support the use Java
floating point literal syntax as well as SQL approximate numeric literal
syntax.

Appropriate suffixes can be used to indicate
the specific type of a numeric literal in accordance with the Java
Language Specification. Support for the use of hexadecimal and octal
numeric literals is not required by this specification.

Enum literals support the use of Java enum
literal syntax. The fully qualified enum class name must be specified.

The JDBC escape syntax may be used for the
specification of date, time, and timestamp literals. For example:

 SELECT o

 FROM Customer c JOIN c.orders o

 WHERE c.name = 'Smith'

 AND o.submissionDate < \{d '2008-12-31'}

The portability of this syntax for date,
time, and timestamp literals is dependent upon the JDBC driver in use.
Persistence providers are not required to translate from this syntax
into the native syntax of the database or driver.

The boolean
literals are _TRUE_ and _FALSE_ .

Entity type literals are specified by entity
names—for example: _Customer_ .

Although reserved literals appear in upper
case, they are case insensitive.

==== Identification Variables

All identification variables used in the
WHERE or HAVING clause of a SELECT or DELETE statement must be declared
in the FROM clause, as described in link:Per.html#a4765[See
Identification Variables]. The identification variables used in the
WHERE clause of an UPDATE statement must be declared in the UPDATE
clause.

Identification variables are existentially
quantified in the WHERE and HAVING clause.
This means that an identification variable represents a member of a
collection or an instance of an entity’s abstract schema type. An
identification variable never designates a collection in its entirety.

==== Path Expressions

It is illegal to use a
_collection_valued_path_expression_ within a WHERE or HAVING clause as
part of a conditional expression except in an
_empty_collection_comparison_expression,_ in a
_collection_member_expression_ , or as an argument to the SIZE operator.

==== Input Parameters

Either positional or named parameters may be
used. Positional and named parameters must not be mixed in a single
query.

Input parameters can only be used in the
WHERE clause or HAVING clause of a query or
as the new value for an update item in the SET clause of an update
statement.

Note that if an input parameter value is
null, comparison operations or arithmetic operations involving the input
parameter will return an unknown value. See
link:Per.html#a5676[See Null Values].

All input parameters must be single-valued,
except in IN expressions (see section link:Per.html#a5107[See In
Expressions]), which support the use of collection-valued input
parameters.

The API for the binding of query parameters
is described in Chapter link:Per.html#a1060[See Entity
Operations].

===== Positional Parameters

The following rules apply to positional
parameters.

Input parameters are designated by the
question mark ( _?_ ) prefix followed by an integer. For example: _?1_ .

Input parameters are numbered starting from
1.

The same parameter can be used more than once
in the query string.

The ordering of the use of parameters within
the query string need not conform to the order of the positional
parameters.

===== Named Parameters

A named parameter is denoted by an identifier
that is prefixed by the ":" symbol. It follows the rules for identifiers
defined in Section link:Per.html#a4760[See Identifiers]. Named
parameters are case sensitive.

Example:

SELECT c

FROM Customer c

WHERE c.status = :stat

The same named parameter can be used more
than once in the query string.

==== Conditional Expression Composition

Conditional expressions are composed of other
conditional expressions, comparison operations, logical operations, path
expressions that evaluate to boolean values, boolean literals, and
boolean input parameters.

The scalar expressions described in section
link:Per.html#a5243[See Scalar Expressions] can be used in
conditional expressions.

Aggregate functions can only be used in
conditional expressions in a HAVING clause. See section
link:Per.html#a5410[See GROUP BY, HAVING].

Standard bracketing _()_ for ordering
expression evaluation is supported.

Conditional expressions are defined as
follows:

conditional_expression ::= conditional_term |
conditional_expression _OR_ conditional_term +
conditional_term ::= conditional_factor | conditional_term _AND_
conditional_factor +
conditional_factor ::= [ _NOT_ ] conditional_primary +
conditional_primary ::= simple_cond_expression | _(_
conditional_expression _)_ +
simple_cond_expression ::=

 comparison_expression |

 between_expression |

 in_expression |

 like_expression |

 null_comparison_expression |

 empty_collection_comparison_expression |

 collection_member_expression |

 exists_expression

==== Operators and Operator Precedence

The operators are listed below in order of
decreasing precedence.

Navigation operator ( _._ )

Arithmetic operators:

+, - unary

*, / multiplication and division

+, - addition and subtraction

Comparison operators : _=_ , _>_ , _>=_ , _<_
, _<=_ , _<>_ (not equal), _[NOT]_ _BETWEEN_ , _[NOT]_ _LIKE_ , _[NOT]_
_IN_ , _IS_ _[NOT]_ _NULL_ , _IS_ _[NOT]_ _EMPTY_ , _[NOT]_ _MEMBER_
_[OF]_ , _[NOT]_ _EXISTS_

Logical operators:

 _NOT_

 _AND_

 _OR_

The following sections describe operators
used in specific expressions.

==== [[a5066]]Comparison Expressions

The syntax for the use of comparison
expressions in a conditional expression is as
followslink:#a19599[63]:

comparison_expression ::=

 string_expression comparison_operator
\{string_expression | all_or_any_expression} |

 boolean_expression \{ _=_ | _<>_ }
\{boolean_expression | all_or_any_expression} |

 enum_expression \{ _=_ | _<>_ }
\{enum_expression | all_or_any_expression} |

 datetime_expression comparison_operator

 \{datetime_expression |
all_or_any_expression} |

 entity_expression \{ _=_ | _<>_ }
\{entity_expression | all_or_any_expression} |

 arithmetic_expression comparison_operator

 \{arithmetic_expression |
all_or_any_expression} |

 entity_type_expression \{ _=_ | _<>_ }
entity_type_expression}



comparison_operator ::= _=_ | _>_ | _>=_ |
_<_ | _<=_ | _<>_

Examples:

item.cost * 1.08 <= 100.00



CONCAT(person.lastName, ‘, ’,
person.firstName)) = ‘Jones, Sam’



TYPE(e) = ExemptEmployee

[discrete]
=== Between __ Expressions

The syntax for the use of the
comparison operator [NOT] BETWEEN in a
conditional expression is as follows:

 __

 __

 _between_expression ::=_

 _arithmetic_expression_ [ _NOT_ ] _BETWEEN_
_arithmetic_expression_ _AND_ _arithmetic_expression |_

 string_expression [ _NOT_ ] _BETWEEN_
_string_expression_ _AND_ _string_expression |_

 datetime_expression [ _NOT_ ] _BETWEEN_
_datetime_expression_ _AND_ _datetime_expression_

The BETWEEN expression

x BETWEEN y AND z

is semantically equivalent to:

y <= x AND x <= z

The rules for unknown and NULL values in
comparison operations apply. See link:Per.html#a5676[See Null
Values].

Examples:

 _p.age BETWEEN 15 and 19_ is equivalent to
_p.age >= 15 AND p.age <= 19_

 _p.age NOT BETWEEN 15 and 19_ is equivalent
to _p.age < 15 OR p.age > 19_

In the following example,
_transactionHistory_ is a list of credit card transactions defined using
an order column.

SELECT t

FROM CreditCard c JOIN c.transactionHistory t

WHERE c.holder.name = ‘John Doe’ AND INDEX(t)
BETWEEN 0 AND 9

==== [[a5107]]In Expressions

The syntax for the use of the comparison
operator [NOT] IN in a conditional expression is as follows:

 _in_expression ::=_

 _\{_ state_valued_path_expression |
type_discriminator} [ _NOT_ ] _IN_

 _\{_ _(_ _in_item_ \{ _,_ _in_item}*_ _)_
_|_ _(_ _subquery_ _)_ _| collection_valued_input_parameter }_

 _in_item ::= literal |
single_valued_input_parameter_

The state_valued_path_expression __ must have
a string, numeric, date, time, timestamp, or enum value.

The literal and/or input parameter values
must be _like_ the same abstract schema type of the
_state_valued_path_expression_ in type. (See
link:Per.html#a5735[See Equality and Comparison Semantics]).

The results of the subquery must be _like_
the same abstract schema type of the state_valued_path_expression in
type. Subqueries are discussed in Section
link:Per.html#a5196[See Subqueries].

Examples:

 _o.country IN (’UK’, ’US’, ’France’)_ is
true for _UK_ and false for _Peru_ , and is equivalent to the expression
_(o.country = ’UK’) OR (o.country = ’US’) OR (o.country = ’ France’)_ .

 _o.country NOT IN (’UK’, ’US’, ’France’)_ is
false for _UK_ and true for _Peru_ , and is equivalent to the expression
_NOT ((o.country = ’UK’) OR (o.country = ’US’) OR (o.country =
’France’))_ .

There must be at least one element in the
comma separated list that defines the set of values for the _IN_
expression.

If the value of a
state_valued_path_expression or _in_item_ in an IN or NOT IN expression
is _NULL_ or unknown, the value of the expression is unknown.

Note that use of a collection-valued input
parameter will mean that a static query cannot be precompiled.

[discrete]
=== Like __ Expressions

The syntax for the use of the comparison
operator [NOT] LIKE in a conditional expression is as follows:

 _like_expression ::=_

{empty} _string_expression_ [ _NOT_ ] _LIKE_
_pattern_value_ [ _ESCAPE_ _escape_character_ ]

The _string_expression_ must have a string
value. The _pattern_value_ is a string literal or a string-valued input
parameter in which an underscore ( ___ ) stands for any single
character, a percent ( _%_ ) character stands for any sequence of
characters (including the empty sequence), and all other characters
stand for themselves. The optional _escape_character_ __ is a
single-character string literal or a character-valued input parameter
(i.e., _char_ or _Character_ ) and is used to escape the special meaning
of the underscore and percent characters in _pattern_value_
_.link:#a19600[64]_

Examples:

 _address.phone LIKE ‘12%3’_ is true for
‘123’ ‘12993’ and false for ‘1234’

 _asentence.word LIKE ‘l_se’_ is true for
‘lose’ and false for ‘loose’

 _aword.underscored LIKE ‘\_%’ ESCAPE ‘\’_ is
true for ‘_foo’ and false for ‘bar’

 _address.phone NOT LIKE ‘12%3’_ is false for
‘123’ and ‘12993’ and true for ‘1234’

If the value of the _string_expression_ or
_pattern_value_ is _NULL_ or unknown, the value of the LIKE expression
is unknown. If the _escape_character_ is specified and is _NULL_ , the
value of the LIKE expression is unknown.

==== Null Comparison Expressions

The syntax for the use of the comparison
operator IS NULL in a conditional expression is as follows:

 _null_comparison_expression ::=_

 \{single_valued_path_expression |
input_parameter } _IS_ [ _NOT_ ] _NULL_ __

A null comparison expression tests whether or
not the single-valued path expression or input parameter is a _NULL_
value.

Null comparisons over instances of embeddable
class types are not supported. Support for comparisons over embeddables
may be added in a future release of this specification.

==== [[a5139]]Empty Collection Comparison Expressions

The syntax for the use of the comparison
operator IS EMPTY in an _empty_collection_comparison_expression_ is as
follows:

 _empty_collection_comparison_expression ::=_

 collection_valued_path_expression _IS_ [
_NOT_ ] _EMPTY_

This expression tests whether or not the
collection designated by the collection-valued path expression is empty
(i.e, has no elements).

Example:



SELECT o

FROM Order o

WHERE o.lineItems IS EMPTY

If the value of the collection-valued path
expression in an empty collection comparison expression is unknown, the
value of the empty comparison expression is unknown.

==== [[a5150]]Collection Member Expressions

The syntax for the use of the comparison
operator MEMBER OFlink:#a19601[65] in an
_collection_member_expression_ is as follows:

 _collection_member_expression ::=_

 entity_or_value_expression _[NOT] MEMBER
[OF]_ collection_valued_path_expression

entity_or_value_expression ::=

 single_valued_object_path_expression |

 state_valued_path_expression |

 simple_entity_or_value_expression

simple_entity_or_value_expression ::=

 identification_variable |

 input_parameter |

 literal

This expression tests whether the designated
value is a member of the collection specified by the collection-valued
path expression.

Expressions that evaluate to embeddable types
are not supported in collection member expressions. Support for use of
embeddables in collection member expressions may be added in a future
release of this specification.

If the collection valued path expression
designates an empty collection, the value of the MEMBER OF expression is
FALSE and the value of the NOT MEMBER OF expression is TRUE. Otherwise,
if the value of the _collection_valued_path_expression_
 or _entity_or_value_expression_ in the
collection member expression is _NULL_ or unknown, the value of the
collection member expression is unknown.

Example:

SELECT p

FROM Person p

WHERE 'Joe' MEMBER OF p.nicknames

==== Exists Expressions

An EXISTS expression is a predicate that is
true only if the result of the subquery consists of one or more values
and that is false otherwise.

The syntax of an exists expression is

exists_expression::= [ _NOT_ ] _EXISTS_ _(_
subquery _)_

Example:

SELECT DISTINCT emp

FROM Employee emp

WHERE EXISTS (

 SELECT spouseEmp

 FROM Employee spouseEmp

 WHERE spouseEmp = emp.spouse)

The result of this query consists of all
employees whose spouses are also employees.

==== All or Any Expressions

An ALL conditional expression is a predicate
over a subquery that is true if the comparison operation is true for all
values in the result of the subquery or the result of the subquery is
empty. An ALL conditional expression is false if the result of the
comparison is false for at least one value of the result of the
subquery, and is unknown if neither true nor false.

An ANY conditional expression is a predicate
over a subquery that is true if the comparison operation is true for
some value in the result of the subquery. An ANY conditional expression
is false if the result of the subquery is empty or if the comparison
operation is false for every value in the result of the subquery, and is
unknown if neither true nor false. The keyword SOME is synonymous with
ANY.

The comparison operators used with ALL or ANY
conditional expressions are =, <, <=, >, >=, <>. The result of the
subquery must be like that of the other argument to the comparison
operator in type. See link:Per.html#a5735[See Equality and
Comparison Semantics].

The syntax of an ALL or ANY expression is
specified as follows:

all_or_any_expression ::= \{ _ALL_ | _ANY_ |
_SOME_ } _(_ subquery _)_

Example:

SELECT emp

FROM Employee emp

WHERE emp.salary > ALL (

 SELECT m.salary

 FROM Manager m

 WHERE m.department = emp.department)

The result of this query consists of all
employees whose salaries exceed the salaries of all managers in their
department.

==== [[a5196]]Subqueries

{empty}Subqueries may be used in the WHERE or
HAVING clause.link:#a19602[66]

The syntax for subqueries is as follows:

{empty}subquery ::= simple_select_clause
subquery_from_clause [where_clause]

{empty} [groupby_clause] [having_clause]

simple_select_clause ::= _SELECT_ [
_DISTINCT_ ] simple_select_expression

subquery_from_clause ::=

 _FROM_
subselect_identification_variable_declaration

 \{ _,_
subselect_identification_variable_declaration |

 collection_member_declaration }*

subselect_identification_variable_declaration
::=

 identification_variable_declaration |

 derived_path_expression [ _AS_ ]
identification_variable \{join}* |

 derived_collection_member_declaration

simple_select_expression::=

 single_valued_path_expression |

 scalar_expression |

 aggregate_expression |

 identification_variable

derived_path_expression ::=

 general_derived_path _._
single_valued_object_field |

 general_derived_path _._
collection_valued_field

general_derived_path ::=

 simple_derived_path |

 treated_derived_path\{ _._
single_valued_object_field}*

simple_derived_path ::=
superquery_identification_variable\{ _._ single_valued_object_field}*

treated_derived_path ::= _TREAT(_
general_derived_path _AS_ subtype _)_

derived_collection_member_declaration ::=

 _IN_
superquery_identification_variable.\{single_valued_object_field.}*collection_valued_field

Examples:

SELECT DISTINCT emp

FROM Employee emp

WHERE EXISTS (

 SELECT spouseEmp

 FROM Employee spouseEmp

 WHERE spouseEmp = emp.spouse)

Note that some contexts in which a subquery
can be used require that the subquery be a scalar subquery (i.e.,
produce a single result). This is illustrated in the following examples
using numeric comparisons.

SELECT c

FROM Customer c

WHERE (SELECT AVG(o.price) FROM c.orders o) >
100

 __

 _SELECT goodCustomer_

 _FROM Customer goodCustomer_

 _WHERE goodCustomer.balanceOwed < (_

 _SELECT AVG(c.balanceOwed)/2.0 FROM Customer
c)_





==== [[a5243]]Scalar Expressions

Numeric, string, datetime, case, and entity
type expressions result in scalar values.

Scalar expressions may be used in the SELECT
clause of a query as well as in the WHERElink:#a19603[67] and
HAVING clauses.

scalar_expression::=

 arithmetic_expression |

 string_expression |

 enum_expression |

 datetime_expression |

 boolean_expression |

 case_expression |

 entity_type_expression

===== Arithmetic Expressions

The arithmetic operators are:

+, - unary

*, / multiplication and division

+, - addition and subtraction

Arithmetic operations use numeric promotion.

Arithmetic functions are described in section
link:Per.html#a5284[See Arithmetic Functions].

===== Built-in String, Arithmetic, and Datetime Functional Expressions

The Java Persistence query language includes
the built-in functions described in subsections
link:Per.html#a5264[See String Functions],
link:Per.html#a5284[See Arithmetic Functions],
link:Per.html#a5304[See Datetime Functions], which may be used
in the SELECT, WHERE or HAVING clause of a query. The invocation of
predefined database functions and user-defined database functions is
described in section link:Per.html#a5311[See Invocation of
Predefined and User-defined Database Functions].

If the value of any argument to a functional
expression is null or unknown, the value of the functional expression is
unknown.

====== [[a5264]]String Functions



functions_returning_strings ::=

 _CONCAT(_ string_expression _,_
string_expression \{ _,_ string_expression}* _)_ |

 _SUBSTRING(_ string_expression _,_

 arithmetic_expression [ _,_
arithmetic_expression] _) |_

 _TRIM(_ [[trim_specification]
[trim_character] _FROM_ ] string_expression _)_ |

 _LOWER(_ string_expression _)_ |

 _UPPER(_ string_expression _)_

trim_specification ::= _LEADING | TRAILING |
BOTH_



functions_returning_numerics::=

 _LENGTH(_ string_expression _)_ |

 _LOCATE(_ string_expression _,_
string_expression[ _,_ arithmetic_expression] _)_

The CONCAT function returns a string that is
a concatenation of its arguments.

The second and third arguments of the
SUBSTRING function denote the starting position and length of the
substring to be returned. These arguments are integers. The third
argument is optional. If it is not specified, the substring from the
start position to the end of the string is returned. The first position
of a string is denoted by 1. The SUBSTRING function returns a string.

The TRIM function trims the specified
character from a string. If the character to be trimmed is not
specified, it will be assumed to be space (or blank). The optional
_trim_character_ __ is a single-character string literal or a
character-valued input parameter (i.e., _char_ or _Character_
)link:#a19604[68]. If a trim specification is not provided, it
defaults to BOTH. The TRIM function returns the trimmed string.

The LOWER and UPPER functions convert a
string to lower and upper case, respectively, with regard to the locale
of the database. They return a string.

{empty}The LOCATE function returns the
position of a given string within a string, starting the search at a
specified position. It returns the first position at which the string
was found as an integer. The first argument is the string to be located;
the second argument is the string to be searched; the optional third
argument is an integer that represents the string position at which the
search is started (by default, the beginning of the string to be
searched). The first position in a string is denoted by 1. If the string
is not found, 0 is returned.link:#a19605[69]

The LENGTH function returns the length of the
string in characters as an integer.

====== [[a5284]]Arithmetic Functions



functions_returning_numerics::=

 _ABS(_ arithmetic_expression _)_ _|_

 _SQRT(_ arithmetic_expression _)_ |

 _MOD(_ arithmetic_expression _,_
arithmetic_expression _)_ _|_

 _SIZE(_ collection_valued_path_expression
_)_ _|_

 _INDEX(_ identification_variable _)_

The ABS function takes a numeric argument and
returns a number (integer, float, or double) of the same type as the
argument to the function.

The SQRT function takes a numeric argument
and returns a double.

The MOD function takes two integer arguments
and returns an integer.

Numeric arguments to these functions may
correspond to the numeric Java object types as well as the primitive
numeric types.

The SIZE function returns an integer value,
the number of elements of the collection. If the collection is empty,
the SIZE function evaluates to zero.

The INDEX function returns an integer value
corresponding to the position of its argument in an ordered list. The
INDEX function can only be applied to identification variables denoting
types for which an order column has been specified.

In the following example, _studentWaitlist_
is a list of students for which an order column has been specified:

SELECT w.name

FROM Course c JOIN c.studentWaitlist w

WHERE c.name = ‘Calculus’

AND INDEX(w) = 0



====== [[a5304]]Datetime Functions



functions_returning_datetime:=

 _CURRENT_DATE_ |

 _CURRENT_TIME_ |

 _CURRENT_TIMESTAMP_

The datetime functions return the value of
current date, time, and timestamp on the database server.

===== [[a5311]]Invocation of Predefined and User-defined Database Functions

The invocation of functions other than the
built-in functions of the Java Persistence query language is supported
by means of the _function_invocation_ syntax. This includes the
invocation of predefined database functions and user-defined database
functions.

function_invocation::= _FUNCTION(_
function_name \{ _,_ function_arg}* _)_



function_arg ::=

 literal |

 state_valued_path_expression |

 input_parameter |

 scalar_expression

The _function_name_ argument is a string that
denotes the database function that is to be invoked. The arguments must
be suitable for the database function that is to be invoked. The result
of the function must be suitable for the invocation context.

The function may be a database-defined
function or a user-defined function. The function may be a scalar
function or an aggregate function.

Applications that use the
_function_invocation_ syntax will not be portable across databases.

Example:

SELECT c

FROM Customer c

WHERE FUNCTION(‘hasGoodCredit’, c.balance,
c.creditLimit)

===== Case Expressions

{empty}The following forms of case
expressions are supported: general case expressions, simple case
expressions, coalesce expressions, and nullif
expressions.link:#a19606[70]

case_expression::=

 general_case_expression |

 simple_case_expression |

 coalesce_expression |

 nullif_expression



general_case_expression::=

 _CASE_ when_clause \{when_clause}* _ELSE_
scalar_expression _END_

when_clause::= _WHEN_ conditional_expression
_THEN_ scalar_expression



simple_case_expression::=

 _CASE_ case_operand simple_when_clause
\{simple_when_clause}*

 _ELSE_ scalar_expression

 _END_

case_operand::= state_valued_path_expression
| type_discriminator

simple_when_clause::= _WHEN_
scalar_expression _THEN_ scalar_expression



coalesce_expression::= _COALESCE(_
scalar_expression \{ _,_ scalar_expression}+ _)_



nullif_expression::= _NULLIF(_
scalar_expression _,_ scalar_expression _)_

Examples:

UPDATE Employee e

SET e.salary =

 CASE WHEN e.rating = 1 THEN e.salary * 1.1

 WHEN e.rating = 2 THEN e.salary * 1.05

 ELSE e.salary * 1.01

 END



UPDATE Employee e

SET e.salary =

 CASE e.rating WHEN 1 THEN e.salary * 1.1

 WHEN 2 THEN e.salary * 1.05

 ELSE e.salary * 1.01

 END



SELECT e.name,

 CASE TYPE(e) WHEN Exempt THEN 'Exempt'

 WHEN Contractor THEN 'Contractor'

 WHEN Intern THEN 'Intern'

 ELSE 'NonExempt'

 END

FROM Employee e

WHERE e.dept.name = 'Engineering'



SELECT e.name,

 f.name,

 CONCAT(CASE WHEN f.annualMiles > 50000 THEN
'Platinum '

 WHEN f.annualMiles > 25000 THEN 'Gold '

 ELSE ''

 END,

 'Frequent Flyer')

FROM Employee e JOIN e.frequentFlierPlan f

===== [[a5381]]Entity Type Expressions

An entity type expression can be used to
restrict query polymorphism. The TYPE operator returns the exact type of
the argument.

The syntax of an entity type expression is as
follows:

entity_type_expression ::=

 _type_discriminator_ |

 entity_type_literal |

 input_parameter

type_discriminator ::=

 _TYPE(_ general_identification_variable |

 single_valued_object_path_expression |

 input_parameter _)_

An entity_type_literal is designated by the
entity name.

The Java class of the entity is used as an
input parameter to specify the entity type.

Examples:

SELECT e

FROM Employee e

WHERE TYPE(e) IN (Exempt, Contractor)



SELECT e

FROM Employee e

WHERE TYPE(e) IN (:empType1, :empType2)



SELECT e

FROM Employee e

WHERE TYPE(e) IN :empTypes



SELECT TYPE(e)

FROM Employee e

WHERE TYPE(e) <> Exempt

=== [[a5410]]GROUP BY, HAVING

image:Per-4.png[image]

The GROUP BY construct enables the
aggregation of result values according to a set of properties. The
HAVING construct enables conditions to be specified that further
restrict the query result. Such conditions are restrictions upon the
groups.

The syntax of the GROUP BY and HAVING clauses
is as follows:

groupby_clause ::= _GROUP BY_ groupby_item \{
_,_ groupby_item}*

groupby_item ::=
single_valued_path_expression | identification_variable



having_clause ::= _HAVING_
conditional_expression

If a query contains both a WHERE clause and a
GROUP BY clause, the effect is that of first applying the where clause,
and then forming the groups and filtering them according to the HAVING
clause. The HAVING clause causes those groups to be retained that
satisfy the condition of the HAVING clause.

The requirements for the SELECT clause when
GROUP BY is used follow those of SQL: namely, any item that appears in
the SELECT clause (other than as an aggregate function or as an argument
to an aggregate function) must also appear in the GROUP BY clause. In
forming the groups, null values are treated as the same for grouping
purposes.

Grouping by an entity is permitted. In this
case, the entity must contain no serialized state fields or lob-valued
state fields that are eagerly fetched. Grouping by an entity that
contains serialized state fields or lob-valued state fields is not
portable, since the implementation is permitted to eagerly fetch fields
or properties that have been specified as LAZY.

Grouping by embeddables is not supported.

The HAVING clause is used to filter over the
groups, and can contain aggregate functions over attributes included in
the groups and/or functions or other query language operators over the
attributes that are used for grouping. It is not required that an
aggregate function used in the HAVING clause also be used in the SELECT
clause.

If there is no GROUP BY clause and the HAVING
clause is used, the result is treated as a single group, and the select
list can only consist of aggregate functions. The use of HAVING in the
absence of GROUP BY is not required to be supported by an implementation
of this specification. Portable applications should not rely on HAVING
without the use of GROUP BY.

Examples:

SELECT c.status, AVG(c.filledOrderCount),
COUNT(c)

FROM Customer c

GROUP BY c.status

HAVING c.status IN (1, 2)



SELECT c.country, COUNT(c)

FROM Customer c

GROUP _BY c_ .country

HAVING COUNT(c) > 30



SELECT c, COUNT(o)

FROM Customer c JOIN c.orders o

GROUP BY c

HAVING COUNT(o) >= 5

=== [[a5438]]SELECT Clause

image:Per-4.png[image]

The SELECT clause denotes the query result.
More than one value may be returned from the SELECT clause of a query.

The SELECT clause can contain one or more of
the following elements: an identification variable that ranges over an
abstract schema type, a single-valued path expression, a scalar
expression, an aggregate expression, a constructor expression.

The SELECT clause has the following syntax:

select_clause ::= _SELECT_ [ _DISTINCT_ ]
select_item \{ _,_ select_item}*

{empty}select_item ::= select_expression [ [
_AS_ ] result_variable]

select_expression ::=

 single_valued_path_expression |

 scalar_expression |

 aggregate_expression |

 identification_variable |

 _OBJECT(_ identification_variable _)_ |

 constructor_expression

constructor_expression ::=

 _NEW_ constructor_name _(_ constructor_item
\{ _,_ constructor_item}* _)_

constructor_item ::=

 single_valued_path_expression |

 scalar_expression |

 aggregate_expression |

 identification_variable

aggregate_expression ::=

 \{ _AVG_ | _MAX_ | _MIN_ | _SUM_ _}_ _(_ [
_DISTINCT_ ] state_valued_path_expression _)_ |

 _COUNT (_ [ _DISTINCT_ ]
identification_variable | state_valued_path_expression |

 single_valued_object_path_expression _) |_

 function_invocation

For example:

SELECT c.id, c.status

FROM Customer c JOIN c.orders o

WHERE o.count > 100

In the following example, _videoInventory_ is
a Map from the entity _Movie_ to the number of copies in stock:

SELECT v.location.street, KEY(i).title,
VALUE(i)

FROM VideoStore v JOIN v.videoInventory i

WHERE v.location.zipcode = '94301' AND
VALUE(i) > 0

Note that the SELECT clause must be specified
to return only single-valued expressions. The query below is therefore
not valid:

 _SELECT o.lineItems FROM Order AS o_

The DISTINCT
keyword is used to specify that duplicate values must be eliminated from
the query result.

If DISTINCT is not specified, duplicate
values are not eliminated.

The result of DISTINCT over embeddable
objects or map _entry_ results is undefined.

Standalone identification variables in the
SELECT clause may optionally be qualified by the
OBJECT operator.link:#a19607[71] The
SELECT clause must not use the OBJECT operator to qualify path
expressions.

{empty}A _result_variable_ may be used to
name a _select_item_ in the query result.link:#a19608[72]

For example,

 _SELECT c, COUNT(l) AS itemCount_

 _FROM Customer c JOIN c.Orders o JOIN
o.lineItems l_

 _WHERE c.address.state = ‘CA’_

GROUP BY c

ORDER BY itemCount



==== Result Type of the SELECT Clause

The type of the query result specified by the
SELECT clause of a query is an entity
abstract schema type, a state field type,
the result of a scalar expression, the result of an aggregate function,
the result of a construction operation, or some sequence of these.

The result type of the SELECT clause is
defined by the the result types of the select expressions contained in
it. When multiple select expressions are used in the SELECT clause, the
elements in this result correspond in order to the order of their
specification in the SELECT clause and in type to the result types of
each of the select expressions.

The type of the result of a select_expression
is as follows:

The result type of an identification_variable
is the type of the entity object or embeddable object to which the
identification variable corresponds. The type of an
identification_variable that refers to an entity abstract schema type is
the type of the entity to which that identification variable corresponds
or a subtype as determined by the object/relational mapping.

The result type of a
single_valued_path_expression that is a state_field_path_expression is
the same type as the corresponding state field of the entity or
embeddable class. If the state field of the entity is a primitive type,
the result type is the corresponding object type.

The result type of a
single_valued_path_expression that is a
single_valued_object_path_expression is the type of the entity object or
embeddable object to which the path expression corresponds. A
single_valued_object_path_expression that results in an entity object
will result in an entity of the type of the relationship field or the
subtype of the relationship field of the entity object as determined by
the object/relational mapping.

The result type of a
single_valued_path_expression that is an _identification_variable_ to
which the KEY or VALUE function has been applied is determined by the
type of the map key or value respectively, as defined by the above
rules.

The result type of a
single_valued_path_expression that is an _identification_variable_ to
which the ENTRY function has been applied is _java.util.Map.Entry_ ,
where the key and value types of the map entry are determined by the
above rules as applied to the map key and map value respectively.

The result type of a _scalar_expression_ is
the type of the scalar value to which the expression evaluates. The
result type of a numeric _scalar_expression_ is defined in section
link:Per.html#a5574[See Numeric Expressions in the SELECT
Clause].

The result type of an
_entity_type_expression_ scalar expression is the Java class to which
the resulting abstract schema type corresponds.

The result type of aggregate_expression is
defined in section link:Per.html#a5538[See Aggregate Functions
in the SELECT Clause].

The result type of a constructor_expression
is the type of the class for which the constructor is defined. The types
of the arguments to the constructor are defined by the above rules.

==== [[a5500]]Constructor Expressions in the SELECT Clause

A constructor may be used in the SELECT list
to return an instance of a Java class. The specified class is not
required to be an entity or to be mapped to the database. The
constructor name must be fully qualified.

If an entity class name is specified as the
constructor name in the SELECT NEW clause, the resulting entity
instances will be in either the new or the detached state, depending on
whether a primary key is retrieved for the constructed object.

If a _single_valued_path_expression_ or
_identification_variable_ that is an argument to the constructor
references an entity, the resulting entity instance referenced by that
_single_valued_path_expression_ or _identification_variable_ will be in
the managed state.

For example,

SELECT NEW
com.acme.example.CustomerDetails(c.id, c.status, o.count)

FROM Customer c JOIN c.orders o

WHERE o.count > 100

==== Null Values in the Query Result

If the result of a query corresponds to an
association field or state field whose value is null, that null value is
returned in the result of the query method. The IS NOT NULL construct
can be used to eliminate such null values from the result set of the
query.

Note, however, that state field types defined
in terms of Java numeric primitive types cannot produce NULL values in
the query result. A query that returns such a state field type as a
result type must not return a null value.

==== [[a5511]]Embeddables in the Query Result

If the result of a query corresponds to an
identification variable or state field whose value is an embeddable, the
embeddable instance returned by the query will not be in the managed
state (i.e., it will not be part of the state of any managed entity).

In the following example, the _Address_
instances returned by the query will reference _Phone_ instances. While
the _Phone_ instances will be managed, the _Address_ instances
referenced by the _addr_ result variable will not be. Modifications to
these embeddable instances will have no effect on persistent state.

@Entity

public class Employee \{

 @Id int id;

 Address address;

 ...

}



@Embeddable

public class Address \{

 String street;

 ...

 @OneToOne Phone phone; // fetch=EAGER

}



@Entity

public class Phone \{

 @Id int id;

 ...

 @OneToOne(mappedBy="address.phone") Employee
emp; // fetch=EAGER

}





SELECT e.address AS addr

FROM Employee e

==== [[a5538]]Aggregate Functions in the SELECT Clause

The result of a query may be the result of an
aggregate function applied to a path expression.

The following aggregate functions can be used
in the SELECT clause of a query: AVG, COUNT, MAX, MIN, SUM, aggregate
functions defined in the database.

For all aggregate functions except COUNT, the
path expression that is the argument to the aggregate function must
terminate in a state field. The path expression argument to COUNT may
terminate in either a state field or a association field, or the
argument to COUNT may be an identification variable.

Arguments to the functions SUM and AVG must
be numeric. Arguments to the functions MAX and MIN must correspond to
orderable state field types (i.e., numeric types, string types,
character types, or date types).

The Java type that is contained in the result
of a query using an aggregate function is as follows:

COUNT returns Long.

MAX, MIN return the type of the state field
to which they are applied.

AVG returns Double.

SUM returns Long when applied to state fields
of integral types (other than BigInteger); Double when applied to state
fields of floating point types; BigInteger when applied to state fields
of type BigInteger; and BigDecimal when applied to state fields of type
BigDecimal.

Null values are eliminated before the
aggregate function is applied, regardless of whether the keyword
DISTINCT is specified.

If SUM, AVG, MAX, or MIN is used, and there
are no values to which the aggregate function can be applied, the result
of the aggregate function is NULL.

If COUNT is used, and there are no values to
which COUNT can be applied, the result of the aggregate function is 0.

{empty}The argument to an aggregate function
may be preceded by the keyword DISTINCT to specify that duplicate values
are to be eliminated before the aggregate function is
applied.link:#a19609[73]

The use of DISTINCT with COUNT is not
supported for arguments of embeddable types or map entry types.

The invocation of aggregate database
functions, including user defined functions, is supported by means of
the FUNCTION operator. See section link:Per.html#a5311[See
Invocation of Predefined and User-defined Database Functions].

===== Examples

The following query returns the average order
quantity:

SELECT AVG(o.quantity) FROM Order o

The following query returns the total cost of
the items that John Smith has ordered.

SELECT SUM(l.price)

FROM Order o JOIN o.lineItems l JOIN
o.customer c

WHERE c.lastname = ‘Smith’ AND c.firstname =
‘John’

The following query returns the total number
of orders.

SELECT COUNT(o)

FROM Order o

The following query counts the number of
items in John Smith’s order for which prices have been specified.

SELECT COUNT(l.price)

FROM Order o JOIN o.lineItems l JOIN
o.customer c

WHERE c.lastname = ‘Smith’ AND c.firstname =
‘John’

Note that this is equivalent to:

SELECT COUNT(l)

FROM Order o JOIN o.lineItems l JOIN
o.customer c

WHERE c.lastname = ‘Smith’ AND c.firstname =
‘John’

 AND l.price IS NOT NULL



==== [[a5574]]Numeric Expressions in the SELECT Clause

The type of a numeric expression in the query
result is determined as follows:

An operand that corresponds to a persistent
state field is of the same type as that persistent state field.

An operand that corresponds to one of
arithmetic functions described in section
link:Per.html#a5284[See Arithmetic Functions] is of the type
defined by section link:Per.html#a5284[See Arithmetic
Functions].

An operand that corresponds to one of an
aggregate functions described in section link:Per.html#a5538[See
Aggregate Functions in the SELECT Clause] is of the type defined by
section link:Per.html#a5538[See Aggregate Functions in the
SELECT Clause].

The result of a case expression, coalesce
expression, nullif expression, or arithmetic expression (+, -, *, /) is
determined by applying the following rule to its
operandslink:#a19610[74].

If there is an operand of type Double or
double, the result of the operation is of type Double;

otherwise, if there is an operand of type
Float or float, the result of the operation is of type Float;

otherwise, if there is an operand of type
BigDecimal, the result of the operation is of type BigDecimal;

otherwise, if there is an operand of type
BigInteger, the result of the operation is of type BigInteger, unless
the operator is / (division), in which case the numeric result type is
not further defined;

otherwise, if there is an operand of type
Long or long, the result of the operation is of type Long, unless the
operator is / (division), in which case the numeric result type is not
further defined;

otherwise, if there is an operand of integral
type, the result of the operation is of type Integer, unless the
operator is / (division), in which case the numeric result type is not
further defined.

Users should note that the semantics of the
SQL division operation are not standard across databases. In particular,
when both operands are of integral types, the result of the division
operation will be an integral type in some databases, and an
non-integral type in others. Portable applications should not assume a
particular result type.

=== [[a5587]]ORDER BY Clause

image:Per-4.png[image]

The ORDER BY clause allows the objects or
values that are returned by the query to be ordered.

The syntax of the ORDER BY clause is

orderby_clause ::= _ORDER BY_ orderby_item \{
_,_ orderby_item}*

orderby_item ::=

 \{ state_field_path_expression |
general_identification_variable | result_variable }

{empty} [ _ASC_ | _DESC_ ]

An orderby_item must be one of the following:

A _state_field_path_expression_ that
evaluates to an orderable state field of an entity or embeddable class
abstract schema type designated in the SELECT clause by one of the
following:

a _general_identification_variable_

a _single_valued_object_path_expression_

A _state_field_path_expression_ that
evaluates to the same state field of the same entity or embeddable
abstract schema type as a _state_field_path_expression_ in the SELECT
clause

A general_identification_variable that
evaluates to the same map field of the same entity or embeddable
abstract schema type as a general_identification_variable in the SELECT
clause

A _result_variable_ that refers to an
orderable item in the SELECT clause for which the same _result_variable_
has been specified. This may be the result of an _aggregate_expression_
, a _scalar_expression_ , or a _state_field_path_expression_ in the
SELECT clause.

For example, the four queries below are
legal.

SELECT o

FROM Customer c JOIN c.orders o JOIN
c.address a

WHERE a.state = ‘CA’

ORDER BY o.quantity DESC, o.totalcost



SELECT o.quantity, a.zipcode

FROM Customer c JOIN c.orders o JOIN
c.address a

WHERE a.state = ‘CA’

ORDER BY o.quantity, a.zipcode



SELECT o.quantity, o.cost*1.08 AS taxedCost,
a.zipcode

FROM Customer c JOIN c.orders o JOIN
c.address a

WHERE a.state = ‘CA’ AND a.county = ‘Santa
Clara’

ORDER BY o.quantity, taxedCost, a.zipcode



SELECT AVG(o.quantity) as q, a.zipcode

FROM Customer c JOIN c.orders o JOIN
c.address a

WHERE a.state = ‘CA’

GROUP BY a.zipcode

ORDER BY q DESC

The following two queries are _not_ legal
because the _orderby_item_ is not reflected in the SELECT clause of the
query.

SELECT p.product_name

FROM Order o JOIN o.lineItems l JOIN
l.product p JOIN o.customer c

WHERE c.lastname = ‘Smith’ AND c.firstname =
‘John’

ORDER BY p.price



SELECT p.product_name

FROM Order o, IN(o.lineItems) l JOIN
o.customer c

WHERE c.lastname = ‘Smith’ AND c.firstname =
‘John’

ORDER BY o.quantity

If more than one _orderby_item_ is specified,
the left-to-right sequence of the _orderby_item_ elements determines the
precedence, whereby the leftmost _orderby_item_ has highest precedence.

The keyword ASC specifies that ascending
ordering be used for the associated _orderby_item_ ; the keyword DESC
specifies that descending ordering be used. Ascending ordering is the
default.

SQL rules for the ordering of null values
apply: that is, all null values must appear before all non-null values
in the ordering or all null values must appear after all non-null values
in the ordering, but it is not specified which.

The ordering of the query result is preserved
in the result of the query execution method if the ORDER BY clause is
used.

=== [[a5636]]Bulk Update and Delete Operations

image:Per-4.png[image]

Bulk update and delete operations apply to
entities of a single entity class (together with its subclasses, if
any). Only one entity abstract schema type may be specified in the FROM
or UPDATE clause.

The syntax of these operations is as follows:

{empty}update_statement ::= update_clause
[where_clause]

{empty}update_clause ::= _UPDATE_ entity_name
[[ _AS_ ] identification_variable]

 _SET_ update_item \{ _,_ update_item}*

update_item ::= [identification_variable _._
]\{single_valued_embeddable_object_field _._ }*

 \{state_field | single_valued_object_field}
_=_ new_value

new_value ::=

 scalar_expression |

 simple_entity_expression |

 NULL



{empty}delete_statement ::= delete_clause
[where_clause]

{empty}delete_clause ::= _DELETE_ _FROM_
entity_name [[ _AS_ ] identification_variable]

The syntax of the WHERE clause is described
in Section link:Per.html#a4985[See WHERE Clause].

A delete operation only applies to entities
of the specified class and its subclasses. It does not cascade to
related entities.

The new_value specified for an update
operation must be compatible in type with the field to which it is
assigned.

Bulk update maps directly to a database
update operation, bypassing optimistic locking checks. Portable
applications must manually update the value of the version column, if
desired, and/or manually validate the value of the version column.

The persistence context is not synchronized
with the result of the bulk update or delete.

 _Caution should be used when executing bulk
update or delete operations because they may result in inconsistencies
between the database and the entities in the active persistence context.
In general, bulk update and delete operations should only be performed
within a transaction in a new persistence context or before fetching or
accessing entities whose state might be affected by such operations._

Examples:

DELETE

FROM Customer c

WHERE c.status = ‘inactive’



DELETE

FROM Customer c

WHERE c.status = ‘inactive’

 AND c.orders IS EMPTY



UPDATE Customer c

SET c.status = ‘outstanding’

WHERE c.balance < 10000



UPDATE Employee e

SET e.address.building = 22

WHERE e.address.building = 14

 AND e.address.city = ‘Santa Clara’

 AND e.project = ‘Java EE’

=== [[a5676]]Null Values

image:Per-4.png[image]

When the target of a reference does not exist
in the database, its value is regarded as _NULL_ . SQL _NULL_ semantics
link:Per.html#a19494[See SQL 2003, Part 2, Foundation
(SQL/Foundation). ISO/IEC 9075-2:2003.] defines the evaluation of
conditional expressions containing _NULL_ values.

The following is a brief description of these
semantics:

Comparison or arithmetic operations with a
NULL value always yield an unknown value.

Two NULL values are not considered to be
equal, the comparison yields an unknown value.

Comparison or arithmetic operations with an
unknown value always yield an unknown value.

The IS NULL and IS NOT NULL operators convert
a _NULL_ state field or single-valued object field value into the
respective TRUE or FALSE value.

Boolean operators use three valued logic,
defined by link:Per.html#a5686[See Definition of the AND
Operator], link:Per.html#a5705[See Definition of the OR
Operator], and link:Per.html#a5724[See Definition of the NOT
Operator].



===

image:Per-5.png[image]

Definition of the [[a5686]]AND
Operator

AND

 T

 F

 U

 T

 T

 F

 U

 F

 F

 F

 F

 U

 U

 F

 U



===

image:Per-5.png[image]

Definition of the [[a5705]]OR
Operator

OR

 T

 F

 U

 T

 T

 T

 T

 F

 T

 F

 U

 U

 T

 U

 U



===

image:Per-5.png[image]

Definition of the [[a5724]]NOT
Operator

NOT



 T

 F

 F

 T

 U

 U

Note: The Java Persistence query language
defines the empty string, ‘’, as a string
with 0 length, which is not equal to a NULL value. However, NULL values
and empty strings may not always be distinguished when queries are
mapped to some databases. Application developers should therefore not
rely on the semantics of query comparisons involving the empty string
and NULL value.

=== [[a5735]]Equality and Comparison Semantics

image:Per-4.png[image]

Only the values of _like_ types are permitted
to be compared. A type is _like_ another type if they correspond to the
same Java language type, or if one is a primitive Java language type and
the other is the wrapped Java class type equivalent (e.g., _int_ and
_Integer_ are like types in this sense). There is one exception to this
rule: it is valid to compare numeric values for which the rules of
numeric promotion apply. Conditional expressions attempting to compare
non-like type values are disallowed except for this numeric case.

Note that the arithmetic operators and
comparison operators are permitted to be applied to state fields and
input parameters of the wrapped Java class equivalents to the primitive
numeric Java types.

Two entities of the same abstract schema type
are equal if and only if they have the same primary key value.

Only equality/inequality comparisons over
enums are required to be supported.

Comparisons over instances of embeddable
class or map entry types are not supported.

=== Examples

image:Per-4.png[image]

The following examples illustrate the syntax
and semantics of the Java Persistence query language. These examples are
based on the example presented in link:Per.html#a4713[See
Example].

==== Simple Queries

Find all orders:

SELECT o

FROM Order o

Find all orders that need to be shipped to
California:

SELECT o

FROM Order o

WHERE o.shippingAddress.state = ‘CA’



Find all states for which there are orders:



SELECT DISTINCT o.shippingAddress.state

FROM Order o

==== Queries with Relationships

Find all orders that have line items:

SELECT DISTINCT o

FROM Order o JOIN o.lineItems l

Note that the result of this query does not
include orders with no associated line items. This query can also be
written as:

SELECT o

FROM Order o

WHERE o.lineItems IS NOT EMPTY

Find all orders that have no line items:

SELECT o

FROM Order o

WHERE o.lineItems IS EMPTY

Find all pending orders:

SELECT DISTINCT o

FROM Order o JOIN o.lineItems l

WHERE l.shipped = FALSE

Find all orders in which the shipping address
differs from the billing address. This example assumes that the
application developer uses two distinct _entity_ types to designate
shipping and billing addresses.

SELECT o

FROM Order o

WHERE

NOT (o.shippingAddress.state =
o.billingAddress.state AND

 o.shippingAddress.city =
o.billingAddress.city AND

 o.shippingAddress.street =
o.billingAddress.street)

If the application developer uses a single
_entity_ type in two different relationships for both the shipping
address and the billing address, the above expression can be simplified
based on the equality rules defined in Section
link:Per.html#a5735[See Equality and Comparison Semantics]. The
query can then be written as:

SELECT o

FROM Order o

WHERE o.shippingAddress <> o.billingAddress

The query checks whether the same entity
abstract schema type instance (identified by its primary key) is related
to an order through two distinct relationships.

==== Queries Using Input Parameters

The following query finds the orders for a
product whose name is designated by an input parameter:

SELECT DISTINCT o

FROM Order o JOIN o.lineItems l

WHERE l.product.name = ?1

For this query, the input parameter must be
of the type of the state field name, i.e., a string.

=== BNF

image:Per-4.png[image]

BNF notation summary:

\{ ... } grouping

[ ... ] optional constructs

boldface keywords

* zero or more

+ one or more

| alternates

The following is the BNF for the Java
Persistence query language.

QL_statement ::= select_statement |
update_statement | delete_statement

{empty}select_statement ::= select_clause
from_clause [where_clause] [groupby_clause]

{empty} [having_clause] [orderby_clause]

{empty}update_statement ::= update_clause
[where_clause]

{empty}delete_statement ::= delete_clause
[where_clause]

from_clause ::=

 _FROM_ identification_variable_declaration

 \{, \{identification_variable_declaration |
collection_member_declaration}}*

identification_variable_declaration ::=
range_variable_declaration \{ join | fetch_join }*

range_variable_declaration ::= entity_name [
_AS_ ] identification_variable

join ::= join_spec
join_association_path_expression [AS] identification_variable

{empty} _[join_condition_ ]

fetch_join ::= join_spec _FETCH_
join_association_path_expression

join_spec::= [ _LEFT_ [ _OUTER_ ] __ |
_INNER_ ] _JOIN_

join_condition ::= _ON_
conditional_expression

join_association_path_expression ::=

 join_collection_valued_path_expression |

 join_single_valued_path_expression |

 _TREAT(_
join_collection_valued_path_expression _AS_ subtype _)_ |

 _TREAT(_ join_single_valued_path_expression
_AS_ subtype _)_

join_collection_valued_path_expression::=

 identification_variable _._
_\{single_valued_embeddable_object_field_ _._ _}*_
collection_valued_field

join_single_valued_path_expression::=

 identification_variable _._
_\{single_valued_embeddable_object_field_ _._ _}*_
single_valued_object_field

collection_member_declaration ::=

 _IN (_ collection_valued_path_expression _)_
[AS] identification_variable

qualified_identification_variable :: =

 map_field_identification_variable |

 _ENTRY(_ identification_variable _)_

map_field_identification_variable :: =

 _KEY(_ identification_variable _)_ |

 _VALUE(_ identification_variable _)_

single_valued_path_expression ::=

 qualified_identification_variable |

 _TREAT(_ qualified_identification_variable
_AS_ subtype _)_ |

 state_field_path_expression |

 single_valued_object_path_expression

general_identification_variable ::=

 identification_variable |

 map_field_identification_variable

general_subpath ::= simple_subpath |
treated_subpath\{ _._ single_valued_object_field}*

simple_subpath ::=

 general_identification_variable |

 general_identification_variable\{ _._
single_valued_object_field}*

treated_subpath ::= _TREAT(_ general_subpath
_AS_ subtype _)_

state_field_path_expression ::=
general_subpath _._ state_field

state_valued_path_expression ::=

 state_field_path_expression |
general_identification_variable

single_valued_object_path_expression ::=
general_subpath _._ single_valued_object_field

collection_valued_path_expression ::=
general_subpath.\{collection_valued_field

{empty}update_clause ::= _UPDATE_ entity_name
[[ _AS_ ] identification_variable]

 _SET_ update_item \{ _,_ update_item}*

update_item ::= [identification_variable _._
]\{single_valued_embeddable_object_field _._ }*

 \{state_field | single_valued_object_field}
_=_ new_value

new_value ::=

 scalar_expression |

 simple_entity_expression |

 _NULL_

{empty}delete_clause ::= _DELETE_ _FROM_
entity_name [[ _AS_ ] identification_variable]

select_clause ::= _SELECT_ [ _DISTINCT_ ]
select_item \{ _,_ select_item}*

{empty}select_item ::= select_expression [[
_AS_ ] result_variable]

select_expression ::=

 single_valued_path_expression |

 scalar_expression |

 aggregate_expression |

 identification_variable |

 _OBJECT(_ identification_variable _)_ |

 constructor_expression

constructor_expression ::=

 _NEW_ constructor_name _(_ constructor_item
\{ _,_ constructor_item}* _)_

constructor_item ::=

 single_valued_path_expression |

 scalar_expression |

 aggregate_expression |

 identification_variable

aggregate_expression ::=

 \{ _AVG_ | _MAX_ | _MIN_ | _SUM_ _}_ _(_ [
_DISTINCT_ ] state_valued_path_expression _)_ |

 _COUNT (_ [ _DISTINCT_ ]
identification_variable | state_valued_path_expression |

 single_valued_object_path_expression _) |_

 function_invocation

where_clause ::= _WHERE_
conditional_expression

groupby_clause ::= _GROUP BY_ groupby_item \{
_,_ groupby_item}*

groupby_item ::=
single_valued_path_expression | identification_variable

having_clause ::= _HAVING_
conditional_expression

orderby_clause ::= _ORDER BY_ orderby_item \{
_,_ orderby_item}*

orderby_item ::=

 state_field_path_expression |
general_identification_variable | result_variable

{empty} [ _ASC_ | _DESC_ ]

{empty}subquery ::= simple_select_clause
subquery_from_clause [where_clause]

{empty} [groupby_clause] [having_clause]

subquery_from_clause ::=

 _FROM_
subselect_identification_variable_declaration

 \{ _,_
subselect_identification_variable_declaration |

 collection_member_declaration}*

subselect_identification_variable_declaration
::=

 identification_variable_declaration |

 derived_path_expression [ _AS_ ]
identification_variable \{join}*|

 derived_collection_member_declaration

derived_path_expression ::=

 general_derived_path _._
single_valued_object_field |

 general_derived_path _._
collection_valued_field

general_derived_path ::=

 simple_derived_path |

 treated_derived_path\{ _._
single_valued_object_field}*

simple_derived_path ::=
superquery_identification_variable\{ _._ single_valued_object_field}*

treated_derived_path ::= _TREAT(_
general_derived_path _AS_ subtype _)_

derived_collection_member_declaration ::=

 _IN_
superquery_identification_variable.\{single_valued_object_field.}*collection_valued_field

simple_select_clause ::= _SELECT_ [
_DISTINCT_ ] simple_select_expression

simple_select_expression::=

 single_valued_path_expression |

 scalar_expression |

 aggregate_expression |

 identification_variable

scalar_expression ::=

 arithmetic_expression |

 string_expression |

 enum_expression |

 datetime_expression |

 boolean_expression |

 case_expression |

 entity_type_expression

conditional_expression ::= conditional_term |
conditional_expression _OR_ conditional_term

conditional_term ::= conditional_factor |
conditional_term _AND_ conditional_factor

conditional_factor ::= [ _NOT_ ]
conditional_primary

conditional_primary ::=
simple_cond_expression | _(_ conditional_expression _)_

simple_cond_expression ::=

 comparison_expression |

 between_expression |

 in_expression |

 like_expression |

 null_comparison_expression |

 empty_collection_comparison_expression |

 collection_member_expression |

 exists_expression

 _between_expression ::=_

 _arithmetic_expression_ [ _NOT_ ] _BETWEEN_

 _arithmetic_expression_ _AND_
_arithmetic_expression_ |

 string_expression [ _NOT_ ] _BETWEEN_
string_expression _AND_ string_expression |

 datetime_expression [ _NOT_ ] _BETWEEN_

 datetime_expression _AND_
datetime_expression

 _in_expression ::=_

 _\{_ state_valued_path_expression |
type_discriminator} [ _NOT_ ] _IN_

 _\{_ _(_ _in_item_ \{ _,_ _in_item}*_ _)_
_|_ _(_ _subquery_ _)_ _| collection_valued_input_parameter }_

 _in_item ::= literal |
single_valued_input_parameter_

 _like_expression ::=_

{empty} __ string_expression [ _NOT_ ] _LIKE_
_pattern_value_ [ _ESCAPE_ _escape_character_ ]

null_comparison_expression ::=

 \{single_valued_path_expression |
input_parameter} _IS_ [ _NOT_ ] _NULL_

empty_collection_comparison_expression ::=

 collection_valued_path_expression _IS [NOT]
EMPTY_

collection_member_expression ::=
entity_or_value_expression

 [ _NOT_ ] _MEMBER_ _[_ _OF_ _]_
collection_valued_path_expression

entity_or_value_expression ::=

 single_valued_object_path_expression |

 state_field_path_expression |

 simple_entity_or_value_expression

simple_entity_or_value_expression ::=

 identification_variable |

 input_parameter |

 literal

exists_expression::= [ _NOT_ ] _EXISTS_ _(_
subquery _)_

all_or_any_expression ::= \{ _ALL_ | _ANY_ |
_SOME_ } _(_ subquery _)_

comparison_expression ::=

 string_expression comparison_operator
\{string_expression | all_or_any_expression} |

 boolean_expression \{ _=_ | _<>_ }
\{boolean_expression | all_or_any_expression} |

 enum_expression \{ _=_ | _<>_ }
\{enum_expression | all_or_any_expression} |

 datetime_expression comparison_operator

 \{datetime_expression |
all_or_any_expression} |

 entity_expression \{ _=_ | _<>_ }
\{entity_expression | all_or_any_expression} |

 arithmetic_expression comparison_operator

 \{arithmetic_expression |
all_or_any_expression} |

 entity_type_expression \{ _=_ | _<>_ }
entity_type_expression}

comparison_operator ::= _=_ | _>_ | _>=_ |
_<_ | _<=_ | _<>_

arithmetic_expression ::=

 arithmetic_term | arithmetic_expression \{
_+_ | _-_ } arithmetic_term

arithmetic_term ::= arithmetic_factor |
arithmetic_term \{ _*_ | _/_ } arithmetic_factor

arithmetic_factor ::= [\{ _+_ | _-_ }]
arithmetic_primary

arithmetic_primary ::=

 state_valued_path_expression |

 numeric_literal |

 _(_ arithmetic_expression _)_ |

 input_parameter |

 functions_returning_numerics |

 aggregate_expression |

 case_expression |

 function_invocation |

 _(_ subquery _)_

string_expression ::=

 state_valued_path_expression |

 string_literal |

 input_parameter |

 functions_returning_strings |

 aggregate_expression |

 case_expression |

 function_invocation |

 _(_ subquery _)_

datetime_expression ::=

 state_valued_path_expression |

 input_parameter |

 functions_returning_datetime |

 aggregate_expression |

 case_expression |

 function_invocation |

 date_time_timestamp_literal |

 _(_ subquery _)_

boolean_expression ::=

 state_valued_path_expression |

 boolean_literal |

 input_parameter |

 case_expression |

 function_invocation |

 _(_ subquery _)_

enum_expression ::=

 state_valued_path_expression |

 enum_literal |

 input_parameter |

 case_expression |

 _(_ subquery _)_

entity_expression ::=

 single_valued_object_path_expression |
simple_entity_expression

simple_entity_expression ::=

 identification_variable |

 input_parameter

entity_type_expression ::=

 _type_discriminator |_

 entity_type_literal |

 input_parameter

type_discriminator ::=

 _TYPE(_ general_identification_variable |

 single_valued_object_path_expression |

 input_parameter _)_

functions_returning_numerics::=

 _LENGTH(_ string_expression _)_ |

 _LOCATE(_ string_expression _,_
string_expression[ _,_ arithmetic_expression] _) |_

 _ABS(_ arithmetic_expression _)_ |

 _SQRT(_ arithmetic_expression _) |_

 _MOD(_ arithmetic_expression _,_
arithmetic_expression _) |_

 _SIZE(_ collection_valued_path_expression _)
|_

 _INDEX(_ identification_variable _)_

functions_returning_datetime ::=

 _CURRENT_DATE_ |

 _CURRENT_TIME_ |

 _CURRENT_TIMESTAMP_

functions_returning_strings ::=

 _CONCAT(_ string_expression _,_
string_expression \{ _,_ string_expression}* _)_ |

 _SUBSTRING(_ string_expression _,_
arithmetic_expression [ _,_ arithmetic_expression] _) |_

 _TRIM(_ [[trim_specification]
[trim_character] _FROM_ ] string_expression _)_ |

 _LOWER(_ string_expression _)_ |

 _UPPER(_ string_expression _)_

trim_specification ::= _LEADING | TRAILING |
BOTH_

function_invocation::= _FUNCTION(_
function_name \{ _,_ function_arg}* _)_

function_arg ::=

 literal |

 state_valued_path_expression |

 input_parameter |

 scalar_expression

 _case_expression ::=_

 _general_case_expression |_

 _simple_case_expression |_

 coalesce_expression |

 nullif_expression

general_case_expression::=

 _CASE_ when_clause \{when_clause}* _ELSE_
scalar_expression _END_

when_clause::= _WHEN_ conditional_expression
_THEN_ scalar_expression

simple_case_expression::=

 _CASE_ case_operand simple_when_clause
\{simple_when_clause}*

 _ELSE_ scalar_expression

 _END_

case_operand::= state_valued_path_expression
| type_discriminator

simple_when_clause::= _WHEN_
scalar_expression _THEN_ scalar_expression

coalesce_expression::= _COALESCE(_
scalar_expression \{ _,_ scalar_expression}+ _)_

nullif_expression::= _NULLIF(_
scalar_expression _,_ scalar_expression _)_

== [[a6072]]Metamodel API

This specification provides a set of
interfaces for dynamically accessing the metamodel corresponding to the
managed classes of a persistence unit.

=== Metamodel API Interfaces

image:Per-4.png[image]

The _javax.persistence.metamodel_ interfaces
provide __ for dynamically accessing the metamodel of the persistent
state and relationships of the managed classes of a persistence unit.

The metamodel can be accessed through the
_EntityManagerFactory_ or _EntityManager getMetamodel_ methods.

 _The metamodel API may be extended to cover
object/relational mapping information in a future release of this
specification._



==== Metamodel Interface



package javax.persistence.metamodel;



import java.util.Set;



/**

 * Provides access to the metamodel of
persistent

 * entities in the persistence unit.

 */

public interface Metamodel \{



 /**

 * Return the metamodel entity type
representing the entity.

 * @param cls the type of the represented
entity

 * @return the metamodel entity type

 * @throws IllegalArgumentException if not an
entity

 */

 <X> EntityType<X> entity(Class<X> cls);



 /**

 * Return the metamodel managed type
representing the

 * entity, mapped superclass, or embeddable
class.

 * @param cls the type of the represented
managed class

 * @return the metamodel managed type

 * @throws IllegalArgumentException if not a
managed class

 */

 <X> ManagedType<X> managedType(Class<X>
cls);



 /**

 * Return the metamodel embeddable type
representing the

 * embeddable class.

 * @param cls the type of the represented
embeddable class

 * @return the metamodel embeddable type

 * @throws IllegalArgumentException if not an
embeddable class

 */

 <X> EmbeddableType<X> embeddable(Class<X>
cls);



 /**

 * Return the metamodel managed types.

 * @return the metamodel managed types

 */

 Set<ManagedType<?>> getManagedTypes();



 /**

 * Return the metamodel entity types.

 * @return the metamodel entity types

 */

 Set<EntityType<?>> getEntities();



 /**

 * Return the metamodel embeddable types.
Returns empty set

 * if there are no embeddable types.

 * @return the metamodel embeddable types

 */

 Set<EmbeddableType<?>> getEmbeddables();

}



==== Type Interface



package javax.persistence.metamodel;



/**

 * Instances of the type Type represent
persistent object

 * or attribute types.

 *

 * @param <X> The type of the represented
object or attribute

 */

public interface Type<X> \{



 public static enum PersistenceType \{

 ENTITY, EMBEDDABLE, MAPPED_SUPERCLASS, BASIC

 }



 /**

 * Return the persistence type.

 * @return persistence type

 */

 PersistenceType getPersistenceType();



 /**

 * Return the represented Java type.

 * @return Java type

 */

 Class<X> getJavaType();

}

==== ManagedType Interface

package javax.persistence.metamodel;



import java.util.Set;



/**

 * Instances of the type ManagedType
represent entity, mapped

 * superclass, and embeddable types.

 *

 * @param <X> The represented type.

 */

public interface ManagedType<X> extends
Type<X> \{



 /**

 * Return the attributes of the managed type.

 * @return attributes of the managed type

 */

 Set<Attribute<? super X, ?>>
getAttributes();



 /**

 * Return the attributes declared by the
managed type.

 * Returns empty set if the managed type has
no declared

 * attributes.

 * @return declared attributes of the managed
type

 */

 Set<Attribute<X, ?>>
getDeclaredAttributes();



 /**

 * Return the single-valued attribute of the
managed

 * type that corresponds to the specified
name and Java type.

 * @param name the name of the represented
attribute

 * @param type the type of the represented
attribute

 * @return single-valued attribute with given
name and type

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not present in the
managed type

 */

 <Y> SingularAttribute<? super X, Y>
getSingularAttribute(

 String name, Class<Y> type);



 /**

 * Return the single-valued attribute
declared by the

 * managed type that corresponds to the
specified name and

 * Java type.

 * @param name the name of the represented
attribute

 * @param type the type of the represented
attribute

 * @return declared single-valued attribute
of the given

 * name and type

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not declared in the
managed type

 */

 <Y> SingularAttribute<X, Y>
getDeclaredSingularAttribute(

 String name, Class<Y> type);















 /**

 * Return the single-valued attributes of the
managed type.

 * Returns empty set if the managed type has
no single-valued

 * attributes.

 * @return single-valued attributes

 */

 Set<SingularAttribute<? super X, ?>>
getSingularAttributes();



 /**

 * Return the single-valued attributes
declared by the managed

 * type.

 * Returns empty set if the managed type has
no declared

 * single-valued attributes.

 * @return declared single-valued attributes

 */

 Set<SingularAttribute<X, ?>>
getDeclaredSingularAttributes();



 /**

 * Return the Collection-valued attribute of
the managed type

 * that corresponds to the specified name and
Java element type.

 * @param name the name of the represented
attribute

 * @param elementType the element type of the
represented

 * attribute

 * @return CollectionAttribute of the given
name and element

 * type

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not present in the
managed type

 */

 <E> CollectionAttribute<? super X, E>
getCollection(

 String name, Class<E> elementType);



 /**

 * Return the Collection-valued attribute
declared by the

 * managed type that corresponds to the
specified name and Java

 * element type.

 * @param name the name of the represented
attribute

 * @param elementType the element type of the
represented

 * attribute

 * @return declared CollectionAttribute of
the given name and

 * element type

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not declared in the
managed type

 */

 <E> CollectionAttribute<X, E>
getDeclaredCollection(

 String name, Class<E> elementType);



 /**

 * Return the Set-valued attribute of the
managed type that

 * corresponds to the specified name and Java
element type.

 * @param name the name of the represented
attribute

 * @param elementType the element type of the
represented

 * attribute

 * @return SetAttribute of the given name and
element type

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not present in the
managed type

 */

 <E> SetAttribute<? super X, E> getSet(String
name,

 Class<E> elementType);



 /**

 * Return the Set-valued attribute declared
by the managed type

 * that corresponds to the specified name and
Java element type.

 * @param name the name of the represented
attribute

 * @param elementType the element type of the
represented

 * attribute

 * @return declared SetAttribute of the given
name and

 * element type

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not declared in the
managed type

 */

 <E> SetAttribute<X, E> getDeclaredSet(String
name,

 Class<E> elementType);



 /**

 * Return the List-valued attribute of the
managed type that

 * corresponds to the specified name and Java
element type.

 * @param name the name of the represented
attribute

 * @param elementType the element type of the
represented

 * attribute

 * @return ListAttribute of the given name
and element type

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not present in the
managed type

 */

 <E> ListAttribute<? super X, E>
getList(String name,

 Class<E> elementType);



 /**

 * Return the List-valued attribute declared
by the managed

 * type that corresponds to the specified
name and Java

 * element type.

 * @param name the name of the represented
attribute

 * @param elementType the element type of the
represented

 * attribute

 * @return declared ListAttribute of the
given name and

 * element type

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not declared in the
managed type

 */

 <E> ListAttribute<X, E>
getDeclaredList(String name,

 Class<E> elementType);



 /**

 * Return the Map-valued attribute of the
managed type that

 * corresponds to the specified name and Java
key and value

 * types.

 * @param name the name of the represented
attribute

 * @param keyType the key type of the
represented attribute

 * @param valueType the value type of the
represented attribute

 * @return MapAttribute of the given name and
key and value

 * types

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not present in the
managed type

 */

 <K, V> MapAttribute<? super X, K, V>
getMap(String name,

 Class<K> keyType,

 Class<V> valueType);





 /**

 * Return the Map-valued attribute declared
by the managed

 * type that corresponds to the specified
name and Java key

 * and value types.

 * @param name the name of the represented
attribute

 * @param keyType the key type of the
represented attribute

 * @param valueType the value type of the
represented attribute

 * @return declared MapAttribute of the given
name and key

 * and value types

 * @throws IllegalArgumentException if
attribute of the given

 * name and type is not declared in the
managed type

 */

 <K, V> MapAttribute<X, K, V>
getDeclaredMap(String name,

 Class<K> keyType,

 Class<V> valueType);



 /**

 * Return all multi-valued attributes
(Collection-, Set-,

 * List-, and Map-valued attributes) of the
managed type.

 * Returns empty set if the managed type has
no multi-valued

 * attributes.

 * @return Collection-, Set-, List-, and
Map-valued attributes

 */

 Set<PluralAttribute<? super X, ?, ?>>
getPluralAttributes();



 /**

 * Return all multi-valued attributes
(Collection-, Set-,

 * List-, and Map-valued attributes) declared
by the

 * managed type.

 * Returns empty set if the managed type has
no declared

 * multi-valued attributes.

 * @return declared Collection-, Set-, List-,
and Map-valued

 * attributes

 */

 Set<PluralAttribute<X, ?, ?>>
getDeclaredPluralAttributes();





//String-based:



 /**

 * Return the attribute of the managed

 * type that corresponds to the specified
name.

 * @param name the name of the represented
attribute

 * @return attribute with given name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not present in the managed type

 */

 Attribute<? super X, ?> getAttribute(String
name);



 /**

 * Return the attribute declared by the
managed

 * type that corresponds to the specified
name.

 * @param name the name of the represented
attribute

 * @return attribute with given name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not declared in the managed type

 */

 Attribute<X, ?> getDeclaredAttribute(String
name);



 /**

 * Return the single-valued attribute of the
managed type that

 * corresponds to the specified name.

 * @param name the name of the represented
attribute

 * @return single-valued attribute with the
given name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not present in the managed type

 */

 SingularAttribute<? super X, ?>
getSingularAttribute(

 String name);



 /**

 * Return the single-valued attribute
declared by the managed

 * type that corresponds to the specified
name.

 * @param name the name of the represented
attribute

 * @return declared single-valued attribute
of the given

 * name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not declared in the managed type

 */

 SingularAttribute<X, ?>
getDeclaredSingularAttribute(

 String name);



 /**

 * Return the Collection-valued attribute of
the managed type

 * that corresponds to the specified name.

 * @param name the name of the represented
attribute

 * @return CollectionAttribute of the given
name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not present in the managed type

 */

 CollectionAttribute<? super X, ?>
getCollection(String name);



 /**

 * Return the Collection-valued attribute
declared by the

 * managed type that corresponds to the
specified name.

 * @param name the name of the represented
attribute

 * @return declared CollectionAttribute of
the given name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not declared in the managed type

 */

 CollectionAttribute<X, ?>
getDeclaredCollection(String name);



 /**

 * Return the Set-valued attribute of the
managed type that

 * corresponds to the specified name.

 * @param name the name of the represented
attribute

 * @return SetAttribute of the given name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not present in the managed type

 */

 SetAttribute<? super X, ?> getSet(String
name);















 /**

 * Return the Set-valued attribute declared
by the managed type

 * that corresponds to the specified name.

 * @param name the name of the represented
attribute

 * @return declared SetAttribute of the given
name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not declared in the managed type

 */

 SetAttribute<X, ?> getDeclaredSet(String
name);



 /**

 * Return the List-valued attribute of the
managed type that

 * corresponds to the specified name.

 * @param name the name of the represented
attribute

 * @return ListAttribute of the given name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not present in the managed type

 */

 ListAttribute<? super X, ?> getList(String
name);



 /**

 * Return the List-valued attribute declared
by the managed

 * type that corresponds to the specified
name.

 * @param name the name of the represented
attribute

 * @return declared ListAttribute of the
given name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not declared in the managed type

 */

 ListAttribute<X, ?> getDeclaredList(String
name);



 /**

 * Return the Map-valued attribute of the
managed type that

 * corresponds to the specified name.

 * @param name the name of the represented
attribute

 * @return MapAttribute of the given name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not present in the managed type

 */

 MapAttribute<? super X, ?, ?> getMap(String
name);



 /**

 * Return the Map-valued attribute declared
by the managed

 * type that corresponds to the specified
name.

 * @param name the name of the represented
attribute

 * @return declared MapAttribute of the given
name

 * @throws IllegalArgumentException if
attribute of the given

 * name is not declared in the managed type

 */

 MapAttribute<X, ?, ?> getDeclaredMap(String
name);

}

==== IdentifiableType Interface



package javax.persistence.metamodel;



import java.util.Set;



/**

 * Instances of the type IdentifiableType
represent entity or

 * mapped superclass types.

 *

 * @param <X> The represented entity or
mapped superclass type.

 */

public interface IdentifiableType<X> extends
ManagedType<X> \{



 /**

 * Return the attribute that corresponds to
the id attribute of

 * the entity or mapped superclass.

 * @param type the type of the represented id
attribute

 * @return id attribute

 * @throws IllegalArgumentException if id
attribute of the given

 * type is not present in the identifiable
type or if

 * the identifiable type has an id class

 */

 <Y> SingularAttribute<? super X, Y>
getId(Class<Y> type);



 /**

 * Return the attribute that corresponds to
the id attribute

 * declared by the entity or mapped
superclass.

 * @param type the type of the represented
declared

 * id attribute

 * @return declared id attribute

 * @throws IllegalArgumentException if id
attribute of the given

 * type is not declared in the identifiable
type or if

 * the identifiable type has an id class

 */

 <Y> SingularAttribute<X, Y>
getDeclaredId(Class<Y> type);



 /**

 * Return the attribute that corresponds to
the version

 * attribute of the entity or mapped
superclass.

 * @param type the type of the represented
version attribute

 * @return version attribute

 * @throws IllegalArgumentException if
version attribute of the

 * given type is not present in the
identifiable type

 */

 <Y> SingularAttribute<? super X, Y>
getVersion(Class<Y> type);



 /**

 * Return the attribute that corresponds to
the version

 * attribute declared by the entity or mapped
superclass.

 * @param type the type of the represented
declared version

 * attribute

 * @return declared version attribute

 * @throws IllegalArgumentException if
version attribute of the

 * type is not declared in the identifiable
type

 */

 <Y> SingularAttribute<X, Y>
getDeclaredVersion(Class<Y> type);





 /**

 * Return the identifiable type that
corresponds to the most

 * specific mapped superclass or entity
extended by the entity

 * or mapped superclass.

 * @return supertype of identifiable type or
null if no

 * such supertype

 */

 IdentifiableType<? super X> getSupertype();



 /**

 * Whether the identifiable type has a single
id attribute.

 * Returns true for a simple id or embedded
id; returns false

 * for an idclass.

 * @return boolean indicating whether the
identifiable

 * type has a single id attribute

 */

 boolean hasSingleIdAttribute();



 /**

 * Whether the identifiable type has a
version attribute.

 * @return boolean indicating whether the
identifiable

 * type has a version attribute

 */

 boolean hasVersionAttribute();



 /**

 * Return the attributes corresponding to the
id class of the

 * identifiable type.

 * @return id attributes

 * @throws IllegalArgumentException if the
identifiable type

 * does not have an id class

 */

 Set<SingularAttribute<? super X, ?>>
getIdClassAttributes();



 /**

 * Return the type that represents the type
of the id.

 * @return type of id

 */

 Type<?> getIdType();

}

==== EntityType Interface



package javax.persistence.metamodel;



/**

 * Instances of the type EntityType represent
entity types.

 *

 * @param <X> The represented entity type.

 */

public interface EntityType<X>

 extends IdentifiableType<X>, Bindable<X> \{



 /**

 * Return the entity name.

 * @return entity name

 */

 String getName();

}

==== EmbeddableType Interface



package javax.persistence.metamodel;



/**

 * Instances of the type EmbeddableType
represent embeddable types.

 *

 * @param <X> The represented type.

 */

public interface EmbeddableType<X> extends
ManagedType<X> \{}

==== MappedSuperclassType Interface



package javax.persistence.metamodel;



/**

 * Instances of the type MappedSuperclassType
represent mapped

 * superclass types.

 *

 * @param <X> The represented entity type

 */

public interface MappedSuperclassType<X>

 extends IdentifiableType<X> \{}

==== BasicType Interface



package javax.persistence.metamodel;



/**

 * Instances of the type BasicType represent
basic types (including

 * temporal and enumerated types).

 *

 * @param <X> The type of the represented
basic type

 */

public interface BasicType<X> extends Type<X>
\{}

==== Bindable Interface



package javax.persistence.metamodel;



/**

 * Instances of the type Bindable represent
object or attribute types

 * that can be bound into a Path.

 *

 * @param <T> The type of the represented
object or attribute

 */

public interface Bindable<T> \{



 public static enum BindableType \{

 SINGULAR_ATTRIBUTE, PLURAL_ATTRIBUTE,
ENTITY_TYPE

 }



 /**

 * Return the bindable type of the
represented object.

 * @return bindable type

 */

 BindableType getBindableType();



 /**

 * Return the Java type of the represented
object.

 * If the bindable type of the object is
PLURAL_ATTRIBUTE,

 * the Java element type is returned. If the
bindable type is

 * SINGULAR_ATTRIBUTE or ENTITY_TYPE, the
Java type of the

 * represented entity or attribute is
returned.

 * @return Java type

 */

 Class<T> getBindableJavaType();

}

==== Attribute Interface



package javax.persistence.metamodel;



/**

 * Represents an attribute of a Java type.

 *

 * @param <X> The represented type that
contains the attribute

 * @param <Y> The type of the represented
attribute

 */

public interface Attribute<X, Y> \{



 public static enum PersistentAttributeType
\{

 MANY_TO_ONE, ONE_TO_ONE, BASIC, EMBEDDED,

 MANY_TO_MANY, ONE_TO_MANY,
ELEMENT_COLLECTION

 }



 /**

 * Return the name of the attribute.

 * @return name

 */

 String getName();



 /**

 * Return the persistent attribute type for
the attribute.

 * @return persistent attribute type

 */

 PersistentAttributeType
getPersistentAttributeType();



 /**

 * Return the managed type representing the
type in which

 * the attribute was declared.

 * @return declaring type

 */

 ManagedType<X> getDeclaringType();



 /**

 * Return the Java type of the represented
attribute.

 * @return Java type

 */

 Class<Y> getJavaType();



 /**

 * Return the java.lang.reflect.Member for
the represented

 * attribute.

 * @return corresponding
java.lang.reflect.Member

 */

 java.lang.reflect.Member getJavaMember();



 /**

 * Is the attribute an association.

 * @return boolean indicating whether the
attribute corresponds

 * to an association

 */

 boolean isAssociation();









 /**

 * Is the attribute collection-valued
(represents a Collection,

 * Set, List, or Map).

 * @return boolean indicating whether the
attribute is

 * collection-valued

 */

 boolean isCollection();

}

==== SingularAttribute Interface



package javax.persistence.metamodel;



/**

 * Instances of the type SingularAttribute
represents persistent

 * single-valued properties or fields.

 *

 * @param <X> The type containing the
represented attribute

 * @param <T> The type of the represented
attribute

 */

public interface SingularAttribute<X, T>

 extends Attribute<X, T>, Bindable<T> \{



 /**

 * Is the attribute an id attribute. This
method will return

 * true if the attribute is an attribute that
corresponds to

 * a simple id, an embedded id, or an
attribute of an id class.

 * @return boolean indicating whether the
attribute is an id

 */

 boolean isId();



 /**

 * Is the attribute a version attribute.

 * @return boolean indicating whether the
attribute is

 * a version attribute

 */

 boolean isVersion();



 /**

 * Can the attribute be null.

 * @return boolean indicating whether the
attribute can be null

 */

 boolean isOptional();



 /**

 * Return the type that represents the type
of the attribute.

 * @return type of attribute

 */

 Type<T> getType();

}



==== PluralAttribute Interface



package javax.persistence.metamodel;



/**

 * Instances of the type PluralAttribute
represent

 * persistent collection-valued attributes.

 *

 * @param <X> The type the represented
collection belongs to

 * @param <C> The type of the represented
collection

 * @param <E> The element type of the
represented collection

 */

public interface PluralAttribute<X, C, E>

 extends Attribute<X, C>, Bindable<E> \{



 public static enum CollectionType \{

 COLLECTION, SET, LIST, MAP

 }



 /**

 * Return the collection type.

 * @return collection type

 */

 CollectionType getCollectionType();



 /**

 * Return the type representing the element
type of the

 * collection.

 * @return element type

 */

 Type<E> getElementType();

}

==== CollectionAttribute Interface



package javax.persistence.metamodel;



/**

 * Instances of the type CollectionAttribute
represent persistent

 * javax.util.Collection-valued attributes.

 *

 * @param <X> The type the represented
Collection belongs to

 * @param <E> The element type of the
represented Collection

 */

public interface CollectionAttribute<X, E>

 extends PluralAttribute<X,
java.util.Collection<E>, E> \{}

==== SetAttribute Interface



package javax.persistence.metamodel;



/**

 * Instances of the type SetAttribute
represent persistent

 * java.util.Set-valued attributes.

 *

 * @param <X> The type the represented Set
belongs to

 * @param <E> The element type of the
represented Set

 */

public interface SetAttribute<X, E>

 extends PluralAttribute<X, java.util.Set<E>,
E> \{}

==== ListAttribute Interface



package javax.persistence.metamodel;



/**

 * Instances of the type ListAttribute
represent persistent

 * java.util.List-valued attributes.

 *

 * @param <X> The type the represented List
belongs to

 * @param <E> The element type of the
represented List

 */

public interface ListAttribute<X, E>

 extends PluralAttribute<X,
java.util.List<E>, E> \{}

==== MapAttribute Interface



package javax.persistence.metamodel;



/**

 * Instances of the type MapAttribute
represent persistent

 * java.util.Map-valued attributes.

 *

 * @param <X> The type the represented Map
belongs to

 * @param <K> The type of the key of the
represented Map

 * @param <V> The type of the value of the
represented Map

 */

public interface MapAttribute<X, K, V>

 extends PluralAttribute<X, java.util.Map<K,
V>, V> \{



 /**

 * Return the Java type of the map key.

 * @return Java key type

 */

 Class<K> getKeyJavaType();



 /**

 * Return the type representing the key type
of the map.

 * @return type representing key type

 */

 Type<K> getKeyType();

}

==== StaticMetamodel Annotation



package javax.persistence.metamodel;



import java.lang.annotation.ElementType;

import java.lang.annotation.Retention;

import java.lang.annotation.RetentionPolicy;

import java.lang.annotation.Target;



/**

 * The StaticMetamodel annotation specifies
that the class

 * is a metamodel class that represents the
entity, mapped

 * superclass, or embeddable class designated
by the value

 * element.

 */

@Target(ElementType.TYPE)

@Retention(RetentionPolicy.RUNTIME)

public @interface StaticMetamodel \{



 /**

 * Class being modeled by the annotated
class.

 */

 Class<?> value();

}





== [[a6925]]Criteria API

The Java Persistence Criteria API is used to
define queries through the construction of object-based query definition
objects, rather than use of the string-based approach of the Java
Persistence query language described in Chapter
link:Per.html#a4665[See Query Language].

This chapter provides the full definition of
the Criteria API.

=== Overview

image:Per-4.png[image]

The Java Persistence Criteria API, like the
Java Persistence query language is based on the abstract persistence
schema of entities, their embedded objects, and their relationships as
its data model. This abstract persistence schema is materialized in the
form of metamodel objects over which the Criteria API operates. The
semantics of criteria queries are designed to reflect those of Java
Persistence query language queries.

The syntax of the Criteria API is designed to
allow the construction of an object-based query “graph”, whose nodes
correspond to the semantic query elements.

Java language variables can be used to
reference individual nodes in a criteria query object as it is
constructed and/or modified. Such variables, when used to refer to the
entities and embeddable types that constitute the query domain, play a
role analogous to that of the identification variables of the Java
Persistence query language.

These concepts are further described in the
sections that follow. The metamodel on which criteria queries are based
is presented in Chapter link:Per.html#a6072[See Metamodel API].
The static metamodel classes that can be used in constructing
strongly-typed criteria queries are described in section
link:Per.html#a6933[See Metamodel]. The
_javax.persistence.criteria_ interfaces are presented in Section
link:Per.html#a6997[See Criteria API Interfaces]. Sections
link:Per.html#a10608[See Criteria Query API Usage] through
link:Per.html#a11413[See Query Modification] describe the
construction and modification of criteria query objects. Additional
requirements on the persistence provider are described in section
link:Per.html#a11427[See Query Execution].

=== [[a6933]]Metamodel

image:Per-4.png[image]

Java Persistence criteria queries are based
on a metamodel of the managed classes of the persistence unit. Static
metamodel classes corresponding to the managed classes of the
persistence unit can be generated by means of an annotation processor or
can be created by the application developer, or the metamodel can be
accessed dynamically by use of the
_javax.persistence.metamodel.Metamodel_ interface. The _getMetamodel_
method of the _EntityManagerFactory_ or _EntityManager_ interface can be
used to obtain a _Metamodel_ instance.

==== Static Metamodel Classes

In the typical case, an annotation processor
is expected to be used to produce static metamodel classes corresponding
to the entities, mapped superclasses, and embeddable classes in the
persistence unit. A static metamodel class models the persistent state
and relationships of the corresponding managed class. For portability,
an annotation processor should generate a canonical metamodel as defined
below.

===== Canonical Metamodel

This specification defines as follows a
canonical metamodel and the structure of canonical metamodel classes.

For every managed class in the persistence
unit, a corresponding metamodel class is produced as follows:

{empty}For each managed class _X_ in package
_p_ , a metamodel class _X__ in package _p_ is
created.link:#a19611[75]

The name of the metamodel class is derived
from the name of the managed class by appending " ___ " to the name of
the managed class.

The metamodel class _X__ must be annotated
with the _javax.persistence.StaticMetamodel_
annotationlink:#a19612[76].

If class _X_ extends another class _S_ ,
where _S_ is the most derived managed class (i.e., entity or mapped
superclass) extended by _X_ , then class _X__ must extend class _S__ ,
where _S__ is the metamodel class created for _S_ .

For every persistent non-collection-valued
attribute _y_ declared by class _X_ , where the type of _y_ is _Y_ , the
metamodel class must contain a declaration as follows:

 public static volatile SingularAttribute<X,
Y> y;

For every persistent collection-valued
attribute _z_ declared by class _X_ , where the element type of _z_ is
_Z_ , the metamodel class must contain a declaration as follows:

if the collection type of _z_ is
_java.util.Collection_ , then

 public static volatile
CollectionAttribute<X, Z> z;



if the collection type of _z_ is
_java.util.Set_ , then

 public static volatile SetAttribute<X, Z> z;



if the collection type of _z_ is
_java.util.List_ , then

 public static volatile ListAttribute<X, Z>
z;



if the collection type of _z_ is
_java.util.Map_ , then

 public static volatile MapAttribute<X, K, Z>
z;

 where _K_ is the type of the key of the map
in class _X_

Import statements must be included for the
needed _javax.persistence.metamodel_ types as appropriate (e.g.,
_javax.persistence.metamodel.SingularAttribute_ ,
_javax.persistence.metamodel.CollectionAttribute_ ,
_javax.persistence.metamodel.SetAttribute_ ,
_javax.persistence.metamodel.ListAttribute_ ,
_javax.persistence.metamodel.MapAttribute_ ) and all classes _X_ , _Y_ ,
_Z_ , and _K_ .

 _Implementations of this specification are
not required to support the use of non-canonical metamodel classes.
Applications that use non-canonical metamodel classes will not be
portable._

===== [[a6961]]Example

Assume the _Order_ entity below.

package com.example;



import java.util.Set;

import java.math.BigDecimal;



@Entity public class Order \{

 @Id Integer orderId;

 @ManyToOne Customer customer;

 @OneToMany Set<Item> lineItems;

 Address shippingAddress;

 BigDecimal totalCost;

 ...

}

The corresponding canonical metamodel class,
_Order__ , __ is as follows:

package com.example;



import java.math.BigDecimal;



import
javax.persistence.metamodel.SingularAttribute;

import
javax.persistence.metamodel.SetAttribute;

import
javax.persistence.metamodel.StaticMetamodel;



@StaticMetamodel(Order.class)

public class Order_ \{



 public static volatile
SingularAttribute<Order, Integer> orderId;

 public static volatile
SingularAttribute<Order, Customer> customer;

 public static volatile SetAttribute<Order,
Item> lineItems;

 public static volatile
SingularAttribute<Order, Address> shippingAddress;

 public static volatile
SingularAttribute<Order, BigDecimal> totalCost;

}

==== Bootstrapping

When the entity manager factory for a
persistence unit is created, it is the responsibility of the persistence
provider to initialize the state of the metamodel classes of the
persistence unit. Any generated metamodel classes must be accessible on
the classpath.

Persistence providers must support the use of
canonical metamodel classes. Persistence providers may, but are not
required to, support the use of non-canonical metamodel classes.

=== [[a6997]]Criteria API Interfaces

image:Per-4.png[image]

==== CriteriaBuilder Interface



package javax.persistence.criteria;



import java.math.BigDecimal;

import java.math.BigInteger;

import java.util.Collection;

import java.util.Map;

import java.util.Set;

import javax.persistence.Tuple;



/**

 * Used to construct criteria queries,
compound selections,

 * expressions, predicates, orderings.

 * Note that Predicate is used instead of
Expression<Boolean>

 * in this API in order to work around the
fact that Java

 * generics are not compatible with varags.

 */

public interface CriteriaBuilder \{



 /**

 * Create a CriteriaQuery object.

 * @return criteria query object

 */

 CriteriaQuery<Object> createQuery();



 /**

 * Create a CriteriaQuery object with the
specified result

 * type.

 * @param resultClass type of the query
result

 * @return criteria query object

 */

 <T> CriteriaQuery<T> createQuery(Class<T>
resultClass);



 /**

 * Create a CriteriaQuery object that returns
a tuple of

 * objects as its result.

 * @return criteria query object

 */

 CriteriaQuery<Tuple> createTupleQuery();





 // methods to construct queries for bulk
updates and deletes:



 /**

 * Create a query object to perform a bulk
update operation.

 * @param targetEntity target type for update
operation

 * @return the query object

 */

 <T> CriteriaUpdate<T> createCriteriaUpdate(

 Class<T> targetEntity);







 /**

 * Create a query object to perform a bulk
delete operation.

 * @param targetEntity target type for delete
operation

 * @return the query object

 */

 <T> CriteriaDelete<T> createCriteriaDelete(

 Class<T> targetEntity);





 // selection construction methods:



 /**

 * Create a selection item corresponding to a
constructor.

 * This method is used to specify a
constructor that will be

 * applied to the results of the query
execution. If the

 * constructor is for an entity class, the
resulting entities

 * will be in the new state after the query
is executed.

 * @param resultClass class whose instance is
to be constructed

 * @param selections arguments to the
constructor

 * @return compound selection item

 * @throws IllegalArgumentException if an
argument is a

 * tuple- or array-valued selection item

 */

 <Y> CompoundSelection<Y> construct(Class<Y>
resultClass,

 Selection<?>... selections);



 /**

 * Create a tuple-valued selection item.

 * @param selections selection items

 * @return tuple-valued compound selection

 * @throws IllegalArgumentException if an
argument is a

 * tuple- or array-valued selection item

 */

 CompoundSelection<Tuple>
tuple(Selection<?>... selections);



 /**

 * Create an array-valued selection item.

 * @param selections selection items

 * @return array-valued compound selection

 * @throws IllegalArgumentException if an
argument is a

 * tuple- or array-valued selection item

 */

 CompoundSelection<Object[]>
array(Selection<?>... selections);





 //ordering:



 /**

 * Create an ordering by the ascending value
of the expression.

 * @param x expression used to define the
ordering

 * @return ascending ordering corresponding
to the expression

 */

 Order asc(Expression<?> x);













 /**

 * Create an ordering by the descending value
of the expression.

 * @param x expression used to define the
ordering

 * @return descending ordering corresponding
to the expression

 */

 Order desc(Expression<?> x);





 //aggregate functions:



 /**

 * Create an aggregate expression applying
the avg operation.

 * @param x expression representing input
value to avg operation

 * @return avg expression

 */

 <N extends Number> Expression<Double>
avg(Expression<N> x);



 /**

 * Create an aggregate expression applying
the sum operation.

 * @param x expression representing input
value to sum operation

 * @return sum expression

 */

 <N extends Number> Expression<N>
sum(Expression<N> x);







 /**

 * Create an aggregate expression applying
the sum operation to

 * an Integer-valued expression, returning a
Long result.

 * @param x expression representing input
value to sum operation

 * @return sum expression

 */

 Expression<Long>
sumAsLong(Expression<Integer> x);



 /**

 * Create an aggregate expression applying
the sum operation to a

 * Float-valued expression, returning a
Double result.

 * @param x expression representing input
value to sum operation

 * @return sum expression

 */

 Expression<Double>
sumAsDouble(Expression<Float> x);



 /**

 * Create an aggregate expression applying
the numerical max

 * operation.

 * @param x expression representing input
value to max operation

 * @return max expression

 */

 <N extends Number> Expression<N>
max(Expression<N> x);



 /**

 * Create an aggregate expression applying
the numerical min

 * operation.

 * @param x expression representing input
value to min operation

 * @return min expression

 */

 <N extends Number> Expression<N>
min(Expression<N> x);





 /**

 * Create an aggregate expression for finding
the greatest of

 * the values (strings, dates, etc).

 * @param x expression representing input
value to greatest

 * operation

 * @return greatest expression

 */

 <X extends Comparable<? super X>>
Expression<X> greatest(

 Expression<X> x);



 /**

 * Create an aggregate expression for finding
the least of

 * the values (strings, dates, etc).

 * @param x expression representing input
value to least

 * operation

 * @return least expression

 */

 <X extends Comparable<? super X>>
Expression<X> least(

 Expression<X> x);



 /**

 * Create an aggregate expression applying
the count operation.

 * @param x expression representing input
value to count

 * operation

 * @return count expression

 */

 Expression<Long> count(Expression<?> x);



 /**

 * Create an aggregate expression applying
the count distinct

 * operation.

 * @param x expression representing input
value to

 * count distinct operation

 * @return count distinct expression

 */

 Expression<Long> countDistinct(Expression<?>
x);





 //subqueries:



 /**

 * Create a predicate testing the existence
of a subquery result.

 * @param subquery subquery whose result is
to be tested

 * @return exists predicate

 */

 Predicate exists(Subquery<?> subquery);



 /**

 * Create an all expression over the subquery
results.

 * @param subquery

 * @return all expression

 */

 <Y> Expression<Y> all(Subquery<Y> subquery);



 /**

 * Create a some expression over the subquery
results.

 * This expression is equivalent to an any
expression.

 * @param subquery

 * @return some expression

 */

 <Y> Expression<Y> some(Subquery<Y>
subquery);



 /**

 * Create an any expression over the subquery
results.

 * This expression is equivalent to a some
expression.

 * @param subquery

 * @return any expression

 */

 <Y> Expression<Y> any(Subquery<Y> subquery);





 //boolean functions:



 /**

 * Create a conjunction of the given boolean
expressions.

 * @param x boolean expression

 * @param y boolean expression

 * @return and predicate

 */

 Predicate and(Expression<Boolean> x,
Expression<Boolean> y);



 /**

 * Create a conjunction of the given
restriction predicates.

 * A conjunction of zero predicates is true.

 * @param restrictions zero or more
restriction predicates

 * @return and predicate

 */

 Predicate and(Predicate... restrictions);



 /**

 * Create a disjunction of the given boolean
expressions.

 * @param x boolean expression

 * @param y boolean expression

 * @return or predicate

 */

 Predicate or(Expression<Boolean> x,
Expression<Boolean> y);



 /**

 * Create a disjunction of the given
restriction predicates.

 * A disjunction of zero predicates is false.

 * @param restrictions zero or more
restriction predicates

 * @return or predicate

 */

 Predicate or(Predicate... restrictions);



 /**

 * Create a negation of the given
restriction.

 * @param restriction restriction expression

 * @return not predicate

 */

 Predicate not(Expression<Boolean>
restriction);



 /**

 * Create a conjunction (with zero
conjuncts).

 * A conjunction with zero conjuncts is true.

 * @return and predicate

 */

 Predicate conjunction();



 /**

 * Create a disjunction (with zero
disjuncts).

 * A disjunction with zero disjuncts is
false.

 * @return or predicate

 */

 Predicate disjunction();



 //turn Expression<Boolean> into a Predicate

 //useful for use with varargs methods



 /**

 * Create a predicate testing for a true
value.

 * @param x expression to be tested

 * @return predicate

 */

 Predicate isTrue(Expression<Boolean> x);



 /**

 * Create a predicate testing for a false
value.

 * @param x expression to be tested

 * @return predicate

 */

 Predicate isFalse(Expression<Boolean> x);





 //null tests:



 /**

 * Create a predicate to test whether the
expression is null.

 * @param x expression

 * @return is-null predicate

 */

 Predicate isNull(Expression<?> x);



 /**

 * Create a predicate to test whether the
expression is not null.

 * @param x expression

 * @return is-not-null predicate

 */

 Predicate isNotNull(Expression<?> x);





 //equality:



 /**

 * Create a predicate for testing the
arguments for equality.

 * @param x expression

 * @param y expression

 * @return equality predicate

 */

 Predicate equal(Expression<?> x,
Expression<?> y);



 /**

 * Create a predicate for testing the
arguments for equality.

 * @param x expression

 * @param y object

 * @return equality predicate

 */

 Predicate equal(Expression<?> x, Object y);



 /**

 * Create a predicate for testing the
arguments for inequality.

 * @param x expression

 * @param y expression

 * @return inequality predicate

 */

 Predicate notEqual(Expression<?> x,
Expression<?> y);



 /**

 * Create a predicate for testing the
arguments for inequality.

 * @param x expression

 * @param y object

 * @return inequality predicate

 */

 Predicate notEqual(Expression<?> x, Object
y);





 //comparisons for generic (non-numeric)
operands:



 /**

 * Create a predicate for testing whether the
first argument is

 * greater than the second.

 * @param x expression

 * @param y expression

 * @return greater-than predicate

 */

 <Y extends Comparable<? super Y>> Predicate
greaterThan(

 Expression<? extends Y> x, Expression<?
extends Y> y);



 /**

 * Create a predicate for testing whether the
first argument is

 * greater than the second.

 * @param x expression

 * @param y value

 * @return greater-than predicate

 */

 <Y extends Comparable<? super Y>> Predicate
greaterThan(

 Expression<? extends Y> x, Y y);



 /**

 * Create a predicate for testing whether the
first argument is

 * greater than or equal to the second.

 * @param x expression

 * @param y expression

 * @return greater-than-or-equal predicate

 */

 <Y extends Comparable<? super Y>> Predicate
greaterThanOrEqualTo(

 Expression<? extends Y> x, Expression<?
extends Y> y);





 /**

 * Create a predicate for testing whether the
first argument is

 * greater than or equal to the second.

 * @param x expression

 * @param y value

 * @return greater-than-or-equal predicate

 */

 <Y extends Comparable<? super Y>> Predicate
greaterThanOrEqualTo(

 Expression<? extends Y> x, Y y);



 /**

 * Create a predicate for testing whether the
first argument is

 * less than the second.

 * @param x expression

 * @param y expression

 * @return less-than predicate

 */

 <Y extends Comparable<? super Y>> Predicate
lessThan(

 Expression<? extends Y> x, Expression<?
extends Y> y);



 /**

 * Create a predicate for testing whether the
first argument is

 * less than the second.

 * @param x expression

 * @param y value

 * @return less-than predicate

 */

 <Y extends Comparable<? super Y>> Predicate
lessThan(

 Expression<? extends Y> x, Y y);



 /**

 * Create a predicate for testing whether the
first argument is

 * less than or equal to the second.

 * @param x expression

 * @param y expression

 * @return less-than-or-equal predicate

 */

 <Y extends Comparable<? super Y>> Predicate
lessThanOrEqualTo(

 Expression<? extends Y> x, Expression<?
extends Y> y);



 /**

 * Create a predicate for testing whether the
first argument is

 * less than or equal to the second.

 * @param x expression

 * @param y value

 * @return less-than-or-equal predicate

 */

 <Y extends Comparable<? super Y>> Predicate
lessThanOrEqualTo(

 Expression<? extends Y> x, Y y);





















 /**

 * Create a predicate for testing whether the
first argument is

 * between the second and third arguments in
value.

 * @param v expression

 * @param x expression

 * @param y expression

 * @return between predicate

 */

 <Y extends Comparable<? super Y>> Predicate
between(

 Expression<? extends Y> v,

 Expression<? extends Y> x,

 Expression<? extends Y> y);



 /**

 * Create a predicate for testing whether the
first argument is

 * between the second and third arguments in
value.

 * @param v expression

 * @param x value

 * @param y value

 * @return between predicate

 */

 <Y extends Comparable<? super Y>> Predicate
between(

 Expression<? extends Y> v, Y x, Y y);





 //comparisons for numeric operands:



 /**

 * Create a predicate for testing whether the
first argument is

 * greater than the second.

 * @param x expression

 * @param y expression

 * @return greater-than predicate

 */

 Predicate gt(Expression<? extends Number> x,

 Expression<? extends Number> y);



 /**

 * Create a predicate for testing whether the
first argument is

 * greater than the second.

 * @param x expression

 * @param y value

 * @return greater-than predicate

 */

 Predicate gt(Expression<? extends Number> x,
Number y);



 /**

 * Create a predicate for testing whether the
first argument is

 * greater than or equal to the second.

 * @param x expression

 * @param y expression

 * @return greater-than-or-equal predicate

 */

 Predicate ge(Expression<? extends Number> x,

 Expression<? extends Number> y);









 /**

 * Create a predicate for testing whether the
first argument is

 * greater than or equal to the second.

 * @param x expression

 * @param y value

 * @return greater-than-or-equal predicate

 */

 Predicate ge(Expression<? extends Number> x,
Number y);



 /**

 * Create a predicate for testing whether the
first argument is

 * less than the second.

 * @param x expression

 * @param y expression

 * @return less-than predicate

 */

 Predicate lt(Expression<? extends Number> x,

 Expression<? extends Number> y);



 /**

 * Create a predicate for testing whether the
first argument is

 * less than the second.

 * @param x expression

 * @param y value

 * @return less-than predicate

 */

 Predicate lt(Expression<? extends Number> x,
Number y);



 /**

 * Create a predicate for testing whether the
first argument is

 * less than or equal to the second.

 * @param x expression

 * @param y expression

 * @return less-than-or-equal predicate

 */

 Predicate le(Expression<? extends Number> x,

 Expression<? extends Number> y);



 /**

 * Create a predicate for testing whether the
first argument is

 * less than or equal to the second.

 * @param x expression

 * @param y value

 * @return less-than-or-equal predicate

 */

 Predicate le(Expression<? extends Number> x,
Number y);





 //numerical operations:



 /**

 * Create an expression that returns the
arithmetic negation

 * of its argument.

 * @param x expression

 * @return arithmetic negation

 */

 <N extends Number> Expression<N>
neg(Expression<N> x);





 /**

 * Create an expression that returns the
absolute value

 * of its argument.

 * @param x expression

 * @return absolute value

 */

 <N extends Number> Expression<N>
abs(Expression<N> x);



 /**

 * Create an expression that returns the sum

 * of its arguments.

 * @param x expression

 * @param y expression

 * @return sum

 */

 <N extends Number> Expression<N>
sum(Expression<? extends N> x,

 Expression<? extends N> y);



 /**

 * Create an expression that returns the sum

 * of its arguments.

 * @param x expression

 * @param y value

 * @return sum

 */

 <N extends Number> Expression<N>
sum(Expression<? extends N> x,

 N y);



 /**

 * Create an expression that returns the sum

 * of its arguments.

 * @param x value

 * @param y expression

 * @return sum

 */

 <N extends Number> Expression<N> sum(N x,

 Expression<? extends N> y);



 /**

 * Create an expression that returns the
product

 * of its arguments.

 * @param x expression

 * @param y expression

 * @return product

 */

 <N extends Number> Expression<N>
prod(Expression<? extends N> x,

 Expression<? extends N> y);



 /**

 * Create an expression that returns the
product

 * of its arguments.

 * @param x expression

 * @param y value

 * @return product

 */

 <N extends Number> Expression<N>
prod(Expression<? extends N> x,

 N y);



 /**

 * Create an expression that returns the
product

 * of its arguments.

 * @param x value

 * @param y expression

 * @return product

 */

 <N extends Number> Expression<N> prod(N x,

 Expression<? extends N> y);



 /**

 * Create an expression that returns the
difference

 * between its arguments.

 * @param x expression

 * @param y expression

 * @return difference

 */

 <N extends Number> Expression<N>
diff(Expression<? extends N> x,

 Expression<? extends N> y);



 /**

 * Create an expression that returns the
difference

 * between its arguments.

 * @param x expression

 * @param y value

 * @return difference

 */

 <N extends Number> Expression<N>
diff(Expression<? extends N> x,

 N y);



 /**

 * Create an expression that returns the
difference

 * between its arguments.

 * @param x value

 * @param y expression

 * @return difference

 */

 <N extends Number> Expression<N> diff(N x,

 Expression<? extends N> y);



 /**

 * Create an expression that returns the
quotient

 * of its arguments.

 * @param x expression

 * @param y expression

 * @return quotient

 */

 Expression<Number> quot(Expression<? extends
Number> x,

 Expression<? extends Number> y);



 /**

 * Create an expression that returns the
quotient

 * of its arguments.

 * @param x expression

 * @param y value

 * @return quotient

 */

 Expression<Number> quot(Expression<? extends
Number> x, Number y);



 /**

 * Create an expression that returns the
quotient

 * of its arguments.

 * @param x value

 * @param y expression

 * @return quotient

 */

 Expression<Number> quot(Number x,
Expression<? extends Number> y);



 /**

 * Create an expression that returns the
modulus

 * of its arguments.

 * @param x expression

 * @param y expression

 * @return modulus

 */

 Expression<Integer> mod(Expression<Integer>
x,

 Expression<Integer> y);



 /**

 * Create an expression that returns the
modulus

 * of its arguments.

 * @param x expression

 * @param y value

 * @return modulus

 */

 Expression<Integer> mod(Expression<Integer>
x, Integer y);



 /**

 * Create an expression that returns the
modulus

 * of its arguments.

 * @param x value

 * @param y expression

 * @return modulus

 */

 Expression<Integer> mod(Integer x,
Expression<Integer> y);



 /**

 * Create an expression that returns the
square root

 * of its argument.

 * @param x expression

 * @return square root

 */

 Expression<Double> sqrt(Expression<? extends
Number> x);





 //typecasts:



 /**

 * Typecast. Returns same expression object.

 * @param number numeric expression

 * @return Expression<Long>

 */

 Expression<Long> toLong(Expression<? extends
Number> number);



 /**

 * Typecast. Returns same expression object.

 * @param number numeric expression

 * @return Expression<Integer>

 */

 Expression<Integer> toInteger(

 Expression<? extends Number> number);



 /**

 * Typecast. Returns same expression object.

 * @param number numeric expression

 * @return Expression<Float>

 */

 Expression<Float> toFloat(Expression<?
extends Number> number);



 /**

 * Typecast. Returns same expression object.

 * @param number numeric expression

 * @return Expression<Double>

 */

 Expression<Double> toDouble(Expression<?
extends Number> number);



 /**

 * Typecast. Returns same expression object.

 * @param number numeric expression

 * @return Expression<BigDecimal>

 */

 Expression<BigDecimal> toBigDecimal(

 Expression<? extends Number> number);



 /**

 * Typecast. Returns same expression object.

 * @param number numeric expression

 * @return Expression<BigInteger>

 */

 Expression<BigInteger> toBigInteger(

 Expression<? extends Number> number);



 /**

 * Typecast. Returns same expression object.

 * @param character expression

 * @return Expression<String>

 */

 Expression<String>
toString(Expression<Character> character);





 //literals:



 /**

 * Create an expression for a literal.

 * @param value value represented by the
expression

 * @return expression literal

 * @throws IllegalArgumentException if value
is null

 */

 <T> Expression<T> literal(T value);



 /**

 * Create an expression for a null literal
with the given type.

 * @param resultClass type of the null
literal

 * @return null expression literal

 */

 <T> Expression<T> nullLiteral(Class<T>
resultClass);





 //parameters:



 /**

 * Create a parameter expression.

 * @param paramClass parameter class

 * @return parameter expression

 */

 <T> ParameterExpression<T>
parameter(Class<T> paramClass);



 /**

 * Create a parameter expression with the
given name.

 * @param paramClass parameter class

 * @param name name that can be used to refer
to

 * the parameter

 * @return parameter expression

 */

 <T> ParameterExpression<T>
parameter(Class<T> paramClass,

 String name);





 //collection operations:



 /**

 * Create a predicate that tests whether a
collection is empty.

 * @param collection expression

 * @return is-empty predicate

 */

 <C extends Collection<?>> Predicate isEmpty(

 Expression<C> collection);



 /**

 * Create a predicate that tests whether a
collection is

 * not empty.

 * @param collection expression

 * @return is-not-empty predicate

 */

 <C extends Collection<?>> Predicate
isNotEmpty(

 Expression<C> collection);



 /**

 * Create an expression that tests the size
of a collection.

 * @param collection expression

 * @return size expression

 */

 <C extends Collection<?>>
Expression<Integer> size(

 Expression<C> collection);



 /**

 * Create an expression that tests the size
of a collection.

 * @param collection collection

 * @return size expression

 */

 <C extends Collection<?>>
Expression<Integer> size(C collection);



 /**

 * Create a predicate that tests whether an
element is

 * a member of a collection.

 * If the collection is empty, the predicate
will be false.

 * @param elem element expression

 * @param collection expression

 * @return is-member predicate

 */

 <E, C extends Collection<E>> Predicate
isMember(

 Expression<E> elem, Expression<C>
collection);



 /**

 * Create a predicate that tests whether an
element is

 * a member of a collection.

 * If the collection is empty, the predicate
will be false.

 * @param elem element

 * @param collection expression

 * @return is-member predicate

 */

 <E, C extends Collection<E>> Predicate
isMember(

 E elem, Expression<C> collection);



 /**

 * Create a predicate that tests whether an
element is

 * not a member of a collection.

 * If the collection is empty, the predicate
will be true.

 * @param elem element expression

 * @param collection expression

 * @return is-not-member predicate

 */

 <E, C extends Collection<E>> Predicate
isNotMember(

 Expression<E> elem, Expression<C>
collection);



 /**

 * Create a predicate that tests whether an
element is

 * not a member of a collection.

 * If the collection is empty, the predicate
will be true.

 * @param elem element

 * @param collection expression

 * @return is-not-member predicate

 */

 <E, C extends Collection<E>> Predicate
isNotMember(

 E elem, Expression<C> collection);

















 //get the values and keys collections of the
Map, which may then

 //be passed to size(), isMember(),
isEmpty(), etc



 /**

 * Create an expression that returns the
values of a map.

 * @param map map

 * @return collection expression

 */

 <V, M extends Map<?, V>>
Expression<Collection<V>> values(M map);



 /**

 * Create an expression that returns the keys
of a map.

 * @param map map

 * @return set expression

 */

 <K, M extends Map<K, ?>> Expression<Set<K>>
keys(M map);





 //string functions:



 /**

 * Create a predicate for testing whether the
expression

 * satisfies the given pattern.

 * @param x string expression

 * @param pattern string expression

 * @return like predicate

 */

 Predicate like(Expression<String> x,
Expression<String> pattern);



 /**

 * Create a predicate for testing whether the
expression

 * satisfies the given pattern.

 * @param x string expression

 * @param pattern string

 * @return like predicate

 */

 Predicate like(Expression<String> x, String
pattern);



 /**

 * Create a predicate for testing whether the
expression

 * satisfies the given pattern.

 * @param x string expression

 * @param pattern string expression

 * @param escapeChar escape character
expression

 * @return like predicate

 */

 Predicate like(Expression<String> x,

 Expression<String> pattern,

 Expression<Character> escapeChar);





















 /**

 * Create a predicate for testing whether the
expression

 * satisfies the given pattern.

 * @param x string expression

 * @param pattern string expression

 * @param escapeChar escape character

 * @return like predicate

 */

 Predicate like(Expression<String> x,

 Expression<String> pattern,

 char escapeChar);



 /**

 * Create a predicate for testing whether the
expression

 * satisfies the given pattern.

 * @param x string expression

 * @param pattern string

 * @param escapeChar escape character
expression

 * @return like predicate

 */

 Predicate like(Expression<String> x,

 String pattern,

 Expression<Character> escapeChar);



 /**

 * Create a predicate for testing whether the
expression

 * satisfies the given pattern.

 * @param x string expression

 * @param pattern string

 * @param escapeChar escape character

 * @return like predicate

 */

 Predicate like(Expression<String> x,

 String pattern,

 char escapeChar);



 /**

 * Create a predicate for testing whether the
expression

 * does not satisfy the given pattern.

 * @param x string expression

 * @param pattern string expression

 * @return not-like predicate

 */

 Predicate notLike(Expression<String> x,

 Expression<String> pattern);





 /**

 * Create a predicate for testing whether the
expression

 * does not satisfy the given pattern.

 * @param x string expression

 * @param pattern string

 * @return not-like predicate

 */

 Predicate notLike(Expression<String> x,
String pattern);









 /**

 * Create a predicate for testing whether the
expression

 * does not satisfy the given pattern.

 * @param x string expression

 * @param pattern string expression

 * @param escapeChar escape character
expression

 * @return not-like predicate

 */

 Predicate notLike(Expression<String> x,

 Expression<String> pattern,

 Expression<Character> escapeChar);



 /**

 * Create a predicate for testing whether the
expression

 * does not satisfy the given pattern.

 * @param x string expression

 * @param pattern string expression

 * @param escapeChar escape character

 * @return not-like predicate

 */

 Predicate notLike(Expression<String> x,

 Expression<String> pattern,

 char escapeChar);



 /**

 * Create a predicate for testing whether the
expression

 * does not satisfy the given pattern.

 * @param x string expression

 * @param pattern string

 * @param escapeChar escape character
expression

 * @return not-like predicate

 */

 Predicate notLike(Expression<String> x,

 String pattern,

 Expression<Character> escapeChar);



 /**

 * Create a predicate for testing whether the
expression

 * does not satisfy the given pattern.

 * @param x string expression

 * @param pattern string

 * @param escapeChar escape character

 * @return not-like predicate

 */

 Predicate notLike(Expression<String> x,

 String pattern,

 char escapeChar);



 /**

 * Create an expression for string
concatenation.

 * @param x string expression

 * @param y string expression

 * @return expression corresponding to
concatenation

 */

 Expression<String> concat(Expression<String>
x,

 Expression<String> y);







 /**

 * Create an expression for string
concatenation.

 * @param x string expression

 * @param y string

 * @return expression corresponding to
concatenation

 */

 Expression<String> concat(Expression<String>
x, String y);



 /**

 * Create an expression for string
concatenation.

 * @param x string

 * @param y string expression

 * @return expression corresponding to
concatenation

 */

 Expression<String> concat(String x,
Expression<String> y);



 /**

 * Create an expression for substring
extraction.

 * Extracts a substring starting at the
specified position

 * through to end of the string.

 * First position is 1.

 * @param x string expression

 * @param from start position expression

 * @return expression corresponding to
substring extraction

 */

 Expression<String>
substring(Expression<String> x,

 Expression<Integer> from);



 /**

 * Create an expression for substring
extraction.

 * Extracts a substring starting at the
specified position

 * through to end of the string.

 * First position is 1.

 * @param x string expression

 * @param from start position

 * @return expression corresponding to
substring extraction

 */

 Expression<String>
substring(Expression<String> x, int from);



 /**

 * Create an expression for substring
extraction.

 * Extracts a substring of given length
starting at the

 * specified position.

 * First position is 1.

 * @param x string expression

 * @param from start position expression

 * @param len length expression

 * @return expression corresponding to
substring extraction

 */

 Expression<String>
substring(Expression<String> x,

 Expression<Integer> from,

 Expression<Integer> len);



 /**

 * Create an expression for substring
extraction.

 * Extracts a substring of given length
starting at the

 * specified position.

 * First position is 1.

 * @param x string expression

 * @param from start position

 * @param len length

 * @return expression corresponding to
substring extraction

 */

 Expression<String>
substring(Expression<String> x,

 int from,

 int len);





 public static enum Trimspec \{

 /**

 * Trim from leading end.

 */

 LEADING,



 /**

 * Trim from trailing end.

 */

 TRAILING,



 /**

 * Trim from both ends.

 */

 BOTH

 }



 /**

 * Create expression to trim blanks from both
ends of

 * a string.

 * @param x expression for string to trim

 * @return trim expression

 */

 Expression<String> trim(Expression<String>
x);





 /**

 * Create expression to trim blanks from a
string.

 * @param ts trim specification

 * @param x expression for string to trim

 * @return trim expression

 */

 Expression<String> trim(Trimspec ts,
Expression<String> x);



 /**

 * Create expression to trim character from
both ends of

 * a string.

 * @param t expression for character to be
trimmed

 * @param x expression for string to trim

 * @return trim expression

 */

 Expression<String>
trim(Expression<Character> t,

 Expression<String> x);



 /**

 * Create expression to trim character from a
string.

 * @param ts trim specification

 * @param t expression for character to be
trimmed

 * @param x expression for string to trim

 * @return trim expression

 */

 Expression<String> trim(Trimspec ts,

 Expression<Character> t,

 Expression<String> x);



 /**

 * Create expression to trim character from
both ends of

 * a string.

 * @param t character to be trimmed

 * @param x expression for string to trim

 * @return trim expression

 */

 Expression<String> trim(char t,
Expression<String> x);



 /**

 * Create expression to trim character from a
string.

 * @param ts trim specification

 * @param t character to be trimmed

 * @param x expression for string to trim

 * @return trim expression

 */

 Expression<String> trim(Trimspec ts,

 char t,

 Expression<String> x);



 /**

 * Create expression for converting a string
to lowercase.

 * @param x string expression

 * @return expression to convert to lowercase

 */

 Expression<String> lower(Expression<String>
x);



 /**

 * Create expression for converting a string
to uppercase.

 * @param x string expression

 * @return expression to convert to uppercase

 */

 Expression<String> upper(Expression<String>
x);



 /**

 * Create expression to return length of a
string.

 * @param x string expression

 * @return length expression

 */

 Expression<Integer>
length(Expression<String> x);















 /**

 * Create expression to locate the position
of one string

 * within another, returning position of
first character

 * if found.

 * The first position in a string is denoted
by 1. If the

 * string to be located is not found, 0 is
returned.

 * @param x expression for string to be
searched

 * @param pattern expression for string to be
located

 * @return expression corresponding to
position

 */

 Expression<Integer>
locate(Expression<String> x,

 Expression<String> pattern);



 /**

 * Create expression to locate the position
of one string

 * within another, returning position of
first character

 * if found.

 * The first position in a string is denoted
by 1. If the

 * string to be located is not found, 0 is
returned.

 * @param x expression for string to be
searched

 * @param pattern string to be located

 * @return expression corresponding to
position

 */

 Expression<Integer>
locate(Expression<String> x, String pattern);



 /**

 * Create expression to locate the position
of one string

 * within another, returning position of
first character

 * if found.

 * The first position in a string is denoted
by 1. If the

 * string to be located is not found, 0 is
returned.

 * @param x expression for string to be
searched

 * @param pattern expression for string to be
located

 * @param from expression for position at
which to start search

 * @return expression corresponding to
position

 */

 Expression<Integer>
locate(Expression<String> x,

 Expression<String> pattern,

 Expression<Integer> from);



 /**

 * Create expression to locate the position
of one string

 * within another, returning position of
first character

 * if found.

 * The first position in a string is denoted
by 1. If the

 * string to be located is not found, 0 is
returned.

 * @param x expression for string to be
searched

 * @param pattern string to be located

 * @param from position at which to start
search

 * @return expression corresponding to
position

 */

 Expression<Integer>
locate(Expression<String> x,

 String pattern,

 int from);











 // Date/time/timestamp functions:



 /**

 * Create expression to return current date.

 * @return expression for current date

 */

 Expression<java.sql.Date> currentDate();



 /**

 * Create expression to return current
timestamp.

 * @return expression for current timestamp

 */

 Expression<java.sql.Timestamp>
currentTimestamp();



 /**

 * Create expression to return current time.

 * @return expression for current time

 */

 Expression<java.sql.Time> currentTime();





 //in builders:



 /**

 * Interface used to build in predicates.

 */

 public static interface In<T> extends
Predicate \{



 /**

 * Return the expression to be tested against
the

 * list of values.

 * @return expression

 */

 Expression<T> getExpression();



 /**

 * Add to list of values to be tested
against.

 * @param value value

 * @return in predicate

 */

 In<T> value(T value);



 /**

 * Add to list of values to be tested
against.

 * @param value expression

 * @return in predicate

 */

 In<T> value(Expression<? extends T> value);

 }



 /**

 * Create predicate to test whether given
expression

 * is contained in a list of values.

 * @param expression to be tested against
list of values

 * @return in predicate

 */

 <T> In<T> in(Expression<? extends T>
expression);





 // coalesce, nullif:



 /**

 * Create an expression that returns null if
all its arguments

 * evaluate to null, and the value of the
first non-null argument

 * otherwise.

 * @param x expression

 * @param y expression

 * @return coalesce expression

 */

 <Y> Expression<Y> coalesce(Expression<?
extends Y> x,

 Expression<? extends Y> y);



 /**

 * Create an expression that returns null if
all its arguments

 * evaluate to null, and the value of the
first non-null argument

 * otherwise.

 * @param x expression

 * @param y value

 * @return coalesce expression

 */

 <Y> Expression<Y> coalesce(Expression<?
extends Y> x, Y y);



 /**

 * Create an expression that tests whether
its argument are

 * equal, returning null if they are and the
value of the

 * first expression if they are not.

 * @param x expression

 * @param y expression

 * @return nullif expression

 */

 <Y> Expression<Y> nullif(Expression<Y> x,
Expression<?> y);



 /**

 * Create an expression that tests whether
its argument are

 * equal, returning null if they are and the
value of the

 * first expression if they are not.

 * @param x expression

 * @param y value

 * @return nullif expression

 */

 <Y> Expression<Y> nullif(Expression<Y> x, Y
y);





 // coalesce builder:



 /**

 * Interface used to build coalesce
expressions.

 *

 * A coalesce expression is equivalent to a
case expression

 * that returns null if all its arguments
evaluate to null,

 * and the value of its first non-null
argument otherwise.

 */

 public static interface Coalesce<T> extends
Expression<T> \{











 /**

 * Add an argument to the coalesce
expression.

 * @param value value

 * @return coalesce expression

 */

 Coalesce<T> value(T value);



 /**

 * Add an argument to the coalesce
expression.

 * @param value expression

 * @return coalesce expression

 */

 Coalesce<T> value(Expression<? extends T>
value);

 }



 /**

 * Create a coalesce expression.

 * @return coalesce expression

 */

 <T> Coalesce<T> coalesce();







 //case builders:



 /**

 * Interface used to build simple case
expressions.

 * Case conditions are evaluated in the order
in which

 * they are specified.

 */

 public static interface SimpleCase<C,R>
extends Expression<R> \{



 /**

 * Return the expression to be tested against
the

 * conditions.

 * @return expression

 */

 Expression<C> getExpression();



 /**

 * Add a when/then clause to the case
expression.

 * @param condition "when" condition

 * @param result "then" result value

 * @return simple case expression

 */

 SimpleCase<C, R> when(C condition, R
result);



 /**

 * Add a when/then clause to the case
expression.

 * @param condition "when" condition

 * @param result "then" result expression

 * @return simple case expression

 */

 SimpleCase<C, R> when(C condition,

 Expression<? extends R> result);









 /**

 * Add an "else" clause to the case
expression.

 * @param result "else" result

 * @return expression

 */

 Expression<R> otherwise(R result);



 /**

 * Add an "else" clause to the case
expression.

 * @param result "else" result expression

 * @return expression

 */

 Expression<R> otherwise(Expression<? extends
R> result);

 }



 /**

 * Create a simple case expression.

 * @param expression to be tested against the
case conditions

 * @return simple case expression

 */

 <C, R> SimpleCase<C,R> selectCase(

 Expression<? extends C> expression);





 /**

 * Interface used to build general case
expressions.

 * Case conditions are evaluated in the order
in which

 * they are specified.

 */

 public static interface Case<R> extends
Expression<R> \{



 /**

 * Add a when/then clause to the case
expression.

 * @param condition "when" condition

 * @param result "then" result value

 * @return general case expression

 */

 Case<R> when(Expression<Boolean> condition,
R result);



 /**

 * Add a when/then clause to the case
expression.

 * @param condition "when" condition

 * @param result "then" result expression

 * @return general case expression

 */

 Case<R> when(Expression<Boolean> condition,

 Expression<? extends R> result);





 /**

 * Add an "else" clause to the case
expression.

 * @param result "else" result

 * @return expression

 */

 Expression<R> otherwise(R result);









 /**

 * Add an "else" clause to the case
expression.

 * @param result "else" result expression

 * @return expression

 */

 Expression<R> otherwise(Expression<? extends
R> result);

 }



 /**

 * Create a general case expression.

 * @return general case expression

 */

 <R> Case<R> selectCase();





 /**

 * Create an expression for the execution of
a database

 * function.

 * @param name function name

 * @param type expected result type

 * @param args function arguments

 * @return expression

 */

 <T> Expression<T> function(String name,

 Class<T> type,

 Expression<?>... args);





//methods for downcasting:





 /**

 * Downcast Join object to the specified
type.

 * @param join Join object

 * @param type type to be downcast to

 * @return Join object of the specified type

 */

 <X, T, V extends T> Join<X, V>

 treat(Join<X, T> join, Class<V> type);



 /**

 * Downcast CollectionJoin object to the
specified type.

 * @param join CollectionJoin object

 * @param type type to be downcast to

 * @return CollectionJoin object of the
specified type

 */

 <X, T, E extends T> CollectionJoin<X, E>

 treat(CollectionJoin<X, T> join, Class<E>
type);



 /**

 * Downcast SetJoin object to the specified
type.

 * @param join SetJoin object

 * @param type type to be downcast to

 * @return SetJoin object of the specified
type

 */

 <X, T, E extends T> SetJoin<X, E>

 treat(SetJoin<X, T> join, Class<E> type);





 /**

 * Downcast ListJoin object to the specified
type.

 * @param join ListJoin object

 * @param type type to be downcast to

 * @return ListJoin object of the specified
type

 */

 <X, T, E extends T> ListJoin<X, E>

 treat(ListJoin<X, T> join, Class<E> type);



 /**

 * Downcast MapJoin object to the specified
type.

 * @param join MapJoin object

 * @param type type to be downcast to

 * @return MapJoin object of the specified
type

 */

 <X, K, T, V extends T> MapJoin<X, K, V>

 treat(MapJoin<X, K, T> join, Class<V> type);



 /**

 * Downcast Path object to the specified
type.

 * @param path path

 * @param type type to be downcast to

 * @return Path object of the specified type

 */

 <X, T extends X> Path<T> treat(Path<X> path,
Class<T> type);



 /**

 * Downcast Root object to the specified
type.

 * @param root root

 * @param type type to be downcast to

 * @return Root object of the specified type

 */

 <X, T extends X> Root<T> treat(Root<X> root,
Class<T> type);

}

==== CommonAbstractCriteria Interface



package javax.persistence.criteria;



/**

 * The CommonAbstractCriteria interface
defines functionality

 * that is common to both top-level criteria
queries and subqueries

 * as well as to update and delete criteria
operations.

 * It is not intended to be used directly in
query construction.

 *

 * Note that criteria queries and criteria
update and delete

 * operations are typed differently.

 * Criteria queries are typed according to
the query result type.

 * Update and delete operations are typed
according to the target

 * of the update or delete.*

 */

public interface CommonAbstractCriteria \{



 /**

 * Create a subquery of the query.

 * @param type the subquery result type

 * @return subquery

 */

 <U> Subquery<U> subquery(Class<U> type);



 /**

 * Return the predicate that corresponds to
the where clause

 * restriction(s), or null if no restrictions
have been

 * specified.

 * @return where clause predicate

 */

 Predicate getRestriction();

}



==== AbstractQuery Interface



package javax.persistence.criteria;



import java.util.List;

import java.util.Set;

import
javax.persistence.metamodel.EntityType;



/**

 * The AbstractQuery interface defines
functionality that is common

 * to both top-level queries and subqueries.

 * It is not intended to be used directly in
query construction.

 *

 * All queries must have:

 * a set of root entities (which may in turn
own joins)

 * All queries may have:

 * a conjunction of restrictions.

 *

 * @param <T> type of the result

 */

public interface AbstractQuery<T> extends
CommonAbstractCriteria \{



 /**

 * Create and add a query root corresponding
to the given entity,

 * forming a cartesian product with any
existing roots.

 * @param entityClass the entity class

 * @return query root corresponding to the
given entity

 */

 <X> Root<X> from(Class<X> entityClass);



 /**

 * Create and add a query root corresponding
to the given entity,

 * forming a cartesian product with any
existing roots.

 * @param entity metamodel entity
representing the entity

 * of type X

 * @return query root corresponding to the
given entity

 */

 <X> Root<X> from(EntityType<X> entity);



 /**

 * Modify the query to restrict the query
results according

 * to the specified boolean expression.

 * Replaces the previously added
restriction(s), if any.

 * @param restriction a simple or compound
boolean expression

 * @return the modified query

 */

 AbstractQuery<T> where(Expression<Boolean>
restriction);



 /**

 * Modify the query to restrict the query
results according

 * to the conjunction of the specified
restriction predicates.

 * Replaces the previously added
restriction(s), if any.

 * If no restrictions are specified, any
previously added

 * restrictions are simply removed.

 * @param restrictions zero or more
restriction predicates

 * @return the modified query

 */

 AbstractQuery<T> where(Predicate...
restrictions);





 /**

 * Specify the expressions that are used to
form groups over

 * the query results.

 * Replaces the previous specified grouping
expressions, if any.

 * If no grouping expressions are specified,
any previously

 * added grouping expressions are simply
removed.

 * @param grouping zero or more grouping
expressions

 * @return the modified query

 */

 AbstractQuery<T> groupBy(Expression<?>...
grouping);



 /**

 * Specify the expressions that are used to
form groups over

 * the query results.

 * Replaces the previous specified grouping
expressions, if any.

 * If no grouping expressions are specified,
any previously

 * added grouping expressions are simply
removed.

 * @param grouping list of zero or more
grouping expressions

 * @return the modified query

 */

 AbstractQuery<T> groupBy(List<Expression<?>>
grouping);



 /**

 * Specify a restriction over the groups of
the query.

 * Replaces the previous having
restriction(s), if any.

 * @param restriction a simple or compound
boolean expression

 * @return the modified query

 */

 AbstractQuery<T> having(Expression<Boolean>
restriction);



 /**

 * Specify restrictions over the groups of
the query

 * according the conjunction of the specified
restriction

 * predicates.

 * Replaces the previously added having
restriction(s), if any.

 * If no restrictions are specified, any
previously added

 * restrictions are simply removed.

 * @param restrictions zero or more
restriction predicates

 * @return the modified query

 */

 AbstractQuery<T> having(Predicate...
restrictions);



 /**

 * Specify whether duplicate query results
will be eliminated.

 * A true value will cause duplicates to be
eliminated.

 * A false value will cause duplicates to be
retained.

 * If distinct has not been specified,
duplicate results must

 * be retained.

 * @param distinct boolean value specifying
whether duplicate

 * results must be eliminated from the query
result or

 * whether they must be retained

 * @return the modified query

 */

 AbstractQuery<T> distinct(boolean distinct);











 /**

 * Return the query roots. These are the
roots that have

 * been defined for the CriteriaQuery or
Subquery itself,

 * including any subquery roots defined as a
result of

 * correlation. Returns empty set if no roots
have been defined.

 * Modifications to the set do not affect the
query.

 * @return the set of query roots

 */

 Set<Root<?>> getRoots();



 /**

 * Return the selection of the query, or null
if no selection

 * has been set.

 * @return selection item

 */

 Selection<T> getSelection();



 /**

 * Return a list of the grouping expressions.
Returns empty

 * list if no grouping expressions have been
specified.

 * Modifications to the list do not affect
the query.

 * @return the list of grouping expressions

 */

 List<Expression<?>> getGroupList();



 /**

 * Return the predicate that corresponds to
the restriction(s)

 * over the grouping items, or null if no
restrictions have

 * been specified.

 * @return having clause predicate

 */

 Predicate getGroupRestriction();



 /**

 * Return whether duplicate query results
must be eliminated or

 * retained.

 * @return boolean indicating whether
duplicate query results

 * must be eliminated

 */

 boolean isDistinct();



 /**

 * Return the result type of the query or
subquery.

 * If a result type was specified as an
argument to the

 * createQuery or subquery method, that type
will be returned.

 * If the query was created using the
createTupleQuery

 * method, the result type is Tuple.

 * Otherwise, the result type is Object.

 * @return result type

 */

 Class<T> getResultType();

}

==== [[a8857]]CriteriaQuery Interface

package javax.persistence.criteria;



import java.util.List;

import java.util.Set;



/**

 * The CriteriaQuery interface defines
functionality that is specific

 * to top-level queries.

 *

 * @param <T> type of the defined result

 */

public interface CriteriaQuery<T> extends
AbstractQuery<T> \{



 /**

 * Specify the item that is to be returned in
the query result.

 * Replaces the previously specified
selection(s), if any.

 *

 * Note: Applications using the string-based
API may need to

 * specify the type of the select item when
it results from

 * a get or join operation and the query
result type is

 * specified. For example:

 *

 * CriteriaQuery<String> q =
cb.createQuery(String.class);

 * Root<Order> order = q.from(Order.class);

 *
q.select(order.get("shippingAddress").<String>get("state"));

 *

 * CriteriaQuery<Product> q2 =
cb.createQuery(Product.class);

 * q2.select(q2.from(Order.class)

 * .join("items")

 * .<Item,Product>join("product"));

 *

 * @param selection selection specifying the
item that

 * is to be returned in the query result

 * @return the modified query

 * @throws IllegalArgumentException if the
selection is

 * a compound selection and more than one
selection

 * item has the same assigned alias

 */

 CriteriaQuery<T> select(Selection<? extends
T> selection);



 /**

 * Specify the selection items that are to be
returned in the

 * query result.

 * Replaces the previously specified
selection(s), if any.

 *

 * The type of the result of the query
execution depends on

 * the specification of the type of the
criteria query object

 * created as well as the arguments to the
multiselect method.

 * An argument to the multiselect method must
not be a tuple-

 * or array-valued compound selection item.

 *

 * The semantics of this method are as
follows:

 *

 * If the type of the criteria query is
CriteriaQuery<Tuple>

 * (i.e., a criteria query object created by
either the

 * createTupleQuery method or by passing a
Tuple class argument

 * to the createQuery method), a Tuple object
corresponding to

 * the arguments of the multiselect method,
in the specified

 * order, will be instantiated and returned
for each row that

 * results from the query execution.

 *

 * If the type of the criteria query is
CriteriaQuery<X> for

 * some user-defined class X (i.e., a
criteria query object

 * created by passing a X class argument to
the createQuery

 * method), the arguments to the multiselect
method will be

 * passed to the X constructor and an
instance of type X will be

 * returned for each row.

 *

 * If the type of the criteria query is
CriteriaQuery<X[]> for

 * some class X, an instance of type X[] will
be returned for

 * each row. The elements of the array will
correspond to the

 * arguments of the multiselect method, in
the specified order.

 *

 * If the type of the criteria query is
CriteriaQuery<Object>

 * or if the criteria query was created
without specifying a

 * type, and only a single argument is passed
to the multiselect

 * method, an instance of type Object will be
returned for

 * each row.

 *

 * If the type of the criteria query is
CriteriaQuery<Object>

 * or if the criteria query was created
without specifying a

 * type, and more than one argument is passed
to the multiselect

 * method, an instance of type Object[] will
be instantiated

 * and returned for each row. The elements of
the array will

 * correspond to the arguments to the
multiselect method, in the

 * specified order.

 *

 * @param selections selection items
corresponding to the

 * results to be returned by the query

 * @return the modified query

 * @throws IllegalArgumentException if a
selection item is

 * not valid or if more than one selection
item has

 * the same assigned alias

 */

 CriteriaQuery<T> multiselect(Selection<?>...
selections);



 /**

 * Specify the selection items that are to be
returned in the

 * query result.

 * Replaces the previously specified
selection(s), if any.

 *

 * The type of the result of the query
execution depends on

 * the specification of the type of the
criteria query object

 * created as well as the argument to the
multiselect method.

 * An element of the list passed to the
multiselect method

 * must not be a tuple- or array-valued
compound selection item.

 *

 * The semantics of this method are as
follows:

 *

 * If the type of the criteria query is
CriteriaQuery<Tuple>

 * (i.e., a criteria query object created by
either the

 * createTupleQuery method or by passing a
Tuple class argument

 * to the createQuery method), a Tuple object
corresponding to

 * the elements of the list passed to the
multiselect method,

 * in the specified order, will be
instantiated and returned

 * for each row that results from the query
execution.

 *

 * If the type of the criteria query is
CriteriaQuery<X> for

 * some user-defined class X (i.e., a
criteria query object

 * created by passing a X class argument to
the createQuery

 * method), the elements of the list passed
to the multiselect

 * method will be passed to the X constructor
and an instance

 * of type X will be returned for each row.

 *

 * If the type of the criteria query is
CriteriaQuery<X[]> for

 * some class X, an instance of type X[] will
be returned for

 * each row. The elements of the array will
correspond to the

 * elements of the list passed to the
multiselect method, in

 * the specified order.

 *

 * If the type of the criteria query is
CriteriaQuery<Object>

 * or if the criteria query was created
without specifying a

 * type, and the list passed to the
multiselect method contains

 * only a single element, an instance of type
Object will be

 * returned for each row.

 *

 * If the type of the criteria query is
CriteriaQuery<Object>

 * or if the criteria query was created
without specifying a

 * type, and the list passed to the
multiselect method contains

 * more than one element, an instance of type
Object[] will be

 * instantiated and returned for each row.
The elements of the

 * array will correspond to the elements of
the list passed to

 * the multiselect method, in the specified
order.

 *

 * @param selectionList list of selection
items corresponding

 * to the results to be returned by the query

 * @return the modified query

 * @throws IllegalArgumentException if a
selection item is

 * not valid or if more than one selection
item has

 * the same assigned alias

 */

 CriteriaQuery<T>
multiselect(List<Selection<?>> selectionList);



 /**

 * Modify the query to restrict the query
result according

 * to the specified boolean expression.

 * Replaces the previously added
restriction(s), if any.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param restriction a simple or compound
boolean expression

 * @return the modified query

 */

 CriteriaQuery<T> where(Expression<Boolean>
restriction);



 /**

 * Modify the query to restrict the query
result according

 * to the conjunction of the specified
restriction predicates.

 * Replaces the previously added
restriction(s), if any.

 * If no restrictions are specified, any
previously added

 * restrictions are simply removed.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param restrictions zero or more
restriction predicates

 * @return the modified query

 */

 CriteriaQuery<T> where(Predicate...
restrictions);



 /**

 * Specify the expressions that are used to
form groups over

 * the query results.

 * Replaces the previous specified grouping
expressions, if any.

 * If no grouping expressions are specified,
any previously

 * added grouping expressions are simply
removed.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param grouping zero or more grouping
expressions

 * @return the modified query

 */

 CriteriaQuery<T> groupBy(Expression<?>...
grouping);



 /**

 * Specify the expressions that are used to
form groups over

 * the query results.

 * Replaces the previous specified grouping
expressions, if any.

 * If no grouping expressions are specified,
any previously

 * added grouping expressions are simply
removed.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param grouping list of zero or more
grouping expressions

 * @return the modified query

 */

 CriteriaQuery<T> groupBy(List<Expression<?>>
grouping);



 /**

 * Specify a restriction over the groups of
the query.

 * Replaces the previous having
restriction(s), if any.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param restriction a simple or compound
boolean expression

 * @return the modified query

 */

 CriteriaQuery<T> having(Expression<Boolean>
restriction);



 /**

 * Specify restrictions over the groups of
the query

 * according the conjunction of the specified
restriction

 * predicates.

 * Replaces the previously added having
restriction(s), if any.

 * If no restrictions are specified, any
previously added

 * restrictions are simply removed.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param restrictions zero or more
restriction predicates

 * @return the modified query

 */

 CriteriaQuery<T> having(Predicate...
restrictions);



 /**

 * Specify the ordering expressions that are
used to

 * order the query results.

 * Replaces the previous ordering
expressions, if any.

 * If no ordering expressions are specified,
the previous

 * ordering, if any, is simply removed, and
results will

 * be returned in no particular order.

 * The left-to-right sequence of the ordering
expressions

 * determines the precedence, whereby the
leftmost has highest

 * precedence.

 * @param o zero or more ordering expressions

 * @return the modified query

 */

 CriteriaQuery<T> orderBy(Order... o);



 /**

 * Specify the ordering expressions that are
used to

 * order the query results.

 * Replaces the previous ordering
expressions, if any.

 * If no ordering expressions are specified,
the previous

 * ordering, if any, is simply removed, and
results will

 * be returned in no particular order.

 * The order of the ordering expressions in
the list

 * determines the precedence, whereby the
first element in the

 * list has highest precedence.

 * @param o list of zero or more ordering
expressions

 * @return the modified query

 */

 CriteriaQuery<T> orderBy(List<Order> o);



 /**

 * Specify whether duplicate query results
will be eliminated.

 * A true value will cause duplicates to be
eliminated.

 * A false value will cause duplicates to be
retained.

 * If distinct has not been specified,
duplicate results must

 * be retained.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param distinct boolean value specifying
whether duplicate

 * results must be eliminated from the query
result or

 * whether they must be retained

 * @return the modified query.

 */

 CriteriaQuery<T> distinct(boolean distinct);



 /**

 * Return the ordering expressions in order
of precedence.

 * Returns empty list if no ordering
expressions have been

 * specified.

 * Modifications to the list do not affect
the query.

 * @return the list of ordering expressions

 */

 List<Order> getOrderList();



 /**

 * Return the parameters of the query.
Returns empty set if

 * there are no parameters.

 * Modifications to the set do not affect the
query.

 * @return the query parameters

 */

 Set<ParameterExpression<?>> getParameters();

}



==== CriteriaUpdate Interface



package javax.persistence.criteria;



import
javax.persistence.metamodel.SingularAttribute;

import
javax.persistence.metamodel.EntityType;



/**

 * The CriteriaUpdate interface defines
functionality for performing

 * bulk update operations using the Criteria
API.

 *

 * Criteria API bulk update operations map
directly to database update

 * operations, bypassing any optimistic
locking checks. Portable

 * applications using bulk update operations
must manually update the

 * value of the version column, if desired,
and/or manually validate

 * the value of the version column.

 * The persistence context is not
synchronized with the result of the

 * bulk update.

 *

 * A CriteriaUpdate object must have a single
root.

 *

 * @param <T> the entity type that is the
target of the update

 */

public interface CriteriaUpdate<T> extends
CommonAbstractCriteria \{



 /**

 * Create and add a query root corresponding
to the entity

 * that is the target of the update.

 * A CriteriaUpdate object has a single root,
the entity that

 * is being updated.

 * @param entityClass the entity class

 * @return query root corresponding to the
given entity

 */

 Root<T> from(Class<T> entityClass);



 /**

 * Create and add a query root corresponding
to the entity

 * that is the target of the update.

 * A CriteriaUpdate object has a single root,
the entity that

 * is being updated.

 * @param entity metamodel entity
representing the entity

 * of type X

 * @return query root corresponding to the
given entity

 */

 Root<T> from(EntityType<T> entity);



 /**

 * Return the query root.

 * @return the query root

 */

 Root<T> getRoot();

















 /**

 * Update the value of the specified
attribute.

 * @param attribute attribute to be updated

 * @param value new value

 * @return the modified update query

 */

 <Y, X extends Y> CriteriaUpdate<T> set(

 SingularAttribute<? super T, Y> attribute,

 X value);





 /**

 * Update the value of the specified
attribute.

 * @param attribute attribute to be updated

 * @param value new value

 * @return the modified update query

 */

 <Y> CriteriaUpdate<T> set(

 SingularAttribute<? super T, Y> attribute,

 Expression<? extends Y> value);



 /**

 * Update the value of the specified
attribute.

 * @param attribute attribute to be updated

 * @param value new value

 * @return the modified update query

 */

 <Y, X extends Y> CriteriaUpdate<T>
set(Path<Y> attribute, X value);



 /**

 * Update the value of the specified
attribute.

 * @param attribute attribute to be updated

 * @param value new value

 * @return the modified update query

 */

 <Y> CriteriaUpdate<T> set(Path<Y> attribute,

 Expression<? extends Y> value);



 /**

 * Update the value of the specified
attribute.

 * @param attributeName name of the attribute
to be updated

 * @param value new value

 * @return the modified update query

 */

 CriteriaUpdate<T> set(String attributeName,
Object value);



 /**

 * Modify the update query to restrict the
target of the update

 * according to the specified boolean
expression.

 * Replaces the previously added
restriction(s), if any.

 * @param restriction a simple or compound
boolean expression

 * @return the modified update query

 */

 CriteriaUpdate<T> where(Expression<Boolean>
restriction);











 /**

 * Modify the update query to restrict the
target of the update

 * according to the conjunction of the
specified restriction

 * predicates.

 * Replaces the previously added
restriction(s), if any.

 * If no restrictions are specified, any
previously added

 * restrictions are simply removed.

 * @param restrictions zero or more
restriction predicates

 * @return the modified update query

 */

 CriteriaUpdate<T> where(Predicate...
restrictions);

}

==== CriteriaDelete Interface



package javax.persistence.criteria;



import
javax.persistence.metamodel.EntityType;



/**

 * The CriteriaDelete interface defines
functionality for performing

 * bulk delete operations using the Criteria
API

 *

 * Criteria API bulk delete operations map
directly to database

 * delete operations. The persistence context
is not synchronized

 * with the result of the bulk delete.

 *

 * A CriteriaDelete object must have a single
root.

 *

 * @param <T> the entity type that is the
target of the delete*

 */

public interface CriteriaDelete<T> extends
CommonAbstractCriteria \{



 /**

 * Create and add a query root corresponding
to the entity

 * that is the target of the delete.

 * A CriteriaDelete object has a single root,
the entity that

 * is being deleted.

 * @param entityClass the entity class

 * @return query root corresponding to the
given entity

 */

 Root<T> from(Class<T> entityClass);



 /**

 * Create and add a query root corresponding
to the entity

 * that is the target of the delete.

 * A CriteriaDelete object has a single root,
the entity that

 * is being deleted.

 * @param entity metamodel entity
representing the entity

 * of type X

 * @return query root corresponding to the
given entity

 */

 Root<T> from(EntityType<T> entity);



 /**

 * Return the query root.

 * @return the query root

 */

 Root<T> getRoot();



 /**

 * Modify the delete query to restrict the
target of the

 * deletion according to the specified
boolean expression.

 * Replaces the previously added
restriction(s), if any.

 * @param restriction a simple or compound
boolean expression

 * @return the modified delete query

 */

 CriteriaDelete<T> where(Expression<Boolean>
restriction);









 /**

 * Modify the delete query to restrict the
target of the

 * deletion according to the conjunction of
the specified

 * restriction predicates.

 * Replaces the previously added
restriction(s), if any.

 * If no restrictions are specified, any
previously added

 * restrictions are simply removed.

 * @param restrictions zero or more
restriction predicates

 * @return the modified delete query

 */

 CriteriaDelete<T> where(Predicate...
restrictions);

}





==== Subquery Interface



package javax.persistence.criteria;



import java.util.List;

import java.util.Set;



/**

 * The Subquery interface defines
functionality that is

 * specific to subqueries.

 *

 * A subquery has an expression as its
selection item.

 *

 * @param <T> the type of the selection item.

 */

public interface Subquery<T>

 extends AbstractQuery<T>, Expression<T> \{



 /**

 * Specify the item that is to be returned as
the subquery

 * result.

 * Replaces the previously specified
selection, if any.

 * @param expression expression specifying
the item that

 * is to be returned as the subquery result

 * @return the modified subquery

 */

 Subquery<T> select(Expression<T>
expression);



 /**

 * Modify the subquery to restrict the result
according

 * to the specified boolean expression.

 * Replaces the previously added
restriction(s), if any.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param restriction a simple or compound
boolean expression

 * @return the modified subquery

 */

 Subquery<T> where(Expression<Boolean>
restriction);



 /**

 * Modify the subquery to restrict the result
according

 * to the conjunction of the specified
restriction predicates.

 * Replaces the previously added
restriction(s), if any.

 * If no restrictions are specified, any
previously added

 * restrictions are simply removed.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param restrictions zero or more
restriction predicates

 * @return the modified subquery

 */

 Subquery<T> where(Predicate...
restrictions);

















 /**

 * Specify the expressions that are used to
form groups over

 * the subquery results.

 * Replaces the previous specified grouping
expressions, if any.

 * If no grouping expressions are specified,
any previously

 * added grouping expressions are simply
removed.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param grouping zero or more grouping
expressions

 * @return the modified subquery

 */

 Subquery<T> groupBy(Expression<?>...
grouping);



 /**

 * Specify the expressions that are used to
form groups over

 * the subquery results.

 * Replaces the previous specified grouping
expressions, if any.

 * If no grouping expressions are specified,
any previously

 * added grouping expressions are simply
removed.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param grouping list of zero or more
grouping expressions

 * @return the modified subquery

 */

 Subquery<T> groupBy(List<Expression<?>>
grouping);



 /**

 * Specify a restriction over the groups of
the subquery.

 * Replaces the previous having
restriction(s), if any.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param restriction a simple or compound
boolean expression

 * @return the modified subquery

 */

 Subquery<T> having(Expression<Boolean>
restriction);



 /**

 * Specify restrictions over the groups of
the subquery

 * according the conjunction of the specified
restriction

 * predicates.

 * Replaces the previously added having
restriction(s), if any.

 * If no restrictions are specified, any
previously added

 * restrictions are simply removed.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param restrictions zero or more
restriction predicates

 * @return the modified subquery

 */

 Subquery<T> having(Predicate...
restrictions);





















 /**

 * Specify whether duplicate query results
will be eliminated.

 * A true value will cause duplicates to be
eliminated.

 * A false value will cause duplicates to be
retained.

 * If distinct has not been specified,
duplicate results must

 * be retained.

 * This method only overrides the return type
of the

 * corresponding AbstractQuery method.

 * @param distinct boolean value specifying
whether duplicate

 * results must be eliminated from the
subquery result or

 * whether they must be retained

 * @return the modified subquery.

 */

 Subquery<T> distinct(boolean distinct);



 /**

 * Create a subquery root correlated to a
root of the

 * enclosing query.

 * @param parentRoot a root of the containing
query

 * @return subquery root

 */

 <Y> Root<Y> correlate(Root<Y> parentRoot);



 /**

 * Create a subquery join object correlated
to a join object

 * of the enclosing query.

 * @param parentJoin join object of the
containing query

 * @return subquery join

 */

 <X, Y> Join<X, Y> correlate(Join<X, Y>
parentJoin);



 /**

 * Create a subquery collection join object
correlated to a

 * collection join object of the enclosing
query.

 * @param parentCollection join object of the
containing query

 * @return subquery join

 */

 <X, Y> CollectionJoin<X, Y> correlate(

 CollectionJoin<X, Y> parentCollection);



 /**

 * Create a subquery set join object
correlated to a set join

 * object of the enclosing query.

 * @param parentSet join object of the
containing query

 * @return subquery join

 */

 <X, Y> SetJoin<X, Y> correlate(SetJoin<X, Y>
parentSet);



 /**

 * Create a subquery list join object
correlated to a list join

 * object of the enclosing query.

 * @param parentList join object of the
containing query

 * @return subquery join

 */

 <X, Y> ListJoin<X, Y> correlate(ListJoin<X,
Y> parentList);









 /**

 * Create a subquery map join object
correlated to a map join

 * object of the enclosing query.

 * @param parentMap join object of the
containing query

 * @return subquery join

 */

 <X, K, V> MapJoin<X, K, V>
correlate(MapJoin<X, K, V> parentMap);



 /**

 * Return the query of which this is a
subquery.

 * @return the enclosing query or subquery

 */

 AbstractQuery<?> getParent();



 /**

 * Return the query of which this is a
subquery.

 * This may be a CriteriaQuery,
CriteriaUpdate, CriteriaDelete,

 * or a Subquery.

 * @return the enclosing query or subquery

 */

 CommonAbstractCriteria getContainingQuery();



 /**

 * Return the selection expression.

 * @return the item to be returned in the
subquery result

 */

 Expression<T> getSelection();



 /**

 * Return the correlated joins of the
subquery (Join objects

 * obtained as a result of the use of the
correlate method).

 * Returns empty set if the subquery has no
correlated

 * joins.

 * Modifications to the set do not affect the
query.

 * @return the correlated joins of the
subquery

 */

 Set<Join<?, ?>> getCorrelatedJoins();

}

==== Selection Interface



package javax.persistence.criteria;



import javax.persistence.TupleElement;

import java.util.List;



/**

 * The Selection interface defines an item
that is to be

 * returned in a query result.

 *

 * @param <X> the type of the selection item

 */

public interface Selection<X> extends
TupleElement<X> \{



 /**

 * Assigns an alias to the selection item.

 * Once assigned, an alias cannot be changed
or reassigned.

 * Returns the same selection item.

 * @param name alias

 * @return selection item

 */

 Selection<X> alias(String name);



 /**

 * Whether the selection item is a compound
selection.

 * @return boolean indicating whether the
selection is a

 * compound selection

 */

 boolean isCompoundSelection();



 /**

 * Return the selection items composing a
compound selection.

 * Modifications to the list do not affect
the query.

 * @return list of selection items

 * @throws IllegalStateException if selection
is not a compound

 * selection

 */

 List<Selection<?>>
getCompoundSelectionItems();

}

==== CompoundSelection Interface

package javax.persistence.criteria;



/**

 * The CompoundSelection interface defines a
compound selection item

 * (tuple, array, or result of constructor).

 *

 * @param <X> the type of the selection item

 */

public interface CompoundSelection<X> extends
Selection<X> \{}

==== Expression Interface



package javax.persistence.criteria;



import java.util.Collection;



/**

 * Type for query expressions.

 *

 * @param <T> the type of the expression

 */

public interface Expression<T> extends
Selection<T> \{



 /**

 * Create a predicate to test whether the
expression is null.

 * @return predicate testing whether the
expression is null

 */

 Predicate isNull();



 /**

 * Create a predicate to test whether the
expression is

 * not null.

 * @return predicate testing whether the
expression is not null

 */

 Predicate isNotNull();



 /**

 * Create a predicate to test whether the
expression is a member

 * of the argument list.

 * @param values values to be tested against

 * @return predicate testing for membership

 */

 Predicate in(Object... values);



 /**

 * Create a predicate to test whether the
expression is a member

 * of the argument list.

 * @param values expressions to be tested
against

 * @return predicate testing for membership

 */

 Predicate in(Expression<?>... values);



 /**

 * Create a predicate to test whether the
expression is a member

 * of the collection.

 * @param values collection of values to be
tested against

 * @return predicate testing for membership

 */

 Predicate in(Collection<?> values);



 /**

 * Create a predicate to test whether the
expression is a member

 * of the collection.

 * @param values expression corresponding to
collection to be

 * tested against

 * @return predicate testing for membership

 */

 Predicate in(Expression<Collection<?>>
values);



 /**

 * Perform a typecast upon the expression,
returning a new

 * expression object.

 * This method does not cause type
conversion:

 * the runtime type is not changed.

 * Warning: may result in a runtime failure.

 * @param type intended type of the
expression

 * @return new expression of the given type

 */

 <X> Expression<X> as(Class<X> type);

}

==== Predicate Interface



package javax.persistence.criteria;



import java.util.List;



/**

 * The type of a simple or compound
predicate: a conjunction or

 * disjunction of restrictions.

 * A simple predicate is considered to be a
conjunction with a

 * single conjunct.

 */

public interface Predicate extends
Expression<Boolean> \{



 public static enum BooleanOperator \{

 AND, OR

 }



 /**

 * Return the boolean operator for the
predicate.

 * If the predicate is simple, this is AND.

 * @return boolean operator for the predicate

 */

 BooleanOperator getOperator();



 /**

 * Whether the predicate has been created
from another

 * predicate by applying the Predicate not()
method or the

 * CriteriaBuilder not() method.

 * @return boolean indicating if the
predicate is

 * a negated predicate

 */

 boolean isNegated();



 /**

 * Return the top-level conjuncts or
disjuncts of the predicate.

 * Returns empty list if there are no
top-level conjuncts or

 * disjuncts of the predicate.

 * Modifications to the list do not affect
the query.

 * @return list of boolean expressions
forming the predicate

 */

 List<Expression<Boolean>> getExpressions();



 /**

 * Create a negation of the predicate.

 * @return negated predicate

 */

 Predicate not();

}

==== Path Interface



package javax.persistence.criteria;



import
javax.persistence.metamodel.PluralAttribute;

import
javax.persistence.metamodel.SingularAttribute;

import javax.persistence.metamodel.Bindable;

import
javax.persistence.metamodel.MapAttribute;



/**

 * Represents a simple or compound attribute
path from a

 * bound type or collection, and is a
"primitive" expression.

 *

 * @param <X> the type referenced by the path

 */

public interface Path<X> extends
Expression<X> \{



 /**

 * Return the bindable object that
corresponds to the

 * path expression.

 * @return bindable object corresponding to
the path

 */

 Bindable<X> getModel();



 /**

 * Return the parent "node" in the path or
null if no parent.

 * @return parent

 */

 Path<?> getParentPath();



 /**

 * Create a path corresponding to the
referenced

 * single-valued attribute.

 * @param attribute single-valued attribute

 * @return path corresponding to the
referenced attribute

 */

 <Y> Path<Y> get(SingularAttribute<? super X,
Y> attribute);



 /**

 * Create a path corresponding to the
referenced

 * collection-valued attribute.

 * @param collection collection-valued
attribute

 * @return expression corresponding to the
referenced attribute

 */

 <E, C extends java.util.Collection<E>>
Expression<C> get(

 PluralAttribute<X, C, E> collection);



 /**

 * Create a path corresponding to the
referenced

 * map-valued attribute.

 * @param map map-valued attribute

 * @return expression corresponding to the
referenced attribute

 */

 <K, V, M extends java.util.Map<K, V>>
Expression<M> get(

 MapAttribute<X, K, V> map);









 /**

 * Create an expression corresponding to the
type of the path.

 * @return expression corresponding to the
type of the path

 */

 Expression<Class<? extends X>> type();





 //String-based:



 /**

 * Create a path corresponding to the
referenced attribute.

 *

 * Note: Applications using the string-based
API may need to

 * specify the type resulting from the get
operation in order

 * to avoid the use of Path variables.

 *

 * For example:

 *

 * CriteriaQuery<Person> q =
cb.createQuery(Person.class);

 * Root<Person> p = q.from(Person.class);

 * q.select(p)

 * .where(cb.isMember("joe",

 * p.<Set<String>>get("nicknames")));

 *

 * rather than:

 *

 * CriteriaQuery<Person> q =
cb.createQuery(Person.class);

 * Root<Person> p = q.from(Person.class);

 * Path<Set<String>> nicknames =
p.get("nicknames");

 * q.select(p)

 * .where(cb.isMember("joe", nicknames));

 *

 * @param attributeName name of the attribute

 * @return path corresponding to the
referenced attribute

 * @throws IllegalStateException if invoked
on a path that

 * corresponds to a basic type

 * @throws IllegalArgumentException if
attribute of the given

 * name does not otherwise exist

 */

 <Y> Path<Y> get(String attributeName);

}

==== FetchParent Interface

package javax.persistence.criteria;



import
javax.persistence.metamodel.PluralAttribute;

import
javax.persistence.metamodel.SingularAttribute;



/**

 * Represents an element of the from clause
which may

 * function as the parent of Fetches.

 *

 * @param <Z> the source type

 * @param <X> the target type

 */

public interface FetchParent<Z, X> \{



 /**

 * Return the fetch joins that have been made
from this type.

 * Returns empty set if no fetch joins have
been made from

 * this type.

 * Modifications to the set do not affect the
query.

 * @return fetch joins made from this type

 */

 java.util.Set<Fetch<X, ?>> getFetches();



 /**

 * Create a fetch join to the specified
single-valued attribute

 * using an inner join.

 * @param attribute target of the join

 * @return the resulting fetch join

 */

 <Y> Fetch<X, Y> fetch(SingularAttribute<?
super X, Y> attribute);



 /**

 * Create a fetch join to the specified
single-valued attribute

 * using the given join type.

 * @param attribute target of the join

 * @param jt join type

 * @return the resulting fetch join

 */

 <Y> Fetch<X, Y> fetch(SingularAttribute<?
super X, Y> attribute,

 JoinType jt);



 /**

 * Create a fetch join to the specified
collection-valued

 * attribute using an inner join.

 * @param attribute target of the join

 * @return the resulting join

 */

 <Y> Fetch<X, Y> fetch(PluralAttribute<?
super X, ?, Y> attribute);



 /**

 * Create a fetch join to the specified
collection-valued

 * attribute using the given join type.

 * @param attribute target of the join

 * @param jt join type

 * @return the resulting join

 */

 <Y> Fetch<X, Y> fetch(PluralAttribute<?
super X, ?, Y> attribute,

 JoinType jt);



 //String-based:



 /**

 * Create a fetch join to the specified
attribute using an

 * inner join.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @return the resulting fetch join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> Fetch<X, Y> fetch(String
attributeName);



 /**

 * Create a fetch join to the specified
attribute using

 * the given join type.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @param jt join type

 * @return the resulting fetch join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> Fetch<X, Y> fetch(String
attributeName, JoinType jt);

}

==== Fetch Interface



package javax.persistence.criteria;



import javax.persistence.metamodel.Attribute;



/**

 * Represents a join-fetched association or
attribute.

 *

 * @param <Z> the source type of the fetch

 * @param <X> the target type of the fetch

 */

public interface Fetch<Z, X> extends
FetchParent<Z, X> \{



 /**

 * Return the metamodel attribute
corresponding to the

 * fetch join.

 * @return metamodel attribute for the join

 */

 Attribute<? super Z, ?> getAttribute();



 /**

 * Return the parent of the fetched item.

 * @return fetch parent

 */

 FetchParent<?, Z> getParent();



 /**

 * Return the join type used in the fetch
join.

 * @return join type

 */

 JoinType getJoinType();

}

==== From Interface



package javax.persistence.criteria;



import
javax.persistence.metamodel.SingularAttribute;

import
javax.persistence.metamodel.CollectionAttribute;

import
javax.persistence.metamodel.ListAttribute;

import
javax.persistence.metamodel.MapAttribute;

import
javax.persistence.metamodel.SetAttribute;

import java.util.Set;



/**

 * Represents a bound type, usually an entity
that appears in

 * the from clause, but may also be an
embeddable belonging to

 * an entity in the from clause.

 * Serves as a factory for Joins of
associations, embeddables, and

 * collections belonging to the type, and for
Paths of attributes

 * belonging to the type.

 *

 * @param <Z> the source type

 * @param <X> the target type

 */

public interface From<Z, X> extends Path<X>,
FetchParent<Z, X> \{



 /**

 * Return the joins that have been made from
this bound type.

 * Returns empty set if no joins have been
made from this

 * bound type.

 * Modifications to the set do not affect the
query.

 * @return joins made from this type

 */

 Set<Join<X, ?>> getJoins();



 /**

 * Whether the From object has been obtained
as a result of

 * correlation (use of a Subquery correlate
method).

 * @return boolean indicating whether the
object has been

 * obtained through correlation

 */

 boolean isCorrelated();



 /**

 * Returns the parent From object from which
the correlated

 * From object has been obtained through
correlation (use

 * of a Subquery correlate method).

 * @return the parent of the correlated From
object

 * @throws IllegalStateException if the From
object has

 * not been obtained through correlation

 */

 From<Z, X> getCorrelationParent();



 /**

 * Create an inner join to the specified
single-valued

 * attribute.

 * @param attribute target of the join

 * @return the resulting join

 */

 <Y> Join<X, Y> join(SingularAttribute<?
super X, Y> attribute);



 /**

 * Create a join to the specified
single-valued attribute

 * using the given join type.

 * @param attribute target of the join

 * @param jt join type

 * @return the resulting join

 */

 <Y> Join<X, Y> join(SingularAttribute<?
super X, Y> attribute,

 JoinType jt);



 /**

 * Create an inner join to the specified
Collection-valued

 * attribute.

 * @param collection target of the join

 * @return the resulting join

 */

 <Y> CollectionJoin<X, Y> join(

 CollectionAttribute<? super X, Y>
collection);



 /**

 * Create an inner join to the specified
Set-valued attribute.

 * @param set target of the join

 * @return the resulting join

 */

 <Y> SetJoin<X, Y> join(SetAttribute<? super
X, Y> set);



 /**

 * Create an inner join to the specified
List-valued attribute.

 * @param list target of the join

 * @return the resulting join

 */

 <Y> ListJoin<X, Y> join(ListAttribute<?
super X, Y> list);



 /**

 * Create an inner join to the specified
Map-valued attribute.

 * @param map target of the join

 * @return the resulting join

 */

 <K, V> MapJoin<X, K, V> join(MapAttribute<?
super X, K, V> map);



 /**

 * Create a join to the specified
Collection-valued attribute

 * using the given join type.

 * @param collection target of the join

 * @param jt join type

 * @return the resulting join

 */

 <Y> CollectionJoin<X, Y> join(

 CollectionAttribute<? super X, Y>
collection, JoinType jt);



 /**

 * Create a join to the specified Set-valued
attribute using

 * the given join type.

 * @param set target of the join

 * @param jt join type

 * @return the resulting join

 */

 <Y> SetJoin<X, Y> join(SetAttribute<? super
X, Y> set,

 JoinType jt);



 /**

 * Create a join to the specified List-valued
attribute using

 * the given join type.

 * @param list target of the join

 * @param jt join type

 * @return the resulting join

 */

 <Y> ListJoin<X, Y> join(ListAttribute<?
super X, Y> list,

 JoinType jt);



 /**

 * Create a join to the specified Map-valued
attribute using

 * the given join type.

 * @param map target of the join

 * @param jt join type

 * @return the resulting join

 */

 <K, V> MapJoin<X, K, V> join(MapAttribute<?
super X, K, V> map,

 JoinType jt);





 //String-based:



 /**

 * Create an inner join to the specified
attribute.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> Join<X, Y> join(String
attributeName);



 /**

 * Create an inner join to the specified
Collection-valued

 * attribute.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> CollectionJoin<X, Y>
joinCollection(String attributeName);



 /**

 * Create an inner join to the specified
Set-valued attribute.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> SetJoin<X, Y> joinSet(String
attributeName);











 /**

 * Create an inner join to the specified
List-valued attribute.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> ListJoin<X, Y> joinList(String
attributeName);



 /**

 * Create an inner join to the specified
Map-valued attribute.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, K, V> MapJoin<X, K, V> joinMap(String
attributeName);



 /**

 * Create a join to the specified attribute
using the given

 * join type.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @param jt join type

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> Join<X, Y> join(String attributeName,
JoinType jt);



 /**

 * Create a join to the specified
Collection-valued attribute

 * using the given join type.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @param jt join type

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> CollectionJoin<X, Y>
joinCollection(String attributeName,

 JoinType jt);



 /**

 * Create a join to the specified Set-valued
attribute using

 * the given join type.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @param jt join type

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> SetJoin<X, Y> joinSet(String
attributeName, JoinType jt);







 /**

 * Create a join to the specified List-valued
attribute using

 * the given join type.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @param jt join type

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, Y> ListJoin<X, Y> joinList(String
attributeName, JoinType jt);



 /**

 * Create a join to the specified Map-valued
attribute using

 * the given join type.

 * @param attributeName name of the attribute
for the

 * target of the join

 * @param jt join type

 * @return the resulting join

 * @throws IllegalArgumentException if
attribute of the given

 * name does not exist

 */

 <X, K, V> MapJoin<X, K, V> joinMap(String
attributeName,

 JoinType jt);

}

==== Root Interface



package javax.persistence.criteria;



import
javax.persistence.metamodel.EntityType;



/**

 * A root type in the from clause.

 * Query roots always reference entities.

 *

 * @param <X> the entity type referenced by
the root

 */

public interface Root<X> extends From<X, X>
\{



 /**

 * Return the metamodel entity corresponding
to the root.

 * @return metamodel entity corresponding to
the root

 */

 EntityType<X> getModel();

}

==== Join Interface

package javax.persistence.criteria;



import javax.persistence.metamodel.Attribute;



/**

 * A join to an entity, embeddable, or basic
type.

 *

 * @param <Z> the source type of the join

 * @param <X> the target type of the join

 */

public interface Join<Z, X> extends From<Z,
X> \{



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restriction a simple or compound
boolean expression

 * @return the modified join object

 */

 Join<Z, X> on(Expression<Boolean>
restriction);



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restrictions zero or more
restriction predicates

 * @return the modified join object

 */

 Join<Z, X> on(Predicate... restrictions);



 /**

 * Return the predicate that corresponds to
the ON

 * restriction(s) on the join, or null if no
ON condition

 * has been specified.

 * @return the ON restriction predicate

 */

 Predicate getOn();



 /**

 * Return the metamodel attribute
corresponding to the join.

 * @return metamodel attribute corresponding
to the join

 */

 Attribute<? super Z, ?> getAttribute();



 /**

 * Return the parent of the join.

 * @return join parent

 */

 From<?, Z> getParent();



 /**

 * Return the join type.

 * @return join type

 */

 JoinType getJoinType();

}

==== JoinType



package javax.persistence.criteria;



/**

 * Defines the three types of joins.

 *

 * Right outer joins and right outer fetch
joins are not required

 * to be supported. Applications that use
RIGHT join types will

 * not be portable.

 */

public enum JoinType \{



 /**

 * Inner join.

 */

 INNER,



 /**

 * Left outer join.

 */

 LEFT,



 /**

 * Right outer join.

 */

 RIGHT

}

==== PluralJoin Interface



package javax.persistence.criteria;



import
javax.persistence.metamodel.PluralAttribute;



/**

 * The PluralJoin interface defines
functionality

 * that is common to joins to all collection
types. It is

 * not intended to be used directly in query
construction.

 *

 * @param <Z> the source type

 * @param <C> the collection type

 * @param <E> the element type of the
collection

 */

public interface PluralJoin<Z, C, E> extends
Join<Z, E> \{



 /**

 * Return the metamodel representation for
the collection-valued

 * attribute corresponding to the join.

 * @return metamodel collection-valued
attribute corresponding

 * to the target of the join

 */

 PluralAttribute<? super Z, C, E> getModel();

}

==== CollectionJoin Interface



package javax.persistence.criteria;



import java.util.Collection;

import
javax.persistence.metamodel.CollectionAttribute;



/**

 * The CollectionJoin interface is the type
of the result of

 * joining to a collection over an
association or element

 * collection that has been specified as a
java.util.Collection.

 *

 * @param <Z> the source type of the join

 * @param <E> the element type of the target
Collection

 */

public interface CollectionJoin<Z, E>

 extends PluralJoin<Z, Collection<E>, E> \{



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restriction a simple or compound
boolean expression

 * @return the modified join object

 */

 CollectionJoin<Z, E> on(Expression<Boolean>
restriction);



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restrictions zero or more
restriction predicates

 * @return the modified join object

 */

 CollectionJoin<Z, E> on(Predicate...
restrictions);



 /**

 * Return the metamodel representation for
the collection

 * attribute.

 * @return metamodel type representing the
Collection that is

 * the target of the join

 */

 CollectionAttribute<? super Z, E>
getModel();

}

























==== SetJoin Interface



package javax.persistence.criteria;



import java.util.Set;

import
javax.persistence.metamodel.SetAttribute;



/**

 * The SetJoin interface is the type of the
result of

 * joining to a collection over an
association or element

 * collection that has been specified as a
java.util.Set.

 *

 * @param <Z> the source type of the join

 * @param <E> the element type of the target
Set

 */

public interface SetJoin<Z, E> extends
PluralJoin<Z, Set<E>, E> \{



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restriction a simple or compound
boolean expression

 * @return the modified join object

 */

 SetJoin<Z, E> on(Expression<Boolean>
restriction);



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restrictions zero or more
restriction predicates

 * @return the modified join object

 */

 SetJoin<Z, E> on(Predicate... restrictions);



 /**

 * Return the metamodel representation for
the set attribute.

 * @return metamodel type representing the
Set that is

 * the target of the join

 */

 SetAttribute<? super Z, E> getModel();

}

==== ListJoin Interface



package javax.persistence.criteria;



import java.util.List;

import
javax.persistence.metamodel.ListAttribute;



/**

 * The ListJoin interface is the type of the
result of

 * joining to a collection over an
association or element

 * collection that has been specified as a
java.util.List.

 *

 * @param <Z> the source type of the join

 * @param <E> the element type of the target
List

 */

public interface ListJoin<Z, E> extends
PluralJoin<Z, List<E>, E> \{



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restriction a simple or compound
boolean expression

 * @return the modified join object

 */

 ListJoin<Z, E> on(Expression<Boolean>
restriction);



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restrictions zero or more
restriction predicates

 * @return the modified join object

 */

 ListJoin<Z, E> on(Predicate...
restrictions);



 /**

 * Return the metamodel representation for
the list attribute.

 * @return metamodel type representing the
List that is

 * the target of the join

 */

 ListAttribute<? super Z, E> getModel();



 /**

 * Create an expression that corresponds to
the index of

 * the object in the referenced association
or element

 * collection.

 * This method must only be invoked upon an
object that

 * represents an association or element
collection for

 * which an order column has been defined.

 * @return expression denoting the index

 */

 Expression<Integer> index();

}

==== MapJoin Interface



package javax.persistence.criteria;



import java.util.Map;

import
javax.persistence.metamodel.MapAttribute;



/**

 * The MapJoin interface is the type of the
result of

 * joining to a collection over an
association or element

 * collection that has been specified as a
java.util.Map.

 *

 * @param <Z> the source type of the join

 * @param <K> the type of the target Map key

 * @param <V> the type of the target Map
value

 */

public interface MapJoin<Z, K, V>

 extends PluralJoin<Z, Map<K, V>, V> \{



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restriction a simple or compound
boolean expression

 * @return the modified join object

 */

 MapJoin<Z, K, V> on(Expression<Boolean>
restriction);



 /**

 * Modify the join to restrict the result
according to the

 * specified ON condition. Replaces the
previous ON condition,

 * if any.

 * Return the join object

 * @param restrictions zero or more
restriction predicates

 * @return the modified join object

 */

 MapJoin<Z, K, V> on(Predicate...
restrictions);



 /**

 * Return the metamodel representation for
the map attribute.

 * @return metamodel type representing the
Map that is

 * the target of the join

 */

 MapAttribute<? super Z, K, V> getModel();



 /**

 * Create a path expression that corresponds
to the map key.

 * @return path corresponding to map key

 */

 Path<K> key();



 /**

 * Create a path expression that corresponds
to the map value.

 * This method is for stylistic use only: it
just returns this.

 * @return path corresponding to the map
value

 */

 Path<V> value();



 /**

 * Create an expression that corresponds to
the map entry.

 * @return expression corresponding to the
map entry

 */

 Expression<Map.Entry<K, V>> entry();

}

==== Order Interface



package javax.persistence.criteria;



/**

 * An object that defines an ordering over
the query results.

 */

public interface Order \{



 /**

 * Switch the ordering.

 * @return a new Order instance with the
reversed ordering

 */

 Order reverse();



 /**

 * Whether ascending ordering is in effect.

 * @return boolean indicating whether
ordering is ascending

 */

 boolean isAscending();



 /**

 * Return the expression that is used for
ordering.

 * @return expression used for ordering

 */

 Expression<?> getExpression();

}

==== ParameterExpression Interface



package javax.persistence.criteria;



import javax.persistence.Parameter;



/**

 * Type of criteria query parameter
expressions.

 *

 * @param <T> the type of the parameter
expression

 */

public interface ParameterExpression<T>

 extends Parameter<T>, Expression<T> \{}

=== [[a10608]]Criteria Query API Usage

image:Per-4.png[image]

The _javax.persistence.criteria_ API
interfaces are designed both to allow criteria queries to be constructed
in a strongly-typed manner, using metamodel objects to provide type
safety, and to allow for string-based use as an alternative:

Metamodel objects are used to specify
navigation through joins and through path
expressionslink:#a19613[77]. Typesafe navigation is achieved by
specification of the source and target types of the navigation.

Strings may be used as an alternative to
metamodel objects, whereby joins and navigation are specified by use of
strings that correspond to attribute names.

Using either the approach based on metamodel
objects or the string-based approach, queries can be constructed both
statically and dynamically. Both approaches are equivalent in terms of
the range of queries that can be expressed and operational semantics.

Section link:Per.html#a10614[See
Constructing Criteria Queries] provides a description of the use of the
criteria API interfaces. This section is illustrated on the basis of the
construction of strongly-typed queries using static metamodel classes.
Section link:Per.html#a11305[See Constructing Strongly-typed
Queries using the javax.persistence.metamodel Interfaces] describes how
the _javax.persistence.metamodel_ API can be used to construct
strongly-typed queries in the absence of such classes. String-based use
of the criteria API is described in section
link:Per.html#a11349[See Use of the Criteria API with Strings to
Reference Attributes].

=== [[a10614]]Constructing Criteria Queries

image:Per-4.png[image]

A criteria query is constructed through the
creation and modification of a
_javax.persistence.criteria.CriteriaQuery_ object.

The _CriteriaBuilder_ interface is used to
construct _CriteriaQuery_ , _CriteriaUpdate_ , and _CriteriaDelete_
objects. The _CriteriaBuilder_ implementation is accessed through the
_getCriteriaBuilder_ method of the _EntityManager_ or
_EntityManagerFactory_ interface.

For example:

...

@PersistenceUnit EntityManagerFactory emf;

CriteriaBuilder cb =
emf.getCriteriaBuilder();

==== [[a10621]]CriteriaQuery Creation

A _CriteriaQuery_ object is created by means
of one of the _createQuery_ methods or the _createTupleQuery_ method of
the _CriteriaBuilder_ interface. A _CriteriaQuery_ object is typed
according to its expected result type when the _CriteriaQuery_ object is
created. A _TypedQuery_ instance created from the _CriteriaQuery_ object
by means of the _EntityManager_ _createQuery_ method will result in
instances of this type when the resulting query is executed.

The following methods are provided for the
creation of _CriteriaQuery_ objects:

 <T> CriteriaQuery<T> createQuery(Class<T>
resultClass);



 CriteriaQuery<Tuple> createTupleQuery();



 CriteriaQuery<Object> createQuery();

Methods for the creation of update and delete
queries are described in section link:Per.html#a11239[See Bulk
Update and Delete Operations].

The methods <T> CriteriaQuery<T>
createQuery(Class<T> resultClass) and _createTupleQuery_ provide for
typing of criteria query results and for typesafe query execution using
the _TypedQuery_ API.

The effect of the _createTupleQuery_ method
is semantically equivalent to invoking the _createQuery_ method with the
_Tuple.class_ argument. The _Tuple_ interface supports the extraction of
multiple selection items in a strongly typed manner. See sections
link:Per.html#a3868[See Tuple Interface] and
link:Per.html#a3949[See TupleElement Interface].

The CriteriaQuery<Object> createQuery()
method supports both the case where the _select_ or _multiselect_ method
specifies only a single selection item and where the _multiselect_
method specifies multiple selection items. If only a single item is
specified, an instance of type _Object_ will be returned for each result
of the query execution. If multiple selection items are specified, an
instance of type _Object[]_ will be instantiated and returned for each
result of the execution.

See section link:Per.html#a10945[See
Specifying the Select List] for further discussion of the specification
of selection items.

==== Query Roots

A _CriteriaQuery_ object defines a query over
one or more entity, embeddable, or basic abstract schema types. The root
objects of the query are entities, from which the other types are
reached by navigation. A query root plays a role analogous to that of a
range variable in the Java Persistence query language and forms the
basis for defining the domain of the query.

A query root is created and added to the
query by use of the _from_ method of the _AbstractQuery_ interface (from
which both the _CriteriaQuery_ and _Subquery_ interfaces inherit). The
argument to the _from_ method is the entity class or _EntityType_
instance for the entity. The result of the _from_ method is a _Root_
object. The _Root_ interface extends the _From_ interface, which
represents objects that may occur in the from clause of a query.

A _CriteriaQuery_ object may have more than
one root. The addition of a query root has the semantic effect of
creating a cartesian product between the entity type referenced by the
added root and those of the other roots.

The following query illustrates the
definition of a query root. When executed, this query causes all
instances of the _Customer_ entity to be returned.

CriteriaBuilder cb = ...

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> customer =
q.from(Customer.class);

q.select(customer);

==== [[a10643]]Joins

The _join_ methods of the _From_ interface
extend the query domain by creating a join with a related class that can
be navigated to or that is an element of the given class of the query
domain.

{empty}The target of the join is specified by
the corresponding _SingularAttribute_ or collection-valued attribute (
_CollectionAttribute_ , _SetAttribute_ , _ListAttribute_ , or
_MapAttribute_ ) of the corresponding metamodel
class.link:#a19615[78] link:#pgfId-1603966[79]

The _join_ methods may be applied to
instances of the _Root_ and _Join_ types.

The result of a _join_ method is a _Join_
object (instance of the _Join_ , _CollectionJoin_ , _SetJoin_ ,
_ListJoin_ , or _MapJoin_ types) that captures the source and target
types of the join.

For example, given the _Order_ entity and
corresponding _Order__ metamodel class shown in section
link:Per.html#a6961[See Example], a join to the lineItems of the
order would be expressed as follows:

CriteriaQuery<Order> q =
cb.createQuery(Order.class);

Root<Order> order = q.from(Order.class);

Join<Order, Item> item =
order.join(Order_.lineItems);

q.select(order);

The argument to the _join_ method,
_Order_.lineItems_ , is of type
_javax.persistence.metamodel.SetAttribute<Order, Item>_ .

The _join_ methods have the same semantics as
the corresponding Java Persistence query language operations, as
described in section link:Per.html#a4957[See FROM Clause and
SQL].

 _Example:_

CriteriaBuilder cb = ...

CriteriaQuery<String> q =
cb.createQuery(String.class);

Root<Customer> customer =
q.from(Customer.class);

Join<Customer, Order> order =
customer.join(Customer_.orders);

Join<Order, Item> item =
order.join(Order_.lineItems);

q.select(customer.get(Customer_.name))


.where(cb.equal(item.get(Item_.product).get(Product_.productType),

 "printer"));

This query is equivalent to the following
Java Persistence query language query:

SELECT c.name

FROM Customer c JOIN c.orders o JOIN
o.lineItems i

WHERE i.product.productType = 'printer'

Joins can be chained, thus allowing this
query to be written more concisely:

CriteriaQuery<String> q =
cb.createQuery(String.class);

Root<Customer> customer =
q.from(Customer.class);

Join<Order, Item> item =


customer.join(Customer_.orders).join(Order_.lineItems);

q.select(customer.get(Customer_.name))


.where(cb.equal(item.get(Item_.product).get(Product_.productType),

 "printer"));

By default, the _join_ method defines an
inner join. Outer joins are defined by specifying a _JoinType_ argument.
Only left outer joins and left outer fetch joins are required to be
supported. Applications that make use of right outer joins or right
outer fetch joins will not be portable.

The following query uses a left outer join:

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> customer =
q.from(Customer.class);

Join<Customer,Order> order =

 customer.join(Customer_.orders,
JoinType.LEFT);

q.where(cb.equal(customer.get(Customer_.status),
1))

 .select(customer);

This query is equivalent to the following
Java Persistence query language query:

SELECT c FROM Customer c LEFT JOIN c.orders o
WHERE c.status = 1

On-conditions can be specified for joins. The
following query uses an on-condition with a left outer join:

CriteriaQuery<Tuple> q =
cb.createTupleQuery();

Root<Supplier> s = q.from(Supplier.class);

Join<Supplier, Product> p =

 s.join(Supplier_.products, JoinType.LEFT);

p.on(cb.equal(p.get(Product_.status),
"inStock"));

q.groupBy(s.get(Supplier_.name));

q.multiselect(s.get(Supplier_.name),
cb.count(p));

This query is equivalent to the following
Java Persistence query language query:

SELECT s.name, COUNT(p)

FROM Suppliers s LEFT JOIN s.products p

 ON p.status = 'inStock'

GROUP BY s.name

==== Fetch Joins

Fetch joins are specified by means of the
_fetch_ method. The _fetch_ method specifies that the referenced
association or attribute is to be fetched as a side effect of the
execution of the query. The _fetch_ method can be applied to a _Root_ or
_Join_ instance.

An association or attribute referenced by the
_fetch_ method must be referenced from an entity or embeddable that is
returned as the result of the query. A fetch join has the same join
semantics as the corresponding inner or outer join, except that the
related objects are not top-level objects in the query result and cannot
be referenced elsewhere by the query. See Section
link:Per.html#a4931[See Fetch Joins].

The _fetch_ method must not be used in a
subquery.

Multiple levels of fetch joins are not
required to be supported by an implementation of this specification.
Applications that use multi-level fetch joins will not be portable.

 _Example:_

 _CriteriaQuery<Department> q =
cb.createQuery(Department.class);_

 _Root<Department> d =
q.from(Department.class);_

 _d.fetch(Department_.employees,_
JoinType.LEFT _);_

 _q.where(cb.equal(d.get(Department_.deptno),
1)).select(d);_

This query is equivalent to the following
Java Persistence query language query:

SELECT d

FROM Department d LEFT JOIN FETCH d.employees

WHERE d.deptno = 1

==== [[a16277]]Path Navigation

A _Path_ instance can be a _Root_ instance, a
_Join_ instance, a _Path_ instance that has been derived from another
_Path_ instance by means of the _get_ navigation method, or a _Path_
instance derived from a map-valued association or element collection by
use of the _key_ or _value_ method.

When a criteria query is executed, path
navigation—like path navigation using the Java Persistence query
language—is obtained using “inner join” semantics. That is, if the value
of a non-terminal _Path_ instance is null, the path is considered to
have no value, and does not participate in the determination of the
query result. See Section link:Per.html#a4792[See Path
Expressions].

The _get_ method is used for path navigation.
The argument to the _get_ method is specified by the corresponding
_SingularAttribute_ or collection-valued attribute
_(CollectionAttribute_ , _SetAttribute_ , _ListAttribute_ , or
_MapAttribute_ ) of the corresponding metamodel
classlink:#a19616[80].

 _Example 1:_

In the following example, _ContactInfo_ is an
embeddable class consisting of an address and set of phones. _Phone_ is
an entity.

CriteriaQuery<Vendor> q =
cb.createQuery(Vendor.class);

Root<Employee> emp = q.from(Employee.class);

Join<ContactInfo, Phone> phone =


emp.join(Employee_.contactInfo).join(ContactInfo_.phones);

q.where(cb.equal(emp.get(Employee_.contactInfo)

 .get(ContactInfo_.address)

 .get(Address_.zipcode),

 "95054"))

 .select(phone.get(Phone_.vendor));

The following Java Persistence query language
query is equivalent:

SELECT p.vendor

FROM Employee e JOIN e.contactInfo.phones p

WHERE e.contactInfo.address.zipcode = '95054'

 _Example 2:_

In this example, the _photos_ attribute
corresponds to a map from photo label to filename. The map key is a
string, the value an object. The result of this query will be returned
as a _Tuple_ object whose elements are of types _String_ and _Object_ .
The _multiselect_ method, described further in section
link:Per.html#a10945[See Specifying the Select List], is used to
specify that the query returns multiple selection items.

CriteriaQuery<Tuple> q =
cb.createTupleQuery();

Root<Item> item = q.from(Item.class);

MapJoin<Item, String, Object> photo =
item.join(Item_.photos);

q.multiselect(item.get(Item_.name), photo)

 .where(cb.like(photo.key(), "%egret%"));



This query is equivalent to the following
Java Persistence query language query:

SELECT i.name, p

FROM Item i JOIN i.photos p

WHERE KEY(p) LIKE ‘%egret%’

==== Restricting the Query Result

The result of a query can be restricted by
specifying one or more predicate conditions. Restriction predicates are
applied to the _CriteriaQuery_ object by means of the _where_ method.
Invocation of the _where_ method results in the modification of the
_CriteriaQuery_ object with the specified restriction(s).

The argument to the _where_ method can be
either an _Expression<Boolean>_ instance or zero or more _Predicate_
instances. A predicate can be either simple or compound.

A simple predicate is created by invoking one
of the conditional methods of the _CriteriaBuilder_ interface, or by the
_isNull_ , _isNotNull_ , and _in_ methods of the _Expression_ interface.
The semantics of the conditional methods—e.g., _equal_ , _notEqual_ ,
_gt_ , _ge_ , _lt_ , _le_ , _between_ , and _like_ — mirror those of the
corresponding Java Persistence query language operators as described in
Chapter link:Per.html#a4665[See Query Language].

Compound predicates are constructed by means
of the _and_ , _or_ , and _not_ methods of the _CriteriaBuilder_
interface.

The restrictions upon the types to which
conditional operations are permitted to be applied are the same as the
respective operators of the Java Persistence query language as described
in subsections link:Per.html#a5066[See Comparison Expressions]
through link:Per.html#a5243[See Scalar Expressions]. The same
null value semantics as described in section
link:Per.html#a5676[See Null Values] and the subsections of
section link:Per.html#a4994[See Conditional Expressions] apply.
The equality and comparison semantics described in section
link:Per.html#a5735[See Equality and Comparison Semantics]
likewise apply.

 _Example 1:_

CriteriaQuery<TransactionHistory> q =

 cb.createQuery(TransactionHistory.class);

Root<CreditCard> cc =
q.from(CreditCard.class);

ListJoin<CreditCard,TransactionHistory> t =

 cc.join(CreditCard_.transactionHistory);

q.select(t)

 .where(cb.equal(cc.get(CreditCard_.customer)

 .get(Customer_.accountNum),

 321987),

 cb.between (t.index(), 0, 9));

This query is equivalent to the following
Java Persistence query language query:

SELECT t

FROM CreditCard c JOIN c.transactionHistory t

WHERE c.customer.accountNum = 321987 AND
INDEX(t) BETWEEN 0 AND 9

 _Example 2:_

CriteriaQuery<Order> q =
cb.createQuery(Order.class);

Root<Order> order = q.from(Order.class);

q.where(cb.isEmpty(order.get(Order_.lineItems)))

 .select(order);

This query is equivalent to the following
Java Persistence query language query:

SELECT o

FROM Order o

WHERE o.lineItems IS EMPTY

==== Downcasting

Downcasting by means of the _treat_ method is
supported in joins and in the construction of _where_ conditions.

 _Example 1:_

CriteriaQuery<String> q =
cb.createQuery(String.class);

Root<Order> order = q.from(Order.class);

Join<Order,Book> book =

 cb.treat(order.join(Order_.product),
Book.class);

q.select(book.get(Book_.isbn));

This query is equivalent to the following
Java Persistence query language query.

SELECT b.ISBN

FROM Order o JOIN TREAT(o.product AS Book) b

 _Example 2:_

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> customer =
q.from(Customer.class);

Join<Customer, Order> order =
customer.join(Customer_.orders);

q.where(cb.equal(cb.treat(order.get(Order_.product),
Book.class)

 .get(Book_.name),

 "Iliad"));

q.select(customer);

This query is equivalent to the following
Java Persistence query language query:

SELECT c

FROM Customer c JOIN c.orders o

WHERE TREAT(o.product AS Book).name = 'Iliad'

 _Example 3:_

CriteriaQuery<Employee> q =
cb.createQuery(Employee.class);

Root<Employee> e = q.from(Employee.class);

q.where(

 cb.or(cb.gt(cb.treat(e,
Exempt.class).get(Exempt_.vacationDays),

 10),

 cb.gt(cb.treat(e,
Contractor.class).get(Contractor_.hours),

 100)));

This query is equivalent to the following
Java Persistence query language query:

SELECT e

FROM Employee e

WHERE TREAT(e AS Exempt).vacationDays > 10

 OR TREAT(e AS Contractor).hours > 100

==== Expressions

An _Expression_ or one of its subtypes can be
used in the construction of the query’s select list or in the
construction of _where_ or _having_ method conditions.

Paths and boolean predicates are expressions.

Other expressions are created by means of the
methods of the _CriteriaBuilder_ interface. The _CriteriaBuilder_
interface provides methods corresponding to the built-in arthmetic,
string, datetime, and case operators and functions of the Java
Persistence query language.

 _Example 1:_

CriteriaQuery<Tuple> q =
cb.createTupleQuery();

Root<Customer> cust = q.from(Customer.class);

Join<Customer, Order> order =
cust.join(Customer_.orders);

Join<Customer, Address> addr =
cust.join(Customer_.address);

q.where(cb.equal(addr.get(Address_.state),
"CA"),

 cb.equal(addr.get(Address_.county), "Santa
Clara"));

q.multiselect(order.get(Order_.quantity),

 cb.prod(order.get(Order_.totalCost), 1.08),

 addr.get(Address_.zipcode));

The following Java Persistence query language
query is equivalent:

SELECT o.quantity, o.totalCost*1.08,
a.zipcode

FROM Customer c JOIN c.orders o JOIN
c.address a

WHERE a.state = 'CA’ AND a.county = 'Santa
Clara’

 _Example 2:_

CriteriaQuery<Employee> q =
cb.createQuery(Employee.class);

Root<Employee> emp = q.from(Employee.class);

q.select(emp)

 .where(cb.notEqual(emp.type(),
Exempt.class));

The _type_ method can only be applied to a
path expression. Its result denotes the type navigated to by the path.

The following Java Persistence query language
query is equivalent:

SELECT e

FROM Employee e

WHERE TYPE(e) <> Exempt

 _Example 3:_

CriteriaQuery<String> q =
cb.createQuery(String.class);

Root<Course> c = q.from(Course.class);

ListJoin<Course, Student> w =
c.join(Course_.studentWaitlist);

q.where(cb.equal(c.get(Course_.name),
"Calculus"),

 cb.equal(w.index(), 0))

 .select(w.get(Student_.name));

The _index_ method can be applied to a
_ListJoin_ object that corresponds to a list for which an order column
has been specified. Its result denotes the position of the item in the
list.

The following Java Persistence query language
query is equivalent:

SELECT w.name

FROM Course c JOIN c.studentWaitlist w

WHERE c.name = 'Calculus’

AND INDEX(w) = 0

 _Example 4:_

CriteriaQuery<BigDecimal> q =
cb.createQuery(BigDecimal.class);

Root<Order> order = q.from(Order.class);

Join<Order, Item> item =
order.join(Order_.lineItems);

Join<Order, Customer> cust =
order.join(Order_.customer);

q.where(cb.equal(cust.get(Customer_.lastName),
"Smith"),

 cb.equal(cust.get(Customer_.firstName),
"John"));

q.select(cb.sum(item.get(Item_.price)));



The aggregation methods _avg_ , _max_ , _min_
, _sum_ , _count_ can only be used in the construction of the select
list or in _having_ method conditions.

The following Java Persistence query language
query is equivalent:

SELECT SUM(i.price)

FROM Order o JOIN o.lineItems i JOIN
o.customer c

WHERE c.lastName = 'Smith’ AND c.firstName =
'John’

 _Example 5:_

CriteriaQuery<Integer> q =
cb.createQuery(Integer.class);

Root<Department> d =
q.from(Department.class);

q.where(cb.equal(d.get(Department_.name),
"Sales"))


.select(cb.size(d.get(Department_.employees)));

The _size_ method can be applied to a path
expression that corresponds to an association or element collection. Its
result denotes the number of elements in the association or element
collection.

The following Java Persistence query language
query is equivalent:

SELECT SIZE(d.employees)

FROM Department d

WHERE d.name = ‘Sales’

 _Example 6:_

Both simple and general case expressions are
supported. The query below illustrates use of a general case expression.

CriteriaQuery<Tuple> q =
cb.createTupleQuery();

Root<Employee> e = q.from(Employee.class);

q.where(cb.equal(e.get(Employee_.department).get(Department_.name),

 "Engineering"));

q.multiselect(e.get(Employee_.name),

 cb.selectCase()

 .when(cb.equal(e.get(Employee_.rating), 1),

 cb.prod(e.get(Employee_.salary), 1.1))

 .when(cb.equal(e.get(Employee_.rating), 2),

 cb.prod(e.get(Employee_.salary), 1.2))

 .otherwise(cb.prod(e.get(Employee_.salary),
1.01)));

The following Java Persistence query language
query is equivalent:

SELECT e.name,

 CASE WHEN e.rating = 1 THEN e.salary * 1.1

 WHEN e.rating = 2 THEN e.salary * 1.2

 ELSE e.salary * 1.01

 END

FROM EMPLOYEE e

WHERE e.department.name = ‘Engineering’

===== Result Types of Expressions

The _getJavaType_ method, as defined in the
_TupleElement_ interface, returns the runtime type of the object on
which it is invoked.

In the case of the _In_ , _Case_ ,
_SimpleCase_ , and _Coalesce_ builder interfaces, the runtime results of
the _getJavaType_ method may differ from the _Expression_ type and may
vary as the expression is incrementally constructed. For non-numerical
operands, the implementation must return the most specific common
superclass of the types of the operands used to form the result.

In the case of the two-argument _sum_ ,
_prod_ , _diff_ , _quot_ , _coalesce_ , and _nullif_ methods, and the
_In_ , _Case_ , _SimpleCase_ , and _Coalesce_ builder methods, the
runtime result types will differ from the _Expression_ type when the
latter is _Number_ . The following rules must be observed by the
implementation when materializing the results of numeric expressions
involving these methods. These rules correspond to those specified for
the Java Persistence query language as defined in section
link:Per.html#a5574[See Numeric Expressions in the SELECT
Clause].

If there is an operand of type Double, the
result of the operation is of type Double;

otherwise, if there is an operand of type
Float, the result of the operation is of type Float;

otherwise, if there is an operand of type
BigDecimal, the result of the operation is of type BigDecimal;

otherwise, if there is an operand of type
BigInteger, the result of the operation is of type BigInteger, unless
the method is _quot_ , in which case the numeric result type is not
further defined;

otherwise, if there is an operand of type
Long, the result of the operation is of type Long, unless the method is
_quot_ , in which case the numeric result type is not further defined;

otherwise, if there is an operand of integral
type, the result of the operation is of type Integer, unless the method
is _quot_ , in which case the numeric result type is not further
defined.

Users should note that the semantics of the
SQL division operation are not standard across databases. In particular,
when both operands are of integral types, the result of the division
operation will be an integral type in some databases, and an
non-integral type in others. Portable applications should not assume a
particular result type.

==== Literals

An _Expression_ literal instance is obtained
by passing a value to the _literal_ method of the _CriteriaBuilder_
interface. An _Expression_ instance representing a null is created by
the _nullLiteral_ method of the _CriteriaBuilder_ interface.

 _Example_ :

CriteriaQuery<String> q =
cb.createQuery(String.class);

Root<Employee> emp = q.from(Employee.class);

Join<Employee, FrequentFlierPlan> fp =

 emp.join(Employee_.frequentFlierPlan);

q.select(cb.<String>selectCase()


.when(cb.gt(fp.get(FrequentFlierPlan_.annualMiles),

 50000),

 cb.literal("Platinum"))


.when(cb.gt(fp.get(FrequentFlierPlan_.annualMiles),

 25000),

 cb.literal("Silver"))

 .otherwise(cb.nullLiteral(String.class)));



The following Java Persistence query language
query is equivalent:

SELECT CASE WHEN fp.annualMiles > 50000 THEN
'Platinum'

 WHEN fp.annualMiles > 25000 THEN 'Gold'

 ELSE NULL

 END

==== Parameter Expressions

A _ParameterExpression_ instance is an
expression that corresponds to a parameter whose value will be supplied
before the query is executed. Parameter expressions can only be used in
the construction of conditional predicates.

Example:

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> c = q.from(Customer.class);

ParameterExpression<Integer> param =
cb.parameter(Integer.class);

q.select(c).where(cb.equal(c.get(Customer_.status),
param));

If a name is supplied when the
_ParameterExpression_ instance is created, the parameter may also be
treated as a named parameter when the query is executed:

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> c = q.from(Customer.class);

ParameterExpression<Integer> param =

 cb.parameter(Integer.class, "stat");

q.select(c).where(cb.equal(c.get(Customer_.status),
param));

This is equivalent to the following query in
the Java Persistence query language:

SELECT c

FROM Customer c

WHERE c.status = :stat

==== [[a10945]]Specifying the Select List

The select list of a query is specified by
use of the _select_ or _multiselect_ methods of the _CriteriaQuery_
interface. The arguments to the _select_ and _multiselect_ methods are
_Selection_ instances.

Portable applications should use the _select_
or _multiselect_ method to specify the query’s selection list.
Applications that do not use one of these methods will not be portable.

The _select_ method takes a single
_Selection_ argument, which can be either an _Expression_ instance or a
_CompoundSelection_ instance. The type of the _Selection_ item must be
assignable to the defined _CriteriaQuery_ result type, as described in
section link:Per.html#a10621[See CriteriaQuery Creation].

The _construct_ , _tuple_ and _array_ methods
of the _CriteriaBuilder_ interface are used to aggregate multiple
selection items into a _CompoundSelection_ instance.

The _multiselect_ method also supports the
specification and aggregation of multiple selection items. When the
_multiselect_ method is used, the aggregation of the selection items is
determined by the result type of the _CriteriaQuery_ object as described
in sections link:Per.html#a10621[See CriteriaQuery Creation] and
link:Per.html#a8857[See CriteriaQuery Interface].

A _Selection_ instance passed to the
_construct_ , _tuple_ , _array_ , or _multiselect_ methods can be one of
the following:

An _Expression_ instance.

A _Selection_ instance obtained as the result
of the invocation of the _CriteriaBuilder construct_ method.

The _distinct_ method of the _CriteriaQuery_
interface is used to specify that duplicate values must be eliminated
from the query result. If the _distinct_ method is not used or
_distinct(false)_ is invoked on the criteria query object, duplicate
values are not eliminated. When _distinct(true)_ is used, and the select
items include embeddable objects or map entry results, the elimination
of duplicates is undefined.

The semantics of the _construct_ method used
in the selection list is as described in section
link:Per.html#a5500[See Constructor Expressions in the SELECT
Clause]. The semantics of embeddables returned by the selection list are
as described in section link:Per.html#a5511[See Embeddables in
the Query Result].

 _Example 1:_

In the following example, _videoInventory_ is
a Map from the entity _Movie_ to the number of copies in stock.

 _CriteriaQuery<Tuple> q =
cb.createTupleQuery();_

 _Root<VideoStore> v =
q.from(VideoStore.class);_

 _MapJoin<VideoStore, Movie, Integer> inv =_

 _v.join(VideoStore_.videoInventory);_


_q.multiselect(v.get(VideoStore_.location).get(Address_.street),_

 _inv.key().get(Movie_.title),_

 _inv);_


_q.where(cb.equal(v.get(VideoStore_.location).get(Address_.zipcode),_

 _"94301"),_

 _cb.gt(inv, 0));_

This query is equivalent to the following, in
which the _tuple_ method is used:

 _CriteriaQuery<Tuple> q =
cb.createTupleQuery();_

 _Root<VideoStore> v =
q.from(VideoStore.class);_

 _MapJoin<VideoStore, Movie, Integer> inv =_

 _v.join(VideoStore_.videoInventory);_


_q.select(cb.tuple(v.get(VideoStore_.location).get(Address_.street),_

 _inv.key().get(Movie_.title),_

 _inv));_


_q.where(cb.equal(v.get(VideoStore_.location).get(Address_.zipcode),_

 _"94301"),_

 _cb.gt(inv, 0));_

Both are equivalent to the following Java
Persistence query language query:

SELECT v.location.street, KEY(i).title,
VALUE(i)

FROM VideoStore v JOIN v.videoInventory i

WHERE v.location.zipcode = '94301' AND
VALUE(i) > 0



 _Example 2:_

 _The following two queries are equivalent to
the Java Persistence query language query above. Because the result type
is not specified by the_ _createQuery_ _method, an_ _Object[]_ _is
returned as a result of the query execution:_

 _CriteriaQuery<Object> q =
cb.createQuery();_

 _Root<VideoStore> v =
q.from(VideoStore.class);_

 _MapJoin<VideoStore, Movie, Integer> inv =_

 _v.join(VideoStore_.videoInventory);_


_q.multiselect(v.get(VideoStore_.location).get(Address_.street),_

 _inv.key().get(Movie_.title),_

 _inv);_


_q.where(cb.equal(v.get(VideoStore_.location).get(Address_.zipcode),_

 _"94301"),_

 _cb.gt(inv, 0));_

Equivalently:

 _CriteriaQuery<Object> q =
cb.createQuery();_

 _Root<VideoStore> v =
q.from(VideoStore.class);_

 _MapJoin<VideoStore, Movie, Integer> inv =_

 _v.join(VideoStore_.videoInventory);_


_q.select(cb.array(v.get(VideoStore_.location).get(Address_.street),_

 _inv.key().get(Movie_.title),_

 _inv));_


_q.where(cb.equal(v.get(VideoStore_.location).get(Address_.zipcode),_

 _"94301"),_

 _cb.gt(inv, 0));_

 _Example 3:_

The following example illustrates the
specification of a constructor.

 _CriteriaQuery<CustomerDetails> q =_

 _cb.createQuery(CustomerDetails.class);_

 _Root<Customer> c = q.from(Customer.class);_

 _Join<Customer, Order> o =
c.join(Customer_.orders);_

 _q.where(cb.gt(o.get(Order_.quantity),
100));_


_q.select(cb.construct(CustomerDetails.class,_

 _c.get(Customer_.id),_

 _c.get(Customer_.status),_

 _o.get(Order_.quantity)));_

The following Java Persistence query language
query is equivalent:

 _SELECT NEW
com.acme.example.CustomerDetails(c.id, c.status, o.quantity)_

 _FROM Customer c JOIN c.orders o_

 _WHERE o.quantity > 100_



===== Assigning Aliases to Selection Items

The _alias_ method of the _Selection_
interface can be used to assign an alias to a selection item. The alias
may then later be used to extract the corresponding item from the query
result when the query is executed. The _alias_ method assigns the given
alias to the _Selection_ item. Once assigned, the alias cannot be
changed.

Example:

CriteriaQuery<Tuple> q =
cb.createTupleQuery();

Root<Customer> c = q.from(Customer.class);

Join<Customer, Order> o =
c.join(Customer_.orders);

Join<Customer, Address> a =
c.join(Customer_.address);

q.where(cb.equal(c.get(Customer_.id),
97510));

q.multiselect(o.get(Order_.quantity).alias("quantity"),

 cb.prod(o.get(Order_.totalCost), 1.08)

 .alias("taxedCost"),

 a.get(Address_.zipcode).alias("zipcode"));

TypedQuery<Tuple> typedQuery =
em.createQuery(q);

Tuple result = typedQuery.getSingleResult();

Double cost = (Double)
result.get("taxedCost");



==== Subqueries

Both correlated and non-correlated subqueries
can be used in restriction predicates. A subquery is constructed through
the creation and modification of a _Subquery_ object.

A _Subquery_ instance can be passed as an
argument to the _all_ , _any_ , or _some_ methods of the
_CriteriaBuilder_ interface for use in conditional expressions.

A _Subquery_ instance can be passed to the
_CriteriaBuilder_ _exists_ method to create a conditional predicate.

 _Example 1: Non-correlated subquery_

The query below contains a non-correlated
subquery. A non-correlated subquery does not reference objects of the
query of which it is a subquery. In particular, _Root_ , _Join_ , and
_Path_ instances are not shared between the subquery and the criteria
query instance of which it is a subquery.

// create criteria query instance, with root
Customer

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> goodCustomer =
q.from(Customer.class);



// create subquery instance, with root
Customer

// the Subquery object is typed according to
its return type

Subquery<Double> sq =
q.subquery(Double.class);

Root<Customer> customer =
sq.from(Customer.class);



// the result of the first query depends on
the subquery

q.where(cb.lt(

 goodCustomer.get(Customer_.balanceOwed),


sq.select(cb.avg(customer.get(Customer_.balanceOwed)))));

q.select(goodCustomer);

This query corresponds to the following Java
Persistence query language query.

SELECT goodCustomer

FROM Customer goodCustomer

WHERE goodCustomer.balanceOwed < (

 SELECT AVG(c.balanceOwed) FROM Customer c)



 _Example 2: Correlated subquery_

// create CriteriaQuery instance, with root
Employee

CriteriaQuery<Employee> q =
cb.createQuery(Employee.class);

Root<Employee> emp = q.from(Employee.class);



// create Subquery instance, with root
Employee

Subquery<Employee> sq =
q.subquery(Employee.class);

Root<Employee> spouseEmp =
sq.from(Employee.class);



// the subquery references the root of the
containing query

sq.where(cb.equal(spouseEmp,
emp.get(Employee_.spouse)))

 .select(spouseEmp);



// an exists condition is applied to the
subquery result:

q.where(cb.exists(sq));

q.select(emp).distinct(true);

The above query corresponds to the following
Java Persistence query language query.

SELECT DISTINCT emp

FROM Employee emp

WHERE EXISTS (

 SELECT spouseEmp

 FROM Employee spouseEmp

 WHERE spouseEmp = emp.spouse)

 _Example 3: Subquery qualified by all()_

// create CriteriaQuery instance, with root
Employee

CriteriaQuery<Employee> q =
cb.createQuery(Employee.class);

Root<Employee> emp = q.from(Employee.class);



// create Subquery instance, with root
Manager

Subquery<BigDecimal> sq =
q.subquery(BigDecimal.class);

Root<Manager> manager =
sq.from(Manager.class);



sq.select(manager.get(Manager_.salary));

sq.where(cb.equal(manager.get(Manager_.department),

 emp.get(Employee_.department)));



// an all expression is applied to the
subquery result

q.select(emp)

 .where(cb.gt(emp.get(Employee_.salary),
cb.all(sq)));

This query corresponds to the following Java
Persistence query language query:

SELECT emp

FROM Employee emp

WHERE emp.salary > ALL (

 SELECT m.salary

 FROM Manager m

 WHERE m.department = emp.department)

 _Example 4: A Special case_

In order to express some correlated
subqueries involving unidirectional relationships, it may be useful to
correlate the domain of the subquery with the domain of the containing
query. This is performed by using the _correlate_ method of the
_Subquery_ interface.

For example:

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> customer =
q.from(Customer.class);

Subquery<Long> sq = q.subquery(Long.class);

Root<Customer> customerSub =
sq.correlate(customer);

Join<Customer,Order> order =
customerSub.join(Customer_.orders);

q.where(cb.gt(sq.select(cb.count(order)),
10))

 .select(customer);

This query corresponds to the following Java
Persistence query language query:

SELECT c

FROM Customer c

WHERE (SELECT COUNT(o) FROM c.orders o) > 10

Note that joins involving the derived
subquery root do not affect the join conditions of the containing query.
The following two query definitions thus differ in semantics:

CriteriaQuery<Order> q =
cb.createQuery(Order.class);

Root<Order> order = q.from(Order.class);

Subquery<Integer> sq =
q.subquery(Integer.class);

Root<Order> orderSub = sq.correlate(order);

Join<Order,Customer> customer =
orderSub.join(Order_.customer);

Join<Customer,Account> account =
customer.join(Customer_.accounts);

sq.select(account.get(Account_.balance));

q.where(cb.lt(cb.literal(10000),
cb.all(sq)));

and

CriteriaQuery<Order> q =
cb.createQuery(Order.class);

Root<Order> order = q.from(Order.class);

Join<Order,Customer> customer =
order.join(Order_.customer);

Subquery<Integer> sq =
q.subquery(Integer.class);

Join<Order,Customer> customerSub =
sq.correlate(customer);

Join<Customer,Account> account =

 customerSub.join(Customer_.accounts);

sq.select(account.get(Account_.balance));

q.where(cb.lt(cb.literal(10000),
cb.all(sq)));

The first of these queries will return orders
that are not associated with customers, whereas the second will not. The
corresponding Java Persistence query language queries are the following:

SELECT o

FROM Order o

WHERE 10000 < ALL (

 SELECT a.balance

 FROM o.customer c JOIN c.accounts a)

and

SELECT o

FROM Order o JOIN o.customer c

WHERE 10000 < ALL (

 SELECT a.balance

 FROM c.accounts a)

==== GroupBy and Having

The _groupBy_ method of the _CriteriaQuery_
interface is used to define a partitioning of the query results into
groups. The _having_ method of the _CriteriaQuery_ interface can be used
to filter over the groups.

The arguments to the _groupBy_ method are
_Expression_ instances.

When the _groupBy_ method is used, each
selection item that is not the result of applying an aggregate method
must correspond to a path expression that is used for defining the
grouping. Requirements on the types that correspond to the elements of
the grouping and having constructs and their relationship to the select
items are as specified in Section link:Per.html#a5410[See GROUP
BY, HAVING].

 _Example:_

 _CriteriaQuery<Tuple> q =
cb.createTupleQuery();_

 _Root<Customer> customer =
q.from(Customer.class);_

 _q.groupBy(customer.get(Customer_.status));_


_q.having(cb.in(customer.get(Customer_.status)).value(1).value(2));_

 _q.select(cb.tuple(_

 _customer.get(Customer_.status),_


_cb.avg(customer.get(Customer_.filledOrderCount)),_

 _cb.count(customer)));_

This query is equivalent to the following
Java Persistence query language query:

 _SELECT c.status, AVG(c.filledOrderCount),
COUNT(c)_

 _FROM Customer c_

 _GROUP BY c.status_

 _HAVING c.status IN (1, 2)_





==== Ordering the Query Results

The ordering of the results of a query is
defined by use of the _orderBy_ method of the _CriteriaQuery_ instance.
The arguments to the _orderBy_ method are _Order_ instances.

An _Order_ instance is created by means of
the _asc_ and _desc_ methods of the _CriteriaBuilder_ interface. An
argument to either of these methods must be one of the following:

Any _Expression_ instance that corresponds to
an orderable state field of an entity or embeddable class abstract
schema type that is specified as an argument to the _select_ or
_multiselect_ method or that is an argument to a tuple or array
constructor that is passed as an argument to the _select_ method.

Any _Expression_ instance that corresponds to
the same state field of the same entity or embeddable abstract schema
type as an _Expression_ instance that is specified as an argument to the
_select_ or _multiselect_ method or that is an argument to a tuple or
array constructor that is passed as an argument to the _select_ method.

An _Expression_ instance that is specified as
an argument to the _select_ or _multiselect_ method or that is an
argument to a tuple or array constructor that is passed as an argument
to the _select_ method or that is semantically equivalent to such an
_Expression_ instance.

If more than one _Order_ instance is
specified, the order in which they appear in the argument list of the
_orderBy_ method determines the precedence, whereby the first item has
highest precedence.

SQL rules for the ordering of null values
apply, as described in Section link:Per.html#a5587[See ORDER BY
Clause].

 _Example 1:_

 _CriteriaQuery<Order> q =
cb.createQuery(Order.class);_

 _Root<Customer> c = q.from(Customer.class);_

 _Join<Customer,Order> o =
c.join(Customer_.orders);_

 _Join<Customer,Address> a =
c.join(Customer_.address);_

 _q.where(cb.equal(a.get(Address_.state),
"CA"));_

q.select(o);

 _q.orderBy(cb.desc(o.get(Order_.quantity)),_

 _cb.asc(o.get(Order_.totalCost)));_

This query corresponds to the following Java
Persistence query language query:

SELECT o

FROM Customer c JOIN c.orders o JOIN
c.address a

WHERE a.state = 'CA’

ORDER BY o.quantity DESC, o.totalcost

 _Example 2:_

 _CriteriaQuery<Tuple> q =
cb.createTupleQuery();_

 _Root<Customer> c = q.from(Customer.class);_

 _Join<Customer, Order> o =
c.join(Customer_.orders);_

 _Join<Customer, Address> a =
c.join(Customer_.address);_

 _q.where(cb.equal(a.get(Address_.state),
"CA"));_

 _q.orderBy(cb.asc(o.get(Order_.quantity)),_

 _cb.asc(a.get(Address_.zipcode)));_

 _q.multiselect(o.get(Order_.quantity),
a.get(Address_.zipcode));_

This query corresponds to the following Java
Persistence query language query:

SELECT o.quantity, a.zipcode

FROM Customer c JOIN c.orders o JOIN
c.address a

WHERE a.state = 'CA’

ORDER BY o.quantity, a.zipcode

It can be equivalently expressed as follows:

 _CriteriaQuery<Tuple> q =
cb.createTupleQuery();_

 _Root<Customer> c = q.from(Customer.class);_

 _Join<Customer, Order> o =
c.join(Customer_.orders);_

 _Join<Customer, Address> a =
c.join(Customer_.address);_

 _q.where(cb.equal(a.get(Address_.state),
"CA"));_

 _q.orderBy(cb.asc(o.get(Order_.quantity)),_

 _cb.asc(a.get(Address_.zipcode)));_

 _q.select(cb.tuple(o.get(Order_.quantity),
a.get(Address_.zipcode)));_

 _Example 3:_

CriteriaQuery<Object[]> q =
cb.createQuery(Object[].class);

Root<Customer> c = q.from(Customer.class);

Join<Customer, Order> o =
c.join(Customer_.orders);

Join<Customer, Address> a =
c.join(Customer_.address);

q.where(cb.equal(a.get(Address_.state),
"CA"),

 cb.equal(a.get(Address_.county), "Santa
Clara"));

q.select(cb.array(o.get(Order_.quantity),

 cb.prod(o.get(Order_.totalCost), 1.08),

 a.get(Address_.zipcode)));

q.orderBy(cb.asc(o.get(Order_.quantity)),

 cb.asc(cb.prod(o.get(Order_.totalCost),
1.08)),

 cb.asc(a.get(Address_.zipcode)));

This query corresponds to the following Java
Persistence query language query:

SELECT o.quantity, o.totalCost * 1.08 AS
taxedCost, a.zipcode

FROM Customer c JOIN c.orders o JOIN
c.address a

WHERE a.state = 'CA' AND a.county = 'Santa
Clara'

ORDER BY o.quantity, taxedCost, a.zipcode

==== [[a11239]]Bulk Update and Delete Operations

A bulk update query is constructed through
the creation and modification of a
_javax.persistence.criteria.CriteriaUpdate_ object.

A _CriteriaUpdate_ object is created by means
of one of the _createCriteriaUpdate_ methods of the _CriteriaBuilder_
interface. A _CriteriaUpdate_ object is typed according to the entity
type that is the target of the update. A _CriteriaUpdate_ object has a
single root, the entity that is being updated.

A bulk delete query is constructed through
the creation and modification of a
_javax.persistence.criteria.CriteriaDelete_ object.

A _CriteriaDelete_ object is created by means
of one of the _createCriteriaDelete_ methods of the _CriteriaBuilder_
interface. A _CriteriaDelete_ object is typed according to the entity
type that is the target of the delete. A _CriteriaDelete_ object has a
single root, the entity that is being deleted.

 _Example 1:_

CriteriaUpdate<Customer> q =
cb.createCriteriaUpdate(Customer.class);

Root<Customer> c = q.from(Customer.class);

q.set(c.get(Customer_.status), "outstanding")

 .where(cb.lt(c.get(Customer_.balance),
10000));



The following Java Persistence query language
update statement is equivalent.

UPDATE Customer c

SET c.status = 'outstanding'

WHERE c.balance < 10000

 _Example 2:_

CriteriaUpdate<Employee> q =
cb.createCriteriaUpdate(Employee.class);

Root<Employee> e = q.from(Employee.class);

q.set(e.get(Employee_.address).get(Address_.building),
22)


.where(cb.equal(e.get(Employee_.address).get(Address_.building),

 14),


cb.equal(e.get(Employee_.address).get(Address_.city),

 "Santa Clara"),


cb.equal(e.get(Employee_.project).get(Project_.name),

 "Java EE"));



 _Address_ is an embeddable class. Note that
updating across implicit joins is not supported.

The following Java Persistence query language
update statement is equivalent.

UPDATE Employee e

SET e.address.building = 22

WHERE e.address.building = 14

 AND e.address.city = 'Santa Clara'

 AND e.project.name = 'Java EE'

 _Example 3:_

The following update query causes multiple
attributes to be updated.

CriteriaUpdate<Employee> q =
cb.createCriteriaUpdate(Employee.class);

Root<Employee> e = q.from(Employee.class);

q.set(e.get(Employee_.salary),

 cb.prod(e.get(Employee_.salary), 1.1f))

 .set(e.get(Employee_.commission),

 cb.prod(e.get(Employee_.commission), 1.1f))

 .set(e.get(Employee_.bonus),

 cb.sum(e.get(Employee_.bonus), 5000))


.where(cb.equal(e.get(Employee_.dept).get(Department_.name),

 "Sales"));

The following Java Persistence query language
update statement is equivalent.

UPDATE Employee e

SET e.salary = e.salary * 1.1,

 e.commission = e.commission * 1.1,

 e.bonus = e.bonus + 5000

WHERE e.dept.name = 'Sales'



 _Example 4:_

CriteriaDelete<Customer> q =
cb.createCriteriaDelete(Customer.class);

Root<Customer> c = q.from(Customer.class);

q.where(cb.equal(c.get(Customer_.status),
"inactive"),

 cb.isEmpty(c.get(Customer_.orders)));



The following Java Persistence query language
delete statement is equivalent.

DELETE

FROM Customer c

WHERE c.status = 'inactive'

 AND c.orders IS EMPTY



Like bulk update and delete operations made
through the Java Persistence query language, criteria API bulk update
and delete operations map directly to database operations, bypassing any
optimistic locking checks. Portable applications using bulk update
operations must manually update the value of the version column, if
desired, and/or manually validate the value of the version column.

The persistence context is not synchronized
with the result of the bulk update or delete. See section
link:Per.html#a5636[See Bulk Update and Delete Operations].

[discrete]
=== [[a11305]]Constructing Strongly-typed Queries using the javax.persistence.metamodel Interfaces

image:Per-4.png[image]

Strongly-typed queries can also be
constructed, either statically or dynamically, in the absence of
generated metamodel classes. The _javax.persistence.metamodel_
interfaces are used to access the metamodel objects that correspond to
the managed classes.

The following examples illustrate this
approach. These are equivalent to the example queries shown in section
link:Per.html#a16277[See Path Navigation].

The _Metamodel_ interface is obtained from
the EntityManager or EntityManagerFactory for the persistence unit, and
then used to obtain the corresponding metamodel objects for the managed
types referenced by the queries.

Example 1:

EntityManager em = ...;

Metamodel mm = em.getMetamodel();



EntityType<Employee> emp_ =
mm.entity(Employee.class);

EmbeddableType<ContactInfo> cinfo_ =

 mm.embeddable(ContactInfo.class);

EntityType<Phone> phone_ =
mm.entity(Phone.class);

EmbeddableType<Address> addr_ =
mm.embeddable(Address.class);



CriteriaQuery<Vendor> q =
cb.createQuery(Vendor.class);

Root<Employee> emp = q.from(Employee.class);

Join<Employee, ContactInfo> cinfo =


emp.join(emp_.getSingularAttribute("contactInfo",

 ContactInfo.class));

Join<ContactInfo, Phone> p =


cinfo.join(cinfo_.getSingularAttribute("phones", Phone.class));

q.where(


cb.equal(emp.get(emp_.getSingularAttribute("contactInfo",

 ContactInfo.class))

 .get(cinfo_.getSingularAttribute("address",

 Address.class))

 .get(addr_.getSingularAttribute("zipcode",

 String.class)),

 "95054"))


.select(p.get(phone_.getSingularAttribute("vendor",Vendor.class)));

Example 2:

EntityManager em = ...;

Metamodel mm = em.getMetamodel();



EntityType<Item> item_ =
mm.entity(Item.class);



CriteriaQuery<Tuple> q =
cb.createTupleQuery();

Root<Item> item = q.from(Item.class);

MapJoin<Item, String, Object> photo =

 item.join(item_.getMap("photos",
String.class, Object.class));

q.multiselect(

 item.get(item_.getSingularAttribute("name",
String.class)),

 photo)

 .where(cb.like(photo.key(), "%egret%"));

=== [[a11349]]Use of the Criteria API with Strings to Reference Attributes

image:Per-4.png[image]

The Criteria API provides the option of
specifying the attribute references used in joins and navigation by
attribute names used as arguments to the various _join_ , _fetch_ , and
_get_ methods.

The resulting queries have the same semantics
as described in section link:Per.html#a10614[See Constructing
Criteria Queries], but do not provide the same level of type safety.

The examples in this section illustrate this
approach. These examples are derived from among those of sections
link:Per.html#a10643[See Joins] and
link:Per.html#a16277[See Path Navigation].

 _Example 1:_

CriteriaBuilder cb = ...

CriteriaQuery<String> q =
cb.createQuery(String.class);

Root<Customer> cust = q.from(Customer.class);

Join<Order, Item> item =

 cust.join("orders").join("lineItems");

q.select(cust.<String>get("name"))

 .where(


cb.equal(item.get("product").get("productType"),

 "printer"));

This query is equivalent to the following
Java Persistence query language query:

SELECT c.name

FROM Customer c JOIN c.orders o JOIN
o.lineItems i

WHERE i.product.productType = 'printer'

It is not required that type parameters be
used. However, their omission may result in compiler warnings, as with
the below version of the same query:

CriteriaBuilder cb = ...

CriteriaQuery q = cb.createQuery();

Root cust = q.from(Customer.class);

Join item =
cust.join("orders").join("lineItems");

q.select(cust.get("name"))

 .where(


cb.equal(item.get("product").get("productType"),

 "printer"));

 _Example 2:_

The following query uses an outer join:

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> cust = q.from(Customer.class);

Join<Customer,Order> order =

 cust.join("orders", JoinType.LEFT);

q.where(cb.equal(cust.get("status"), 1))

 .select(cust);

This query is equivalent to the following
Java Persistence query language query:

SELECT c FROM Customer c LEFT JOIN c.orders o
WHERE c.status = 1



 _Example 3:_

In the following example, _ContactInfo_ is an
embeddable class consisting of an address and set of phones. _Phone_ is
an entity.

CriteriaQuery<Vendor> q =
cb.createQuery(Vendor.class);

Root<Employee> emp = q.from(Employee.class);

Join<ContactInfo, Phone> phone =

 emp.join("contactInfo").join("phones");

q.where(cb.equal(emp.get("contactInfo")

 .get("address")

 .get("zipcode"),

 "95054"));

q.select(phone.<Vendor>get("vendor"));

The following Java Persistence query language
query is equivalent:

SELECT p.vendor

FROM Employee e JOIN e.contactInfo.phones p

WHERE e.contactInfo.address.zipcode = '95054'

 _Example 4:_

In this example, the _photos_ attribute
corresponds to a map from photo label to filename. The map key is a
string, the value an object.

CriteriaQuery<Object> q = cb.createQuery();

Root<Item> item = q.from(Item.class);

MapJoin<Item, String, Object> photo =
item.joinMap("photos");

q.multiselect(item.get("name"), photo)

 .where(cb.like(photo.key(), "%egret%"));

This query is equivalent to the following
Java Persistence query language query:

SELECT i.name, p

FROM Item i JOIN i.photos p

WHERE KEY(p) LIKE ’%egret%’

=== [[a11413]]Query Modification

image:Per-4.png[image]

A _CriteriaQuery_ , _CriteriaUpdate_ , or
_CriteriaDelete_ object may be modified, either before or after _Query_
or _TypedQuery_ objects have been created and executed from it. For
example, such modification may entail replacement of the _where_
predicate or the _select_ list. Modifications may thus result in the
same query object “base” being reused for several query instances.

For example, the user might create and
execute a query from the following _CriteriaQuery_ object:

CriteriaQuery<Customer> q =
cb.createQuery(Customer.class);

Root<Customer> c = q.from(Customer.class);

Predicate pred =


cb.equal(c.get(Customer_.address).get(Address_.city),"Chicago");

q.select(c);

q.where(pred);

The _CriteriaQuery_ object might then be
modified to reflect a different predicate condition, for example:

Predicate pred2 =

 cb.gt(c.get(Customer_.balanceOwed), 1000);

q.where(pred2);

Note, however, that query elements—-in this
example, predicate conditions—are dependent on the _CriteriaQuery_ ,
_CriteriaUpdate_ , or _CriteriaDelete_ instance, and are thus not
portably reusable with different instances.

=== [[a11427]]Query Execution

image:Per-4.png[image]

A criteria query is executed by passing the
_CriteriaQuery_ , _CriteriaUpdate_ , or _CriteriaDelete_ object to the
_createQuery_ method of the _EntityManager_ interface to create an
executable _TypedQuery_ object (or, in the case of _CriteriaUpdate_ and
_CriteriaDelete_ , a _Query_ object), which can then be passed to one of
the query execution methods of the _TypedQuery_ or _Query_ interface.

A _CriteriaQuery_ , _CriteriaUpdate_ , or
_CriteriaDelete_ object may be further modified after an executable
query object has been created from it. The modification of the
_CriteriaQuery_ , _CriteriaUpdate_ , or _CriteriaDelete_ object does not
have any impact on the already created executable query object. If the
modified _CriteriaQuery_ , _CriteriaUpdate_ , or _CriteriaDelete_ object
is passed to the _createQuery_ method, the persistence provider must
insure that a new executable query object is created and returned that
reflects the semantics of the changed query definition.

 _CriteriaQuery_ , _CriteriaUpdate_ , and
_CriteriaDelete_ objects must be serializable. A persistence vendor is
required to support the subsequent deserialization of such an object
into a separate JVM instance of that vendor’s runtime, where both
runtime instances have access to any required vendor implementation
classes. _CriteriaQuery_ , _CriteriaUpdate_ , and _CriteriaDelete_
objects are not required to be interoperable across vendors.

== [[a11431]]Entity Managers and Persistence Contexts

=== [[a11432]]Persistence Contexts

image:Per-4.png[image]

A persistence context is a set of managed
entity instances in which for any persistent entity identity there is a
unique entity instance. Within the persistence context, the entity
instances and their lifecycle are managed by the entity manager.

In Java EE environments, a JTA transaction
typically involves calls across multiple components. Such components may
often need to access the same persistence context within a single
transaction. To facilitate such use of entity managers in Java EE
environments, when an entity manager is injected into a component or
looked up directly in the JNDI naming context, its persistence context
will automatically be propagated with the current JTA transaction, and
the EntityManager references that are mapped to the same persistence
unit will provide access to this same persistence context within the JTA
transaction. This propagation of persistence contexts by the Java EE
container avoids the need for the application to pass references to
EntityManager instances from one component to another. An entity manager
for which the container manages the persistence context in this manner
is termed a _container-managed entity manager_ . A container-managed
entity manager’s lifecycle is managed by the Java EE container.

In less common use cases within Java EE
environments, applications may need to access a persistence context that
is “stand-alone”—i.e. not propagated along with the JTA transaction
across the EntityManager references for the given persistence unit.
Instead, each instance of creating an entity manager causes a new
isolated persistence context to be created that is not accessible
through other EntityManager references within the same transaction.
These use cases are supported through the _createEntityManager_ methods
of the _EntityManagerFactory_ interface. An entity manager that is used
by the application to create and destroy a persistence context in this
manner is termed an _application-managed entity manager_ . An
application-managed entity manager’s lifecycle is managed by the
application.

Both container-managed entity managers and
application-managed entity managers and their persistence contexts are
required to be supported in Java EE web containers and EJB containers.
Within an EJB environment, container-managed entity managers are
typically used.

In Java SE environments and in Java EE
application client containers, only application-managed entity managers
are required to be supportedlink:#a19617[81].

=== Obtaining an EntityManager

image:Per-4.png[image]

The entity manager for a persistence context
is obtained from an entity manager factory.

When container-managed entity managers are
used (in Java EE environments), the application does not interact with
the entity manager factory. The entity managers are obtained directly
through dependency injection or from JNDI, and the container manages
interaction with the entity manager factory transparently to the
application.

When application-managed entity managers are
used, the application must use the entity manager factory to manage the
entity manager and persistence context lifecycle.

An entity manager must not be shared among
multiple concurrently executing threads, as the entity manager and
persistence context are not required to be threadsafe. Entity managers
must only be accessed in a single-threaded manner.

==== Obtaining an Entity Manager in the Java EE Environment

A container-managed entity manager is
obtained by the application through dependency injection or through
direct lookup of the entity manager in the JNDI namespace. The container
manages the persistence context lifecycle and the creation and the
closing of the entity manager instance transparently to the application.

The _PersistenceContext_ annotation is used
for entity manager injection. The _type_ element specifies whether a
transaction-scoped or extended persistence context is to be used, as
described in section link:Per.html#a11791[See Container-managed
Persistence Contexts]. The _synchronization_ element specifies whether
the persistence context is always automatically joined to the current
transaction (the default) or is not joined to the current transaction
unless the _joinTransaction_ method is invoked by the application. The
_unitName_ element may optionally be specified to designate the
persistence unit whose entity manager factory is used by the container.
The semantics of the persistence context synchronization type are
further described in section link:Per.html#a11797[See Persistence
Context Synchronization Type]. Section link:Per.html#a13887[See
PersistenceUnit Annotation] provides further information about the
_unitName_ element.

For example,

 @PersistenceContext

 EntityManager em;




@PersistenceContext(type=PersistenceContextType.EXTENDED)

 EntityManager orderEM;





The JNDI lookup of an entity manager is
illustrated below:

@Stateless

@PersistenceContext(name="OrderEM")

public class MySessionBean implements
MyInterface \{

 @Resource SessionContext ctx;



 public void doSomething() \{

 EntityManager em =
(EntityManager)ctx.lookup("OrderEM");

 ...

 }

}

==== [[a11465]]Obtaining an Application-managed Entity Manager

An application-managed entity manager is
obtained by the application from an entity manager factory.

The _EntityManagerFactory_ API used to obtain
an application-managed entity manager is the same independent of whether
this API is used in Java EE or Java SE environments.

=== Obtaining an Entity Manager Factory

image:Per-4.png[image]

The _EntityManagerFactory_ interface is used
by the application to create an application-managed entity
managerlink:#a19618[82].

Each entity manager factory provides entity
manager instances that are all configured in the same manner (e.g.,
configured to connect to the same database, use the same initial
settings as defined by the implementation, etc.)

{empty}More than one entity manager factory
instance may be available simultaneously in the
JVM.link:#a19619[83]

Methods of the _EntityManagerFactory_
interface are threadsafe.

==== Obtaining an Entity Manager Factory in a Java EE Container

Within a Java EE environment, an entity
manager factory can be injected using the _PersistenceUnit_ annotation
or obtained through JNDI lookup. The _unitName_ element may optionally
be specified to designate the persistence unit whose entity manager
factory is used. (See section link:Per.html#a13887[See
PersistenceUnit Annotation]).

For example,

 @PersistenceUnit

 EntityManagerFactory emf;

==== Obtaining an Entity Manager Factory in a Java SE Environment

Outside a Java EE container environment, the
_javax.persistence.Persistence_ class is the bootstrap class that
provides access to an entity manager factory. The application creates an
entity manager factory by calling the _createEntityManagerFactory_
method of the _javax.persistence.Persistence_ class, described in
section link:Per.html#a13443[See javax.persistence.Persistence
Class].

For example,

EntityManagerFactory emf =


javax.persistence.Persistence.createEntityManagerFactory("Order");

EntityManager em = emf.createEntityManager();

=== EntityManagerFactory Interface

image:Per-4.png[image]

The _EntityManagerFactory_ interface is used
by the application to obtain an application-managed entity manager. When
the application has finished using the entity manager factory, and/or at
application shutdown, the application should close the entity manager
factory. Once an entity manager factory has been closed, all its entity
managers are considered to be in the closed state.

The _EntityManagerFactory_ interface provides
access to information and services that are global to the persistence
unit. This includes access to the second level cache that is maintained
by the persistence provider and to the _PersistenceUnitUtil_ interface.
The _Cache_ interface is described in section
link:Per.html#a12124[See Cache Interface]; the
_PersistenceUnitUtil_ interface in section
link:Per.html#a12177[See PersistenceUnitUtil Interface].



package javax.persistence;



import java.util.Map;

import javax.persistence.metamodel.Metamodel;

import
javax.persistence.criteria.CriteriaBuilder;



/**

 * Interface used to interact with the entity
manager factory

 * for the persistence unit.

 */

public interface EntityManagerFactory \{



 /**

 * Create a new application-managed
EntityManager.

 * This method returns a new EntityManager
instance each time

 * it is invoked.

 * The isOpen method will return true on the
returned instance.

 * @return entity manager instance

 * @throws IllegalStateException if the
entity manager factory

 * has been closed

 */

 public EntityManager createEntityManager();



 /**

 * Create a new application-managed
EntityManager with the

 * specified Map of properties.

 * This method returns a new EntityManager
instance each time

 * it is invoked.

 * The isOpen method will return true on the
returned instance.

 * @param map properties for entity manager

 * @return entity manager instance

 * @throws IllegalStateException if the
entity manager factory

 * has been closed

 */

 public EntityManager createEntityManager(Map
map);



 /**

 * Create a new JTA application-managed
EntityManager with the

 * specified synchronization type.

 * This method returns a new EntityManager
instance each time

 * it is invoked.

 * The isOpen method will return true on the
returned instance.

 * @param synchronizationType how and when
the entity manager

 * should be synchronized with the current
JTA transaction

 * @return entity manager instance

 * @throws IllegalStateException if the
entity manager factory

 * has been configured for resource-local
entity managers or has

 * been closed

 */

 public EntityManager createEntityManager(

 SynchronizationType synchronizationType);















 /**

 * Create a new JTA application-managed
EntityManager with the

 * specified synchronization type and Map of
properties.

 * This method returns a new EntityManager
instance each time

 * it is invoked.

 * The isOpen method will return true on the
returned instance.

 * @param synchronizationType how and when
the entity manager

 * should be synchronized with the current
JTA transaction

 * @param map properties for entity manager;
may be null

 * @return entity manager instance

 * @throws IllegalStateException if the
entity manager factory

 * has been configured for resource-local
entity managers or has

 * been closed

 */

 public EntityManager createEntityManager(

 SynchronizationType synchronizationType, Map
map);



 /**

 * Return an instance of CriteriaBuilder for
the creation of

 * CriteriaQuery objects.

 * @return CriteriaBuilder instance

 * @throws IllegalStateException if the
entity manager factory

 * has been closed

 */

 public CriteriaBuilder getCriteriaBuilder();



 /**

 * Return an instance of Metamodel interface
for access to the

 * metamodel of the persistence unit.

 * @return Metamodel instance

 * @throws IllegalStateException if the
entity manager factory

 * has been closed

 */

 public Metamodel getMetamodel();



 /**

 * Indicates whether the factory is open.
Returns true

 * until the factory has been closed.

 * @return boolean indicating whether the
factory is open

 */

 public boolean isOpen();



 /**

 * Close the factory, releasing any resources
that it holds.

 * After a factory instance has been closed,
all methods invoked

 * on it will throw the
IllegalStateException, except for isOpen,

 * which will return false. Once an
EntityManagerFactory has

 * been closed, all its entity managers are
considered to be

 * in the closed state.

 * @throws IllegalStateException if the
entity manager factory

 * has been closed

 */

 public void close();













 /**

 * Get the properties and associated values
that are in effect

 * for the entity manager factory. Changing
the contents of the

 * map does not change the configuration in
effect.

 * @return properties

 * @throws IllegalStateException if the
entity manager factory

 * has been closed

 */

 public Map<String, Object> getProperties();



 /**

 * Access the cache that is associated with
the entity manager

 * factory (the "second level cache").

 * @return instance of the Cache interface or
null if no cache

 * is in use

 * @throws IllegalStateException if the
entity manager factory

 * has been closed

 */

 public Cache getCache();



 /**

 * Return interface providing access to
utility methods

 * for the persistence unit.

 * @return PersistenceUnitUtil interface

 * @throws IllegalStateException if the
entity manager factory

 * has been closed

 */

 public PersistenceUnitUtil
getPersistenceUnitUtil();



 /**

 * Define the query, typed query, or stored
procedure query as

 * a named query such that future query
objects can be created

 * from it using the createNamedQuery or

 * createNamedStoredProcedureQuery method.

 * Any configuration of the query object
(except for actual

 * parameter binding) in effect when the
named query is added

 * is retained as part of the named query
definition.

 * This includes configuration information
such as max results,

 * hints, flush mode, lock mode, result set
mapping information,

 * and information about stored procedure
parameters.

 * When the query is executed, information
that can be set

 * by means of the query APIs can be
overridden. Information

 * that is overridden does not affect the
named query as

 * registered with the entity manager
factory, and thus does

 * not affect subsequent query objects
created from it by

 * means of the createNamedQuery or

 * createNamedStoredProcedureQuery methods.

 * If a named query of the same name has been
previously

 * defined, either statically via metadata or
via this method,

 * that query definition is replaced.

 * @param name name for the query

 * @param query Query, TypedQuery, or
StoredProcedureQuery object

 */

 public void addNamedQuery(String name, Query
query);











 /**

 * Return an object of the specified type to
allow access to the

 * provider-specific API. If the provider's
EntityManagerFactory

 * implementation does not support the
specified class, the

 * PersistenceException is thrown.

 * @param cls the class of the object to be
returned. This is

 * normally either the underlying
EntityManagerFactory

 * implementation class or an interface that
it implements.

 * @return an instance of the specified class

 * @throws PersistenceException if the
provider does not

 * support the call

 */

 public <T> T unwrap(Class<T> cls);



 /**

 * Add a named copy of the EntityGraph to the

 * EntityManagerFactory. If an entity graph
with the same name

 * already exists, it is replaced.

 * @param graphName name for the entity graph

 * @param entityGraph entity graph

 */

 public <T> void addNamedEntityGraph(String
graphName,

 EntityGraph<T> entityGraph);

}

Any number of vendor-specific properties may
be included in the map passed to the _createEntityManager_ methods.
Properties that are not recognized by a vendor must be ignored.

Note that the policies of the installation
environment may restrict some information from being made available
through the _EntityManagerFactory_ _getProperties_ method (for example,
JDBC user, password, URL).

Vendors should use vendor namespaces for
properties (e.g., _com.acme.persistence.logging_ ). Entries that make
use of the namespace _javax.persistence_ and its subnamespaces must not
be used for vendor-specific information. The namespace
_javax.persistence_ is reserved for use by this specification.

=== Controlling Transactions

image:Per-4.png[image]

Depending on the transactional type of the
entity manager, transactions involving EntityManager operations may be
controlled either through JTA or through use of the resource-local
_EntityTransaction_ API, which is mapped to a resource transaction over
the resource that underlies the entities managed by the entity manager.

An entity manager whose underlying
transactions are controlled through JTA is termed a _JTA entity manager_
.

An entity manager whose underlying
transactions are controlled by the application through the
_EntityTransaction_ API is termed a _resource-local entity manager_ .

A container-managed entity manager must be a
JTA entity manager. JTA entity managers are only specified for use in
Java EE containers.

An application-managed entity manager may be
either a JTA entity manager or a resource-local entity manager.

An entity manager is defined to be of a given
transactional type—either JTA or resource-local—at the time its
underlying entity manager factory is configured and created. See
sections link:Per.html#a12296[See transaction-type] and
link:Per.html#a12802[See Java EE Deployment].

Both JTA entity managers and resource-local
entity managers are required to be supported in Java EE web containers
and EJB containers. Within an EJB environment, a JTA entity manager is
typically used. In general, in Java SE environments only resource-local
entity managers are supported.

==== JTA EntityManagers

An entity manager whose transactions are
controlled through JTA is a JTA entity manager. In general, a JTA entity
manager participates in the current JTA transaction, which is begun and
committed external to the entity manager and propagated to the
underlying resource manager.

==== Resource-local EntityManagers

An entity manager whose transactions are
controlled by the application through the _EntityTransaction_ API is a
resource-local entity manager. A resource-local entity manager
transaction is mapped to a resource transaction over the resource by the
persistence provider. Resource-local entity managers may use server or
local resources to connect to the database and are unaware of the
presence of JTA transactions that may or may not be active.

==== The EntityTransaction Interface

The _EntityTransaction_ interface is used to
control resource transactions on resource-local entity managers. The
_EntityManager.getTransaction()_ method returns an instance of the
_EntityTransaction_ interface.

When a resource-local entity manager is used,
and the persistence provider runtime throws an exception defined to
cause transaction rollback, the persistence provider must mark the
transaction for rollback.

If the _EntityTransaction.commit_ operation
fails, the persistence provider must roll back the transaction.

package javax.persistence;



/**

 * Interface used to control transactions on
resource-local

 * entity managers.

 */

public interface EntityTransaction \{



 /**

 * Start a resource transaction.

 * @throws IllegalStateException if
isActive() is true

 */

 public void begin();



 /**

 * Commit the current resource transaction,
writing any

 * unflushed changes to the database.

 * @throws IllegalStateException if
isActive() is false

 * @throws RollbackException if the commit
fails

 */

 public void commit();



 /**

 * Roll back the current resource
transaction.

 * @throws IllegalStateException if
isActive() is false

 * @throws PersistenceException if an
unexpected error

 * condition is encountered

 */

 public void rollback();



 /**

 * Mark the current resource transaction so
that the only

 * possible outcome of the transaction is for
the transaction

 * to be rolled back.

 * @throws IllegalStateException if
isActive() is false

 */

 public void setRollbackOnly();



 /**

 * Determine whether the current resource
transaction has been

 * marked for rollback.

 * @return boolean indicating whether the
transaction has been

 * marked for rollback

 * @throws IllegalStateException if
isActive() is false

 */

 public boolean getRollbackOnly();



 /**

 * Indicate whether a resource transaction is
in progress.

 * @return boolean indicating whether
transaction is

 * in progress

 * @throws PersistenceException if an
unexpected error

 * condition is encountered

 */

 public boolean isActive();

}

==== Example

The following example illustrates the
creation of an entity manager factory in a Java SE environment, and its
use in creating and using a resource-local entity manager.

import javax.persistence.*;



public class PasswordChanger \{

 public static void main (String[] args) \{



 EntityManagerFactory emf =


Persistence.createEntityManagerFactory("Order");

 EntityManager em =
emf.createEntityManager();



 em.getTransaction().begin();

 User user = (User)em.createQuery

 ("SELECT u FROM User u WHERE u.name=:name
AND u.pass=:pass")

 .setParameter("name", args[0])

 .setParameter("pass", args[1])

 .getSingleResult();



 if (user!=null)

 user.setPassword(args[2]);



 em.getTransaction().commit();



 em.close();

 emf.close();

 }

}



=== [[a11791]]Container-managed Persistence Contexts

image:Per-4.png[image]

When a container-managed entity manager is
used, the lifecycle of the persistence context is always managed
automatically, transparently to the application, and the persistence
context is propagated with the JTA transaction.

A container-managed persistence context may
be defined to have either a lifetime that is scoped to a single
transaction or an extended lifetime that spans multiple transactions,
depending on the _PersistenceContextType_ that is specified when its
entity manager is created. This specification refers to such persistence
contexts as _transaction-scoped persistence contexts_ and _extended
persistence contexts_ respectively.

The lifetime of the persistence context is
declared using the _PersistenceContext_ annotation or the
_persistence-context-ref_ deployment descriptor element. By default, a
transaction-scoped persistence context is used.

Sections link:Per.html#a11805[See
Container-managed Transaction-scoped Persistence Context] and
link:Per.html#a11810[See Container-managed Extended Persistence
Context] describe transaction-scoped and extended persistence contexts
in the absence of persistence context propagation. Persistence context
propagation is described in section link:Per.html#a11816[See
Persistence Context Propagation].

Persistence contexts are always associated
with an entity manager factory. In the following sections, “the
persistence context” should be understood to mean “the persistence
context associated with a particular entity manager factory”.

==== [[a11797]]Persistence Context Synchronization Type

By default, a container-managed persistence
context is of type _SynchronizationType.SYNCHRONIZED_ . Such a
persistence context is automatically joined to the current JTA
transaction, and updates made to the persistence context are propagated
to the underlying resource manager.

A container-managed persistence context may
be specified to be of type _SynchronizationType.UNSYNCHRONIZED_ . A
persistence context of type _SynchronizationType.UNSYNCHRONIZED_ is not
enlisted in any JTA transaction unless explicitly joined to that
transaction by the application. A persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ is enlisted in a JTA transaction
and registered for subsequent transaction notifications against that
transaction by the invocation of the _EntityManager_ _joinTransaction_
method. The persistence context remains joined to the transaction until
the transaction commits or rolls back. After the transaction commits or
rolls back, the persistence context will not be joined to any subsequent
transaction unless the _joinTransaction_ method is invoked in the scope
of that subsequent transaction.

A persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ must not be flushed to the database
unless it is joined to a transaction. The application's use of queries
with pessimistic locks, bulk update or delete queries, etc. result in
the provider throwing the _TransactionRequiredException_ . After the
persistence context has been joined to the JTA transaction, these
operations are again allowed.

The application is permitted to invoke the
persist, merge, remove, and refresh entity lifecycle operations on an
entity manager of type _SynchronizationType.UNSYNCHRONIZED_ independent
of whether the persistence context is joined to the current transaction.
After the persistence context has been joined to a transaction, changes
in a persistence context can be flushed to the database either
explicitly by the application or by the provider. If the _flush_ method
is not explicitly invoked, the persistence provider may defer flushing
until commit time depending on the operations invoked and the flush mode
setting in effect.

If an extended persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ has not been joined to the current
JTA transaction, rollback of the JTA transaction will have no effect
upon the persistence context. In general, it is recommended that a
non-JTA datasource be specified for use by the persistence provider for
a persistence context of type _SynchronizationType.UNSYNCHRONIZED_ that
has not been joined to a JTA transaction in order to alleviate the risk
of integrating uncommitted changes into the persistence context in the
event that the transaction is later rolled back.

If a persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ has been joined to the JTA
transaction, transaction rollback will cause the persistence context to
be cleared and all pre-existing managed and removed instances to become
detached. (See section link:Per.html#a2049[See Transaction
Rollback].)

When a JTA transaction exists, a persistence
context of type _SynchronizationType.UNSYNCHRONIZED_ is propagated with
that transaction according to the rules in section
link:Per.html#a11820[See Requirements for Persistence Context
Propagation] regardless of whether the persistence context has been
joined to that transaction.

==== [[a11805]]Container-managed Transaction-scoped Persistence Context

The application can obtain a
container-managed entity manager with transaction-scoped persistence
context by injection or direct lookup in the JNDI namespace. The
persistence context type for the entity manager is defaulted or defined
as _PersistenceContextType.TRANSACTION_ .

A new persistence context begins when the
container-managed entity manager is invokedlink:#a19620[84] in
the scope of an active JTA transaction, and there is no current
persistence context already associated with the JTA transaction. The
persistence context is created and then associated with the JTA
transaction. This association of the persistence context with the JTA
transaction is independent of the synchronization type of the
persistence context and whether the persistence context has been joined
to the transaction.

{empty}The persistence context ends when the
associated JTA transaction commits or rolls back, and all entities that
were managed by the EntityManager become
detached.link:#a19621[85]

If the entity manager is invoked outside the
scope of a transaction, any entities loaded from the database will
immediately become detached at the end of the method call.

==== [[a11810]]Container-managed Extended Persistence Context

A container-managed extended persistence
context can only be initiated within the scope of a stateful session
bean. It exists from the point at which the stateful session bean that
declares a dependency on an entity manager of type
_PersistenceContextType.EXTENDED_ is created, and is said to be _bound_
to the stateful session bean. The dependency on the extended persistence
context is declared by means of the _PersistenceContext_ annotation or
_persistence-context-ref_ deployment descriptor element. The association
of the extended persistence context with the JTA transaction is
independent of the synchronization type of the persistence context and
whether the persistence context has been joined to the transaction.

The persistence context is closed by the
container when the _@Remove_ method of the stateful session bean
completes (or the stateful session bean instance is otherwise
destroyed).

===== Inheritance of Extended Persistence Context

If a stateful session bean instantiates a
stateful session bean (executing in the same EJB container instance)
which also has such an extended persistence context with the same
synchronization type, the extended persistence context of the first
stateful session bean is inherited by the second stateful session bean
and bound to it, and this rule recursively applies—independently of
whether transactions are active or not at the point of the creation of
the stateful session beans. If the stateful session beans differ in
declared synchronization type, the EJBException is thrown by the
container.

If the persistence context has been inherited
by any stateful session beans, the container does not close the
persistence context until all such stateful session beans have been
removed or otherwise destroyed.

==== [[a11816]]Persistence Context Propagation

As described in section
link:Per.html#a11432[See Persistence Contexts], a single
persistence context may correspond to one or more JTA entity manager
instances (all associated with the same entity manager
factorylink:#a19622[86]).

The persistence context is propagated across
the entity manager instances as the JTA transaction is propagated. A
persistence context of type _SynchronizationType.UNSYNCHRONIZED_ is
propagated with the JTA transaction regardless of whether it has been
joined to the transaction.

Propagation of persistence contexts only
applies within a local environment. Persistence contexts are not
propagated to remote tiers.

===== [[a11820]]Requirements for Persistence Context Propagation

Persistence contexts are propagated by the
container across component invocations as follows.

If a component is called and there is no JTA
transaction or the JTA transaction is not propagated, the persistence
context is not propagated.

If an entity manager is then invoked from
within the component:

Invocation of an entity manager defined with
_PersistenceContextType.TRANSACTION_ will result in use of a new
persistence context (as described in section
link:Per.html#a11805[See Container-managed Transaction-scoped
Persistence Context]).

Invocation of an entity manager defined with
_PersistenceContextType.EXTENDED_ will result in the use of the existing
extended persistence context bound to that component.

If the entity manager is invoked within a JTA
transaction, the persistence context will be associated with the JTA
transaction.

If a component is called and the JTA
transaction is propagated into that component:

If the component is a stateful session bean
to which an extended persistence context has been bound and there is a
different persistence context associated with the JTA transaction, an
_EJBException_ is thrown by the container.

If there is a persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ associated with the JTA transaction
and the target component specifies a persistence context of type
_SynchronizationType.SYNCHRONIZED_ , the _IllegalStateException_ is
thrown by the container.

Otherwise, if there is a persistence context
associated with the JTA transaction, that persistence context is
propagated and used.

Note that a component with a persistence
context of type _SynchronizationType.UNSYNCHRONIZED_ may be called by a
component propagating either a persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ or a persistence context of type
_SynchronizationType.SYNCHRONIZED_ into it.

==== Examples

===== Container-managed Transaction-scoped Persistence Context



@Stateless

public class ShoppingCartImpl implements
ShoppingCart \{



 @PersistenceContext EntityManager em;



 public Order getOrder(Long id) \{

 Order order = em.find(Order.class, id);

 order.getLineItems();

 return order;

 }



 public Product getProduct(String name) \{

 return (Product) em.createQuery("select p
from Product p where p.name = :name")

 .setParameter("name", name)

 .getSingleResult();

 }



 public LineItem createLineItem(Order order,
Product product, int quantity) \{

 LineItem li = new LineItem(order, product,
quantity);

 order.getLineItems().add(li);

 em.persist(li);

 return li;

 }



}

===== Container-managed Extended Persistence Context



/*

 * An extended transaction context is used.
The entities remain

 * managed in the persistence context across
multiple transactions.

 */

@Stateful

@Transaction(REQUIRES_NEW)

public class ShoppingCartImpl implements
ShoppingCart \{



 @PersistenceContext(type=EXTENDED)

 EntityManager em;



 private Order order;

 private Product product;



 public void initOrder(Long id) \{

 order = em.find(Order.class, id);

 }



 public void initProduct(String name) \{

 product = (Product) em.createQuery("select p
from Product p where p.name = :name")

 .setParameter("name", name)

 .getSingleResult();

 }



 public LineItem createLineItem(int quantity)
\{

 LineItem li = new LineItem(order, product,
quantity);

 order.getLineItems().add(li);

 em.persist(li);

 return li;

 }



}

=== [[a11894]]Application-managed Persistence Contexts

image:Per-4.png[image]

When an application-managed entity manager is
used, the application interacts directly with the persistence provider's
entity manager factory to manage the entity manager lifecycle and to
obtain and destroy persistence contexts.

All such application-managed persistence
contexts are extended in scope, and can span multiple transactions.

The _EntityManagerFactory_ .
_createEntityManager_ method and the _EntityManager_ _close_ and
_isOpen_ methods are used to manage the lifecycle of an
application-managed entity manager and its associated persistence
context.

The extended persistence context exists from
the point at which the entity manager has been created using
_EntityManagerFactory.createEntityManager_ until the entity manager is
closed by means of _EntityManager.close_ .

An extended persistence context obtained from
the application-managed entity manager is a stand-alone persistence
context—it is not propagated with the transaction.

When a JTA application-managed entity manager
is used, an application-managed persistence context may be specified to
be of type _SynchronizationType.UNSYNCHRONIZED_ . A persistence context
of type _SynchronizationType.UNSYNCHRONIZED_ is not enlisted in any JTA
transaction unless explicitly joined to that transaction by the
application. A persistence context of type
_SynchronizationType.UNSYNCHRONIZED_ is enlisted in a JTA transaction
and registered for subsequent transaction notifications against that
transaction by the invocation of the _EntityManager_ _joinTransaction_
method. The persistence context remains joined to the transaction until
the transaction commits or rolls back. After the transaction commits or
rolls back, the persistence context will not be joined to any subsequent
transaction unless the _joinTransaction_ method is invoked in the scope
of that subsequent transaction.

When a JTA application-managed entity manager
is used, if the entity manager is created outside the scope of the
current JTA transaction, it is the responsibility of the application to
join the entity manager to the transaction (if desired) by calling
_EntityManager.joinTransaction_ . If the entity manager is created
outside the scope of a JTA transaction, it is not joined to the
transaction unless _EntityManager.joinTransaction_ is called.

The _EntityManager.close_ method closes an
entity manager to release its persistence context and other resources.
After calling _close_ , the application must not invoke any further
methods on the _EntityManager_ instance except for _getTransaction_ and
_isOpen_ , or the _IllegalStateException_ will be thrown. If the _close_
method is invoked when a transaction is active, the persistence context
remains managed until the transaction completes.

The _EntityManager.isOpen_ method indicates
whether the entity manager is open. The _isOpen_ method returns true
until the entity manager has been closed.

==== Examples

===== Application-managed Persistence Context used in Stateless Session Bean



/*

 * Container-managed transaction demarcation
is used.

 * The session bean creates and closes an
entity manager

 * in each business method.

 */

@Stateless

public class ShoppingCartImpl implements
ShoppingCart \{



 @PersistenceUnit

 private EntityManagerFactory emf;



 public Order getOrder(Long id) \{

 EntityManager em =
emf.createEntityManager();

 Order order = em.find(Order.class, id);

 order.getLineItems();

 em.close();

 return order;

 }



 public Product getProduct() \{

 EntityManager em =
emf.createEntityManager();

 Product product = (Product)
em.createQuery("select p from Product p where p.name = :name")

 .setParameter("name", name)

 .getSingleResult();

 em.close();

 return product;

 }



 public LineItem createLineItem(Order order,
Product product, int quantity) \{

 EntityManager em =
emf.createEntityManager();

 LineItem li = new LineItem(order, product,
quantity);

 order.getLineItems().add(li);

 em.persist(li);

 em.close();

 return li; // remains managed until JTA
transaction ends

 }

}

===== Application-managed Persistence Context used in Stateless Session Bean



/*

 * Container-managed transaction demarcation
is used.

 * The session bean creates entity manager in
PostConstruct

 * method and clears persistence context at
the end of each

 * business method.

 */

@Stateless

public class ShoppingCartImpl implements
ShoppingCart \{



 @PersistenceUnit

 private EntityManagerFactory emf;



 private EntityManager em;



 @PostConstruct

 public void init()

 em = emf.createEntityManager();

 }



 public Order getOrder(Long id) \{

 Order order = em.find(Order.class, id);

 order.getLineItems();

 em.clear(); // entities are detached

 return order;

 }



 public Product getProduct() \{

 Product product = (Product)
em.createQuery("select p from Product p where p.name = :name")

 .setParameter("name", name)

 .getSingleResult();

 em.clear();

 return product;

 }



 public LineItem createLineItem(Order order,
Product product, int quantity) \{

 em.joinTransaction();

 LineItem li = new LineItem(order, product,
quantity);

 order.getLineItems().add(li);

 em.persist(li);



 // persistence context is flushed to
database;

 // all updates will be committed to database
on tx commit

 em.flush();



 // entities in persistence context are
detached

 em.clear();

 return li;

 }



 @PreDestroy

 public void destroy()

 em.close();

 }



}

===== Application-managed Persistence Context used in Stateful Session Bean



/*

 * Container-managed transaction demarcation
is used.

 * Entities remain managed until the entity
manager is closed.

 */

@Stateful

public class ShoppingCartImpl implements
ShoppingCart \{



 @PersistenceUnit

 private EntityManagerFactory emf;



 private EntityManager em;



 private Order order;

 private Product product;



 @PostConstruct

 public void init() \{

 em = emf.createEntityManager();

 }



 public void initOrder(Long id) \{

 order = em.find(Order.class, id);

 }



 public void initProduct(String name) \{

 product = (Product) em.createQuery("select p
from Product p where p.name = :name")

 .setParameter("name", name)

 .getSingleResult();

 }



 public LineItem createLineItem(int quantity)
\{

 em.joinTransaction();

 LineItem li = new LineItem(order, product,
quantity);

 order.getLineItems().add(li);

 em.persist(li);

 return li;

 }



 @Remove

 public void destroy() \{

 em.close();

 }



}

===== Application-managed Persistence Context with Resource Transaction



// Usage in an ordinary Java class



public class ShoppingImpl \{



 private EntityManager em;

 private EntityManagerFactory emf;



 public ShoppingCart() \{

 emf =
Persistence.createEntityManagerFactory("orderMgt");

 em = emf.createEntityManager();

 }





 private Order order;

 private Product product;



 public void initOrder(Long id) \{

 order = em.find(Order.class, id);

 }



 public void initProduct(String name) \{

 product = (Product) em.createQuery("select p
from Product p where p.name = :name")

 .setParameter("name", name)

 .getSingleResult();

 }



 public LineItem createLineItem(int quantity)
\{

 em.getTransaction().begin();



 LineItem li = new LineItem(order, product,
quantity);

 order.getLineItems().add(li);

 em.persist(li);



 em.getTransaction().commit();



 return li;

 }



 public void destroy() \{

 em.close();

 emf.close();

 }



}

=== Requirements on the Container

image:Per-4.png[image]

==== Application-managed Persistence Contexts

When application-managed persistence contexts
are used, the container must instantiate the entity manager factory and
expose it to the application via JNDI. The container might use internal
APIs to create the entity manager factory, or it might use the
_PersistenceProvider.createContainerEntityManagerFactory_ method.
However, the container is required to support third-party persistence
providers, and in this case the container must use the
_PersistenceProvider.createContainerEntityManagerFactory_ method to
create the entity manager factory and the _EntityManagerFactory.close_
method to destroy the entity manager factory prior to shutdown (if it
has not been previously closed by the application).

==== Container Managed Persistence Contexts

The container is responsible for managing the
lifecycle of container-managed persistence contexts, for injecting
_EntityManager_ references into web components and session bean and
message-driven bean components, and for making _EntityManager_
references available to direct lookups in JNDI.

When operating with a third-party persistence
provider, the container uses the contracts defined in section
link:Per.html#a12100[See Runtime Contracts between the Container
and Persistence Provider] to create and destroy container-managed
persistence contexts. It is undefined whether a new entity manager
instance is created for every persistence context, or whether entity
manager instances are sometimes reused. Exactly how the container
maintains the association between persistence context and JTA
transaction is not defined.

If a persistence context is already
associated with a JTA transaction, the container uses that persistence
context for subsequent invocations within the scope of that transaction,
according to the semantics for persistence context propagation defined
in section link:Per.html#a11816[See Persistence Context
Propagation].

=== [[a12100]]Runtime Contracts between the Container and Persistence Provider

image:Per-4.png[image]

{empty}This section describes contracts
between the container and the persistence provider for the pluggability
of third-party persistence providers. Containers are required to support
these pluggability contracts.link:#a19623[87]

==== Container Responsibilities

For the management of a transaction-scoped
persistence context, if there is no EntityManager already associated
with the JTA transaction:

The container creates a new entity manager by
calling _EntityManagerFactory.createEntityManager_ when the first
invocation of an entity manager with
_PersistenceContextType.TRANSACTION_ occurs within the scope of a
business method executing in the JTA transaction.

After the JTA transaction has completed
(either by transaction commit or rollback), the container closes the
entity manager by calling _EntityManager.close_ .
link:#a19624[88] Note that the JTA transaction may rollback in a
background thread (e.g., as a result of transaction timeout), in which
case the container should arrange for the entity manager to be closed
but the _EntityManager.close_ method should not be concurrently invoked
while the application is in an EntityManager invocation.

The container must throw the
_TransactionRequiredException_ if a transaction-scoped persistence
context is used and the _EntityManager_ _persist_ , _remove_ , _merge_ ,
or _refresh_ method is invoked when no transaction is active.

For stateful session beans with extended
persistence contexts:

The container creates an entity manager by
calling _EntityManagerFactory.createEntityManager_ when a stateful
session bean is created that declares a dependency on an entity manager
with _PersistenceContextType.EXTENDED_ . (See section
link:Per.html#a11810[See Container-managed Extended Persistence
Context]).

The container closes the entity manager by
calling _EntityManager.close_ after the stateful session bean and all
other stateful session beans that have inherited the same persistence
context as the entity manager have been removed.

When a business method of the stateful
session bean is invoked, if the stateful session bean uses container
managed transaction demarcation, and the entity manager is not already
associated with the current JTA transaction, the container associates
the entity manager with the current JTA transaction and, if the
persistence context is of type _SynchronizationType.SYNCHRONIZED_ , the
container calls _EntityManager.joinTransaction_ . If there is a
different persistence context already associated with the JTA
transaction, the container throws the _EJBException_ .

When a business method of the stateful
session bean is invoked, if the stateful session bean uses bean managed
transaction demarcation and a UserTransaction is begun within the
method, the container associates the persistence context with the JTA
transaction and, if the persistence context is of type
_SynchronizationType.SYNCHRONIZED_ , the container calls
_EntityManager.joinTransaction_ .

The container must throw the
_IllegalStateException_ if the application calls _EntityManager.close_
on a container-managed entity manager.

When the container creates an entity manager,
it may pass a map of properties to the persistence provider by using the
_EntityManagerFactory.createEntityManager(Map map)_ method. If
properties have been specified in the _PersistenceContext_ annotation or
the _persistence-context-ref_ deployment descriptor element, this method
must be used and the map must include the specified properties.

If the application invokes
_EntityManager.unwrap(Class<T> cls)_ , and the container cannot satisfy
the request, the container must delegate the _unwrap_ invocation to the
provider’s entity manager instance.

==== Provider Responsibilities

The Provider has no knowledge of the
distinction between transaction-scoped and extended persistence
contexts. It provides entity managers to the container when requested
and registers for transaction synchronization notifications.

When
_EntityManagerFactory.createEntityManager_ is invoked, the provider must
create and return a new entity manager. If a JTA transaction is active
and the persistence context is of type
_SynchronizationType.SYNCHRONIZED_ , the provider must register for
synchronization notifications against the JTA transaction.

When _EntityManager.joinTransaction_ is
invoked, the provider must register for synchronization notifications
against the current JTA transaction if a previous _joinTransaction_
invocation for the transaction has not already been processed.

When the JTA transaction commits, if the
persistence context is of type _SynchronizationType.SYNCHRONIZED_ or has
otherwise been joined to the transaction, the provider must flush all
modified entity state to the database.

When the JTA transaction rolls back, the
provider must detach all managed entities if the persistence context is
of type _SynchronizationType.SYNCHRONIZED_ or has otherwise been joined
to the transaction. Note that the JTA transaction may rollback in a
background thread (e.g., as a result of transaction timeout), in which
case the provider should arrange for the managed entities to be detached
from the persistence context but not concurrently while the application
is in an EntityManager invocation.

When the provider throws an exception defined
to cause transaction rollback, the provider must mark the transaction
for rollback if the persistence context is of type
_SynchronizationType.SYNCHRONIZED_ or has otherwise been joined to the
transaction.

When _EntityManager.close_ is invoked, the
provider should release all resources that it may have allocated after
any outstanding transactions involving the entity manager have
completed. If the entity manager was already in a closed state, the
provider must throw the _IllegalStateException_ .

When _EntityManager.clear_ is invoked, the
provider must detach all managed entities.

=== [[a12124]]Cache Interface

image:Per-4.png[image]

The _Cache_ interface provides basic
functionality over the persistence provider’s second level cache, if
used.

package javax.persistence;



/**

 * Interface used to interact with the
second-level cache.

 * If a cache is not in use, the methods of
this interface have

 * no effect, except for contains, which
returns false.

 */

public interface Cache \{



 /**

 * Whether the cache contains data for the
given entity.

 * @param cls entity class

 * @param primaryKey primary key

 * @return boolean indicating whether the
entity is in the cache

 */

 public boolean contains(Class cls, Object
primaryKey);



 /**

 * Remove the data for the given entity from
the cache.

 * @param cls entity class

 * @param primaryKey primary key

 */

 public void evict(Class cls, Object
primaryKey);



 /**

 * Remove the data for entities of the
specified class (and its

 * subclasses) from the cache.

 * @param cls entity class

 */

 public void evict(Class cls);



 /**

 * Clear the cache.

 */

 public void evictAll();



 /**

 * Return an object of the specified type to
allow access to the

 * provider-specific API. If the provider's
Cache

 * implementation does not support the
specified class, the

 * PersistenceException is thrown.

 * @param cls the class of the object to be
returned. This is

 * normally either the underlying Cache
implementation

 * class or an interface that it implements.

 * @return an instance of the specified class

 * @throws PersistenceException if the
provider does not

 * support the call

 */

 public <T> T unwrap(Class<T> cls);



}

=== [[a12177]]PersistenceUnitUtil Interface

image:Per-4.png[image]

The _PersistenceUnitUtil_ interface provides
access to utility methods that can be invoked on entities associated
with the persistence unit. The behavior is undefined if these methods
are invoked on an entity instance that is not associated with the
persistence unit from whose entity manager factory this interface has
been obtained.

package javax.persistence;



/**

 * Utility interface between the application
and the persistence

 * provider managing the persistence unit.

 *

 * The methods of this interface should only
be invoked on entity

 * instances obtained from or managed by
entity managers for this

 * persistence unit or on new entity
instances.

 */

public interface PersistenceUnitUtil extends
PersistenceUtil \{



 /**

 * Determine the load state of a given
persistent attribute

 * of an entity belonging to the persistence
unit.

 * @param entity entity instance containing
the attribute

 * @param attributeName name of attribute
whose load state is

 * to be determined

 * @return false if entity's state has not
been loaded or if

 * the attribute state has not been loaded,
else true

 */

 public boolean isLoaded(Object entity,
String attributeName);



 /**

 * Determine the load state of an entity
belonging to the

 * persistence unit.

 * This method can be used to determine the
load state

 * of an entity passed as a reference. An
entity is

 * considered loaded if all attributes for
which FetchType

 * EAGER has been specified have been loaded.

 * The isLoaded(Object, String) method should
be used to

 * determine the load state of an attribute.

 * Not doing so might lead to unintended
loading of state.

 * @param entity entity whose load state is
to be determined

 * @return false if the entity has not been
loaded, else true

 */

 public boolean isLoaded(Object entity);



 /**

 * Return the id of the entity.

 * A generated id is not guaranteed to be
available until after

 * the database insert has occurred.

 * Returns null if the entity does not yet
have an id.

 * @param entity entity instance

 * @return id of the entity

 * @throws IllegalArgumentException if the
object is found not

 * to be an entity

 */

 public Object getIdentifier(Object entity);

}

== [[a12229]]Entity Packaging

This chapter describes the packaging of
persistence units.

=== Persistence Unit

image:Per-4.png[image]

A persistence unit is a logical grouping that
includes:

An entity manager factory and its entity
managers, together with their configuration information.

The set of managed classes included in the
persistence unit and managed by the entity managers of the entity
manager factory.

Mapping metadata (in the form of metadata
annotations and/or XML metadata) that specifies the mapping of the
classes to the database.

=== [[a12236]]Persistence Unit Packaging

image:Per-4.png[image]

Within Java EE environments, an EJB-JAR, WAR,
EAR, or application client JAR can define a persistence unit. Any number
of persistence units may be defined within these scopes.

A persistence unit may be packaged within one
or more jar files contained within a WAR or EAR, as a set of classes
within an EJB-JAR file or in the WAR _classes_ directory, or as a
combination of these as defined below.

A persistence unit is defined by a
_persistence.xml_ file. The jar file or directory whose _META-INF_
directory contains the _persistence.xml_ file is termed the _root_ of
the persistence unit. In Java EE environments, the root of a persistence
unit must be one of the following:

an EJB-JAR file

{empty}the _WEB-INF/classes_ directory of a
WAR filelink:#a19625[89]

a jar file in the _WEB-INF/lib_ directory of
a WAR file

a jar file in the EAR library directory

an application client jar file

It is not required that an EJB-JAR or WAR
file containing a persistence unit be packaged in an EAR unless the
persistence unit contains persistence classes in addition to those
contained within the EJB-JAR or WAR. See Section
link:Per.html#a12305[See mapping-file, jar-file, class,
exclude-unlisted-classes].

NOTE: Java Persistence 1.0 supported use of a
jar file in the root of the EAR as the root of a persistence unit. This
use is no longer supported. Portable applications should use the EAR
library directory for this case instead. See
link:Per.html#a19499[See JSR-366: Java Platform, Enterprise
Edition 8 (Java EE 8) Specification.
http://jcp.org/en/jsr/detail?id=366.].

A persistence unit must have a name. Only one
persistence unit of any given name must be defined within a single
EJB-JAR file, within a single WAR file, within a single application
client jar, or within an EAR. See Section
link:Per.html#a12459[See Persistence Unit Scope].

The _persistence.xml_ file may be used to
designate more than one persistence unit within the same scope.

All persistence classes defined at the level
of the Java EE EAR must be accessible to other Java EE components in the
application—i.e. loaded by the application classloader—such that if the
same entity class is referenced by two different Java EE components
(which may be using different persistence units), the referenced class
is the same identical class.

In Java SE environments, the metadata mapping
files, jar files, and classes described in the following sections can be
used. To insure the portability of a Java SE application, it is
necessary to explicitly list the managed persistence classes that are
included in the persistence unit using the _class_ element of the
_persistence.xml_ file. See Section link:Per.html#a12305[See
mapping-file, jar-file, class, exclude-unlisted-classes].

[discrete]
=== persistence.xml file

A _persistence.xml_ file defines a
persistence unit. The _persistence.xml_ file is located in the
_META-INF_ directory of the root of the persistence unit. It may be used
to specify managed persistence classes included in the persistence unit,
object/relational mapping information for those classes, scripts for use
in schema generation and the bulk loading of data, and other
configuration information for the persistence unit and for the entity
manager(s) and entity manager factory for the persistence unit. This
information may be defined by containment or by reference, as described
below.

The object/relational mapping information can
take the form of annotations on the managed persistence classes included
in the persistence unit, an _orm.xml_ file contained in the _META-INF_
directory of the root of the persistence unit, one or more XML files on
the classpath and referenced from the _persistence.xml_ file, or a
combination of these.

The managed persistence classes may either be
contained within the root of the persistence unit; or they may be
specified by reference—i.e., by naming the classes, class archives, or
XML mapping files (which in turn reference classes) that are accessible
on the application classpath; or they may be specified by some
combination of these means. See Section link:Per.html#a12305[See
mapping-file, jar-file, class, exclude-unlisted-classes].

The root element of the _persistence.xml_
file is the _persistence_ element. The _persistence_ element consists of
one or more _persistence-unit_ elements.

The _persistence-unit_ element consists of
the _name_ and _transaction-type_ attributes and the following
sub-elements: _description_ , _provider_ , _jta-data-source_ ,
_non-jta-data-source_ , _mapping-file_ , _jar-file_ , _class_ ,
_exclude-unlisted-classes_ , _shared-cache-mode_ , _validation-mode_ ,
and _properties_ .

The _name_ attribute is required; the other
attributes and elements are optional. Their semantics are described in
the following subsections.

Examples:

<persistence>

 <persistence-unit name="OrderManagement">

 <description>

 This unit manages orders and customers.

 It does not rely on any vendor-specific
features and can

 therefore be deployed to any persistence
provider.

 </description>


<jta-data-source>jdbc/MyOrderDB</jta-data-source>

 <mapping-file>ormap.xml</mapping-file>

 <jar-file>MyOrderApp.jar</jar-file>

 <class>com.widgets.Order</class>

 <class>com.widgets.Customer</class>

 </persistence-unit>

</persistence>





<persistence>

 <persistence-unit name="OrderManagement2">

 <description>

 This unit manages inventory for auto parts.

 It depends on features provided by the

 com.acme.persistence implementation.

 </description>


<provider>com.acme.AcmePersistence</provider>


<jta-data-source>jdbc/MyPartDB</jta-data-source>

 <mapping-file>ormap2.xml</mapping-file>

 <jar-file>MyPartsApp.jar</jar-file>

 <properties>

 <property

 name="com.acme.persistence.sql-logging"

 value="on"/>

 </properties>

 </persistence-unit>

</persistence>



===== name

The _name_ attribute defines the name for the
persistence unit. This name may be used to identify a persistence unit
referred to by the _PersistenceContext_ and _PersistenceUnit_
annotations and in the programmatic API for creating an entity manager
factory.

===== [[a12296]]transaction-type

The _transaction-type_ attribute is used to
specify whether the entity managers provided by the entity manager
factory for the persistence unit must be JTA entity managers or
resource-local entity managers. The value of this element is _JTA_ or
_RESOURCE_LOCAL_ . A _transaction-type_ of _JTA_ assumes that a JTA data
source will be provided—either as specified by the _jta-data-source_
element or provided by the container. In general, in Java EE
environments, a _transaction-type_ of _RESOURCE_LOCAL_ assumes that a
non-JTA datasource will be provided. In a Java EE environment, if this
element is not specified, the default is _JTA_ . In a Java SE
environment, if this element is not specified, the default is
_RESOURCE_LOCAL_ .

===== description

The _description_ element provides optional
descriptive information about the persistence unit.

===== [[a12300]]provider

The _provider_ element specifies the name of
the persistence provider's _javax.persistence.spi.PersistenceProvider_
class. The _provider_ element is optional, but should be specified if
the application is dependent upon a particular persistence provider
being used.

===== [[a12302]]jta-data-source, non-jta-data-source

In Java EE environments, the
_jta-data-source_ and _non-jta-data-source_ elements are used to specify
the JNDI name of the JTA and/or non-JTA data source to be used by the
persistence provider. If neither is specified, the deployer must specify
a JTA data source at deployment or the default JTA data source must be
provided by the container, and a JTA EntityManagerFactory will be
created to correspond to it.

In Java SE environments, these elements may
be used or the data source information may be specified by other
means—depending upon the requirements of the provider.

===== [[a12305]]mapping-file, jar-file, class, exclude-unlisted-classes

The following classes must be implicitly or
explicitly denoted as managed persistence classes to be included within
a persistence unit: entity classes; embeddable classes; mapped
superclasses; converter classes.

{empty}The set of managed persistence classes
that are managed by a persistence unit is defined by using one or more
of the following:link:#a19626[90]

Annotated managed persistence classes
contained in the root of the persistence unit (unless the
_exclude-unlisted-classes_ element is specified)

One or more object/relational mapping XML
files

One or more jar files that will be searched
for classes

An explicit list of classes

The set of entities managed by the
persistence unit is the union of these sources, with the mapping
metadata annotations (or annotation defaults) for any given class being
overridden by the XML mapping information file if there are both
annotations as well as XML mappings for that class. The minimum portable
level of overriding is at the level of the persistent field or property.

The classes and/or jars that are named as
part of a persistence unit must be on the classpath; referencing them
from the _persistence.xml_ file does not cause them to be placed on the
classpath.

All classes must be on the classpath to
ensure that entity managers from different persistence units that map
the same class will be accessing the same identical class.

====== Annotated Classes in the Root of the Persistence Unit

All classes contained in the root of the
persistence unit are searched for annotated managed persistence
classes—classes with the _Entity_ , _Embeddable_ , _MappedSuperclass_ ,
or _Converter_ annotation—and any mapping metadata annotations found on
these classes will be processed, or they will be mapped using the
mapping annotation defaults. If it is not intended that the annotated
persistence classes contained in the root of the persistence unit be
included in the persistence unit, the _exclude-unlisted-classes_ element
must be specified as _true_ . The _exclude-unlisted-classes_ element is
not intended for use in Java SE environments.

====== Object/relational Mapping Files

An object/relational mapping XML file
contains mapping information for the classes listed in it.

An object/relational mapping XML file named
_orm.xml_ may be specified in the _META-INF_ directory in the root of
the persistence unit or in the _META-INF_ directory of any jar file
referenced by the _persistence.xml_ . Alternatively, or in addition, one
or more mapping files may be referenced by the _mapping-file_ elements
of the _persistence-unit_ element. These mapping files may be present
anywhere on the class path.

An _orm.xml_ mapping file or other mapping
file is loaded as a resource by the persistence provider. If a mapping
file is specified, the classes and mapping information specified in the
mapping file will be used as described in Chapter
link:Per.html#a16944[See XML Object/Relational Mapping
Descriptor]. If multiple mapping files are specified (possibly including
one or more _orm.xml_ files), the resulting mappings are obtained by
combining the mappings from all of the files. The result is undefined if
multiple mapping files (including any _orm.xml_ file) referenced within
a single persistence unit contain overlapping mapping information for
any given class. The object/relational mapping information contained in
any mapping file referenced within the persistence unit must be disjoint
at the class-level from object/relational mapping information contained
in any other such mapping file.

====== Jar Files

{empty}One or more JAR files may be specified
using the _jar-file_ elements instead of, or in addition to the mapping
files specified in the _mapping-file_ elements. If specified, these JAR
files will be searched for managed persistence classes, and any mapping
metadata annotations found on them will be processed, or they will be
mapped using the mapping annotation defaults defined by this
specification. Such JAR files are specified relative to the directory or
jar file that _containslink:#a19627[91]_ the root of the
persistence unit.link:#a19628[92]

The following examples illustrate the use of
the _jar-file_ element to reference additional persistence classes.
These examples use the convention that a jar file with a name
terminating in “ _PUnit_ ” contains the _persistence.xml_ file and that
a jar file with a name terminating in “ _Entities_ ” contains additional
persistence classes.

 _Example 1:_

app.ear

 lib/earEntities.jar

 earRootPUnit.jar (with
META-INF/persistence.xml )

 _persistence.xml_ contains:

 <jar-file>lib/earEntities.jar</jar-file>



 _Example 2:_

app.ear

 lib/earEntities.jar

 lib/earLibPUnit.jar (with
META-INF/persistence.xml )

 _persistence.xml_ contains:

 <jar-file>earEntities.jar</jar-file>



 _Example 3:_

app.ear

 lib/earEntities.jar

 ejbjar.jar (with META-INF/persistence.xml )

 _persistence.xml_ contains:

 <jar-file>lib/earEntities.jar</jar-file>



Example 4:

app.ear

 war1.war

 WEB-INF/lib/warEntities.jar

 WEB-INF/lib/warPUnit.jar (with
META-INF/persistence.xml )

 _persistence.xml_ contains:

 <jar-file>warEntities.jar</jar-file>



Example 5:

app.ear

 war2.war

 WEB-INF/lib/warEntities.jar

 WEB-INF/classes/META-INF/persistence.xml

 _persistence.xml_ contains:

 <jar-file>lib/warEntities.jar</jar-file>



Example 6:

app.ear

 lib/earEntities.jar

 war2.war

 WEB-INF/classes/META-INF/persistence.xml

 _persistence.xml_ contains:


<jar-file>../../lib/earEntities.jar</jar-file>



Example 7:

app.ear

 lib/earEntities.jar

 war1.war

 WEB-INF/lib/warPUnit.jar (with
META-INF/persistence.xml )

 _persistence.xml_ contains:


<jar-file>../../../lib/earEntities.jar</jar-file>



====== List of Managed Classes

A list of named managed persistence
classes—entity classes, embeddable classes, mapped superclasses, and
converter classes—may be specified instead of, or in addition to, the
JAR files and mapping files. Any mapping metadata annotations found on
these classes will be processed, or they will be mapped using the
mapping annotation defaults. The _class_ element is used to list a
managed persistence class.

A list of all named managed persistence
classes must be specified in Java SE environments to insure portability.
Portable Java SE applications should not rely on the other mechanisms
described here to specify the managed persistence classes of a
persistence unit. Persistence providers may require that the set of
entity classes and classes that are to be managed must be fully
enumerated in each of the _persistence.xml_ files in Java SE
environments.

===== [[a12380]]shared-cache-mode

The _shared-cache-mode_ element determines
whether second-level caching is in effect for the persistence unit. See
section link:Per.html#a3065[See The shared-cache-mode Element].

===== [[a12382]]validation-mode

The _validation-mode_ element determines
whether automatic lifecycle event time validation is in effect. See
section link:Per.html#a2374[See Enabling Automatic Validation].

===== [[a12384]]properties

The _properties_ element is used to specify
both standard and vendor-specific properties and hints that apply to the
persistence unit and its entity manager factory configuration.

The following properties and hints defined by
this specification are intended for use in both Java EE and Java SE
environments:

 _javax.persistence.lock.timeout_ — value in
milliseconds for pessimistic lock timeout. This is a hint only.

 _javax.persistence.query.timeout_ — value in
milliseconds for query timeout. This is a hint only.


_javax.persistence.validation.group.pre-persist_ — groups that are
targeted for validation upon the pre-persist event (overrides the
default behavior).


_javax.persistence.validation.group.pre-update_ — groups that are
targeted for validation upon the pre-update event (overrides the default
behavior).


_javax.persistence.validation.group.pre-remove_ — groups that are
targeted for validation upon the pre-remove event (overrides the default
behavior).

The following properties defined by this
specification are intended for use in Java SE environments.

 _javax.persistence.jdbc.driver_ — fully
qualified name of the driver class

 _javax.persistence.jdbc.url_ —
driver-specific URL

 _javax.persistence.jdbc.user_ — username
used by database connection

 _javax.persistence.jdbc.password_ — password
for database connection validation

Scripts for use in schema generation may be
specified using the
_javax.persistence.schema-generation.create-script-source_ and
_javax.persistence.schema-generation.drop-script-source_ properties. A
script to specify SQL for the bulk loading of data may be specified by
the _javax.persistence.sql-load-script-source_ property. These
properties are intended for use in both Java EE and Java SE
environments:


_javax.persistence.schema-generation.create-script-source_ — _name of a
script packaged as part of the persistence application or a string
corresponding to a file URL string that designates a script._


_javax.persistence.schema-generation.drop-script-source_ — _name of a
script packaged as part of the persistence application or a string
corresponding to a file URL string that designates a script._

 _javax.persistence.sql-load-script-source_ —
_name of a script packaged as part of the persistence unit or a string
corresponding to a file URL string that designates a script._

When scripts are packaged as part of the
persistence application, these properties must specify locations
relative to the root of the persistence unit. When scripts are provided
externally (or when schema generation is to occur into script files, as
described below), strings corresponding to file URLs must be specified.
In Java EE environments, such file URL specifications must be absolute
paths (not relative). In Java EE environments, all source and target
file locations must be accessible to the application server deploying
the persistence unit.

In general, it is expected that schema
generation will be initiated by means of the APIs described in
link:Per.html#a12917[See Schema Generation]. However, schema
generation actions may also be specified by means of the following
properties used in the _persistence.xml_ file.


_javax.persistence.schema-generation.database.action_

The
_javax.persistence.schema-generation.database.action_ property specifies
the action to be taken by the persistence provider with regard to the
database artifacts. The values for this property are _none_ , _create_ ,
_drop-and-create_ , _drop_ . If this property is not specified, it is
assumed that schema generation is not needed or will be initiated by
other means, and, by default, no schema generation actions will be taken
on the database. (See link:Per.html#a12917[See Schema
Generation].)


_javax.persistence.schema-generation.scripts.action_

The
_javax.persistence.schema-generation.scripts.action_ property specifies
which scripts are to be generated by the persistence provider. The
values for this property are _none_ , _create_ , _drop-and-create_ ,
_drop_ . A script will only be generated if the script target is
specified. If this property is not specified, it is assumed that script
generation is not needed or will be initiated by other means, and, by
default, no scripts will be generated. (See
link:Per.html#a12917[See Schema Generation].)


_javax.persistence.schema-generation.create-source_

The
_javax.persistence.schema-generation.create-source_ property specifies
whether the creation of database artifacts is to occur on the basis of
the object/relational mapping metadata, DDL script, or a combination of
the two. The values for this property are _metadata_ , _script_ ,
_metadata-then-script_ , _script-then-metadata_ . If this property is
not specified, and a script is specified by the
_javax.persistence.schema-generation.create-script-source_ property, the
script (only) will be used for schema generation; otherwise if this
property is not specified, schema generation will occur on the basis of
the object/relational mapping metadata (only). The
_metadata-then-script_ and _script-then-metadata_ values specify that a
combination of metadata and script is to be used and the order in which
this use is to occur. If either of these values is specified and the
resulting database actions are not disjoint, the results are undefined
and schema generation may fail.


_javax.persistence.schema-generation.drop-source_

The
_javax.persistence.schema-generation.drop-source_ property specifies
whether the dropping of database artifacts is to occur on the basis of
the object/relational mapping metadata, DDL script, or a combination of
the two. The values for this property are _metadata_ , _script_ ,
_metadata-then-script_ , _script-then-metadata_ . If this property is
not specified, and a script is specified by the
_javax.persistence.schema-generation.drop-script-source_ property, the
script (only) will be used for the dropping of database artifacts;
otherwise if this property is not specified, the dropping of database
artifacts will occur on the basis of the object/relational mapping
metadata (only). The _metadata-then-script_ and _script-then-metadata_
values specify that a combination of metadata and script is to be used
and the order in which this use is to occur. If either of these values
is specified and the resulting database actions are not disjoint, the
results are undefined and the dropping of database artifacts may fail.


_javax.persistence.schema-generation.scripts.create-target_ , +
_javax.persistence.schema-generation.scripts.drop-target_

If scripts are to be generated, the target
locations for the writing of these scripts must be specified. These
targets are specified as strings corresponding to file URLs.

If a persistence provider does not recognize
a property (other than a property defined by this specification), the
provider must ignore it.

Vendors should use vendor namespaces for
properties (e.g., _com.acme.persistence.logging_ ). Entries that make
use of the namespace _javax.persistence_ and its subnamespaces must not
be used for vendor-specific information. The namespace
_javax.persistence_ is reserved for use by this specification.

===== Examples

The following are sample contents of a
_persistence.xml_ file.

 _Example 1:_

<persistence-unit name="OrderManagement"/>



A persistence unit named _OrderManagement_ is
created.

Any annotated managed persistence classes
found in the root of the persistence unit are added to the list of
managed persistence classes. If a _META-INF/orm.xml_ file exists, any
classes referenced by it and mapping information contained in it are
used as specified above. Because no provider is specified, the
persistence unit is assumed to be portable across providers. Because the
transaction type is not specified, JTA is assumed for Java EE
environments. The container must provide the data source (it may be
specified at application deployment, for example). In Java SE
environments, the data source may be specified by other means and a
transaction type of _RESOURCE_LOCAL_ is assumed.

 _Example 2:_

<persistence-unit name="OrderManagement2">

 <mapping-file>mappings.xml</mapping-file>

</persistence-unit>



A persistence unit named _OrderManagement2_
is created. Any annotated managed persistence classes found in the root
of the persistence unit are added to the list of managed persistence
classes. The _mappings.xml_ resource exists on the classpath and any
classes and mapping information contained in it are used as specified
above. If a _META-INF/orm.xml_ file exists, any classes and mapping
information contained in it are used as well. The transaction type, data
source, and provider are as described above.

 _Example 3:_

<persistence-unit name="OrderManagement3">

 <jar-file>order.jar</jar-file>

 <jar-file>order-supplemental.jar</jar-file>

</persistence-unit>



A persistence unit named _OrderManagement3_
is created. Any annotated managed persistence classes found in the root
of the persistence unit are added to the list of managed persistence
classes. If a _META-INF/orm.xml_ file exists, any classes and mapping
information contained in it are used as specified above. The _order.jar_
and _order-supplemental.jar_ files are searched for managed persistence
classes and any annotated managed persistence classes found in them
and/or any classes specified in the _orm.xml_ files of these jar files
are added. The transaction-type, data source and provider are as
described above.

 _Example 4:_

<persistence-unit

 name="OrderManagement4"

 transaction-type=RESOURCE_LOCAL>


<non-jta-data-source>java:app/jdbc/MyDB</non-jta-data-source>


<mapping-file>order-mappings.xml</mapping-file>

 <class>com.acme.Order</class>

 <class>com.acme.Customer</class>

 <class>com.acme.Item</class>

 <exclude-unlisted-classes/>

</persistence-unit>



A persistence unit named _OrderManagement4_
is created. The file _order-mappings.xml_ is read as a resource and any
classes referenced by it and mapping information contained in it are
usedlink:#a19629[93]. The annotated _Order_ , _Customer_ and
_Item_ classes are loaded and are added. No (other) classes contained in
the root of the persistence unit are added to the list of managed
persistence classes. The persistence unit assumed to be portable across
providers. A entity manager factory supplying resource-local entity
managers will be created. The data source _java:app/jdbc/MyDB_ must be
used.

 _Example 5:_

<persistence-unit name="OrderManagement5">


<provider>com.acme.AcmePersistence</provider>

 <mapping-file>order1.xml</mapping-file>

 <mapping-file>order2.xml</mapping-file>

 <jar-file>order.jar</jar-file>

 <jar-file>order-supplemental.jar</jar-file>

</persistence-unit>



A persistence unit named _OrderManagement5_
is created. Any annotated managed persistence classes found in the root
of the persistence unit are added to the list of managed classes. The
_order1.xml_ and _order2.xml_ files are read as resources and any
classes referenced by them and mapping information contained in them are
also used as specified above. The _order.jar_ is a jar file on the
classpath containing another persistence unit, while
_order-supplemental.jar_ is just a library of classes. Both of these jar
files are searched for annotated managed persistence classes and any
annotated managed persistence classes found in them and any classes
specified in the _orm.xml_ files (if any) of these jar files are added.
The provider _com.acme.AcmePersistence_ must be used.

Note that the _persistence.xml_ file
contained in _order.jar_ is not used to augment the persistence unit
_OrderManagement5_ with the classes of the persistence unit whose root
is _order.jar_ .

==== [[a12459]]Persistence Unit Scope

An EJB-JAR, WAR, application client jar, or
EAR can define a persistence unit.

When referencing a persistence unit using the
_unitName_ annotation element or _persistence-unit-name_ deployment
descriptor element, the visibility scope of the persistence unit is
determined by its point of definition:

A persistence unit that is defined at the
level of an EJB-JAR, WAR, or application client jar is scoped to that
EJB-JAR, WAR, or application jar respectively and is visible to the
components defined in that jar or war.

A persistence unit that is defined at the
level of the EAR is generally visible to all components in the
application. However, if a persistence unit of the same name is defined
by an EJB-JAR, WAR, or application jar file within the EAR, the
persistence unit of that name defined at EAR level will not be visible
to the components defined by that EJB-JAR, WAR, or application jar file
unless the persistence unit reference uses the persistence unit name #
syntax to specify a path name to disambiguate the reference. When the #
syntax is used, the path name is relative to the referencing application
component jar file. For example, the syntax
_../lib/persistenceUnitRoot.jar#myPersistenceUnit_ refers to a
persistence unit whose name, as specified in the name element of the
_persistence.xml_ file, is _myPersistenceUnit_ and for which the
relative path name of the root of the persistence unit is
_../lib/persistenceUnitRoot.jar_ . The # syntax may be used with both
the _unitName_ annotation element or _persistence-unit-name_ deployment
descriptor element to reference a persistence unit defined at EAR level.

[discrete]
=== persistence.xml Schema

image:Per-4.png[image]

This section provides the XML schema for the
_persistence.xml_ file.

<?xml version="1.0" encoding="UTF-8"?>

<!-- persistence.xml schema -->

<xsd:schema
targetNamespace="http://xmlns.jcp.org/xml/ns/persistence"

 xmlns:xsd="http://www.w3.org/2001/XMLSchema"


xmlns:persistence="http://xmlns.jcp.org/xml/ns/persistence"

 elementFormDefault="qualified"

 attributeFormDefault="unqualified"

 version="2.2">



 <xsd:annotation>

 <xsd:documentation>

 @(#)persistence_2_2.xsd 2.2 July 17, 2017

 </xsd:documentation>

 </xsd:annotation>

 <xsd:annotation>

 <xsd:documentation><![CDATA[



 This is the XML Schema for the persistence
configuration file.

 The file must be named
"META-INF/persistence.xml" in the

 persistence archive.



 Persistence configuration files must
indicate

 the persistence schema by using the
persistence namespace:



 http://xmlns.jcp.org/xml/ns/persistence



 and indicate the version of the schema by

 using the version element as shown below:



 <persistence
xmlns="http://xmlns.jcp.org/xml/ns/persistence"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence


http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd"

 version="2.2">

 ...

 </persistence>



 ]]></xsd:documentation>

 </xsd:annotation>



 <xsd:simpleType name="versionType">

 <xsd:restriction base="xsd:token">

 <xsd:pattern value="[0-9]+(\.[0-9]+)*"/>

 </xsd:restriction>

 </xsd:simpleType>



 <!--
**************************************************** -->



 <xsd:element name="persistence">

 <xsd:complexType>

 <xsd:sequence>



 <!--
**************************************************** -->



 <xsd:element name="persistence-unit"

 minOccurs="1" maxOccurs="unbounded">

 <xsd:complexType>

 <xsd:annotation>

 <xsd:documentation>



 Configuration of a persistence unit.



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>



 <!--
**************************************************** -->



 <xsd:element name="description"
type="xsd:string"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 Description of this persistence unit.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="provider"
type="xsd:string"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 Provider class that supplies EntityManagers
for this

 persistence unit.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="jta-data-source"
type="xsd:string"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 The container-specific name of the JTA
datasource to use.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="non-jta-data-source"
type="xsd:string"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 The container-specific name of a non-JTA
datasource to use.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="mapping-file"
type="xsd:string"

 minOccurs="0" maxOccurs="unbounded">

 <xsd:annotation>

 <xsd:documentation>



 File containing mapping information. Loaded
as a resource

 by the persistence provider.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="jar-file"
type="xsd:string"

 minOccurs="0" maxOccurs="unbounded">

 <xsd:annotation>

 <xsd:documentation>



 Jar file that is to be scanned for managed
classes.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="class" type="xsd:string"

 minOccurs="0" maxOccurs="unbounded">

 <xsd:annotation>

 <xsd:documentation>



 Managed class to be included in the
persistence unit and

 to scan for annotations. It should be
annotated

 with either @Entity, @Embeddable or
@MappedSuperclass.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="exclude-unlisted-classes"
type="xsd:boolean"

 default="true" minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 When set to true then only listed classes
and jars will

 be scanned for persistent classes, otherwise
the

 enclosing jar or directory will also be
scanned.

 Not applicable to Java SE persistence units.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="shared-cache-mode"


type="persistence:persistence-unit-caching-type"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 Defines whether caching is enabled for the

 persistence unit if caching is supported by
the

 persistence provider. When set to ALL, all
entities

 will be cached. When set to NONE, no
entities will

 be cached. When set to ENABLE_SELECTIVE,
only entities

 specified as cacheable will be cached. When
set to

 DISABLE_SELECTIVE, entities specified as not
cacheable

 will not be cached. When not specified or
when set to

 UNSPECIFIED, provider defaults may apply.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:element name="validation-mode"


type="persistence:persistence-unit-validation-mode-type"

 minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 The validation mode to be used for the
persistence unit.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:element>





 <!--
**************************************************** -->



 <xsd:element name="properties"
minOccurs="0">

 <xsd:annotation>

 <xsd:documentation>



 A list of standard and vendor-specific
properties

 and hints.



 </xsd:documentation>

 </xsd:annotation>

 <xsd:complexType>

 <xsd:sequence>

 <xsd:element name="property"

 minOccurs="0" maxOccurs="unbounded">

 <xsd:annotation>

 <xsd:documentation>

 A name-value pair.

 </xsd:documentation>

 </xsd:annotation>

 <xsd:complexType>

 <xsd:attribute name="name" type="xsd:string"

 use="required"/>

 <xsd:attribute name="value"
type="xsd:string"

 use="required"/>

 </xsd:complexType>

 </xsd:element>

 </xsd:sequence>

 </xsd:complexType>

 </xsd:element>



 </xsd:sequence>



 <!--
**************************************************** -->



 <xsd:attribute name="name" type="xsd:string"
use="required">

 <xsd:annotation>

 <xsd:documentation>



 Name used in code to reference this
persistence unit.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:attribute>



 <!--
**************************************************** -->



 <xsd:attribute name="transaction-type"


type="persistence:persistence-unit-transaction-type">

 <xsd:annotation>

 <xsd:documentation>



 Type of transactions used by EntityManagers
from this

 persistence unit.



 </xsd:documentation>

 </xsd:annotation>

 </xsd:attribute>



 </xsd:complexType>

 </xsd:element>

 </xsd:sequence>

 <xsd:attribute name="version"
type="persistence:versionType"

 fixed="2.2" use="required"/>

 </xsd:complexType>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:simpleType
name="persistence-unit-transaction-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum PersistenceUnitTransactionType
\{JTA, RESOURCE_LOCAL};



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="JTA"/>

 <xsd:enumeration value="RESOURCE_LOCAL"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:simpleType
name="persistence-unit-caching-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum SharedCacheMode \{ ALL, NONE,
ENABLE_SELECTIVE, DISABLE_SELECTIVE, UNSPECIFIED};



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="ALL"/>

 <xsd:enumeration value="NONE"/>

 <xsd:enumeration value="ENABLE_SELECTIVE"/>

 <xsd:enumeration value="DISABLE_SELECTIVE"/>

 <xsd:enumeration value="UNSPECIFIED"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:simpleType
name="persistence-unit-validation-mode-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum ValidationMode \{ AUTO,
CALLBACK, NONE};



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="AUTO"/>

 <xsd:enumeration value="CALLBACK"/>

 <xsd:enumeration value="NONE"/>

 </xsd:restriction>

 </xsd:simpleType>



</xsd:schema>

== Container and Provider Contracts for Deployment and Bootstrapping

This chapter defines requirements on the Java
EE container and on the persistence provider for deployment and
bootstrapping.

=== [[a12802]]Java EE Deployment

image:Per-4.png[image]

Each persistence unit deployed into a Java EE
container consists of a single _persistence.xml_ file, any number of
mapping files, and any number of class files.

At deployment time the container is
responsible for scanning the locations specified in Section
link:Per.html#a12236[See Persistence Unit Packaging] and
discovering the _persistence.xml_ files and processing them.

When the container finds a _persistence.xml_
file, it must process the persistence unit definitions that it contains.
The container must validate the _persistence.xml_ file against the
_persistence_2_2.xsd_ , _persistence_2_1.xsd_ , _persistence_2_0.xsd_ ,
or _persistence_1_0.xsd_ schema in accordance with the version specified
by the _persistence.xml_ file and report any validation errors. Provider
or data source information not specified in the _persistence.xml_ file
must be provided at deployment time or defaulted by the container. The
container may optionally add any container-specific properties to be
passed to the provider when creating the entity manager factory for the
persistence unit.

Once the container has read the persistence
metadata, it determines the _javax.persistence.spi.PersistenceProvider_
implementation class for each deployed named persistence unit. The
container then creates an instance of the _PersistenceProvider_
implementation class for each deployed named persistence unit and
invokes the _createContainerEntityManagerFactory_ method on that
instance.

The container must implement the
_PersistenceUnitInfo_ interface described in section
link:Per.html#a13160[See
javax.persistence.spi.PersistenceUnitInfo Interface] and pass the
metadata—in the form of a _PersistenceUnitInfo_ instance—to the
persistence provider as part of this call.

If a Bean Validation provider exists in the
container environment and the _validation-mode_ _NONE_ is not specified,
a _ValidatorFactory_ instance must be made available by the container.
The container is responsible for passing this _ValidatorFactory_
instance via the map that is passed as an argument to the
_createContainerEntityManagerFactory_ call. The map key used must be the
standard property name _javax.persistence.validation.factory_ .

If CDI is enabled, a _BeanManager_ instance
must be made available by the container. The container is responsible
for passing this _BeanManager_ instance via the map that is passed as an
argument to the _createContainerEntityManagerFactory_ call. The map key
used must be the standard property name _javax.persistence.bean.manager_
.

The _EntityManagerFactory_ instance obtained
as a result will be used by the container to create container-managed
entity managers. Only one EntityManagerFactory is permitted to be
created for each deployed persistence unit configuration. Any number of
EntityManager instances may be created from a given factory.

In a Java EE environment, the classes of the
persistence unit should not be loaded by the application class loader or
any of its parent class loaders until after the entity manager factory
for the persistence unit has been created.

When a persistence unit is redeployed, the
container should call the _close_ method on the previous
_EntityManagerFactory_ instance and call the
_createContainerEntityManagerFactory_ method again, with the required
_PersistenceUnitInfo_ metadata, to achieve the redeployment.

=== Bootstrapping in Java SE Environments

image:Per-4.png[image]

In Java SE environments, the
_Persistence.createEntityManagerFactory_ method is used by the
application to create an entity manager factorylink:#a19630[94].

A persistence provider implementation running
in a Java SE environment should also act as a service provider by
supplying a service provider configuration file as defined by the Java
SE platform.

The provider configuration file serves to
export the provider implementation class to the _Persistence_ bootstrap
class, positioning the provider as a candidate for backing named
persistence units. The provider supplies the provider configuration file
by creating a text file named
_javax.persistence.spi.PersistenceProvider_ and placing it in the
_META-INF/services_ directory of one of its JAR files. The contents of
the file should be the name of the provider implementation class of the
_javax.persistence.spi.PersistenceProvider_ interface.

 _Example:_

A persistence vendor called ACME persistence
products ships a JAR called _acme.jar_ that contains its persistence
provider implementation. The JAR includes the provider configuration
file.

acme.jar


META-INF/services/javax.persistence.spi.PersistenceProvider

 com.acme.PersistenceProvider

 …

The contents of the
_META-INF/services/javax.persistence.spi.PersistenceProvider_ file is
nothing more than the name of the implementation class:
_com.acme.PersistenceProvider_ .

Persistence provider jars may be installed or
made available in the same ways as other service providers, e.g. as
extensions or added to the application classpath.

The _Persistence_ bootstrap class must locate
all of the persistence providers using the _PersistenceProviderResolver_
mechanism described in section link:Per.html#a12837[See
Determining the Available Persistence Providers] and call
_createEntityManagerFactory_ on them in turn until an appropriate
backing provider returns an _EntityManagerFactory_ instance. A provider
may deem itself as appropriate for the persistence unit if any of the
following are true:

Its implementation class has been specified
in the _provider_ element for that persistence unit in the
_persistence.xml_ file and has not been overridden by a different
_javax.persistence.provider_ property value included in the Map passed
to the _createEntityManagerFactory_ method.

The _javax.persistence.provider_ property was
included in the Map passed to _createEntityManagerFactory_ and the value
of the property is the provider’s implementation class.

No provider was specified for the persistence
unit in either the _persistence.xml_ or the property map.

If a provider does not qualify as the
provider for the named persistence unit, it must return _null_ when
_createEntityManagerFactory_ is invoked on it.

==== Schema Generation

In Java SE environments, the
_Persistence.generateSchema_ method may be used by the application to
cause schema generation to occur as a separate phase from entity manager
factory creation.

In this case, the _Persistence_ bootstrap
class must locate all of the persistence providers using the
_PersistenceProviderResolver_ mechanism described in section
link:Per.html#a12837[See Determining the Available Persistence
Providers] and call _generateSchema_ on them in turn until an
appropriate backing provider returns _true_ . A provider may deem itself
as appropriate for the persistence unit if any of the following are
true:

Its implementation class has been specified
in the _provider_ element for that persistence unit in the
_persistence.xml_ file and has not been overridden by a different
_javax.persistence.provider_ property value included in the Map passed
to the _generateSchema_ method.

The _javax.persistence.provider_ property was
included in the Map passed to _generateSchema_ and the value of the
property is the provider's implementation class.

No provider was specified for the persistence
unit in either the _persistence.xml_ or the property map.

If a provider does not qualify as the
provider for the named persistence unit, it must return _false_ when
_generateSchema_ is invoked on it.

=== [[a12837]]Determining the Available Persistence Providers

image:Per-4.png[image]

{empty}The _PersistenceProviderResolver_ and
_PersistenceProviderResolverHolder_ mechanism supports the dynamic
discovery of persistence providers.link:#a19631[95]

The _PersistenceProviderResolver_ instance is
responsible for returning the list of providers available in the
environment.

The _PersistenceProviderResolverHolder_ class
holds the _PersistenceProviderResolver_ instance that is in use. The
implementation of _PersistenceProviderResolverHolder_ must be
threadsafe, but no guarantee is made against multiple threads setting
the resolver.

{empty}The container is allowed to implement
and set a specific _PersistenceProviderResolver_ provided that it
respects the _PersistenceProviderResolver_ contract. The
_PersistenceProviderResolver_ instance to be used is set by the
container using the
_PersistenceProviderResolverHolder.setPersistenceProviderResolver_
method.link:#a19632[96]

If no _PersistenceProviderResolver_ is set,
the _PersistenceProviderResolverHolder_ must return a
_PersistenceProviderResolver_ that returns the providers whose
persistence provider jars have been installed or made available as
service providers or extensions. This default
_PersistenceProviderResolver_ instance does not guarantee the order in
which persistence providers are returned.

A _PersistenceProviderResolver_ must be
threadsafe.

The
_PersistenceProviderResolver.getPersistenceProviders()_ method must be
used to determine the list of available persistence providers.

The results of calling the
_PersistenceProviderResolverHolder.getPersistenceProviderResolver_ and
the _PersistenceProviderResolver.getPersistenceProviders_ methods must
not be cached. In particular, the following methods must use the
_PersistenceProviderResolver_ instance returned by the
_PersistenceProviderResolverHolder.getPersistenceProviderResolver_
method to determine the list of available providers:


_Persistence.createEntityManagerFactory(String)_


_Persistence.createEntityManagerFactory(String, Map)_

 _PersistenceUtil.isLoaded(Object)_

 _PersistenceUtil.isLoaded(Object, String)_

These methods must not cache the list of
providers and must not cache the _PersistenceProviderResolver_ instance.

Note that the
_PersistenceProviderResolver.getPersistenceProviders()_ method can
potentially be called many times. It is therefore recommended that the
implementation of this method make use of caching.

Note that only a single
_PersistenceProviderResolver_ instance can be defined in a given
classloader hierarchy at a given time.

==== PersistenceProviderResolver interface

package javax.persistence.spi;



import java.util.List;



/**

 * Determine the list of persistence
providers available in the

 * runtime environment.

 *

 * Implementations must be thread-safe.

 *

 * Note that the getPersistenceProviders
method can potentially

 * be called many times: it is recommended
that the implementation

 * of this method make use of caching.

 */

public interface PersistenceProviderResolver
\{



 /**

 * Returns a list of the PersistenceProvider
implementations

 * available in the runtime environment.

 *

 * @return list of the persistence providers
available

 * in the environment

 */

 List<PersistenceProvider>
getPersistenceProviders();





 /**

 * Clear cache of providers.

 */

 void clearCachedProviders();

}

==== PersistenceProviderResolverHolder class



package javax.persistence.spi;



import java.util.List;



/**

 * Holds the global
PersistenceProviderResolver instance.

 * If no PersistenceProviderResolver is set
by the environment,

 * the default PersistenceProviderResolver is
used.

 *

 * Implementations must be thread-safe.

 */

public class
PersistenceProviderResolverHolder \{



 /**

 * Returns the current persistence provider
resolver.

 * @return persistence provider resolver in
use

 */

 public static PersistenceProviderResolver
getPersistenceProviderResolver() \{

 ...;

 }



 /**

 * Defines the persistence provider resolver
used.

 * @param resolver
PersistenceProviderResolver to be used

 */

 public static void
setPersistenceProviderResolver(

 PersistenceProviderResolver resolver) \{

 ...;

 }

}

=== [[a12917]]Schema Generation

image:Per-4.png[image]

In cases where a preconfigured database (or a
“legacy” database) is not used or is not available, the Java Persistence
schema generation facility may be used to generate the tables and other
database artifacts required by the persistence application. Whether
schema generation entails the creation of schemas proper in the database
is determined by the environment and the configuration of the schema
generation process, as described below.

Schema generation may happen either prior to
application deployment or when the entity manager factory is created as
part of the application deployment and initialization process.

In Java EE environments, the container may
call the _PersistenceProvider_ _generateSchema_ method separately from
and/or prior to the creation of the entity manager factory for the
persistence unit, or the container may pass additional information to
the _createContainerEntityManagerFactory_ call to cause schema
generation to happen as part of the entity manager factory creation and
application initialization process. The information passed to these
methods controls whether the generation occurs directly in the target
database, whether DDL scripts for schema generation are created, or
both.

In Java SE environments, the application may
call the _Persistence_ _generateSchema_ method separately from and/or
prior to the creation of the entity manager factory or may pass
information to the _createEntityManagerFactory_ method to cause schema
generation to occur as part of the entity manager factory creation.

The application may provide DDL scripts to be
used for schema generation as described in
link:Per.html#a12384[See properties]. The application developer
may package these scripts as part of the persistence unit or may specify
strings corresponding to file URLs for the location of such scripts. In
Java EE environments, such scripts may be executed by the container, or
the container may direct the persistence provider to execute the
scripts. In Java SE environments, the execution of the scripts is the
responsibility of the persistence provider. In the absence of the
specification of scripts, schema generation, if requested, will be
determined by the object/relational metadata of the persistence unit.

The following standard properties are defined
for configuring the schema generation process. In Java EE environments
these properties are passed by the container in the _Map_ argument to
either the _PersistenceProvider_ _generateSchema_ method or the
_createContainerEntityManagerFactory_ method. In Java SE environments,
they are passed in the _Map_ argument to either the _Persistence_
_generateSchema_ method or _createEntityManagerFactory_ method.

In Java EE environments, any strings
corresponding to file URLs for script sources or targets must specify
absolute paths (not relative). In Java EE environments, all source and
target file locations must be accessible to the application server
deploying the persistence unit


_javax.persistence.schema-generation.database.action_

The
_javax.persistence.schema-generation.database.action_ property specifies
the action to be taken by the persistence provider with regard to the
database artifacts. The values for this property are _"none"_ ,
_"create"_ , _"drop-and-create"_ , _"drop"_ . If the
_javax.persistence.schema-generation.database.action_ property is not
specified, no schema generation actions must be taken on the database.


_javax.persistence.schema-generation.scripts.action_

The
_javax.persistence.schema-generation.scripts.action_ property specifies
which scripts are to be generated by the persistence provider. The
values for this property are _"none"_ , _"create"_ , _"drop-and-create"_
, _"drop"_ . A script will only be generated if the script target is
specified. If this property is not specified, no scripts will be
generated.


_javax.persistence.schema-generation.create-source_

The
_javax.persistence.schema-generation.create-source_ property specifies
whether the creation of database artifacts is to occur on the basis of
the object/relational mapping metadata, DDL script, or a combination of
the two. The values for this property are _"metadata"_ , _"script"_ ,
_"metadata-then-script"_ , _"script-then-metadata"_ . If this property
is not specified, and a script is specified by the
_javax.persistence.schema-generation.create-script-source_ property, the
script (only) will be used for schema generation; otherwise if this
property is not specified, schema generation will occur on the basis of
the object/relational mapping metadata (only). The
_"metadata-then-script"_ and _"script-then-metadata"_ values specify
that a combination of metadata and script is to be used and the order in
which this use is to occur. If either of these values is specified and
the resulting database actions are not disjoint, the results are
undefined and schema generation may fail.


_javax.persistence.schema-generation.drop-source_

The
_javax.persistence.schema-generation.drop-source_ property specifies
whether the dropping of database artifacts is to occur on the basis of
the object/relational mapping metadata, DDL script, or a combination of
the two. The values for this property are _"metadata"_ , _"script"_ ,
_"metadata-then-script"_ , _"script-then-metadata"_ . If this property
is not specified, and a script is specified by the
_javax.persistence.schema-generation.drop-script-source_ property, the
script (only) will be used for the dropping of database artifacts;
otherwise if this property is not specified, the dropping of database
artifacts will occur on the basis of the object/relational mapping
metadata (only). The _"metadata-then-script"_ and
_"script-then-metadata"_ values specify that a combination of metadata
and script is to be used and the order in which this use is to occur. If
either of these values is specified and the resulting database actions
are not disjoint, the results are undefined and the dropping of database
artifacts may fail.


_javax.persistence.schema-generation.create-database-schemas_

In Java EE environments, it is anticipated
that the Java EE platform provider may wish to control the creation of
database schemas rather than delegate this task to the persistence
provider. The
_javax.persistence.schema-generation.create-database-schemas_ property
specifies whether the persistence provider is to create the database
schema(s) in addition to creating database objects such as tables,
sequences, constraints, etc. The value of this boolean property should
be set to true if the persistence provider is to create schemas in the
database or to generate DDL that contains “CREATE SCHEMA” commands. If
this property is not supplied, the provider should not attempt to create
database schemas. This property may also be specified in Java SE
environments.


_javax.persistence.schema-generation.scripts.create-target_ , +
_javax.persistence.schema-generation.scripts.drop-target_

If scripts are to be generated, the target
locations for the writing of these scripts must be specified.

The
_javax.persistence.schema-generation.scripts.create-target_ property
specifies a _java.IO.Writer_ configured for use by the persistence
provider for output of the DDL script or a string specifying the file
URL for the DDL script. This property should only be specified if
scripts are to be generated.

The
_javax.persistence.schema-generation.scripts.drop-target_ property
specifies a _java.IO.Writer_ configured for use by the persistence
provider for output of the DDL script or a string specifying the file
URL for the DDL script. This property should only be specified if
scripts are to be generated.

 _javax.persistence.database-product-name_
, +
_javax.persistence.database-major-version_ , +
_javax.persistence.database-minor-version_

If scripts are to be generated by the
persistence provider and a connection to the target database is not
supplied, the _javax.persistence.database-product-name_ property must be
specified. The value of this property should be the value returned for
the target database by the JDBC _DatabaseMetaData_ method
_getDatabaseProductName_ . If sufficient database version information is
not included in the result of this method, the
_javax.persistence.database-major-version_ and
_javax.persistence.database-minor-version_ properties should be
specified as needed. These should contain the values returned by the
JDBC _getDatabaseMajorVersion_ and _getDatabaseMinorVersion_ methods
respectively.


_javax.persistence.schema-generation.create-script-source_ , +
_javax.persistence.schema-generation.drop-script-source_

The
_javax.persistence.schema-generation.create-script-source_ and
_javax.persistence.schema-generation.drop-script-source_ properties are
used for script execution. In Java EE container environments, it is
generally expected that the container will be responsible for executing
DDL scripts, although the container is permitted to delegate this task
to the persistence provider. If DDL scripts are to be used in Java SE
environments or if the Java EE container delegates the execution of
scripts to the persistence provider, these properties must be specified.

The
_javax.persistence.schema-generation.create-script-source_ property
specifies a _java.IO.Reader_ configured for reading of the DDL script or
a string designating a file URL for the DDL script.

The
_javax.persistence.schema-generation.drop-script-source_ property
specifies a _java.IO.Reader_ configured for reading of the DDL script or
a string designating a file URL for the DDL script.


_javax.persistence.schema-generation.connection_

The
_javax.persistence.schema-generation.connection_ property specifies the
JDBC connection to be used for schema generation. This is intended for
use in Java EE environments, where the platform provider may want to
control the database privileges that are available to the persistence
provider. This connection is provided by the container, and should be
closed by the container when the schema generation request or entity
manager factory creation completes. The connection provided must have
credentials sufficient for the persistence provider to carry out the
requested actions. If this property is not specified, the persistence
provider should use the DataSource that has otherwise been provided.

==== Data Loading

Data loading, by means of the use of SQL
scripts, may occur as part of the schema generation process after the
creation of the database artifacts or independently of schema
generation. The specification of the
_javax.persistence.sql-load-script-source_ controls whether data loading
will occur.

 _javax.persistence.sql-load-script-source_

In Java EE container environments, it is
generally expected that the container will be responsible for executing
data load scripts, although the container is permitted to delegate this
task to the persistence provider. If a load script is to be used in Java
SE environments or if the Java EE container delegates the execution of
the load script to the persistence provider, this property must be
specified.

The
_javax.persistence.sql-load-script-source_ property specifies a
_java.IO.Reader_ configured for reading of the SQL load script for
database initialization or a string designating a file URL for the
script.

=== Responsibilities of the Persistence Provider

image:Per-4.png[image]

The persistence provider must implement the
_PersistenceProvider_ SPI.

In Java EE environments, the persistence
provider must process the metadata that is passed to it at the time
_createContainerEntityManagerFactory_ method is called and create an
instance of _EntityManagerFactory_ using the _PersistenceUnitInfo_
metadata for the factory. The factory is then returned to the container.

In Java SE environments, the persistence
provider must validate the _persistence.xml_ file against the
_persistence_ schema that corresponds to the version specified by the
_persistence.xml_ file and report any validation errors.

The persistence provider processes the
metadata annotations on the managed classes of the persistence unit.

When the entity manager factory for a
persistence unit is created, it is the responsibility of the persistence
provider to initialize the state of the metamodel classes of the
persistence unit.

When the persistence provider obtains an
object/relational mapping file, it processes the definitions that it
contains. The persistence provider must validate any object/relational
mapping files against the object/relational mapping schema version
specified by the object/relational mapping file and report any
validation errors. The object relational mapping file must specify the
object/relational mapping schema that it is written against by
indicating the _version_ element.

In Java SE environments, the application can
pass the _ValidatorFactory_ instance via the map that is passed as an
argument to the _Persistence.createEntityManagerFactory_ call. The map
key used must be the standard property name
_javax.persistence.validation.factory_ . If no _ValidatorFactory_
instance is provided by the application, and if a Bean Validation
provider is present in the classpath, the persistence provider must
instantiate the _ValidatorFactory_ using the default bootstrapping
approach as defined by the Bean Validation specification
link:Per.html#a19498[See JSR-380: Bean Validation, v. 2.0.
http://jcp.org/en/jsr/detail?id=380.], namely
_Validation.buildDefaultValidatorFactory()_ .

[discrete]
=== javax.persistence.spi.PersistenceProvider

The interface
_javax.persistence.spi.PersistenceProvider_ must be implemented by the
persistence provider.

It is invoked by the container in Java EE
environments and by the _javax.persistence.Persistence_ class in Java SE
environments. The _javax.persistence.spi.PersistenceProvider_
implementation is not intended to be used by the application.

The _PersistenceProvider_ implementation
class must have a public no-arg constructor.

package javax.persistence.spi;



import
javax.persistence.EntityManagerFactory;

import java.util.Map;



/**

 * Interface implemented by the persistence
provider.

 *

 * It is invoked by the container in Java EE
environments and

 * by the Persistence class in Java SE
environments to

 * create an EntityManagerFactory and/or to
cause schema generation

 * to occur.

 */

public interface PersistenceProvider \{



 /**

 * Called by Persistence class when an
EntityManagerFactory

 * is to be created.

 *

 * @param emName the name of the persistence
unit

 * @param map a Map of properties for use by
the

 * persistence provider. These properties may
be used to

 * override the values of the corresponding
elements in

 * the persistence.xml file or specify values
for

 * properties not specified in the
persistence.xml

 * (and may be null if no properties are
specified).

 * @return EntityManagerFactory for the
persistence unit,

 * or null if the provider is not the right
provider

 */

 public EntityManagerFactory
createEntityManagerFactory(

 String emName, Map map);



 /**

 * Called by the container when an
EntityManagerFactory

 * is to be created.

 *

 * @param info metadata for use by the
persistence provider

 * @param map a Map of integration-level
properties for use

 * by the persistence provider (may be null
if no properties

 * are specified). These properties may
include properties to

 * control schema generation.

 * If a Bean Validation provider is present
in the classpath,

 * the container must pass the
ValidatorFactory instance in

 * the map with the key
"javax.persistence.validation.factory".

 * If the containing archive is a bean
archive, the container

 * must pass the BeanManager instance in the
map with the key

 * "javax.persistence.bean.manager".

 * @return EntityManagerFactory for the
persistence unit

 * specified by the metadata

 */

 public EntityManagerFactory
createContainerEntityManagerFactory(

 PersistenceUnitInfo info, Map map);



 /**

 * Create database schemas and/or tables
and/or create DDL

 * scripts as determined by the supplied
properties.

 *

 * Called by the container when schema
generation is to

 * occur as a separate phase from creation of
the entity

 * manager factory.

 *

 * @param info metadata for use by the
persistence provider

 * @param map properties for schema
generation; these

 * may also include provider-specific
properties

 * @throws PersistenceException if
insufficient or inconsistent

 * configuration information is provided or
if schema

 * generation otherwise fails.

 */

 public void
generateSchema(PersistenceUnitInfo info, Map map);



 /**

 * Create database schemas and/or tables
and/or create DDL

 * scripts as determined by the supplied
properties.

 * Called by the Persistence class when
schema generation is to

 * occur as a separate phase from creation of
the entity

 * manager factory.

 * @param persistenceUnitName the name of the
persistence unit

 * @param map properties for schema
generation; these may

 * also contain provider-specific properties.
The

 * value of these properties override any
values that

 * may have been configured elsewhere.

 * @return true if schema was generated,
otherwise false

 * @throws PersistenceException if
insufficient or inconsistent

 * configuration information is provided or
if schema

 * generation otherwise fails.

 */

 public boolean generateSchema(String
persistenceUnitName,

 Map map);





 /**

 * Return the utility interface implemented
by the persistence

 * provider.

 * @return ProviderUtil interface

 */

 public ProviderUtil getProviderUtil();

}

The properties used in the
_createEntityManagerFactory_ method in Java SE environments are
described further in section link:Per.html#a13443[See
javax.persistence.Persistence Class] below.

[discrete]
=== javax.persistence.spi.ProviderUtil

The _ProviderUtil_ interface is invoked by
the _PersistenceUtil_ implementation to determine the load status of an
entity or entity attribute. It is not intended to be invoked by the
application.

package javax.persistence.spi;



/**

 * Utility interface implemented by the
persistence provider.

 * This interface is invoked by the
PersistenceUtil implementation

 * to determine the load status of an entity
or entity attribute.

 */

public interface ProviderUtil \{



 /**

 * If the provider determines that the entity
has been provided

 * by itself and that the state of the
specified attribute has

 * been loaded, this method returns
LoadState.LOADED.

 * If the provider determines that the entity
has been provided

 * by itself and that either entity
attributes with FetchType

 * EAGER have not been loaded or that the
state of the specified

 * attribute has not been loaded, this
methods returns

 * LoadState.NOT_LOADED.

 * If a provider cannot determine the load
state, this method

 * returns LoadState.UNKNOWN.

 * The provider's implementation of this
method must not obtain

 * a reference to an attribute value, as this
could trigger the

 * loading of entity state if the entity has
been provided by a

 * different provider.

 * @param entity

 * @param attributeName name of attribute
whose load status is

 * to be determined

 * @return load status of the attribute

 */

 public LoadState isLoadedWithoutReference(

 Object entity, String attributeName);



 /**

 * If the provider determines that the entity
has been provided

 * by itself and that the state of the
specified attribute has

 * been loaded, this method returns
LoadState.LOADED.

 * If a provider determines that the entity
has been provided

 * by itself and that either the entity
attributes with FetchType

 * EAGER have not been loaded or that the
state of the specified

 * attribute has not been loaded, this method
returns

 * return LoadState.NOT_LOADED.

 * If the provider cannot determine the load
state, this method

 * returns LoadState.UNKNOWN.

 * The provider's implementation of this
method is permitted to

 * obtain a reference to the attribute value.
(This access is

 * safe because providers which might trigger
the loading of the

 * attribute state will have already been
determined by

 * isLoadedWithoutReference. )

 * @param entity

 * @param attributeName name of attribute
whose load status is

 * to be determined

 * @return load status of the attribute

 */

 public LoadState isLoadedWithReference(

 Object entity, String attributeName);



 /**

 * If the provider determines that the entity
has been provided

 * by itself and that the state of all
attributes for which

 * FetchType EAGER has been specified have
been loaded, this

 * method returns LoadState.LOADED.

 * If the provider determines that the entity
has been provided

 * by itself and that not all attributes with
FetchType EAGER

 * have been loaded, this method returns
LoadState.NOT_LOADED.

 * If the provider cannot determine if the
entity has been

 * provided by itself, this method returns
LoadState.UNKNOWN.

 * The provider's implementation of this
method must not obtain

 * a reference to any attribute value, as
this could trigger the

 * loading of entity state if the entity has
been provided by a

 * different provider.

 * @param entity whose loaded status is to be
determined

 * @return load status of the entity

 */

 public LoadState isLoaded(Object entity);

}



package javax.persistence.spi;



public enum LoadState \{



 /**

 * the state of the element is known to have
been loaded

 */

 LOADED,



 /**

 * the state of the element is known not to
have been loaded

 */

 NOT_LOADED,



 /**

 * the load state of the element cannot be
determined

 */

 UNKNOWN

}



[discrete]
=== [[a13160]]javax.persistence.spi.PersistenceUnitInfo Interface

image:Per-4.png[image]



package javax.persistence.spi;



import javax.sql.DataSource;

import java.util.List;

import java.util.Properties;

import java.net.URL;

import javax.persistence.SharedCacheMode;

import javax.persistence.ValidationMode;



/**

 * Interface implemented by the container and
used by the

 * persistence provider when creating an
EntityManagerFactory.

 */

public interface PersistenceUnitInfo \{



 /**

 * Returns the name of the persistence unit.
Corresponds to

 * the name attribute in the persistence.xml
file.

 * @return the name of the persistence unit

 */

 public String getPersistenceUnitName();



 /**

 * Returns the fully qualified name of the
persistence provider

 * implementation class. Corresponds to the
provider element in

 * the persistence.xml file.

 * @return the fully qualified name of the
persistence provider

 * implementation class

 */

 public String
getPersistenceProviderClassName();



 /**

 * Returns the transaction type of the entity
managers created by

 * the EntityManagerFactory. The transaction
type corresponds to

 * the transaction-type attribute in the
persistence.xml file.

 * @return transaction type of the entity
managers created

 * by the EntityManagerFactory

 */

 public PersistenceUnitTransactionType
getTransactionType();



 /**

 * Returns the JTA-enabled data source to be
used by the

 * persistence provider. The data source
corresponds to the

 * jta-data-source element in the
persistence.xml file or is

 * provided at deployment or by the
container.

 * @return the JTA-enabled data source to be
used by the

 * persistence provider

 */

 public DataSource getJtaDataSource();













 /**

 * Returns the non-JTA-enabled data source to
be used by the

 * persistence provider for accessing data
outside a JTA

 * transaction. The data source corresponds
to the named

 * non-jta-data-source element in the
persistence.xml file or

 * provided at deployment or by the
container.

 * @return the non-JTA-enabled data source to
be used by the

 * persistence provider for accessing data
outside a JTA

 * transaction

 */

 public DataSource getNonJtaDataSource();



 /**

 * Returns the list of the names of the
mapping files that the

 * persistence provider must load to
determine the mappings for

 * the entity classes. The mapping files must
be in the standard

 * XML mapping format, be uniquely named and
be resource-loadable

 * from the application classpath. Each
mapping file name

 * corresponds to a mapping-file element in
the

 * persistence.xml file.

 * @return the list of mapping file names
that the persistence

 * provider must load to determine the
mappings for the entity

 * classes

 */

 public List<String> getMappingFileNames();



 /**

 * Returns a list of URLs for the jar files
or exploded jar

 * file directories that the persistence
provider must examine

 * for managed classes of the persistence
unit. Each URL

 * corresponds to a jar-file element in the

 * persistence.xml file. A URL will either be
a file: URL

 * referring to a jar file or referring to a
directory

 * that contains an exploded jar file, or
some other URL from

 * which an InputStream in jar format can be
obtained.

 * @return a list of URL objects referring to
jar files or

 * directories

 */

 public List<URL> getJarFileUrls();



 /**

 * Returns the URL for the jar file or
directory that is the

 * root of the persistence unit. (If the
persistence unit is

 * rooted in the WEB-INF/classes directory,
this will be the

 * URL of that directory.)

 * The URL will either be a file: URL
referring to a jar file

 * or referring to a directory that contains
an exploded jar

 * file, or some other URL from which an
InputStream in jar

 * format can be obtained.

 * @return a URL referring to a jar file or
directory

 */

 public URL getPersistenceUnitRootUrl();

















 /**

 * Returns the list of the names of the
classes that the

 * persistence provider must add to its set
of managed

 * classes. Each name corresponds to a named
class element in the

 * persistence.xml file.

 * @return the list of the names of the
classes that the

 * persistence provider must add to its set
of managed

 * classes

 */

 public List<String> getManagedClassNames();



 /**

 * Returns whether classes in the root of the
persistence unit

 * that have not been explicitly listed are
to be included in the

 * set of managed classes. This value
corresponds to the

 * exclude-unlisted-classes element in the
persistence.xml file.

 * @return whether classes in the root of the
persistence

 * unit that have not been explicitly listed
are to be

 * included in the set of managed classes

 */

 public boolean excludeUnlistedClasses();



 /**

 * Returns the specification of how the
provider must use

 * a second-level cache for the persistence
unit.

 * The result of this method corresponds to
the shared-cache-mode

 * element in the persistence.xml file.

 * @return the second-level cache mode that
must be used by the

 * provider for the persistence unit

 */

 public SharedCacheMode getSharedCacheMode();



 /**

 * Returns the validation mode to be used by
the persistence

 * provider for the persistence unit. The
validation mode

 * corresponds to the validation-mode element
in the

 * persistence.xml file.

 * @return the validation mode to be used by
the

 * persistence provider for the persistence
unit

 */

 public ValidationMode getValidationMode();



 /**

 * Returns a properties object. Each property
corresponds to a

 * property element in the persistence.xml
file.

 * @return Properties object

 */

 public Properties getProperties();



 /**

 * Returns the schema version of the
persistence.xml file.

 * @return persistence.xml schema version

 */

 public String
getPersistenceXMLSchemaVersion();









 /**

 * Returns ClassLoader that the provider may
use to load any

 * classes, resources, or open URLs.

 * @return ClassLoader that the provider may
use to load any

 * classes, resources, or open URLs

 */

 public ClassLoader getClassLoader();



 /**

 * Add a transformer supplied by the provider
that will be

 * called for every new class definition or
class redefinition

 * that gets loaded by the loader returned by
the

 * PersistenceUnitInfo.getClassLoader method.
The transformer

 * has no effect on the result returned by
the

 * PersistenceUnitInfo.getNewTempClassLoader
method.

 * Classes are only transformed once within
the same classloading

 * scope, regardless of how many persistence
units they may be

 * a part of.

 * @param transformer provider-supplied
transformer that the

 * container invokes at class-(re)definition
time

 */

 public void addTransformer(ClassTransformer
transformer);



 /**

 * Return a new instance of a ClassLoader
that the provider may

 * use to temporarily load any classes,
resources, or open

 * URLs. The scope and classpath of this
loader is exactly the

 * same as that of the loader returned by

 * PersistenceUnitInfo.getClassLoader. None
of the classes loaded

 * by this class loader will be visible to
application

 * components. The provider may only use this
ClassLoader within

 * the scope of the
createContainerEntityManagerFactory call.

 * @return temporary ClassLoader with same
visibility as current

 * loader

 */

 public ClassLoader getNewTempClassLoader();

}

The enum
_javax.persistence.spi.PersistenceUnitTransactionType_ defines whether
the entity managers created by the factory will be JTA or resource-local
entity managers.

package javax.persistence.spi;



public enum PersistenceUnitTransactionType \{

 JTA,

 RESOURCE_LOCAL

}

The enum _javax.persistence.SharedCacheMode_
defines the use of caching. The _persistence.xml_ _shared-cache-mode_
element has no default value. The _getSharedCacheMode_ method must
return _UNSPECIFIED_ if the _shared-cache-mode_ element has not been
specified for the persistence unit.

package javax.persistence;



public enum SharedCacheMode \{

 ALL,

 NONE,

 ENABLE_SELECTIVE,

 DISABLE_SELECTIVE,

 UNSPECIFIED

}

The enum _javax.persistence.ValidationMode_
defines the validation mode.

package javax.persistence;



public enum ValidationMode \{

 AUTO,

 CALLBACK,

 NONE

}

[discrete]
=== javax.persistence.spi.ClassTransformer Interface

The _javax.persistence.spi.ClassTransformer_
interface is implemented by a persistence provider that wants to
transform entities and managed classes at class load time or at class
redefinition time.



package javax.persistence.spi;



import java.security.ProtectionDomain;

import
java.lang.instrument.IllegalClassFormatException;



/**

 * A persistence provider supplies an
instance of this

 * interface to the
PersistenceUnitInfo.addTransformer

 * method. The supplied transformer instance
will get

 * called to transform entity class files
when they are

 * loaded or redefined. The transformation
occurs before

 * the class is defined by the JVM.

 */

public interface ClassTransformer \{



 /**

 * Invoked when a class is being loaded or
redefined.

 * The implementation of this method may
transform the

 * supplied class file and return a new
replacement class

 * file.

 *

 * @param loader the defining loader of the
class to be

 * transformed, may be null if the bootstrap
loader

 * @param className the name of the class in
the internal form

 * of fully qualified class and interface
names

 * @param classBeingRedefined if this is a
redefine, the

 * class being redefined, otherwise null

 * @param protectionDomain the protection
domain of the

 * class being defined or redefined

 * @param classfileBuffer the input byte
buffer in class

 * file format - must not be modified

 * @return a well-formed class file buffer
(the result of

 * the transform), or null if no transform is
performed

 * @throws IllegalClassFormatException if the
input does

 * not represent a well-formed class file

 */

 byte[] transform(ClassLoader loader,

 String className,

 Class<?> classBeingRedefined,

 ProtectionDomain protectionDomain,

 byte[] classfileBuffer)

 throws IllegalClassFormatException;

}

[discrete]
=== [[a13443]]javax.persistence.Persistence Class

image:Per-4.png[image]

The _Persistence_ class is used to obtain an
_EntityManagerFactory_ instance in Java SE environments. It may also be
used for schema generation— i.e., to create database schemas and/or
tables and/or to create DDL scripts.

The _Persistence_ class is available in a
Java EE container environment as well; however, support for the Java SE
bootstrapping APIs is not required in container environments.

The _Persistence_ class is used to obtain a
_PersistenceUtil_ instance in both Java EE and Java SE environments.

package javax.persistence;



import java.util.*;

...



/**

 * Provider-independent class

 *

 * Class that is used to obtain an
EntityManagerFactory in Java SE

 * environments. It may also be used to cause
schema generation to

 * occur.

 *

 * Class that is used to obtain an instance
of PersistenceUtil in

 * Java EE and Java SE environments.

 */

public class Persistence \{



 /**

 * Create and return an EntityManagerFactory
for the

 * named persistence unit.

 *

 * Use of this method is not required to be
supported in

 * Java EE container environments.

 *

 * @param persistenceUnitName the name of the
persistence unit

 * @return the factory that creates
EntityManagers configured

 * according to the specified persistence
unit

 */

 public static EntityManagerFactory
createEntityManagerFactory(

 String persistenceUnitName) \{...}



 /**

 * Create and return an EntityManagerFactory
for the

 * named persistence unit using the given
properties.

 *

 * Use of this method is not required to be
supported in

 * Java EE container environments.

 *

 * @param persistenceUnitName the name of the
persistence unit

 * @param props additional properties to use
when creating the

 * factory. These properties may include
properties to control

 * schema generation. The values of these
properties override

 * any values that may have been configured
elsewhere.

 * @return the factory that creates
EntityManagers configured

 * according to the specified persistence
unit

 */

 public static EntityManagerFactory
createEntityManagerFactory(

 String persistenceUnitName, Map properties)
\{...};



 /**

 * Create database schemas and/or tables
and/or create DDL

 * scripts as determined by the supplied
properties

 *

 * Called when schema generation is to occur
as a separate

 * phase from creation of the entity manager
factory.

 * @param persistenceUnitName the name of the
persistence unit

 * @param map properties for schema
generation; these may also

 * contain provider-specific properties. The
values of

 * these properties override any values that
may have

 * been configured elsewhere.

 * @throws PersistenceException if
insufficient or inconsistent

 * configuration information is provided or
if schema

 * generation otherwise fails.

 */

 public static void generateSchema(String
persistenceUnitName,

 Map properties);



 /*

 * Return PersistenceUtil instance

 */

 public static PersistenceUtil
getPersistenceUtil() \{...}



 ...

}



The _properties_ argument passed to the
_createEntityManagerFactory_ method is used to specify both standard and
vendor-specific properties and hints intended for use in creating the
entity manager factory.

The following properties correspond to the
elements and properties in the _persistence.xml_ file. When any of these
properties are specified in the Map parameter passed to the
_createEntityManagerFactory_ method, their values override the values of
the corresponding elements and properties in the _persistence.xml_ file
for the named persistence unit. They also override any defaults that the
persistence provider might have applied.

 _javax.persistence.lock.timeout_ — integer
value in milliseconds for pessimistic lock timeout or string
corresponding to integer value. This corresponds to the property of the
same name in the _persistence.xml_ , and is a hint only. See section
link:Per.html#a2132[See Lock Mode Properties and Uses].

 _javax.persistence.query.timeout_ — integer
value in milliseconds for query timeout or string corresponding to
integer value. This corresponds to the property of the same name in the
_persistence.xml_ , and is a hint only. See section
link:Per.html#a4391[See Query Hints].

 _javax.persistence.provider_ — string
corresponding to the _provider_ element in the pe _rsistence.xml_ . See
section link:Per.html#a12300[See provider].

 _javax.persistence.transactionType_ — string
corresponding to the _transaction-type_ attribute in the
_persistence.xml_ . See section link:Per.html#a12296[See
transaction-type].

 _javax.persistence.jtaDataSource_ — string
corresponding to the _jta-data-source_ element in the _persistence.xml_
. See section link:Per.html#a12302[See jta-data-source,
non-jta-data-source].

 _javax.persistence.nonJtaDataSource_ —
string corresponding to the _non-jta-data-source_ element in the
_persistence.xml_ . See section link:Per.html#a12302[See
jta-data-source, non-jta-data-source].

{empty} _javax.persistence.sharedCache.mode_
— string corresponding to the _shared-cache-mode_ element in the
_persistence.xml_ . See section link:Per.html#a12380[See
shared-cache-mode]

 _javax.persistence.validation.mode_ — string
corresponding to the _validation-mode_ element in the _persistence.xml_
. The value is " _auto_ ", " _callback_ ", or " _none_ ". See sections
link:Per.html#a12382[See validation-mode] and
link:Per.html#a2374[See Enabling Automatic Validation].


_javax.persistence.validation.group.pre-persist_ — string corresponding
to the _javax.persistence.validation.group.pre-persist_ property in the
_persistence.xml_ . See sections link:Per.html#a12384[See
properties] and link:Per.html#a2380[See Requirements for
Automatic Validation upon Lifecycle Events].


_javax.persistence.validation.group.pre-update_ — string corresponding
to the _javax.persistence.validation.group.pre-update_ property in the
_persistence.xml_ . See sections link:Per.html#a12384[See
properties] and link:Per.html#a2380[See Requirements for
Automatic Validation upon Lifecycle Events].


_javax.persistence.validation.group.pre-remove_ — string corresponding
to the _javax.persistence.validation.group.pre-remove_ property in the
_persistence.xml_ . See sections link:Per.html#a12384[See
properties] and link:Per.html#a2380[See Requirements for
Automatic Validation upon Lifecycle Events].


_javax.persistence.schema-generation.create-script-source_ — string
corresponding to the
_javax.persistence.schema-generation.create-script-source_ property _in
the_ _persistence.xml_ _. See section link:Per.html#a12384[See
properties]._


_javax.persistence.schema-generation.drop-script-source_ — string
corresponding to the
_javax.persistence.schema-generation.drop-script-source_ property _in
the_ _persistence.xml_ _. See section link:Per.html#a12384[See
properties]._

 _javax.persistence.sql-load-script-source_ —
string corresponding to the _javax.persistence.sql-load-script-source_
property _in the_ _persistence.xml_ _. See section
link:Per.html#a12384[See properties]._


_javax.persistence.schema-generation.database.action_ — string
corresponding to the
_javax.persistence.schema-generation.database.action_ property _in the_
_persistence.xml_ _. See section link:Per.html#a12384[See
properties]._


_javax.persistence.schema-generation.scripts.action_ — string
corresponding to the
_javax.persistence.schema-generation.scripts.action_ property _in the_
_persistence.xml_ _. See section link:Per.html#a12384[See
properties]._


_javax.persistence.schema-generation.create-source_ — string
corresponding to the _javax.persistence.schema-generation.create-source_
property _in the_ _persistence.xml_ _. See section
link:Per.html#a12384[See properties]._


_javax.persistence.schema-generation.drop-source_ — string corresponding
to the _javax.persistence.schema-generation.drop-source_ property _in
the_ _persistence.xml_ _. See section link:Per.html#a12384[See
properties]._


_javax.persistence.schema-generation.scripts.create-target_ —string
corresponding to the
_javax.persistence.schema-generation.scripts.create-target_ property _in
the_ _persistence.xml_ _. See section link:Per.html#a12384[See
properties]._


_javax.persistence.schema-generation.scripts.drop-target_ — string
corresponding to the
_javax.persistence.schema-generation.scripts.drop-target_ property _in
the_ _persistence.xml_ _. See section link:Per.html#a12384[See
properties]._

The following additional standard properties
are defined by this specification for the configuration of the entity
manager factory:

 _javax.persistence.jdbc.driver_ — value is
the fully qualified name of the driver class.

 _javax.persistence.jdbc.url_ — string
corresponding to the driver-specific URL.

 _javax.persistence.jdbc.user_ — value is the
username used by database connection.

 _javax.persistence.jdbc.password_ — value is
the password for database connection validation.

 _javax.persistence.dataSource_ — value is
instance of _javax.sql.DataSource_ to be used for the specified
persistence unit.

 _javax.persistence.validation.factory_ —
value is instance of _javax.validation.ValidatorFactory_ .

Any number of vendor-specific properties may
also be included in the map. If a persistence provider does not
recognize a property (other than a property defined by this
specification), the provider must ignore it.

Vendors should use vendor namespaces for
properties (e.g., _com.acme.persistence.logging_ ). Entries that make
use of the namespace _javax.persistence_ and its subnamespaces must not
be used for vendor-specific information. The namespace
_javax.persistence_ is reserved for use by this specification.

=== PersistenceUtil Interface

image:Per-4.png[image]

This interface is used to determine load
state. The semantics of the methods of this interface are defined in
section link:Per.html#a13592[See Contracts for Determining the
Load State of an Entity or Entity Attribute] below.

package javax.persistence;



/**

 * Utility interface between the application
and the persistence

 * provider(s).

 *

 _* The PersistenceUtil interface instance
obtained from the_

 _* Persistence class is used to determine
the load state of an_

 _* entity or entity attribute regardless of
which persistence_

 _* provider in the environment created the
entity._

 */

public interface PersistenceUtil \{



 /**

 * Determine the load state of a given
persistent attribute.

 * @param entity containing the attribute

 * @param attributeName name of attribute
whose load state is

 * to be determined

 * @return false if entity's state has not
been loaded or

 * if the attribute state has not been
loaded, else true

 */

 public boolean isLoaded(Object entity,
String attributeName);



 /**

 * Determine the load state of an entity.

 * This method can be used to determine the
load state

 * of an entity passed as a reference. An
entity is

 * considered loaded if all attributes for
which FetchType

 * EAGER has been specified have been loaded.

 * The isLoaded(Object, String) method should
be used to

 * determine the load state of an attribute.

 * Not doing so might lead to unintended
loading of state.

 * @param entity whose load state is to be
determined

 * @return false if the entity has not been
loaded, else true

 */

 public boolean isLoaded(Object entity);

}

==== [[a13592]]Contracts for Determining the Load State of an Entity or Entity Attribute

The implementation of the
_PersistenceUtil.isLoaded(Object)_ method must determine the list of
persistence providers available in the runtime
environmentlink:#a19633[97] and call the
_ProviderUtil.isLoaded(Object)_ method on each of them until either:

one provider returns _LoadState.LOADED_ . In
this case _PersistenceUtil.isLoaded_ returns _true_ .

one provider returns _LoadState.NOT_LOADED_ .
In this case _PersistenceUtil.isLoaded_ returns _false_ .

all providers return _LoadState.UNKNOWN_ . In
this case _PersistenceUtil.isLoaded_ returns _true_ .

If the _PersistenceUtil_ implementation
determines that only a single provider is available in the environment,
it is permitted to use provider-specific methods to determine the result
of _isLoaded(Object)_ as long as the semantics defined in section
link:Per.html#a2019[See Load State] are observed.

The implementation of the
_PersistenceUtil.isLoaded(Object,String)_ method must determine the list
of persistence providers available in the environment and call the
_ProviderUtil.isLoadedWithoutReference_ method on each of them until
either:

one provider returns _LoadState.LOADED_ . In
this case _PersistenceUtil.isLoaded_ returns _true_ .

one provider returns _LoadState.NOT_LOADED_ .
In this case _PersistenceUtil.isLoaded_ returns _false_ .

all providers return _LoadState.UNKNOWN_ . In
this case, the _PersistenceUtil.isLoaded_ method then calls
_ProviderUtil.isLoadedWithReference_ on each of the providers until:

one provider returns _LoadState.LOADED_ . In
this case _PersistenceUtil.isLoaded_ return _true_ .

one provider returns _LoadState.NOT_LOADED_ .
In this case, _PersistenceUtil.isLoaded_ returns _false_ .

all providers return _LoadState.UNKNOWN_ . In
this case, _PersistenceUtil.isLoaded_ returns _true_ .

If the _PersistenceUtil_ implementation
determines that only a single provider is available in the environment,
it is permitted to use provider specific methods to determine the result
of _isLoaded(Object, String)_ as long as the semantics defined in
section link:Per.html#a2019[See Load State] are observed.

 __

 _NOTE: The rationale for splitting the
determination of load state between the methods isLoadedWithoutReference
and isLoadedWithReference is the following._

 _It is assumed that the provider that loaded
the entity is present in the environment._

 _Providers that use bytecode enhancement
don't need to access an attribute reference to determine its load state,
and can determine if the entity has been provided by them._

 _By first querying all providers using
bytecode enhancement, it is insured that no attribute will be loaded by
side effect._

 _Proxy-based providers do need to access an
attribute reference to determine load state, but will not trigger
attribute loading as a side effect._

 _If no provider recognizes an entity as
provided by it, it is assumed to be an object that is not instrumented
and is considered loaded._



== Metadata Annotations

This chapter and chapter
link:Per.html#a13915[See Metadata for Object/Relational Mapping]
define the metadata annotations introduced by this specification.

The XML schema defined in chapter
link:Per.html#a16944[See XML Object/Relational Mapping
Descriptor] provides an alternative to the use of metadata annotations.

These annotations and types are in the
package _javax.persistence_ .

=== Entity

image:Per-4.png[image]

The _Entity_ annotation specifies that the
class is an entity. This annotation is applied to the entity class.

The _name_ annotation element specifies the
entity name. If the _name_ element is not specified, the entity name
defaults to the unqualified name of the entity class. This name is used
to refer to the entity in queries.

@Documented @Target(TYPE) @Retention(RUNTIME)

public @interface Entity \{

 String name() default "";

}

=== Callback Annotations

image:Per-4.png[image]

The _EntityListeners_ annotation specifies
the callback listener classes to be used for an entity or mapped
superclass. The _EntityListeners_ annotation may be applied to an entity
class or mapped superclass.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface EntityListeners \{

 Class[] value();

}

The ExcludeSuperclassListeners annotation
specifies that the invocation of superclass listeners is to be excluded
for the entity class (or mapped superclass) and its subclasses.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface ExcludeSuperclassListeners
\{

}

The ExcludeDefaultListeners annotation
specifies that the invocation of default listeners is to be excluded for
the entity class (or mapped superclass) and its subclasses.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface ExcludeDefaultListeners \{

}

The following annotations are used to specify
callback methods for the corresponding lifecycle events. These
annotations may be applied to methods of an entity class, of a mapped
superclass, or of an entity listener class.

@Target(\{METHOD}) @Retention(RUNTIME)

public @interface PrePersist \{}



@Target(\{METHOD}) @Retention(RUNTIME)

public @interface PostPersist \{}



@Target(\{METHOD}) @Retention(RUNTIME)

public @interface PreRemove \{}



@Target(\{METHOD}) @Retention(RUNTIME)

public @interface PostRemove \{}



@Target(\{METHOD}) @Retention(RUNTIME)

public @interface PreUpdate \{}



@Target(\{METHOD}) @Retention(RUNTIME)

public @interface PostUpdate \{}



@Target(\{METHOD}) @Retention(RUNTIME)

public @interface PostLoad \{}





=== [[a13662]]EntityGraph Annotations

image:Per-4.png[image]

==== NamedEntityGraph and NamedEntityGraphs Annotations

The _NamedEntityGraph_ annotation is used to
define a named entity graph. The entity graph may be retrieved by name
using the _EntityManagerFactory_ interface. The entity graph may be used
to specify the path and boundaries for _find_ operations or queries.

The _NamedEntityGraph_ annotation must be
applied to the entity class that forms the root of the corresponding
graph of entities.

The _name_ element is used to refer to the
entity graph. It defaults to the entity name of the root entity to which
the annotation is applied. Entity graph names must be unique within the
persistence unit.

The _attributeNodes_ element lists attributes
of the annotated entity class that are to be included in the entity
graph.

The _includeAllAttributes_ element specifies
that all attributes of the annotated entity class are to be included in
the entity graph. An _attributeNode_ element may still be used in
conjunction with this element to specify a subgraph for the attribute.

The _subgraphs_ element specifies a list of
subgraphs, further specifying attributes that are managed types. These
subgraphs are referenced by name from _NamedAttributeNode_ definitions.

The _subclassSubgraphs_ element specifies a
list of subgraphs that add additional attributes for subclasses of the
root entity to which the annotation is applied.

The _NamedEntityGraphs_ annotation can be
used to specify multiple named entity graphs for the entity to which it
is applied.

@Target(\{TYPE}) @Retention(RUNTIME)

@Repeatable(NamedEntityGraphs.class)

public @interface NamedEntityGraph \{

 String name() default "";

 NamedAttributeNode[] attributeNodes()
default \{};

 boolean includeAllAttributes() default
false;

 NamedSubgraph[] subgraphs() default \{};

 NamedSubgraph[] subclassSubgraphs() default
\{};

}



@Target(\{TYPE}) @Retention(RUNTIME)

public @interface NamedEntityGraphs\{

 NamedEntityGraph[] value();

}





==== NamedAttributeNode Annotation

The _NamedAttributeNode_ annotation is used
to specify an attribute node of within an entity graph or subgraph.

The _value_ element specifies the name of the
corresponding attribute.

The _subgraph_ element is used to refer to a
_NamedSubgraph_ specification that further characterizes an attribute
node corresponding to a managed type (entity or embeddable). The value
of the _subgraph_ element must correspond to the _name_ used for the
subgraph in the _NamedSubgraph_ element. If the referenced attribute is
an entity which has entity subclasses, there may be more than one
_NamedSubgraph_ element with this name, and the _subgraph_ element is
considered to refer to all of these.

The _keySubgraph_ element is used to refer to
a _NamedSubgraph_ specification that further characterizes an attribute
node corresponding to the key of a Map-valued attribute. The value of
the the _keySubgraph_ element must correspond to the _name_ used for the
subgraph in the _NamedSubgraph_ element. If the referenced attribute is
an entity which has entity subclasses, there may be more than one
_NamedSubgraph_ element with this name, and the _keySubgraph_ element is
considered to refer to all of these.

@Target(\{}) @Retention(RUNTIME)

public @interface NamedAttributeNode \{

 String value();

 String subgraph() default "";

 String keySubgraph() default "";

}

==== NamedSubgraph Annotation

The _NamedSubgraph_ annotation is used to
further define an attribute node. It is referenced by its name from the
_subgraph_ or _keySubgraph_ element of a _NamedAttributeNode_ element.

The _name_ element is the name used to
reference the subgraph from a _NamedAttributeNode_ definition. In the
case of entity inheritance, multiple subgraph elements have the same
name.

The _type_ element must be specified when the
subgraph corresponds to a subclass of the entity type corresponding to
the referencing attribute node.

The _attributeNodes_ element lists attributes
of the class that must be included. If the subgraph corresponds to a
subclass of the class referenced by the corresponding attribute node,
only subclass-specific attributes are listed.

@Target(\{}) @Retention(RUNTIME)

public @interface NamedSubgraph \{

 String name();

 Class type() default void.class;

 NamedAttributeNode[] attributeNodes();

}

=== [[a13710]]Annotations for Queries

image:Per-4.png[image]

==== [[a13711]]NamedQuery Annotation

The _NamedQuery_ annotation is used to
specify a named query in the Java Persistence query language.

The _name_ element is used to refer to the
query when using the _EntityManager_ methods that create query objects.

The _query_ element must specify a query
string in the Java Persistence query language.

The _lockMode_ element specifies a lock mode
for the results returned by the query. If a lock mode other than _NONE_
is specified, the query must be executed within a transaction and the
persistence context joined to the transaction.

The _hints_ elements may be used to specify
query properties and hints. Properties defined by this specification
must be observed by the provider; hints defined by this specification
should be observed by the provider when possible. Vendor-specific hints
that are not recognized by a provider must be ignored.

The _NamedQuery_ and _NamedQueries_
annotations can be applied to an entity or mapped superclass.

@Target(\{TYPE}) @Retention(RUNTIME)

@Repeatable(NamedQueries.class)

public @interface NamedQuery \{

 String name();

 String query();

 LockModeType lockMode() default NONE;

 QueryHint[] hints() default \{};

}



@Target(\{}) @Retention(RUNTIME)

public @interface QueryHint \{

 String name();

 String value();

}



@Target(\{TYPE}) @Retention(RUNTIME)

public @interface NamedQueries \{

 NamedQuery[] value ();

}



==== NamedNativeQuery Annotation

The _NamedNativeQuery_ annotation is used to
specify a native SQL named query.

The _name_ element is used to refer to the
query when using the _EntityManager_ methods that create query objects.

The _query_ element specifies the native
query.

The _resultClass_ element refers to the class
of the result; the value of the _resultSetMapping_ element is the name
of a _SqlResultSetMapping_ specification, as defined in metadata.

The _hints_ elements may be used to specify
query properties and hints. Hints defined by this specification should
be observed by the provider when possible. Vendor-specific hints that
are not recognized by a provider must be ignored.

The _NamedNativeQuery_ and
_NamedNativeQueries_ annotations can be applied to an entity or mapped
superclass.

@Target(\{TYPE}) @Retention(RUNTIME)

@Repeatable(NamedNativeQueries.class)

public @interface NamedNativeQuery \{

 String name();

 String query();

 QueryHint[] hints() default \{};

 Class resultClass() default void.class;

 String resultSetMapping() default "";

}



@Target(\{TYPE}) @Retention(RUNTIME)

public @interface NamedNativeQueries \{

 NamedNativeQuery[] value ();

}

==== [[a13759]]NamedStoredProcedureQuery Annotation

The _NamedStoredProcedureQuery_ annotation is
used to specify a stored procedure, its parameters, and its result type.

The _name_ element is the name that is passed
as an argument to the _createNamedStoredProcedureQuery_ method to create
an executable _StoredProcedureQuery_ object.

The _procedureName_ element is the name of
the stored procedure in the database.

The parameters of the stored procedure are
specified by the _parameters_ element. All parameters must be specified
in the order in which they occur in the parameter list of the stored
procedure.

The _resultClasses_ element refers to the
class (or classes) that are used to map the results. The
_resultSetMappings_ element names one or more result set mappings, as
defined by the _SqlResultSetMapping_ annotation.

If there are multiple result sets, it is
assumed that they will be mapped using the same mechanism—e.g., either
all via a set of result class mappings or all via a set of result set
mappings. The order of the specification of these mappings must be the
same as the order in which the result sets will be returned by the
stored procedure invocation. If the stored procedure returns one or more
result sets and no _resultClasses_ or _resultSetMappings_ element is
specified, any result set will be returned as a list of type _Object[]_
. The combining of different strategies for the mapping of stored
procedure result sets is undefined.

The _hints_ element may be used to specify
query properties and hints. Properties defined by this specification
must be observed by the provider. Vendor-specific hints that are not
recognized by a provider must be ignored.

The _NamedStoredProcedureQuery_ and
_NamedStoredProcedureQueries_ annotations can be applied to an entity or
mapped superclass.

@Target(TYPE) @Retention(RUNTIME)

@Repeatable(NamedStoredProcedureQueries.class)

public @interface NamedStoredProcedureQuery\{

 String name();

 String procedureName();

 StoredProcedureParameter[] parameters()
default \{};

 Class[] resultClasses() default \{};

 String[] resultSetMappings() default \{};

 QueryHint[] hints() default \{};

}



@Target(TYPE) @Retention(RUNTIME)

public @interface NamedStoredProcedureQueries
\{

 NamedStoredProcedureQuery [] value;

}

All parameters of a named stored procedure
query must be specified using the _StoredProcedureParameter_ annotation.
The _name_ element refers to the name of the parameter as defined by the
stored procedure in the database. If a parameter name is not specified,
it is assumed that the stored procedure uses positional parameters. The
_mode_ element specifies whether the parameter is an IN, INOUT, OUT, or
REF_CURSOR parameter. REF_CURSOR parameters are used by some databases
to return result sets from stored procedures. The _type_ element refers
to the JDBC type for the parameter.

@Target(\{}) @Retention(RUNTIME)

public @interface StoredProcedureParameter \{

 String name() default "";

 ParameterMode mode() default
ParameterMode.IN;

 Class type();

}



public enum ParameterMode \{

 IN,

 INOUT,

 OUT,

 REF_CURSOR

}

==== [[a13797]]Annotations for SQL Result Set Mappings

The _SqlResultSetMapping_ annotation is used
to specify the mapping of the result of a native SQL query or stored
procedure.

 _@Target(\{TYPE}) @Retention(RUNTIME)_

@Repeatable(SqlResultSetMappings.class)

 _public @interface SqlResultSetMapping \{_

 _String name();_

 _EntityResult[] entities() default \{};_

 ConstructorResult[] classes() default \{};

 _ColumnResult[] columns() default \{};_

 _}_



 _@Target(\{TYPE}) @Retention(RUNTIME)_

public @interface SqlResultSetMappings \{

 SqlResultSetMapping[] value();

}



The _name_ element is the name given to the
result set mapping, and is used to refer to it in the methods of the
_Query_ and _StoredProcedureQuery_ APIs. The _entities_ , _classes_ ,
and _columns_ elements are used to specify the mapping to entities,
constructors, and to scalar values respectively.

@Target(\{}) @Retention(RUNTIME)

public @interface EntityResult \{

 Class entityClass();

 FieldResult[] fields() default \{};

 String discriminatorColumn() default "";

}



The _entityClass_ element specifies the class
of the result.

The _fields_ element is used to map the
columns specified in the SELECT list of the query to the properties or
fields of the entity class.

The _discriminatorColumn_ element is used to
specify the column name (or alias) of the column in the SELECT list that
is used to determine the type of the entity instance.

@Target(\{}) @Retention(RUNTIME)

public @interface FieldResult \{

 String name();

 String column();

}



The _name_ element is the name of the
persistent field or property of the class.

The _column_ element specifies the name of
the corresponding column in the SELECT list—i.e., column alias, if
applicable.

@Target(value=\{}) @Retention(RUNTIME)

public @interface ConstructorResult \{

 Class targetClass();

 ColumnResult[] columns();

}

The _targetClass_ element specifies the class
whose constructor is to be invoked.

The _columns_ element specifies the mapping
of columns in the SELECT list to the arguments of the intended
constructor.

@Target(\{}) @Retention(RUNTIME)

public @interface ColumnResult \{

 String name();

 Class type() default void.class;

}



The _name_ element specifies the name of the
column in the SELECT list.

The _type_ element specifies the Java type to
which the column type is to be mapped. If the _type_ element is not
specified, the default JDBC type mapping for the column will be used.

=== References to EntityManager and EntityManagerFactory

image:Per-4.png[image]

These annotations are used to express
dependencies on entity managers and entity manager factories.

==== PersistenceContext Annotation

The _PersistenceContext_ annotation is used
to express a dependency on a container-managed entity manager and its
associated persistence context.

The _name_ element refers to the name by
which the entity manager is to be accessed in the environment
referencing context, and is not needed when dependency injection is
used.

The optional _unitName_ element refers to the
name of the persistence unit. If the _unitName_ element is specified,
the persistence unit for the entity manager that is accessible in JNDI
must have the same name.

The _type_ element specifies whether a
transaction-scoped or extended persistence context is to be used. If the
_type_ element is not specified, a transaction-scoped persistence
context is used.

The _synchronizationType_ element specifies
whether the persistence context is always automatically synchronized
with the current transaction or whether the persistence context must be
explicitly joined to the current transaction by means of the
EntityManager _joinTransaction_ method.

The optional _properties_ element may be used
to specify properties for the container or persistence provider.
Properties defined by this specification must be observed by the
provider. Vendor specific properties may be included in the set of
properties, and are passed to the persistence provider by the container
when the entity manager is created. Properties that are not recognized
by a vendor must be ignored.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

@Repeatable(PersistenceContexts.class)

public @interface PersistenceContext \{

 String name() default "";

 String unitName() default "";

 PersistenceContextType type() default
TRANSACTION;

 SynchronizationType synchronization()
default SYNCHRONIZED;

 PersistenceProperty[] properties() default
\{};

}



public enum PersistenceContextType \{

 TRANSACTION,

 EXTENDED

}



public enum SynchronizationType \{

 SYNCHRONIZED,

 UNSYNCHRONIZED

}



@Target(\{}) @Retention(RUNTIME)

public @interface PersistenceProperty \{

 String name();

 String value();

}



The _PersistenceContexts_ annotation declares
one or more _PersistenceContext_ annotations. It is used to express a
dependency on multiple persistence contextslink:#a19634[98].

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface PersistenceContexts \{

 PersistenceContext[] value();

}

==== [[a13887]]PersistenceUnit Annotation

The _PersistenceUnit_ annotation is used to
express a dependency on an entity manager factory and its associated
persistence unit.

The _name_ element refers to the name by
which the entity manager factory is to be accessed in the environment
referencing context, and is not needed when dependency injection is
used.

The optional _unitName_ element refers to the
name of the persistence unit as defined in the _persistence.xml_ file.
If the _unitName_ element is specified, the persistence unit for the
entity manager factory that is accessible in JNDI must have the same
name.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

@Repeatable(PersistenceUnits.class)

 _public @interface PersistenceUnit \{_

 _String name() default "";_

 _String unitName() default "";_

}



The _PersistenceUnits_ annotation declares
one or more _PersistenceUnit_ annotations. It is used to express a
dependency on multiple persistence unitslink:#a19635[99].

@Target(TYPE) @Retention(RUNTIME)

public @interface PersistenceUnits \{

 PersistenceUnit[] value();

}

=== [[a13903]]Annotations for Type Converter Classes

image:Per-4.png[image]

The _Converter_ annotation specifies that the
annotated class is a converter and defines its scope. A converter class
must be annotated with the _Converter_ annotation or defined in the XML
descriptor as a converter.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface Converter \{

 boolean autoApply() default false;

}

If the _autoApply_ element is specified as
_true_ , the persistence provider must automatically apply the converter
to all mapped attributes of the specified target type for all entities
in the persistence unit except for attributes for which conversion is
overridden by means of the _Convert_ annotation (or XML equivalent). The
_Convert_ annotation is described in section
link:Per.html#a14398[See Convert Annotation].

In determining whether a converter is
applicable to an attribute, the provider must treat primitive types and
wrapper types as equivalent.

Note that Id attributes, version attributes,
relationship attributes, and attributes explicitly annotated as
_Enumerated_ or _Temporal_ (or designated as such via XML) will not be
converted.

If _autoApply_ is _false_ , only those
attributes of the target type for which the _Convert_ annotation (or
corresponding XML element) has been specified will be converted.

Note that if _autoApply_ is _true_ , the
_Convert_ annotation may be used to override or disable auto-apply
conversion on a per-attribute basis.

If there is more than one converter defined
for the same target type, the _Convert_ annotation should be used to
explicitly specify which converter to use.

== [[a13915]]Metadata for Object/Relational Mapping

The object/relational mapping metadata is
part of the application domain model contract. It expresses requirements
and expectations on the part of the application as to the mapping of the
entities and relationships of the application domain to a database.
Queries (and, in particular, SQL queries) written against the database
schema that corresponds to the application domain model are dependent
upon the mappings expressed by means of the object/relational mapping
metadata. The implementation of this specification must assume this
application dependency upon the object/relational mapping metadata and
insure that the semantics and requirements expressed by that mapping are
observed.

The use of object/relational mapping metadata
to control schema generation is specified in section
link:Per.html#a16444[See Object/Relational Metadata Used in
Schema Generation].

=== Annotations for Object/Relational Mapping

image:Per-4.png[image]

These annotations and types are in the
package _javax.persistence_ .

XML metadata may be used as an alternative to
these annotations, or to override or augment annotations, as described
in Chapter link:Per.html#a16944[See XML Object/Relational Mapping
Descriptor].

==== Access Annotation

The _Access_ annotation is used to specify an
access type to be applied to an entity class, mapped superclass, or
embeddable class, or to a specific attribute of such a class.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

public @interface Access \{

 AccessType value();

}



public enum AccessType \{

 FIELD,

 PROPERTY

}



Table link:Per.html#a13935[See Access
Annotation Elements] lists the annotation elements that may be specified
for the _Access_ annotation.

===

image:Per-5.png[image]

[[a13935]]Access Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|AccessType |value
|(Required) The access type to be applied to
the class or attribute. |
|===

==== [[a13942]]AssociationOverride Annotation

The _AssociationOverride_ annotation is used
to override a mapping for an entity relationship.

The _AssociationOverride_ annotation may be
applied to an entity that extends a mapped superclass to override a
relationship mapping defined by the mapped superclass. If the
_AssociationOverride_ annotation is not specified, the association is
mapped the same as in the original mapping. When used to override a
mapping defined by a mapped superclass, the _AssociationOverride_
annotation is applied to the entity class.

The _AssociationOverride_ annotation may be
used to override a relationship mapping from an embeddable within an
entity to another entity when the embeddable is on the owning side of
the relationship. When used to override a relationship mapping defined
by an embeddable class (including an embeddable class embedded within
another embeddable class), the _AssociationOverride_ annotation is
applied to the field or property containing the embeddable.

{empty}When the _AssociationOverride_
annotation is used to override a relationship mapping from an embeddable
class, the _name_ element specifies the referencing relationship field
or property within the embeddable class. To override mappings at
multiple levels of embedding, a dot (".") notation syntax must be used
in the _name_ element to indicate an attribute within an embedded
attribute. The value of each identifier used with the dot notation is
the name of the respective embedded field or property. When the
_AssociationOverride_ annotation is applied to override the mappings of
an embeddable class used as a map value, " _value._ " must be used to
prefix the name of the attribute within the embeddable class that is
being overridden in order to specify it as part of the map
value.link:#a19636[100]

{empty}If the relationship mapping is a
foreign key mapping, the _joinColumns_ element of the
_AssociationOverride_ annotation is used. If the relationship mapping
uses a join table, the _joinTable_ element of the _AssociationOverride_
element must be specified to override the mapping of the join table
and/or its join columns.link:#a19637[101]

The _joinColumns_ element refers to the table
for the class that contains the annotation.

The _foreignKey_ element is used to specify
or control the generation of a foreign key constraint for the columns
corresponding to the _joinColumns_ element when table generation is in
effect. If both this element and the _foreignKey_ element of any of the
_joinColumns_ elements are specified, the behavior is undefined.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

@Repeatable(AssociationOverrides.class)

public @interface AssociationOverride \{

 String name();

 JoinColumn[] joinColumns() default \{};

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

 JoinTable joinTable() default @JoinTable;

}

link:Per.html#a13960[See
AssociationOverride Annotation Elements] lists the annotation elements
that may be specified for the _AssociationOverride_ annotation.

===

image:Per-5.png[image]

[[a13960]]AssociationOverride Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Required) The name of the relationship
property whose mapping is being overridden if property-based access is
being used, or the name of the relationship field if field-based access
is used. |

|JoinColumn[]
|joinColumns |The
join column(s) being mapped to the persistent attribute(s). The
joinColumns element must be specified if a foreign key mapping is used
in the overriding of the mapping of the relationship. The joinColumns
element must not be specified if a join table is used in the overriding
of the mapping of the relationship |

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint
specification for the join columns. This is used only if table
generation is in effect. |Provider’s default

|JoinTable
|joinTable |The
join table that maps the relationship. The joinTable element must be
specified if a join table is used in the overriding of the mapping of
the relationship. The joinTable element must not be specified if a
foreign key mapping is used in the overriding of the mapping of the
relationship. |.
|===

 _Example 1:_

@MappedSuperclass

public class Employee \{



 @Id protected Integer id;

 @Version protected Integer version;

 @ManyToOne

 protected Address address;



 public Integer getId() \{ ... }

 public void setId(Integer id) \{ ... }

 public Address getAddress() \{ ... }

 public void setAddress(Address address) \{
... }

}



@Entity

@AssociationOverride(name="address",

 joinColumns=@JoinColumn(name="ADDR_ID"))

public class PartTimeEmployee extends
Employee \{

 // address field mapping overridden to
ADDR_ID foreign key

 @Column(name="WAGE")

 protected Float hourlyWage;

 public Float getHourlyWage() \{ ... }

 public void setHourlyWage(Float wage) \{ ...
}

}



 _Example 2:_ Overriding of the mapping for
the _phoneNumbers_ relationship defined in the _ContactInfo_ embeddable
class.

@Entity

public class Employee \{

 @Id int id;

 @AssociationOverride(

 name="phoneNumbers",

 joinTable=@JoinTable(

 name="EMPPHONES",

 joinColumns=@JoinColumn(name="EMP"),

 inverseJoinColumns=@JoinColumn(name="PHONE")

 )

 )

 @Embedded ContactInfo contactInfo;

 ...

}



@Embeddable

public class ContactInfo \{

 @ManyToOne Address address; //
Unidirectional

 @ManyToMany(targetEntity=PhoneNumber.class)
List phoneNumbers;

}



@Entity

public class PhoneNumber \{

 @Id int number;


@ManyToMany(mappedBy="contactInfo.phoneNumbers")

 Collection<Employee> employees;

}

==== AssociationOverrides Annotation

The mappings of multiple relationship
properties or fields may be overridden. The _AssociationOverrides_
annotation can be used for this purpose.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

public @interface AssociationOverrides \{

 AssociationOverride[] value();

}



Table link:Per.html#a14040[See
AssociationOverrides Annotation Elements] lists the annotation elements
that may be specified for the _AssociationOverrides_ annotation.

===

image:Per-5.png[image]

[[a14040]]AssociationOverrides Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|AssociationOverride[]
|value |(Required)
The association override mappings that are to be applied to the
relationship field or property. |
|===

 _Example:_

@MappedSuperclass

public class Employee \{



 @Id protected Integer id;

 @Version protected Integer version;

 @ManyToOne protected Address address;

 @OneToOne protected Locker locker;



 public Integer getId() \{ ... }

 public void setId(Integer id) \{ ... }

 public Address getAddress() \{ ... }

 public void setAddress(Address address) \{
... }

 public Locker getLocker() \{ ... }

 public void setLocker(Locker locker) \{ ...
}



}



@Entity

@AssociationOverrides(\{

 @AssociationOverride(name="address",

 joinColumns=@JoinColumn("ADDR_ID")),

 @AssociationOverride(name="locker",

 joinColumns=@JoinColumn("LCKR_ID"))})



public PartTimeEmployee \{ ... }





Alternatively:

@Entity

@AssociationOverride(name="address",

 joinColumns=@JoinColumn("ADDR_ID"))

@AssociationOverride(name="locker",

 joinColumns=@JoinColumn("LCKR_ID"))



public PartTimeEmployee \{ ... }



==== [[a14084]]AttributeOverride Annotation

The _AttributeOverride_ annotation is used to
override the mapping of a _Basic_ (whether explicit or default) property
or field or _Id_ property or field.

The _AttributeOverride_ annotation may be
applied to an entity that extends a mapped superclass or to an embedded
field or property to override a _Basic_ mapping or _Id_ mapping defined
by the mapped superclass or embeddable class (or embeddable class of one
of its attributes).

The _AttributeOverride_ annotation may be
applied to an element collection containing instances of an embeddable
class or to a map collection whose key and/or value is an embeddable
class. When the _AttributeOverride_ annotation is applied to a map, "
_key._ " or " _value._ " must be used to prefix the name of the
attribute that is being overridden in order to specify it as part of the
map key or map value.

To override mappings at multiple levels of
embedding, a dot (".") notation form must be used in the _name_ element
to indicate an attribute within an embedded attribute. The value of each
identifier used with the dot notation is the name of the respective
embedded field or property.

If the _AttributeOverride_ annotation is not
specified, the column is mapped the same as in the original mapping.

link:Per.html#a14100[See
AttributeOverride Annotation Elements] lists the annotation elements
that may be specified for the _AttributeOverride_ annotation.

The _column_ element refers to the table for
the class that contains the annotation.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

@Repeatable(AttributeOverrides.class)

public @interface AttributeOverride \{

 String name();

 Column column();

}



===

image:Per-5.png[image]

[[a14100]]AttributeOverride Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Required) The name of the property whose
mapping is being overridden if property-based access is being used, or
the name of the field if field-based access is used.
|

|Column |column
|(Required) The column that is being mapped
to the persistent attribute. The mapping type will remain the same as is
defined in the embeddable class or mapped superclass.
|
|===

 _Example 1:_

@MappedSuperclass

public class Employee \{



 @Id protected Integer id;

 @Version protected Integer version;

 protected String address;



 public Integer getId() \{ ... }

 public void setId(Integer id) \{ ... }

 public String getAddress() \{ ... }

 public void setAddress(String address) \{
... }

}



@Entity

@AttributeOverride(name="address",
column=@Column(name="ADDR"))

public class PartTimeEmployee extends
Employee \{

 // address field mapping overridden to ADDR

 protected Float wage();

 public Float getHourlyWage() \{ ... }

 public void setHourlyWage(Float wage) \{ ...
}

}

 _Example 2:_

@Embeddable public class Address \{

 protected String street;

 protected String city;

 protected String state;

 @Embedded protected Zipcode zipcode;

}



@Embeddable public class Zipcode \{

 protected String zip;

 protected String plusFour;

}





@Entity public class Customer \{

 @Id protected Integer id;

 protected String name;



 @AttributeOverride(name="state",

 column=@Column(name="ADDR_STATE"))

 @AttributeOverride(name="zipcode.zip",

 column= @Column(name="ADDR_ZIP"))

 @Embedded protected Address address;

 ...

}



 _Example 3:_

@Entity

public class PropertyRecord \{

 @EmbeddedId PropertyOwner owner;



 @AttributeOverrides(name="key.street",

 column=@Column(name="STREET_NAME"))

 @AttributeOverride(name="value.size",

 column=@Column(name="SQUARE_FEET"))

 @AttributeOverride(name="value.tax",

 column=@Column(name="ASSESSMENT"))

 @ElementCollection

 Map<Address, PropertyInfo> parcels;

}



@Embeddable public class PropertyInfo \{

 Integer parcelNumber;

 Integer size;

 BigDecimal tax;

}

==== [[a14178]]AttributeOverrides Annotation

The mappings of multiple properties or fields
may be overridden. The _AttributeOverrides_ annotation can be used for
this purpose.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

public @interface AttributeOverrides \{

 AttributeOverride[] value();

}



Table link:Per.html#a14187[See
AttributeOverrides Annotation Elements] lists the annotation elements
that may be specified for the _AttributeOverrides_ annotation.

===

image:Per-5.png[image]

[[a14187]]AttributeOverrides Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|AttributeOverride[]
|value |(Required)
The AttributeOverride mappings that are to be applied to the field or
property. |
|===



 _Example:_

@Embedded

@AttributeOverrides(\{

 @AttributeOverride(name="startDate",

 column=@Column(name="EMP_START")),

 @AttributeOverride(name="endDate",

 column=@Column(name="EMP_END"))

})

public EmploymentPeriod getEmploymentPeriod()
\{ ... }



==== [[a14205]]Basic Annotation

The _Basic_ annotation is the simplest type
of mapping to a database column. The _Basic_ annotation can be applied
to a persistent property or instance variable of any of the following
types: Java primitive types, wrappers of the primitive types,
_java.lang.String_ , _java.math.BigInteger_ , _java.math.BigDecimal_ ,
_java.util.Date_ , _java.util.Calendar_ , _java.sql.Date_ ,
_java.sql.Time_ , _java.sql.Timestamp_ , _java.time.LocalDate_ ,
_java.time.LocalTime_ , _java.time.LocalDateTime_ ,
_java.time.OffsetTime_ , _java.time.OffsetDateTime_ , _byte[]_ ,
_Byte[]_ , _char[]_ , _Character[]_ , enums, and any other type that
implements _Serializable_ .link:#a19638[102] As described in
Section link:Per.html#a511[See Mapping Defaults for
Non-Relationship Fields or Properties], the use of the _Basic_
annotation is optional for persistent fields and properties of these
types. If the _Basic_ annotation is not specified for such a field or
property, the default values of the _Basic_ annotation will apply.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Basic \{

 FetchType fetch() default EAGER;

 boolean optional() default true;

}

link:Per.html#a14218[See Basic
Annotation Elements] lists the annotation elements that may be specified
for the _Basic_ annotation and their default values.

The _FetchType_ enum defines strategies for
fetching data from the database:

public enum FetchType \{ LAZY, EAGER };

The _EAGER_ strategy is a requirement on the
persistence provider runtime that data must be eagerly fetched. The
_LAZY_ strategy is a _hint_ to the persistence provider runtime that
data should be fetched lazily when it is first accessed. The
implementation is permitted to eagerly fetch data for which the _LAZY_
strategy hint has been specified. In particular, lazy fetching might
only be available for _Basic_ mappings for which property-based access
is used.

The _optional_ element is a hint as to
whether the value of the field or property may be null. It is
disregarded for primitive types.

===

image:Per-5.png[image]

[[a14218]]Basic Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|FetchType |fetch
|(Optional) Whether the value of the field or
property should be lazily loaded or must be eagerly fetched. The EAGER
strategy is a requirement on the persistence provider runtime that the
value must be eagerly fetched. The LAZY strategy is a hint to the
persistence provider runtime. |EAGER

|boolean |optional
|(Optional) Whether the value of the field or
property may be null. This is a hint and is disregarded for primitive
types; it may be used in schema generation.
|true
|===

Example _1:_

@Basic

protected String name;

Example 2 _:_

@Basic(fetch=LAZY)

protected String getName() \{ return name; }

==== Cacheable Annotation

The _Cacheable_ annotation
specifies whether an entity should be cached if caching is enabled when
the value of the _persistence.xml_ _shared-cache-mode_ element is
_ENABLE_SELECTIVE_ or _DISABLE_SELECTIVE_ . The value of the _Cacheable_
annotation is inherited by subclasses; it can be overridden by
specifying _Cacheable_ on a subclass.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface Cacheable \{

 boolean value() default true;

}



 _Cacheable(false)_ means that the entity and
its state must not be cached by the provider.

If the _shared-cache-mode_ element is not
specified in the _persistence.xml_ file and the
_javax.persistence.sharedCache.mode_ property is not specified when the
entity manager factory for the persistence unit is created, the
semantics of the _Cacheable_ annotation are undefined.

===

image:Per-5.png[image]

Cacheable Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|boolean |value
|(Optional) Whether or not the entity should
be cached. |true
|===

==== [[a14250]]CollectionTable Annotation

The _CollectionTable_ annotation is used in
the mapping of collections of basic or embeddable types. The
_CollectionTable_ annotation specifies the table that is used for the
mapping of the collection and is specified on the collection-valued
field or property.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface CollectionTable \{

 String name() default "";

 String catalog() default "";

 String schema() default "";

 JoinColumn[] joinColumns() default \{};

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

}

By default, the columns of the collection
table that correspond to the embeddable class or basic type are derived
from the attributes of the embeddable class or from the basic type
according to the default values of the _Column_ annotation, as described
in Section link:Per.html#a14330[See Column Annotation]. In the
case of a basic type, the column name is derived from the name of the
collection-valued field or property. In the case of an embeddable class,
the column names are derived from the field or property names of the
embeddable class.

To override the default properties of the
column used for a basic type, the _Column_ annotation is used on the
collection-valued attribute in addition to the _ElementCollection_
annotation. The value of the _table_ element of the _Column_ annotation
defaults to the name of the collection table.

To override these defaults for an embeddable
class, the _AttributeOverride_ and/or _AttributeOverrides_ annotations
must be used in addition to the _ElementCollection_ annotation. The
value of the _table_ element of the _Column_ annotation used in the
_AttributeOverride_ annotation defaults to the name of the collection
table. If the embeddable class contains references to other entities,
the default values for the columns corresponding to those references may
be overridden by means of the _AssociationOverride_ and/or
_AssociationOverrides_ annotations.

The _foreignKey_ element is used to specify
or control the generation of a foreign key constraint for the columns
corresponding to the _joinColumns_ element when table generation is in
effect. If both this element and the _foreignKey_ element of any of the
_joinColumns_ elements are specified, the behavior is undefined. If no
_foreignKey_ annotation element is specified in either location, the
persistence provider's default foreign key strategy will apply.

If the _CollectionTable_ annotation is
missing, the default values of the _CollectionTable_ annotation elements
apply.

link:Per.html#a14269[See
CollectionTable Annotation Elements] lists the annotation elements that
may be specified for the _CollectionTable_ annotation and their default
values.

===

image:Per-5.png[image]

[[a14269]]CollectionTable Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the collection table.
|The concatenation of the name of the
containing entity and the name of the collection attribute, separated by
an underscore.

|String |catalog
|(Optional) The catalog of the table.
|Default catalog.

|String |schema
|(Optional) The schema of the table.
|Default schema for user.

|JoinColumn[]
|joinColumns
|(Optional) The foreign key columns of the
collection table which reference the primary table of the entity.
|(Default only applies if a single join
column is used.) The same defaults as for JoinColumn (i.e., the
concatenation of the following: the name of the entity; "_"; the name of
the referenced primary key column.) However, if there is more than one
join column, a JoinColumn annotation must be specified for each join
column using the JoinColumns annotation. Both the name and the
referencedColumnName elements must be specified in each such JoinColumn
annotation.

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint
specification for the join columns. This is used only if table
generation is in effect. |Provider’s default

|UniqueConstraint[]
|uniqueConstraints
|(Optional) Unique constraints that are to be
placed on the table. These are only used if table generation is in
effect. |No additional constraints

|Index[] |indexes
|(Optional) Indexes for the table. These are
only used if table generation is in effect.
|No additional indexes
|===

Example _:_

 _@Embeddable public class Address \{_

 _protected String street;_

 _protected String city;_

 _protected String state;_

 _..._

 _}_

 __

 _@Entity public class Person \{_

 _@Id protected String ssn;_

 _protected String name;_

 _protected Address home;_

 _..._

 _@ElementCollection // use default table
(PERSON_NICKNAMES)_

 _@Column(name="name", length=50)_

 _protected Set<String> nickNames = new
HashSet();_

 _..._

 _}_

 __

 _@Entity public class WealthyPerson extends
Person \{_

 _@ElementCollection_

 _@CollectionTable(name="HOMES") // use
default join column name_

 _@AttributeOverrides(\{_

 _@AttributeOverride(name="street",_

 _column=@Column(name="HOME_STREET")),_

 _@AttributeOverride(name="city",_

 _column=@Column(name="HOME_CITY")),_

 _@AttributeOverride(name="state",_

 _column=@Column(name="HOME_STATE"))_

 _})_

 _protected Set<Address> vacationHomes = new
HashSet();_

 _..._

 _}_

==== [[a14330]]Column Annotation

The _Column_ annotation is used to specify a
mapped column for a persistent property or field.

link:Per.html#a14349[See Column
Annotation Elements] lists the annotation elements that may be specified
for the _Column_ annotation and their default values.

If no _Column_ annotation is specified, the
default values in link:Per.html#a14349[See Column Annotation
Elements] apply.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Column \{

 String name() default "";

 boolean unique() default false;

 boolean nullable() default true;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 String table() default "";

 int length() default 255;

 int precision() default 0; // decimal
precision

 int scale() default 0; // decimal scale

}



===

image:Per-5.png[image]

[[a14349]]Column Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the column.
|The property or field name.

|boolean |unique
|(Optional) Whether the column is a unique
key. This is a shortcut for the UniqueConstraint annotation at the table
level and is useful for when the unique key constraint corresponds to
only a single column. This constraint applies in addition to any
constraint entailed by primary key mapping and to constraints specified
at the table level. |false

|boolean |nullable
|(Optional) Whether the database column is
nullable. |true

|boolean
|insertable
|(Optional) Whether the column is included in
SQL INSERT statements generated by the persistence provider.
|true

|boolean
|updatable
|(Optional) Whether the column is included in
SQL UPDATE statements generated by the persistence provider.
|true

|String
|columnDefinition
|(Optional) The SQL fragment that is used
when generating the DDL for the column.
|Generated SQL to create a column of the
inferred type.

|String |table
|(Optional) The name of the table that
contains the column. If absent the column is assumed to be in the
primary table for the mapped object. |Column
is in primary table.

|int |length
|(Optional) The column length. (Applies only
if a string-valued column is used.) |255

|int |precision
|(Optional) The precision for a decimal
(exact numeric) column. (Applies only if a decimal column is used.)
|0 (Value must be set by developer.)

|int |scale
|(Optional) The scale for a decimal (exact
numeric) column. (Applies only if a decimal column is used.)
|0
|===

 _Example 1:_

@Column(name="DESC", nullable=false,
length=512)

public String getDescription() \{ return
description; }

 _Example 2:_

@Column(name="DESC",

 columnDefinition="CLOB NOT NULL",

 table="EMP_DETAIL")

@Lob

public String getDescription() \{ return
description; }

 _Example 3:_

@Column(name="ORDER_COST", updatable=false,
precision=12, scale=2)

public BigDecimal getCost() \{ return cost; }

==== [[a14398]]Convert Annotation

The _Convert_ annotation is applied directly
to an attribute of an entity, mapped superclass, or embeddable class to
specify conversion of a Basic attribute or to override the use of a
converter that has been specified as _autoApply=true_ . When persistent
properties are used, the _Convert_ annotation is applied to the getter
method. It is not necessary to use the _Basic_ annotation or
corresponding XML element to specify the basic type

The _Convert_ annotation may be applied to an
entity that extends a mapped superclass to specify or override the
conversion mapping for an inherited basic attribute.

@Target(\{METHOD, FIELD, TYPE})
@Retention(RUNTIME)

@Repeatable(Converts.class)

public @interface Convert \{

 Class converter() default void.class;

 String attributeName() default "";

 boolean disableConversion() default false;

}

Table link:Per.html#a14410[See Convert
Annotation Elements] lists the annotation elements that may be specified
for the _Convert_ annotation.

===

image:Per-5.png[image]

[[a14410]]Convert Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Class |converter
|(Optional) The converter to be applied.
|No converter

|String
|attributeName
|(Optional) The name of the attribute to
convert. Must be specified unless the Convert annotation is applied to
an attribute of basic type or to an element collection of basic type.
Must not be specified otherwise. |The basic
attribute or basic element collection attribute to which the annotation
is applied

|boolean
|disableConversion
|(Optional) Whether conversion of the
attribute is to be disabled. |false
|===

The _converter_ element is used to specify
the converter that is to be applied. If an autoApply converter is
applicable to the given field or property, the converter specified by
the _converter_ element will be applied instead.

The _disableConversion_ element specifies
that any applicable autoApply converter must not be applied.

The behavior is undefined if neither the
_converter_ element nor the _disableConversion_ element has been
specified.

The _Convert_ annotation should not be used
to specify conversion of the following: Id attributes (including the
attributes of embedded ids and derived identities), version attributes,
relationship attributes, and attributes explicitly annotated (or
designated via XML) as _Enumerated_ or _Temporal_ . Applications that
specify such conversions will not be portable.

The _Convert_ annotation may be applied to a
basic attribute or to an element collection of basic type (in which case
the converter is applied to the elements of the collection). In these
cases, the _attributeName_ element must not be specified.

The _Convert_ annotation may be applied to an
embedded attribute or to a map collection attribute whose key or value
is of embeddable type (in which case the converter is applied to the
specified attribute of the embeddable instances contained in the
collection). In these cases, the _attributeName_ element must be
specified.

To override conversion mappings at multiple
levels of embedding, a dot ( _"."_ ) notation form must be used in the
_attributeName_ element to indicate an attribute within an embedded
attribute. The value of each identifier used with the dot notation is
the name of the respective embedded field or property.

When the _Convert_ annotation is applied to a
map containing instances of embeddable classes, the _attributeName_
element must be specified, and _"key."_ or _"value."_ must be used to
prefix the name of the attribute that is to be converted in order to
specify it as part of the map key or map value.

When the _Convert_ annotation is applied to a
map to specify conversion of a map key of basic type, _"key"_ must be
used as the value of the _attributeName_ element to specify that it is
the map key that is to be converted.

The _Convert_ annotation may be applied to an
entity class that extends a mapped superclass to specify or override a
conversion mapping for an inherited basic or embedded attribute.

 _Example 1:_ Convert a basic attribute

@Converter

public class BooleanToIntegerConverter

implements AttributeConverter<Boolean,
Integer> \{ ... }



@Entity

public class Employee \{

 @Id long id;




@Convert(converter=BooleanToIntegerConverter.class)

 boolean fullTime;

 ...

}

 _Example 2:_ Auto-apply conversion of a
basic attribute

@Converter(autoApply=true)

public class EmployeeDateConverter

implements
AttributeConverter<com.acme.EmployeeDate, java.sql.Date> \{ ... }



@Entity

public class Employee \{

 @Id long id;

 ...

 // EmployeeDateConverter is applied
automatically

 EmployeeDate startDate;

}

 _Example 3:_ Disable conversion in the
presence of an auto-apply converter

@Convert(disableConversion=true)

EmployeeDate lastReview;

 _Example 4:_ Apply a converter to an element
collection of basic type

@ElementCollection

// applies to each element in the collection

@Convert(converter=NameConverter.class)

List<String> names;

 _Example 5:_ Apply a converter to an element
collection that is a map of basic values. The converter is applied to
the map _value_ .

@ElementCollection

@Convert(converter=EmployeeNameConverter.class)

Map<String, String> responsibilities;

 _Example 6:_ Apply a converter to a map key
of basic type

@OneToMany

@Convert(converter=ResponsibilityCodeConverter.class,

 attributeName="key")

Map<String, Employee> responsibilities;

 _Example 7:_ Apply a converter to an
embeddable attribute

@Embedded

@Convert(converter=CountryConverter.class,

 attributeName="country")

Address address;

 _Example 8:_ Apply a converter to a nested
embeddable attribute

@Embedded

@Convert(converter=CityConverter.class,

 attributeName="region.city")

Address address;



 _Example 9:_ Apply a converter to a nested
attribute of an embeddable that is a map key of an element collection

@Entity public class PropertyRecord \{

 ...

 @Convert(converter=CityConverter.class,

 attributeName="key.region.city")

 @ElementCollection

 Map<Address, PropertyInfo> parcels;

}

 _Example 10:_ Apply a converter to an
embeddable that is a map key for a relationship

@OneToMany

@Convert(converter=ResponsibilityCodeConverter.class,

 attributeName="key.jobType")

Map<Responsibility, Employee>
responsibilities;

 _Example 11:_ Override conversion mappings
for attributes inherited from a mapped superclass

@Entity

@Convert(converter=DateConverter.class,
attributeName="startDate")

@Convert(converter=DateConverter.class,
attributeName="endDate")

public class FullTimeEmployee extends
GenericEmployee \{ ... }

==== Converts Annotation

The _Converts_ annotation can be used to
group _Convert_ annotations. Multiple converters must not be applied to
the same basic attribute.

@Target(\{METHOD, FIELD, TYPE})

@Retention(RUNTIME)

public @interface Converts \{

 Convert[] value();

}

Table link:Per.html#a14515[See
Converts Annotation Elements] lists the annotation elements that may be
specified for the _Converts_ annotation.

===

image:Per-5.png[image]

[[a14515]]Converts Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Convert[] |value
|(Required) The Convert mappings that are to
be applied to the entity or the field or property.
|
|===

 _Example:_ Multiple converters applied to an
embedded attribute

@Embedded

@Converts(\{

 @Convert(converter=CountryConverter.class,

 attributeName="country"),

 @Convert(converter=CityConverter.class,

 attributeName="region.city")})

Address address;

==== [[a14530]]DiscriminatorColumn Annotation

For the SINGLE_TABLE mapping strategy, and
typically also for the JOINED strategy, the persistence provider will
use a type discriminator column. The _DiscriminatorColumn_ annotation is
used to define the discriminator column for the SINGLE_TABLE and JOINED
inheritance mapping strategies.

{empty}The strategy and the discriminator
column are only specified in the root of an entity class hierarchy or
subhierarchy in which a different inheritance strategy is
applied.link:#a19639[103]

The _DiscriminatorColumn_ annotation can be
specified on an entity class (including on an abstract entity class).

If the _DiscriminatorColumn_ annotation is
missing, and a discriminator column is required, the name of the
discriminator column defaults to "DTYPE" and the discriminator type to
STRING.

link:Per.html#a14548[See
DiscriminatorColumn Annotation Elements] lists the annotation elements
that may be specified for the _DiscriminatorColumn_ annotation and their
default values.

The supported discriminator types are defined
by the _DiscriminatorType_ enum:

public enum DiscriminatorType \{ STRING,
CHAR, INTEGER };

The type of the discriminator column, if
specified in the optional _columnDefinition_ element, must be consistent
with the discriminator type.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface DiscriminatorColumn \{

 String name() default "DTYPE";

 DiscriminatorType discriminatorType()
default STRING;

 String columnDefinition() default "";

 int length() default 31;

}



===

image:Per-5.png[image]

[[a14548]]DiscriminatorColumn Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of column to be used for
the discriminator. |“DTYPE”

|DiscriminatorType
|discriminatorType
|(Optional) The type of object/column to use
as a class discriminator.
|DiscriminatorType.STRING

|String
|columnDefinition
|(Optional) The SQL fragment that is used
when generating the DDL for the discriminator column.
|Provider-generated SQL to create a column of
the specified discriminator type.

|int |length
|(Optional) The column length for
String-based discriminator types. Ignored for other discriminator types.
|31
|===

 _Example:_

@Entity

@Table(name="CUST")

@DiscriminatorColumn(name="DISC",
discriminatorType=STRING,length=20)

public class Customer \{ ... }



@Entity

public class ValuedCustomer extends Customer
\{ ... }



==== DiscriminatorValue Annotation

The _DiscriminatorValue_ annotation is used
to specify the value of the discriminator column for entities of the
given type. The _DiscriminatorValue_ annotation can only be specified on
a concrete entity class. If the _DiscriminatorValue_ annotation is not
specified and a discriminator column is used, a provider-specific
function will be used to generate a value representing the entity type.

The inheritance strategy and the
discriminator column are only specified in the root of an entity class
hierarchy or subhierarchy in which a different inheritance strategy is
applied. The discriminator value, if not defaulted, should be specified
for each entity class in the hierarchy.

link:Per.html#a14585[See
DiscriminatorValue Annotation Elements] lists the annotation elements
that may be specified for the _DiscriminatorValue_ annotation and their
default values.

The discriminator value must be consistent in
type with the discriminator type of the specified or defaulted
discriminator column. If the discriminator type is an integer, the value
specified must be able to be converted to an integer value (e.g., " _1_
").

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface DiscriminatorValue \{

 String value();

}

===

image:Per-5.png[image]

[[a14585]]DiscriminatorValue Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |value
|(Optional) The value that indicates that the
row is an entity of the annotated entity type.
|If the DiscriminatorValue annotation is not
specified, a provider-specific function to generate a value representing
the entity type is used for the value of the discriminator column. If
the DiscriminatorType is STRING, the discriminator value default is the
entity name.
|===

 _Example:_

@Entity

@Table(name="CUST")

@Inheritance(strategy=SINGLE_TABLE)

@DiscriminatorColumn(name="DISC",
discriminatorType=STRING,length=20)

@DiscriminatorValue("CUSTOMER")

public class Customer \{ ... }



@Entity

@DiscriminatorValue("VCUSTOMER")

public class ValuedCustomer extends Customer
\{ ... }



==== ElementCollection Annotation

{empty}The _ElementCollection_ annotation
defines a collection of instances of a basic type or embeddable class.
The _ElementCollection_ annotation (or equivalent XML element) must be
specified if the collection is to be mapped by means of a collection
table.link:#a19640[104]

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface ElementCollection \{

 Class targetClass() default void.class;

 FetchType fetch() default LAZY;

}



Table link:Per.html#a14614[See
ElementCollection Annotation Elements] lists the annotation elements
that may be specified for the _ElementCollection_ annotation and their
default values.

===

image:Per-5.png[image]

[[a14614]]ElementCollection Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Class
|targetClass
|(Optional) The basic or embeddable class
that is the element type of the collection. Optional only if the
collection field or property is defined using Java generics. Must be
specified otherwise. |The parameterized type
of the collection when defined using generics.

|FetchType |fetch
| (Optional) Whether the collection should be
lazily loaded or must be eagerly fetched. The EAGER strategy is a
requirement on the persistence provider runtime that the collection
elements must be eagerly fetched. The LAZY strategy is a hint to the
persistence provider runtime. |LAZY
|===

 _Example:_

@Entity public class Person \{

 @Id protected String ssn;

 protected String name;



 @ElementCollection

 protected Set<String> nickNames = new
HashSet();

 ...

}

==== [[a14634]]Embeddable Annotation

The _Embeddable_ annotation is used to
specify a class whose instances are stored as an intrinsic part of an
owning entity and share the identity of the entity.

@Documented @Target(\{TYPE})
@Retention(RUNTIME)

public @interface Embeddable \{

}



 _Example 1:_

@Embeddable

public class EmploymentPeriod \{

 @Temporal(DATE) java.util.Date startDate;

 @Temporal(DATE) java.util.Date endDate;

 ...

}

 _Example 2:_

@Embeddable public class PhoneNumber \{

 protected String areaCode;

 protected String localNumber;

 @ManyToOne PhoneServiceProvider provider;

 ...

}



@Entity public class PhoneServiceProvider \{

 @Id protected String name;

 ...

}



 _Example 3:_

@Embeddable public class Address \{

 protected String street;

 protected String city;

 protected String state;

 @Embedded protected Zipcode zipcode;

}



@Embeddable public class Zipcode \{

 protected String zip;

 protected String plusFour;

}

==== [[a14672]]Embedded Annotation

{empty}The _Embedded_ annotation is used to
specify a persistent field or property of an entity or embeddable class
whose value is an instance of an embeddable
class.link:#a19641[105] Each of the persistent properties or
fields of the embedded object is mapped to the database table for the
entity or embeddable class. The embeddable class must be annotated as
_Embeddable_ .link:#a19642[106]

The _AttributeOverride_ ,
_AttributeOverrides_ , _AssociationOverride_ , and
_AssociationOverrides_ annotations may be used to override mappings
declared or defaulted by the embeddable class.

Implementations are not required to support
embedded objects that are mapped across more than one table (e.g., split
across primary and secondary tables or multiple secondary tables).

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Embedded \{}

 _Example:_

@Embedded

@AttributeOverrides(\{

 @AttributeOverride(name="startDate",

 column=@Column(name="EMP_START")),

 @AttributeOverride(name="endDate",

 column=@Column(name="EMP_END"))

})

public EmploymentPeriod getEmploymentPeriod()
\{ ... }

==== [[a14687]]EmbeddedId Annotation

The _EmbeddedId_ annotation is applied to a
persistent field or property of an entity class or mapped superclass to
denote a composite primary key that is an embeddable class. The
embeddable class must be annotated as _Embeddable_
.link:#a19643[107] Relationship mappings defined within an
embedded id class are not supported.

There must be only one _EmbeddedId_
annotation and no _Id_ annotation when the _EmbeddedId_ annotation is
used.

The _AttributeOverride_ annotation may be
used to override the column mappings declared within the embeddable
class.

The _MapsId_ annotation may be used in
conjunction with the _EmbeddedId_ annotation to specify a derived
primary key. See Sections link:Per.html#a149[See Primary Keys
Corresponding to Derived Identities] and link:Per.html#a15583[See
MapKeyTemporal Annotation].

If the entity has a derived primary key, the
_AttributeOverride_ annotation may only be used to override those
attributes of the embedded id that do not correspond to the relationship
to the parent entity.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface EmbeddedId \{}

 _Example 1:_

@Entity public class Employee \{



 @EmbeddedId protected EmployeePK empPK;

 String name;

 @ManyToOne Set<Department> dept;

 ...

}

 _Example 2:_

@Embeddable

public class DependentId \{

 String name;

 EmployeeId empPK; // corresponds to PK type
of Employee

}



@Entity

public class Dependent \{

 // default column name for "name" attribute
is overridden

 @AttributeOverride(name="name",
@Column(name="dep_name"))

 @EmbeddedId DependentId id;

 ...

 @MapsId("empPK")

 @ManyToOne Employee emp;

}

==== [[a14719]]Enumerated Annotation

An _Enumerated_ annotation specifies that a
persistent property or field should be persisted as a enumerated type.
The _Enumerated_ annotation may be used in conjunction with the _Basic_
annotation. The _Enumerated_ annotation may be used in conjunction with
the _ElementCollectionlink:#a19644[108]_ annotation when the
element collection value is of basic type.

An enum can be mapped as either a string or
an integerlink:#a19645[109]. The _EnumType_ enum defines the
mapping for enumerated types.

public enum EnumType \{

 ORDINAL,

 STRING

}

If the enumerated type is not specified or
the _Enumerated_ annotation is not used, the enumerated type is assumed
to be _ORDINAL_ unless a converter is being applied.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Enumerated \{

 EnumType value() default ORDINAL;

}

link:Per.html#a14733[See Enumerated
Annotation Elements] lists the annotation elements that may be specified
for the _Enumerated_ annotation and their default values.

===

image:Per-5.png[image]

[[a14733]]Enumerated Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|EnumType |value
|(Optional) The type used in mapping an enum
type. |ORDINAL
|===

 _Example:_

public enum EmployeeStatus \{FULL_TIME,
PART_TIME, CONTRACT}



public enum SalaryRate \{JUNIOR, SENIOR,
MANAGER, EXECUTIVE}

 __

@Entity public class Employee \{

 ...

 public EmployeeStatus getStatus() \{...}



 @Enumerated(STRING)

 public SalaryRate getPayScale() \{...}

 ...

}

If the status property is mapped to a column
of integer type, and the payscale property to a column of varchar type,
an instance that has a status of _PART_TIME_ and a pay rate of _JUNIOR_
will be stored with _STATUS_ set to 1 and _PAYSCALE_ set to _"JUNIOR"_ .

==== [[a14754]]ForeignKey Annotation

The _ForeignKey_ annotation is used to
specify the handling of foreign key constraints when schema generation
is in effect. If this annotation is not specified, the persistence
provider’s default foreign key strategy will be used.

@Target(\{}) @Retention(RUNTIME)

public @interface ForeignKey \{

 String name() default "";

 ConstraintMode value() default CONSTRAINT;

 String foreignKeyDefinition() default "";

}

The _name_ element specifies a name for the
foreign key constraint.

The _ConstraintMode_ enum is used to control
the application of constraints.

public enum ConstraintMode \{CONSTRAINT,
NO_CONSTRAINT, PROVIDER_DEFAULT}.



The enum values have the following semantics:
A value of _CONSTRAINT_ will cause the persistence provider to generate
a foreign key constraint. A value of _NO_CONSTRAINT_ will result in no
constraint being generated. A value of _PROVIDER_DEFAULT_ will result in
the provider's default behavior (which may or may not result in the
generation of a constraint for any given join column or set of join
columns).

The syntax used in the _foreignKeyDefinition_
element should follow the SQL syntax used by the target database for
foreign key constraints. For example, this may be similar to the
following:

FOREIGN KEY ( <COLUMN expression> \{, <COLUMN
expression>}... )

REFERENCES <TABLE identifier> [

{empty} ( <COLUMN expression> \{, <COLUMN
expression>}... ) ]

{empty}[ ON UPDATE <referential action> ]

{empty}[ ON DELETE <referential action> ]

If the _ForeignKey_ annotation is specified
with a _ConstraintMode_ value of _CONSTRAINT_ , but the
_foreignKeyDefinition_ element is not specified, the provider will
generate a foreign key constraint whose update and delete actions it
determines most appropriate for the join column(s) to which the foreign
key constraint is applied

link:Per.html#a14776[See ForeignKey
Annotation Elements] lists the annotation elements that may be specified
for the _ForeignKey_ annotation.

===

image:Per-5.png[image]

[[a14776]]ForeignKey Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the foreign key
constraint. |A provider-generated name.

|ConstraintMode
|value |(Optional)
Whether to generate a constraint. |CONSTRAINT

|String
|foreignKeyDefinition
|(Optional) The foreign key constraint
definition. |Provider-default. If the value
of the ConstraintMode element is NO_CONSTRAINT, the provider must not
generate a foreign key constraint.
|===

==== [[a14790]]GeneratedValue Annotation

The _GeneratedValue_ annotation provides for
the specification of generation strategies for the values of primary
keys. The _GeneratedValue_ annotation may be applied to a primary key
property or field of an entity or mapped superclass in conjunction with
the _Id_ annotation. link:#a19646[110] The use of the
_GeneratedValue_ annotation is only required to be supported for simple
primary keys. Use of the _GeneratedValue_ annotation is not supported
for derived primary keys.

link:Per.html#a14806[See
GeneratedValue Annotation Elements] lists the annotation elements that
may be specified for the _GeneratedValue_ annotation and their default
values.

The types of primary key generation are
defined by the _GenerationType_ enum:

public enum GenerationType \{ TABLE,
SEQUENCE, IDENTITY, AUTO };

The _TABLE_ generator type value indicates
that the persistence provider must assign primary keys for the entity
using an underlying database table to ensure uniqueness.

{empty}The _SEQUENCE_ and _IDENTITY_ values
specify the use of a database sequence or identity column,
respectively.link:#a19647[111]

The further specification of table generators
and sequence generators is described in sections
link:Per.html#a16164[See SequenceGenerator Annotation] and
link:Per.html#a16256[See TableGenerator Annotation].

The _AUTO_ value indicates that the
persistence provider should pick an appropriate strategy for the
particular database. The _AUTO_ generation strategy may expect a
database resource to exist, or it may attempt to create one. A vendor
may provide documentation on how to create such resources in the event
that it does not support schema generation or cannot create the schema
resource at runtime.

This specification does not define the exact
behavior of these strategies.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface GeneratedValue \{

 GenerationType strategy() default AUTO;

 String generator() default "";

}

===

image:Per-5.png[image]

[[a14806]]GeneratedValue Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|GenerationType
|strategy
|(Optional) The primary key generation
strategy that the persistence provider must use to generate the
annotated entity primary key.
|GenerationType.AUTO

|String |generator
|(Optional) The name of the primary key
generator to use as specified in the SequenceGenerator or TableGenerator
annotation. |Default primary key generator
supplied by persistence provider.
|===

 _Example 1:_

@Id

@GeneratedValue(strategy=SEQUENCE,
generator="CUST_SEQ")

@Column(name="CUST_ID")

public Long getId() \{ return id; }

 _Example 2:_

@Id

@GeneratedValue(strategy=TABLE,
generator="CUST_GEN")

@Column(name="CUST_ID")

Long id;

==== [[a14827]]Id Annotation

The _Id_ annotation specifies the primary key
property or field of an entity. The _Id_ annotation may be applied in an
entity or mapped superclass.

The field or property to which the _Id_
annotation is applied should be one of the following types: any Java
primitive type; any primitive wrapper type; _java.lang.String_ ;
_java.util.Date_ ; _java.sql.Date_ ; _java.math.BigDecimal_ ;
_java.math.BigIntegerlink:#a19648[112]_ . See section
link:Per.html#a132[See Primary Keys and Entity Identity].

The mapped column for the primary key of the
entity is assumed to be the primary key of the primary table. If no
_Column_ annotation is specified, the primary key column name is assumed
to be the name of the primary key property or field.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Id \{}

 _Example:_

@Id

public Long getId() \{ return id; }

==== [[a14836]]IdClass Annotation

The _IdClass_ annotation is applied to an
entity class or a mapped superclass to specify a composite primary key
class that is mapped to multiple fields or properties of the entity.

The names of the fields or properties in the
primary key class and the primary key fields or properties of the entity
must correspond and their types must match according to the rules
specified in Section link:Per.html#a132[See Primary Keys and
Entity Identity] and Section link:Per.html#a149[See Primary
Keys Corresponding to Derived Identities].

The _Id_ annotation must also be applied to
the corresponding fields or properties of the entity.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface IdClass \{

 Class value();

}



Table link:Per.html#a14847[See IdClass
Annotation Elements] lists the annotation elements that may be specified
for the _IdClass_ annotation.

===

image:Per-5.png[image]

[[a14847]]IdClass Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Class |value
|(Required) The composite primary key class.
|
|===

 _Example:_

@IdClass(com.acme.EmployeePK.class)

@Entity

public class Employee \{

 @Id String empName;

 @Id Date birthDay;

...

}

==== [[a14862]]Index Annotation

The _Index_ annotation is used in schema
generation. Note that it is not necessary to specify an index for a
primary key, as the primary key index will be created automatically,
however, the Index annotation may be used to specify the ordering of the
columns in the index for the primary key.

@Target(\{}) @Retention(RUNTIME)

public @interface Index \{

 String name() default "";

 String columnList();

 boolean unique() default false;

}

The syntax of the _columnList_ element is a
_column_list_ , as follows:

column::= index_column [,index_column]*

{empty}index_column::= column_name [ASC |
DESC]

The persistence provider must observe the
specified ordering of the columns.

If _ASC_ or _DESC_ is not specified, _ASC_
(ascending order) is assumed.

link:Per.html#a14877[See Index
Annotation Elements] lists the annotation elements that may be specified
for the _Index_ annotation.

===

image:Per-5.png[image]

[[a14877]]Index Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the index.
|A provider-generated name.

|String
|columnList
|(Required) The names of the columns to be
included in the index. |

|boolean |unique
|(Optional) Whether the index is unique.
|false
|===

==== [[a14891]]Inheritance Annotation

The _Inheritance_ annotation defines the
inheritance strategy to be used for an entity class hierarchy. It is
specified on the entity class that is the root of the entity class
hierarchy.

If the _Inheritance_ annotation is not
specified or if no inheritance type is specified for an entity class
hierarchy, the SINGLE_TABLE mapping strategy is used.

Support for the combination of inheritance
strategies is not required by this specification. Portable applications
should only use a single inheritance strategy within an entity
hierarchy.

The three inheritance mapping strategies are
the single table per class hierarchy, joined subclass, and table per
concrete class strategies. See link:Per.html#a966[See
Inheritance Mapping Strategies] for a more detailed discussion of
inheritance strategies.

The inheritance strategy options are defined
by the _InheritanceType_ enum:

public enum InheritanceType

 \{ SINGLE_TABLE, JOINED, TABLE_PER_CLASS };

Support for the TABLE_PER_CLASS mapping
strategy is optional in this release.

link:Per.html#a14907[See Inheritance
Annotation Elements] lists the annotation elements that may be specified
for the _Inheritance_ annotation and their default values.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface Inheritance \{

 InheritanceType strategy() default
SINGLE_TABLE;

}



===

image:Per-5.png[image]

[[a14907]]Inheritance Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|InheritanceType
|strategy
|(Optional) The inheritance strategy to use
for the entity inheritance hierarchy.
|InheritanceType.SINGLE_TABLE
|===

 _Example:_

@Entity

@Inheritance(strategy=JOINED)

public class Customer \{ ... }



@Entity

public class ValuedCustomer extends Customer
\{ ... }

==== [[a14922]]JoinColumn Annotation

The _JoinColumn_ annotation is used to
specify a column for joining an entity association or element
collection.

link:Per.html#a14945[See JoinColumn
Annotation Elements] lists the annotation elements that may be specified
for the _JoinColumn_ annotation and their default values.

If the _JoinColumn_ annotation itself is
defaulted, a single join column is assumed and the default values
described in link:Per.html#a14945[See JoinColumn Annotation
Elements] apply.

The _name_ annotation element defines the
name of the foreign key column. The remaining annotation elements (other
than _referencedColumnName_ ) refer to this column and have the same
semantics as for the _Column_ annotation.

If the _referencedColumnName_ element is
missing, the foreign key is assumed to refer to the primary key of the
referenced table.

Support for referenced columns that are not
primary key columns of the referenced table is optional. Applications
that use such mappings will not be portable.

The _foreignKey_ annotation element is used
to specify or control the generation of a foreign key constraint when
schema generation is in effect. If this element is not specified, the
persistence provider’s default foreign key strategy will apply.

If more than one _JoinColumn_ annotation is
applied to a field or property, both the _name_ and the
_referencedColumnName_ elements must be specified in each such
_JoinColumn_ annotation.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

@Repeatable(JoinColumns.class)

public @interface JoinColumn \{

 String name() default "";

 String referencedColumnName() default "";

 boolean unique() default false;

 boolean nullable() default true;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 String table() default "";

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

}

===

image:Per-5.png[image]

[[a14945]]JoinColumn Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the foreign key
column. The table in which it is found depends upon the context. If the
join is for a OneToOne or ManyToOne mapping using a foreign key mapping
strategy, the foreign key column is in the table of the source entity or
embeddable. If the join is for a unidirectional OneToMany mapping using
a foreign key mapping strategy, the foreign key is in the table of the
target entity. If the join is for a ManyToMany mapping or for a OneToOne
or bidirectional ManyToOne/OneToMany mapping using a join table, the
foreign key is in a join table. If the join is for an element
collection, the foreign key is in a collection table.
|(Default only applies if a single join
column is used.) The concatenation of the following: the name of the
referencing relationship property or field of the referencing entity or
embeddable class; "_"; the name of the referenced primary key column. If
there is no such referencing relationship property or field in the
entity, or if the join is for an element collection, the join column
name is formed as the concatenation of the following: the name of the
entity; "_"; the name of the referenced primary key column.

|String
|referencedColumnName
|(Optional) The name of the column referenced
by this foreign key column. When used with entity relationship mappings
other than the cases described below, the referenced column is in the
table of the target entity. When used with a unidirectional OneToMany
foreign key mapping, the referenced column is in the table of the source
entity. When used inside a JoinTable annotation, the referenced key
column is in the entity table of the owning entity, or inverse entity if
the join is part of the inverse join definition. When used in a
collection table mapping, the referenced column is in the table of the
entity containing the collection. |(Default
only applies if single join column is being used.) The same name as the
primary key column of the referenced table.

|boolean |unique
|(Optional) Whether the property is a unique
key. This is a shortcut for the UniqueConstraint annotation at the table
level and is useful for when the unique key constraint is only a single
field. It is not necessary to explicitly specify this for a join column
that corresponds to a primary key that is part of a foreign key.
|false

|boolean |nullable
|(Optional) Whether the foreign key column is
nullable. |true

|boolean
|insertable
|(Optional) Whether the column is included in
SQL INSERT statements generated by the persistence provider.
|true

|boolean
|updatable
|(Optional) Whether the column is included in
SQL UPDATE statements generated by the persistence provider.
|true

|String
|columnDefinition
|(Optional) The SQL fragment that is used
when generating the DDL for the column.
|Generated SQL for the column.

|String |table
|(Optional) The name of the table that
contains the column. | If the join is for a
OneToOne or ManyToOne mapping using a foreign key mapping strategy, the
name of the table of the source entity or embeddable. If the join is for
a unidirectional OneToMany mapping using a foreign key mapping strategy,
the name of the table of the target entity. If the join is for a
ManyToMany mapping or for a OneToOne or bidirectional ManyToOne/
OneToMany mapping using a join table, the name of the join table. If the
join is for an element collection, the name of the collection table.

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint for
the join column. This is used only if table generation is in effect.
|Provider’s default
|===

 _Example 1:_

@ManyToOne

@JoinColumn(name="ADDR_ID")

public Address getAddress() \{ return
address; }

 __

 _Example 2:_ Unidirectional One-to-Many
association using a foreign key mapping.

In Customer class:

@OneToMany

@JoinColumn(name= _"_ CUST_ID _"_ ) // join
column is in table for Order

public Set<Order> getOrders() \{return
orders;}

==== JoinColumns Annotation

Composite foreign keys are supported by means
of the _JoinColumns_ annotation. The _JoinColumns_ annotation groups
_JoinColumn_ annotations for the same relationship.

When the _JoinColumns_ annotation is used,
both the _name_ and the _referencedColumnName_ elements must be
specified in each of the grouped _JoinColumn_ annotations.

The _foreignKey_ annotation element is used
to specify or control the generation of a foreign key constraint when
schema generation is in effect. If both this element and the
_foreignKey_ element of any of the _JoinColumn_ elements referenced by
the _value_ element are specified, the behavior is undefined. If no
_foreignKey_ annotation element is specified in either location, the
persistence provider's default foreign key strategy will apply.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface JoinColumns \{

 JoinColumn[] value();

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

}



Table link:Per.html#a15003[See
JoinColumns Annotation Elements] lists the annotation elements that may
be specified for the _JoinColumns_ annotation.

===

image:Per-5.png[image]

[[a15003]]JoinColumns Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|JoinColumn[]
|value |(Required)
The join columns that map the relationship.
|

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint
specification for the join columns. This is used only if table
generation is in effect. |Provider’s default
|===

 _Example:_

@ManyToOne

@JoinColumns(\{

 @JoinColumn(name="ADDR_ID",
referencedColumnName="ID"),

 @JoinColumn(name="ADDR_ZIP",
referencedColumnName="ZIP")

})

public Address getAddress() \{ return
address; }

 __

==== [[a15022]]JoinTable Annotation

The _JoinTable_ annotation is used in the
mapping of entity associations. A _JoinTable_ annotation is specified on
the owning side of the association. A join table is typically used in
the mapping of many-to-many and unidirectional one-to-many associations.
It may also be used to map bidirectional many-to-one/one-to-many
associations, unidirectional many-to-one relationships, and one-to-one
associations (both bidirectional and unidirectional).

link:Per.html#a15043[See JoinTable
Annotation Elements] lists the annotation elements that may be specified
for the _JoinTable_ annotation and their default values.

If the _JoinTable_ annotation is not
explicitly specified for the mapping of a many-to-many or unidirectional
one-to-many relationship, the default values of the annotation elements
apply.

The name of the join table is assumed to be
the table names of the associated primary tables concatenated together
(owning side first) using an underscore.

The _foreignKey_ element is used to specify
or control the generation of a foreign key constraint for the columns
corresponding to the _joinColumns_ element when table generation is in
effect. If both this element and the _foreignKey_ element of any of the
_joinColumns_ elements are specified, the behavior is undefined. If no
_foreignKey_ annotation element is specified in either location, the
persistence provider's default foreign key strategy will apply. The
_inverseForeignKey_ element applies to the generation of a foreign key
constraint for the columns corresponding to the _inverseJoinColumns_
element, and similar rules apply.

When a join table is used in mapping a
relationship with an embeddable class on the owning side of the
relationship, the containing entity rather than the embeddable class is
considered the owner of the relationship.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface JoinTable \{

 String name() default "";

 String catalog() default "";

 String schema() default "";

 JoinColumn[] joinColumns() default \{};

 JoinColumn[] inverseJoinColumns() default
\{};

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

 ForeignKey inverseForeignKey()

 default @ForeignKey(PROVIDER_DEFAULT);

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

}

===

image:Per-5.png[image]

[[a15043]]JoinTable Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the join table.
|The concatenated names of the two associated
primary entity tables (owning side first), separated by an underscore.

|String |catalog
|(Optional) The catalog of the table.
|Default catalog.

|String |schema
|(Optional) The schema of the table.
|Default schema for user.

|JoinColumn[]
|joinColumns
|(Optional) The foreign key columns of the
join table which reference the primary table of the entity owning the
association (i.e. the owning side of the association).
|The same defaults as for JoinColumn.

|JoinColumn[]
|inverseJoinColumns
|(Optional) The foreign key columns of the
join table which reference the primary table of the entity that does not
own the association (i.e. the inverse side of the association).
|The same defaults as for JoinColumn.

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint
specification for the join columns. This is used only if table
generation is in effect. |Provider’s default.

|ForeignKey
|inverseForeignKey
|(Optional) The foreign key constraint
specification for the inverse join columns. This is used only if table
generation is in effect. |Provider’s default.

|UniqueConstraint[]
|uniqueConstraints
|(Optional) Unique constraints that are to be
placed on the table. These are only used if table generation is in
effect. |No additional constraints

|Index[] |indexes
|(Optional) Indexes for the table. These are
only used if table generation is in effect.
|No additional indexes
|===

 _Example:_

@JoinTable(

 name="CUST_PHONE",

 joinColumns=

 @JoinColumn(name="CUST_ID",
referencedColumnName="ID"),

 inverseJoinColumns=

 @JoinColumn(name="PHONE_ID",
referencedColumnName="ID")

)

==== [[a15087]]Lob Annotation

A _Lob_ annotation specifies that a
persistent property or field should be persisted as a large object to a
database-supported large object type. Portable applications should use
the _Lob_ annotation when mapping to a database Lob type. The _Lob_
annotation may be used in conjunction with the _Basic_ annotation or
with the _ElementCollectionlink:#a19649[113]_ annotation when the
element collection value is of basic type. A Lob may be either a binary
or character type. The Lob type is inferred from the type of the
persistent field or property and, except for string and character types,
defaults to Blob.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Lob \{

}

 _Example 1:_

@Lob @Basic(fetch=EAGER)

@Column(name="REPORT")

protected String report;

 _Example 2:_

@Lob @Basic(fetch=LAZY)

@Column(name="EMP_PIC",
columnDefinition="BLOB NOT NULL")

protected byte[] pic;

==== [[a15100]]ManyToMany Annotation

A _ManyToMany_ annotation defines a
many-valued association with many-to-many multiplicity. If the
collection is defined using generics to specify the element type, the
associated target entity class does not need to be specified; otherwise
it must be specified.

Every many-to-many association has two sides,
the owning side and the non-owning, or inverse, side. If the association
is bidirectional, either side may be designated as the owning side. If
the relationship is bidirectional, the non-owning side must use the
_mappedBy_ element of the _ManyToMany_ annotation to specify the
relationship field or property of the owning side.

The join table for the relationship, if not
defaulted, is specified on the owning side.

The _ManyToMany_ annotation may be used
within an embeddable class contained within an entity class to specify a
relationship to a collection of entitieslink:#a19650[114]. If the
relationship is bidirectional and the entity containing the embeddable
class is the owner of the relationship, the non-owning side must use the
_mappedBy_ element of the _ManyToMany_ annotation to specify the
relationship field or property of the embeddable class. The dot ( _"."_
) notation syntax must be used in the _mappedBy_ element to indicate the
relationship attribute within the embedded attribute. The value of each
identifier used with the dot notation is the name of the respective
embedded field or property.

link:Per.html#a15119[See ManyToMany
Annotation Elements] lists these annotation elements that may be
specified for the _ManyToMany_ annotation and their default values.

The _cascade_ element specifies the set of
cascadable operations that are propagated to the associated entity. The
operations that are cascadable are defined by the _CascadeType_ enum:

 _public enum CascadeType_ _\{_ _ALL,_
_PERSIST,_ _MERGE,_ _REMOVE,_ _REFRESH,_ _DETACH};_

The value _cascade=ALL_ is equivalent to
_cascade=\{PERSIST,_ _MERGE,_ _REMOVE,_ _REFRESH, DETACH}_ .

When the collection is a _java.util.Map_ ,
the _cascade_ element applies to the map _value_ .

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface ManyToMany \{

 Class targetEntity() default void.class;

 CascadeType[] cascade() default \{};

 FetchType fetch() default LAZY;

 String mappedBy() default "";

}

The _EAGER_ strategy is a requirement on the
persistence provider runtime that the associated entity must be eagerly
fetched. The _LAZY_ strategy is a _hint_ to the persistence provider
runtime that the associated entity should be fetched lazily when it is
first accessed. The implementation is permitted to eagerly fetch
associations for which the _LAZY_ strategy hint has been specified.

===

image:Per-5.png[image]

[[a15119]]ManyToMany Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Class
|targetEntity
|(Optional) The entity class that is the
target of the association. Optional only if the collection-valued
relationship property is defined using Java generics. Must be specified
otherwise. |The parameterized type of the
collection when defined using generics.

|CascadeType[]
|cascade
|(Optional) The operations that must be
cascaded to the target of the association.
|No operations are cascaded.

|FetchType |fetch
|(Optional) Whether the association should be
lazily loaded or must be eagerly fetched. The EAGER strategy is a
requirement on the persistence provider runtime that the associated
entities must be eagerly fetched. The LAZY strategy is a hint to the
persistence provider runtime. |LAZY

|String |mappedBy
|The field or property that owns the
relationship. Required unless the relationship is unidirectional.
|
|===

 _Example 1:_

In Customer class:

@ManyToMany

@JoinTable(name="CUST_PHONES")

public Set<PhoneNumber> getPhones() \{ return
phones; }

In PhoneNumber class:

@ManyToMany(mappedBy="phones")

public Set<Customer> getCustomers() \{ return
customers; }

 _Example 2:_

In Customer class:

@ManyToMany(targetEntity=com.acme.PhoneNumber.class)

public Set getPhones() \{ return phones; }

In PhoneNumber class:

@ManyToMany(targetEntity=com.acme.Customer.class,
mappedBy="phones")

public Set getCustomers() \{ return
customers; } __

 _Example 3:_

 _In Customer class:_

@ManyToMany

@JoinTable(

 name="CUST_PHONE",

 joinColumns=

 @JoinColumn(name="CUST_ID",
referencedColumnName="ID"),

 inverseJoinColumns=

 @JoinColumn(name="PHONE_ID",
referencedColumnName="ID")

)

public Set<PhoneNumber> getPhones() \{ return
phones; }

In PhoneNumberClass:

@ManyToMany(mappedBy="phones")

public Set<Customer> getCustomers() \{ return
customers; }

 _Example 4:_

Embeddable class used by the Employee entity
specifies a many-to-many relationship.

@Entity

public class Employee \{

 @Id int id;

 @Embedded ContactInfo contactInfo;

 ...

}



@Embeddable

public class ContactInfo \{

 @ManyToOne Address address; //
Unidirectional

 @ManyToMany List<PhoneNumber> phoneNumbers;
// Bidirectional

}



@Entity

public class PhoneNumber \{

 @Id int phNumber;


@ManyToMany(mappedBy="contactInfo.phoneNumbers")

 Collection<Employee> employees;

}



==== ManyToOne Annotation

The _ManyToOne_ annotation defines a
single-valued association to another entity class that has many-to-one
multiplicity. It is not normally necessary to specify the target entity
explicitly since it can usually be inferred from the type of the object
being referenced.

The _ManyToOne_ annotation may be used within
an embeddable class to specify a relationship from the embeddable class
to an entity class. If the relationship is bidirectional, the non-owning
_OneToMany_ entity side must use the _mappedBy_ element of the
_OneToMany_ annotation to specify the relationship field or property of
the embeddable field or property on the owning side of the relationship.
The dot ( _"."_ ) notation syntax must be used in the _mappedBy_ element
to indicate the relationship attribute within the embedded attribute.
The value of each identifier used with the dot notation is the name of
the respective embedded field or property.

link:Per.html#a15202[See ManyToOne
Annotation Elements] lists the annotation elements that may be specified
for the _ManyToOne_ annotation and their default values.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface ManyToOne \{

 Class targetEntity() default void.class;

 CascadeType[] cascade() default \{};

 FetchType fetch() default EAGER;

 boolean optional() default true;

}

The operations that can be cascaded are
defined by the _CascadeType_ enum, defined in section
link:Per.html#a15100[See ManyToMany Annotation].

The _EAGER_ strategy is a requirement on the
persistence provider runtime that the associated entity must be eagerly
fetched. The _LAZY_ strategy is a _hint_ to the persistence provider
runtime that the associated entity should be fetched lazily when it is
first accessed. The implementation is permitted to eagerly fetch
associations for which the _LAZY_ strategy hint has been specified.

===

image:Per-5.png[image]

[[a15202]]ManyToOne Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Class
|targetEntity
|(Optional) The entity class that is the
target of the association. |The type of the
field or property that stores the association.

|CascadeType[]
|cascade
|(Optional) The operations that must be
cascaded to the target of the association.
|No operations are cascaded.

|FetchType |fetch
|(Optional) Whether the association should be
lazily loaded or must be eagerly fetched. The EAGER strategy is a
requirement on the persistence provider runtime that the associated
entity must be eagerly fetched. The LAZY strategy is a hint to the
persistence provider runtime. |EAGER

|boolean |optional
|(Optional) Whether the association is
optional. If set to false then a non-null relationship must always
exist. |true
|===

 _Example 1:_

@ManyToOne(optional=false)

@JoinColumn(name="CUST_ID", nullable=false,
updatable=false)

public Customer getCustomer() \{ return
customer; }

 _Example 2:_

@Entity

public class Employee \{

 @Id int id;

 @Embedded JobInfo jobInfo;

 ...

}



@Embeddable

public class JobInfo \{

 String jobDescription;

 @ManyToOne ProgramManager pm; //
Bidirectional

}



@Entity

public class ProgramManager \{

 @Id int id;

 @OneToMany(mappedBy="jobInfo.pm")

 Collection<Employee> manages;

}

==== MapKey Annotation

The _MapKey_ annotation is used to specify
the map key for associations of type _java.util.Map_ when the map key is
itself the primary key or a persistent field or property of the entity
that is the value of the map.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface MapKey \{

 String name() default "";

}



The _name_ element designates the name of the
persistent field or property of the associated entity that is used as
the map key. If the _name_ element is not specified, the primary key of
the associated entity is used as the map key. If the primary key is a
composite primary key and is mapped as _IdClass_ , an instance of the
primary key class is used as the key.

If a persistent field or property other than
the primary key is used as a map key, it is expected to be unique within
the context of the relationship.

The _MapKeyClass_ annotation is not used when
_MapKey_ is specified and vice versa.

Table link:Per.html#a15256[See MapKey
Annotation Elements] lists the annotation elements that may be specified
for the _MapKey_ annotation.

===

image:Per-5.png[image]

[[a15256]]MapKey Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the persistent field
or property that is used as the map key. |The
primary key is used as the map key.
|===

 _Example 1:_

@Entity

public class Department \{

 ...

 @OneToMany(mappedBy="department")

 @MapKey // map key is primary key

 public Map<Integer, Employee> getEmployees()
\{... }

 ...

}



@Entity

public class Employee \{

 ...

 @Id public Integer getEmpId() \{ ... }



 @ManyToOne

 @JoinColumn(name="dept_id")

 public Department getDepartment() \{ ... }

 ...

}



 _Example 2:_

@Entity

public class Department \{

 ...

 @OneToMany(mappedBy="department")

 @MapKey(name="name")

 public Map<String, Employee> getEmployees()
\{... }

 ...

 }



@Entity

public class Employee \{

 @Id public Integer getEmpId() \{ ... }

 ...

 public String getName() \{ ... }

 ...

 @ManyToOne

 @JoinColumn(name="dept_id")

 public Department getDepartment() \{ ... }

 ...

}

==== MapKeyClass Annotation

The _MapKeyClass_ annotation is used to
specify the type of the map key for associations of type _java.util.Map_
. The map key can be a basic type, an embeddable class, or an entity. If
the map is specified using Java generics, the _MapKeyClass_ annotation
and associated type need not be specified; otherwise they must be
specified.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface MapKeyClass \{

 Class value();

}



The _MapKeyClass_ annotation is used in
conjunction with _ElementCollection_ or one of the collection-valued
relationship annotations ( _OneToMany_ or _ManyToMany_ ).

The _MapKey_ annotation is not used when
_MapKeyClass_ is specified and vice versa.

Table link:Per.html#a15316[See
MapKeyClass Annotation Elements] lists the annotation elements that may
be specified for the _MapKeyClass_ annotation.

===

image:Per-5.png[image]

[[a15316]]MapKeyClass Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Class |value
|(Required) The type of the map key.
|
|===

 _Example 1:_

@Entity

public class Item \{

 @Id int id;

 ...

 @ElementCollection(targetClass=String.class)

 @MapKeyClass(String.class)

 Map images; // map from image name to image
filename

 ...

}



 _Example 2:_

// MapKeyClass and target type of
relationship can be defaulted



@Entity

public class Item \{

 @Id int id;

 ...

 @ElementCollection

 Map<String, String> images;

 ...

}



 _Example 3:_

@Entity

public class Company \{

 @Id int id;

 ...


@OneToMany(targetEntity=com.example.VicePresident.class)

 @MapKeyClass(com.example.Division.class)

 Map organization;

}



 _Example 4:_

// MapKeyClass and target type of
relationship are defaulted



@Entity

public class Company \{

 @Id int id;

 ...

 @OneToMany

 Map<Division, VicePresident> organization;

}



==== [[a15367]]MapKeyColumn Annotation

The _MapKeyColumn_ annotation is used to
specify the mapping for the key column of a map whose map key is a basic
type. If the _name_ element is not specified, it defaults to the
concatenation of the following: the name of the referencing relationship
field or property; " ___ "; " _KEY_ ".

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface MapKeyColumn \{

 String name() default "";

 boolean unique() default false;

 boolean nullable() default false;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 String table() default "";

 int length() default 255;

 int precision() default 0; // decimal
precision

 int scale() default 0; // decimal scale

}

If no _MapKeyColumn_ annotation is specified,
the default values in Table link:Per.html#a15384[See MapKeyColumn
Annotation Elements] apply.

===

image:Per-5.png[image]

[[a15384]]MapKeyColumn Annotation Elements __

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the map key column.
The table in which it is found depends upon the context. If the map key
is for an element collection, the map key column is in the collection
table for the map value. If the map key is for a ManyToMany entity
relationship or for a OneToMany entity relationship using a join table,
the map key column is in a join table. If the map key is for a OneToMany
entity relationship using a foreign key mapping strategy, the map key
column is in the table of the entity that is the value of the map.
|The concatenation of the following: the name
of the referencing property or field name; " ___ "; " _KEY_ ".

|boolean |unique
|(Optional) Whether the column is a unique
key. This is a shortcut for the UniqueConstraint annotation at the table
level and is useful for when the unique key constraint corresponds to
only a single column. This constraint applies in addition to any
constraint entailed by primary key mapping and to constraints specified
at the table level. |false

|boolean |nullable
|(Optional) Whether the database column is
nullable. |true

|boolean
|insertable
|(Optional) Whether the column is included in
SQL INSERT statements generated by the persistence provider.
|true

|boolean
|updatable
|(Optional) Whether the column is included in
SQL UPDATE statements generated by the persistence provider.
|true

|String
|columnDefinition
|(Optional) The SQL fragment that is used
when generating the DDL for the column.
|Generated SQL to create a column of the
inferred type.

|String |table
|(Optional) The name of the table that
contains the column. |If the map key is for
an element collection, the name of the collection table for the map
value. If the map key is for a OneToMany or ManyToMany entity
relationship using a join table, the name of the join table for the map.
If the map key is for a OneToMany entity relationship using a foreign
key mapping strategy, the name of the primary table of the entity that
is the value of the map.

|int |length
|(Optional) The column length. (Applies only
if a string-valued column is used.) |255

|int |precision
|(Optional) The precision for a decimal
(exact numeric) column. (Applies only if a decimal column is used.)
|0 (Value must be set by developer.)

|int |scale
|(Optional) The scale for a decimal (exact
numeric) column. (Applies only if a decimal column is used.)
|0
|===

 _Example:_

@Entity

public class Item \{

 @Id int id;

 ...

 @ElementCollection

 @MapKeyColumn(name="IMAGE_NAME")

 @Column(name="IMAGE_FILENAME")

 @CollectionTable(name="IMAGE_MAPPING")

 Map<String, String> images; // map from
image name to filename

 ...

}

==== [[a15433]]MapKeyEnumerated Annotation

The _MapKeyEnumerated_ annotation is used to
specify the enum type for a map key whose basic type is an enumerated
type.

The _MapKeyEnumerated_ annotation can be
applied to an element collection or relationship of type _java.util.Map_
, in conjunction with the _ElementCollection_ , _OneToMany_ , or
_ManyToMany_ annotation. If the map is specified using Java generics,
the _MapKeyClass_ annotation and associated type need not be specified;
otherwise they must be specified.

If the enumerated type is not specified or
the _MapKeyEnumerated_ annotation is not used, the enumerated type is
assumed to be _ORDINAL_ .

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface MapKeyEnumerated \{

 EnumType value() default ORDINAL;

}

link:Per.html#a15443[See
MapKeyEnumerated Annotation Elements] lists the annotation elements that
may be specified for the _MapKeyEnumerated_ annotation and their default
values. The _EnumType_ enum is defined in section
link:Per.html#a14719[See Enumerated Annotation].

===

image:Per-5.png[image]

[[a15443]]MapKeyEnumerated Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|EnumType |value
|(Optional) The type used in mapping an enum
type. |ORDINAL
|===

==== [[a15450]]MapKeyJoinColumn Annotation

The _MapKeyJoinColumn_ annotation is used to
specify a mapping to an entity that is a map key. The map key join
column is in the collection table, join table, or table of the target
entity that is used to represent the map.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

@Repeatable(MapKeyJoinColumns.class)

public @interface MapKeyJoinColumn \{

 String name() default "";

 String referencedColumnName() default "";

 boolean unique() default false;

 boolean nullable() default false;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 String table() default "";

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

}



Table link:Per.html#a15474[See
MapKeyJoinColumn Annotation Elements] lists the annotation elements that
may be specified for the _MapKeyJoinColumn_ annotation and their default
values.

If no _MapKeyJoinColumn_ annotation is
specified, a single join column is assumed and the default values
described below (and in Table link:Per.html#a15474[See
MapKeyJoinColumn Annotation Elements]) apply.

The _name_ annotation element defines the
name of the foreign key column. The remaining annotation elements (other
than _referencedColumnName_ ) refer to this column.

If there is a single map key join column, and
if the name annotation member is missing, the map key join column name
is formed as the concatenation of the following: the name of the
referencing relationship property or field of the referencing entity or
embeddable; " ___ "; " _KEY_ ".

If the _referencedColumnName_ element is
missing, the foreign key is assumed to refer to the primary key of the
referenced table. Support for referenced columns that are not primary
key columns of the referenced table is optional. Applications that use
such mappings will not be portable.

The _foreignKey_ element is used to specify
or control the generation of a foreign key constraint for the map key
join column when table generation is in effect. If the _foreignKey_
element is not specified, the persistence provider’s default foreign key
strategy will be used.

If more than one _MapKeyJoinColumn_
annotation is applied to a field or property, both the _name_ and the
_referencedColumnName_ elements must be specified in each such
_MapKeyJoinColumn_ annotation.

===

image:Per-5.png[image]

[[a15474]]MapKeyJoinColumn Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the foreign key
column for the map key. The table in which it is found depends upon the
context. If the join is for a map key for an element collection, the
foreign key column is in the collection table for the map value. If the
join is for a map key for a ManyToMany entity relationship or for a
OneToMany entity relationship using a join table, the foreign key column
is in a join table. If the join is for a OneToMany entity relationship
using a foreign key mapping strategy, the foreign key column for the map
key is in the table of the entity that is the value of the map.
|(Default only applies if a single join
column is used.) The concatenation of the following: the name of the
referencing relationship property or field of the referencing entity or
embeddable class; "_"; "KEY".

|String
|referencedColumnName
|(Optional) The name of the column referenced
by this foreign key column. The referenced column is in the table of the
target entity. |(Default only applies if
single join column is being used.) The same name as the primary key
column of the referenced table.

|boolean |unique
|(Optional) Whether the property is a unique
key. This is a shortcut for the UniqueConstraint annotation at the table
level and is useful for when the unique key constraint is only a single
field. |false

|boolean |nullable
|(Optional) Whether the foreign key column is
nullable. |true

|boolean
|insertable
|(Optional) Whether the column is included in
SQL INSERT statements generated by the persistence provider.
|true

|boolean
|updatable
|(Optional) Whether the column is included in
SQL UPDATE statements generated by the persistence provider.
|true

|String
|columnDefinition
|(Optional) The SQL fragment that is used
when generating the DDL for the column.
|Generated SQL for the column.

|String |table
|(Optional) The name of the table that
contains the foreign key column. If the join is for a map key for an
element collection, the foreign key column is in the collection table
for the map value. If the join is for a map key for a ManyToMany entity
relationship or for a OneToMany entity relationship using a join table,
the foreign key column is in a join table. If the join is for a
OneToMany entity relationship using a foreign key mapping strategy, the
foreign key column for the map key is in the table of the entity that is
the value of the map. |If the map is for an
element collection, the name of the collection table for the map value.
If the map is for a OneToMany or ManyToMany entity relationship using a
join table, the name of the join table for the map. If the map is for a
OneToMany entity relationship using a foreign key mapping strategy, the
name of the primary table of the entity that is the value of the map.

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint
specification for the join column. This is used only if table generation
is in effect. |Provider’s default
|===

 _Example 1:_

@Entity

public class Company \{

 @Id int id;

 ...

 @OneToMany // unidirectional

 @JoinTable(

 name="COMPANY_ORGANIZATION",

 joinColumns=@JoinColumn(name="COMPANY"),


inverseJoinColumns=@JoinColumn(name="VICEPRESIDENT"))

 @MapKeyJoinColumn(name="DIVISION")

 Map<Division, VicePresident> organization;

}

 __

 _Example 2:_

@Entity

public class VideoStore \{

 @Id int id;

 String name;

 Address location;

 ...

 @ElementCollection

 @CollectionTable(name="INVENTORY",

 joinColumns=@JoinColumn(name="STORE"))

 @Column(name="COPIES_IN_STOCK")

 @MapKeyJoinColumn(name="MOVIE",
referencedColumnName="ID")

 Map<Movie, Integer> videoInventory;

 ...

}



@Entity

public class Movie \{

 @Id long id;

 String title;

 ...

}



 _Example 3:_

@Entity

public class Student \{

 @Id int studentId;

 ...

 @ManyToMany // students and courses are also
many-many

 @JoinTable(name="ENROLLMENTS",

 joinColumns=@JoinColumn(name="STUDENT"),


inverseJoinColumns=@JoinColumn(name="SEMESTER"))

 @MapKeyJoinColumn(name="COURSE")

 Map<Course, Semester> enrollment;

 ...

}

==== MapKeyJoinColumns Annotation

Composite map keys referencing entities are
supported by means of the _MapKeyJoinColumns_ annotation. The
_MapKeyJoinColumns_ annotation groups _MapKeyJoinColumn_ annotations.

When the _MapKeyJoinColumns_ annotation is
used, both the _name_ and the _referencedColumnName_ elements must be
specified in each of the grouped _MapKeyJoinColumn_ annotations.

The _foreignKey_ element is used to specify
or control the generation of a foreign key constraint for the columns
corresponding to the _MapKeyJoinColumn_ elements referenced by the
_value_ element when table generation is in effect. If both this element
and the _foreignKey_ element of any of the _MapKeyJoinColumn_ elements
are specified, the behavior is undefined. If no _foreignKey_ annotation
element is specified in either location, the persistence provider's
default foreign key strategy will apply.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface MapKeyJoinColumns \{

 MapKeyJoinColumn[] value();

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

}



Table link:Per.html#a15572[See
MapKeyJoinColumns Annotation Elements] lists the annotation elements
that may be specified for the _MapKeyJoinColumns_ annotation.

===

image:Per-5.png[image]

[[a15572]]MapKeyJoinColumns Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|MapKeyJoinColumn[]
|value |(Required)
The map key join columns that are used to map to the entity that is the
map key. |

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint
specification for the join columns. This is used only if table
generation is in effect. |Provider’s default
|===

==== [[a15583]]MapKeyTemporal Annotation

The _MapKeyTemporal_ annotation is used to
specify the temporal type for a map key whose basic type is a temporal
type.

The _MapKeyTemporal_ annotation can be
applied to an element collection or relationship of type _java.util.Map_
, in conjunction with the _ElementCollection_ , _OneToMany_ , or
_ManyToMany_ annotation. If the map is specified using Java generics,
the _MapKeyClass_ annotation and associated type need not be specified;
otherwise they must be specified.



@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface MapKeyTemporal \{

 TemporalType value();

}

link:Per.html#a15593[See
MapKeyTemporal Annotation Elements] lists the annotation elements that
may be specified for the _MapKeyTemporal_ annotation and their default
values. The _TemporalType_ enum is defined in section
link:Per.html#a16361[See Temporal Annotation].

===

image:Per-5.png[image]

[[a15593]]MapKeyTemporal Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|TemporalType
|value |(Required)
The type used in mapping java.util.Date or java.util.Calendar.
|
|===

==== MappedSuperclass Annotation

The _MappedSuperclass_ annotation designates
a class whose mapping information is applied to the entities that
inherit from it. A mapped superclass has no separate table defined for
it.

A class designated with the
_MappedSuperclass_ annotation can be mapped in the same way as an entity
except that the mappings will apply only to its subclasses since no
table exists for the mapped superclass itself. When applied to the
subclasses the inherited mappings will apply in the context of the
subclass tables. Mapping information may be overridden in such
subclasses by using the _AttributeOverride_ , _AttributeOverrides_ ,
_AssociationOverride_ , and _AssociationOverrides_ annotations.

@Documented @Target(TYPE) @Retention(RUNTIME)

public @interface MappedSuperclass \{}

==== MapsId Annotation

The _MapsId_ annotation is used to designate
a _ManyToOne_ or _OneToOne_ relationship attribute that provides the
mapping for an _EmbeddedId_ primary key, an attribute within an
_EmbeddedId_ primary key, or a simple primary key of the parent entity.

The _value_ element specifies the attribute
within a composite key to which the relationship attribute corresponds.
If the entity’s primary key is of the same Java type as the primary key
of the entity referenced by the relationship, the _value_ attribute is
not specified.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface MapsId \{

 String value() default "";

}



Table link:Per.html#a15615[See MapsId
Annotation Elements] lists the annotation elements that may be specified
for the _MapsId_ annotation.

===

image:Per-5.png[image]

[[a15615]]MapsId Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |value
|(Optional) The name of the attribute within
the composite key to which the relationship attribute corresponds.
|The relationship maps the entity’s primary
key.
|===

 _Example:_

// parent entity has simple primary key



@Entity

public class Employee \{

 @Id long empId;

 String name;

 ...

}



// dependent entity uses EmbeddedId for
composite key



@Embeddable

public class DependentId \{

 String name;

 long empid; // corresponds to PK type of
Employee

}



@Entity

public class Dependent \{

 @EmbeddedId DependentId id;

 ...

 @MapsId("empid") // maps the empid attribute
of embedded id

 @ManyToOne Employee emp;

}

==== OneToMany Annotation

A _OneToMany_ annotation defines a
many-valued association with one-to-many multiplicity.

link:Per.html#a15667[See OneToMany
Annotation Elements] lists the annotation elements that may be specified
for the _OneToMany_ annotation and their default values.

If the collection is defined using generics
to specify the element type, the associated target entity class need not
be specified; otherwise it must be specified.

The _OneToMany_ annotation may be used within
an embeddable class contained within an entity class to specify a
relationship to a collection of entitieslink:#a19651[115]. If the
relationship is bidirectional, the _mappedBy_ element must be used to
specify the relationship field or property of the entity that is the
owner of the relationship.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface OneToMany \{

 Class targetEntity() default void.class;

 CascadeType[] cascade() default \{};

 FetchType fetch() default LAZY;

 String mappedBy() default "";

 boolean orphanRemoval() default false;

}

The operations that can be cascaded are
defined by the _CascadeType_ enum, defined in section
link:Per.html#a15100[See ManyToMany Annotation].

When the collection is a _java.util.Map_ ,
the _cascade_ element and the _orphanRemoval_ element apply to the map
_value_ .

If _orphanRemoval_ is _true_ and an entity
that is the target of the relationship is removed from the relationship
(either by removal from the collection or by setting the relationship to
null), the remove operation will be applied to the entity being
orphaned. If the entity being orphaned is a detached, new, or removed
entity, the semantics of _orphanRemoval_ do not apply.

If _orphanRemoval_ is _true_ and the remove
operation is applied to the source entity, the remove operation will be
cascaded to the relationship target in accordance with the rules of
section link:Per.html#a1946[See Removal], (and hence it is not
necessary to specify _cascade=REMOVE_ for the
relationship)link:#a19652[116].

The remove operation is applied at the time
of the flush operation. The _orphanRemoval_ functionality is intended
for entities that are privately "owned" by their parent entity. Portable
applications must otherwise not depend upon a specific order of removal,
and must not reassign an entity that has been orphaned to another
relationship or otherwise attempt to persist it.

The default mapping for unidirectional
one-to-many relationships uses a join table as is described in
link:Per.html#a758[See Unidirectional Multi-Valued
Relationships]. Unidirectional one-to-many relationships may be
implemented using one-to-many foreign key mappings, using the
_JoinColumn_ and _JoinColumns_ annotations.

===

image:Per-5.png[image]

[[a15667]]OneToMany Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Class
|targetEntity
|(Optional) The entity class that is the
target of the association. Optional only if the collection-valued
relationship property is defined using Java generics. Must be specified
otherwise. |The parameterized type of the
collection when defined using generics.

|CascadeType[]
|cascade
|(Optional) The operations that must be
cascaded to the target of the association.
|No operations are cascaded.

|FetchType |fetch
|(Optional) Whether the association should be
lazily loaded or must be eagerly fetched. The EAGER strategy is a
requirement on the persistence provider runtime that the associated
entities must be eagerly fetched. The LAZY strategy is a hint to the
persistence provider runtime. |LAZY

|String |mappedBy
|The field or property that owns the
relationship. Required unless the relationship is unidirectional.
|

|boolean
|orphanRemoval
|(Optional) Whether to apply the remove
operation to entities that have been removed from the relationship and
to cascade the remove operation to those entities.
|false
|===

 _Example 1:_ One-to-Many association using
generics

In Customer class:

@OneToMany(cascade=ALL, mappedBy="customer",
orphanRemoval=true)

public Set<Order> getOrders() \{ return
orders; }

In Order class:

@ManyToOne

@JoinColumn(name="CUST_ID", nullable=false)

public Customer getCustomer() \{ return
customer; }

 _Example 2:_ One-to-Many association without
using generics

In Customer class:

@OneToMany(

 targetEntity=com.acme.Order.class,

 cascade=ALL,

 mappedBy="customer",

 orphanRemoval=true

)

public Set getOrders() \{ return orders; }

In Order class:

 _@ManyToOne_

 _@JoinColumn(name="CUST_ID",
nullable=false)_

protected Customer customer;

 _Example 3:_ Unidirectional One-to-Many
association using a foreign key mapping

In Customer class:

@OneToMany(orphanRemoval=true)

@JoinColumn(name= _"_ CUST_ID _"_ ) // join
column is in table for Order

public Set<Order> getOrders() \{return
orders;}

==== OneToOne Annotation

The _OneToOne_ annotation defines a
single-valued association to another entity that has one-to-one
multiplicity. It is not normally necessary to specify the associated
target entity explicitly since it can usually be inferred from the type
of the object being referenced.

If the relationship is bidirectional, the
_mappedBy_ element must be used to specify the relationship field or
property of the entity that is the owner of the relationship.

The _OneToOne_ annotation may be used within
an embeddable class to specify a relationship from the embeddable class
to an entity class. If the relationship is bidirectional and the entity
containing the embeddable class is on the owning side of the
relationship, the non-owning side must use the _mappedBy_ element of the
_OneToOne_ annotation to specify the relationship field or property of
the embeddable class. The dot ( _"."_ ) notation syntax must be used in
the _mappedBy_ element to indicate the relationship attribute within the
embedded attribute. The value of each identifier used with the dot
notation is the name of the respective embedded field or property.

link:Per.html#a15735[See OneToOne
Annotation Elements] lists the annotation elements that may be specified
for the _OneToOne_ annotation and their default values.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface OneToOne \{

 Class targetEntity() default void.class;

 CascadeType[] cascade() default \{};

 FetchType fetch() default EAGER;

 boolean optional() default true;

 String mappedBy() default "";

 boolean orphanRemoval() default false;

}



The operations that can be cascaded are
defined by the _CascadeType_ enum, defined in section
link:Per.html#a15100[See ManyToMany Annotation].

If _orphanRemoval_ is _true_ and an entity
that is the target of the relationship is removed from the relationship
(by setting the relationship to null), the remove operation will be
applied to the entity being orphaned. If the entity being orphaned is a
detached, new, or removed entity, the semantics of _orphanRemoval_ do
not apply.

If _orphanRemoval_ is _true_ and the remove
operation is applied to the source entity, the remove operation will be
cascaded to the relationship target in accordance with the rules of
section link:Per.html#a1946[See Removal], (and hence it is not
necessary to specify _cascade=REMOVE_ for the
relationship)link:#a19653[117].

The remove operation is applied at the time
of the flush operation. The _orphanRemoval_ functionality is intended
for entities that are privately "owned" by their parent entity. Portable
applications must otherwise not depend upon a specific order of removal,
and must not reassign an entity that has been orphaned to another
relationship or otherwise attempt to persist it.

===

image:Per-5.png[image]

[[a15735]]OneToOne Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|Class
|targetEntity
|(Optional) The entity class that is the
target of the association. |The type of the
field or property that stores the association.

|CascadeType[]
|cascade
|(Optional) The operations that must be
cascaded to the target of the association.
|No operations are cascaded.

|FetchType |fetch
|(Optional) Whether the association should be
lazily loaded or must be eagerly fetched. The EAGER strategy is a
requirement on the persistence provider runtime that the associated
entity must be eagerly fetched. The LAZY strategy is a hint to the
persistence provider runtime. |EAGER

|boolean |optional
|(Optional) Whether the association is
optional. If set to false then a non-null relationship must always
exist. |true

|String |mappedBy
|(Optional) The field or property that owns
the relationship. The mappedBy element is only specified on the inverse
(non-owning) side of the association. |

|boolean
|orphanRemoval
|(Optional) Whether to apply the remove
operation to entities that have been removed from the relationship and
to cascade the remove operation to those entities.
|false
|===

 _Example 1:_ One-to-one association that
maps a foreign key column.

On Customer class:

@OneToOne(optional=false)

@JoinColumn(

 name="CUSTREC_ID", unique=true,
nullable=false, updatable=false)

public CustomerRecord getCustomerRecord() \{
return customerRecord; }

On CustomerRecord class:

@OneToOne(optional=false,
mappedBy="customerRecord")

public Customer getCustomer() \{ return
customer; }

 _Example 2:_ One-to-one association where
both source and target share the same primary key values.

On Employee class:

@Entity

public class Employee \{

 @Id Integer id;



 @OneToOne(orphanRemoval=true)

 @MapsId

 EmployeeInfo info;

 ...

}

On EmployeeInfo class:

@Entity

public class EmployeeInfo \{

 @Id Integer id;

 ...

}

 _Example 3:_ One-to-one association from an
embeddable class to another entity.

@Entity

public class Employee \{

 @Id int id;

 @Embedded LocationDetails location;

 ...

}



@Embeddable

public class LocationDetails \{

 int officeNumber;

 @OneToOne ParkingSpot parkingSpot;

 ...

}



@Entity

public class ParkingSpot \{

 @Id int id;

 String garage;

 @OneToOne(mappedBy="location.parkingSpot")
Employee assignedTo;

 ...

}



==== OrderBy Annotation

The _OrderBy_ annotation specifies the
ordering the elements of a collection-valued association or element
collection are to have when the association or collection is retrieved.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface OrderBy \{

 String value() default "";

}



The syntax of the _value_ ordering element is
an orderby_list, as follows:

orderby_list::= orderby_item [,orderby_item]*

{empty}orderby_item::=
[property_or_field_name] [ASC | DESC]



If orderby_list is not specified or if _ASC_
or _DESC_ is not specified, _ASC_ (ascending order) is assumed.

{empty}If the ordering element is not
specified for an entity association, ordering by the primary key of the
associated entity is assumed.link:#a19654[118]

A property or field name specified as an
_orderby_item_ must correspond to a basic persistent property or field
of the associated class or embedded class within it. The properties or
fields used in the ordering must correspond to columns for which
comparison operators are supported.

The dot (".") notation is used to refer to an
attribute within an embedded attribute. The value of each identifier
used with the dot notation is the name of the respective embedded field
or property.

The _OrderBy_ annotation may be applied to an
element collection. When _OrderBy_ is applied to an element collection
of basic type, the ordering will be by value of the basic objects and
the _property_or_field_name_ is not used.link:#a19655[119] When
specifying an ordering over an element collection of embeddable type,
the dot notation must be used to specify the attribute or attributes
that determine the ordering.

The _OrderBy_ annotation is not used when an
order column is specified. See section link:Per.html#a15873[See
OrderColumn Annotation].

Table link:Per.html#a15828[See OrderBy
Annotation Elements] lists the annotation elements that may be specified
for the _OrderBy_ annotation.

===

image:Per-5.png[image]

[[a15828]]OrderBy Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |value
|(Optional) The list of attributes
(optionally qualified with ASC or DESC) whose values are used in the
ordering. |Ascending ordering by the primary
key.
|===

 _Example 1:_

@Entity public class Course \{

 ...

 @ManyToMany

 @OrderBy("lastname ASC")

 public List<Student> getStudents() \{...};

 ...

}



 _Example 2:_

@Entity public class Student \{

 ...

 @ManyToMany(mappedBy="students")

 @OrderBy // PK is assumed

 public List<Course> getCourses() \{...};

 ...

}



 _Example 3:_

@Entity public class Person \{

 ...

 @ElementCollection

 @OrderBy("zipcode.zip, zipcode.plusFour")

 public Set<Address> getResidences() \{...};

 ...

}



@Embeddable public class Address \{

 protected String street;

 protected String city;

 protected String state;

 @Embedded protected Zipcode zipcode;

}



@Embeddable public class Zipcode \{

 protected String zip;

 protected String plusFour;

}

==== [[a15873]]OrderColumn Annotation

{empty}The _OrderColumn_ annotation specifies
a column that is used to maintain the persistent order of a list. The
persistence provider is responsible for maintaining the order upon
retrieval and in the database. The persistence provider is responsible
for updating the ordering upon flushing to the database to reflect any
insertion, deletion, or reordering affecting the list. The _OrderColumn_
annotation may be specified on a one-to-many or many-to-many
relationship or on an element collection. The _OrderColumn_ annotation
is specified on the side of the relationship that references the
collection that is to be ordered. The order column is not visible as
part of the state of the entity or embeddable
class.link:#a19656[120]

The _OrderBy_ annotation is not used when
_OrderColumn_ is specified.

link:Per.html#a15888[See OrderColumn
Annotation Elements] lists the annotation elements that may be specified
for the _OrderColumn_ annotation and their default values.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface OrderColumn \{

 String name() default "";

 boolean nullable() default true;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

}

If _name_ is not specified, the column name
is the concatenation of the following: the name of the referencing
relationship property or field of the referencing entity or embeddable
class; " ___ "; " _ORDER_ ".

The order column must be of integral type.
The persistence provider must maintain a contiguous (non-sparse)
ordering of the values of the order column when updating the association
or element collection. The order column value for the first element of
the list must be 0.

===

image:Per-5.png[image]

[[a15888]]OrderColumn Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the ordering column.
|The concatenation of the name of the
referencing property or field; " ___ "; " _ORDER_ ".

|boolean |nullable
|(Optional) Whether the database column is
nullable. |true

|boolean
|insertable
|(Optional) Whether the column is included in
SQL INSERT statements generated by the persistence provider.
|true

|boolean
|updatable
|(Optional) Whether the column is included in
SQL UPDATE statements generated by the persistence provider.
|true

|String
|columnDefinition
|(Optional) The SQL fragment that is used
when generating the DDL for the column.
|Generated SQL to create a column of the
inferred type.
|===

 _Example 1:_

@Entity

public class CreditCard \{



 @Id long ccNumber;



 @OneToMany // unidirectional

 @OrderColumn

 List<CardTransaction> transactionHistory;

 ...

}



 _Example 2:_

@Entity public class Course \{

 ...

 @ManyToMany

 @JoinTable(name="COURSE_ENROLLMENT")

 public Set<Student> getStudents() \{...};

 ...

 @ManyToMany // unidirectional

 @JoinTable(name="WAIT_LIST")

 @OrderColumn(name="WAITLIST_ORDER")

 public List<Student> getWaitList() \{...}

}



@Entity public class Student \{

 ...

 @ManyToMany(mappedBy="students")

 public Set<Course> getCourses() \{...};

 ...

}



 __

 _Example of querying the ordered list:_

SELECT w

FROM course c JOIN c.waitlist w

WHERE c.name = "geometry" AND INDEX(w) = 0

==== [[a15947]]PrimaryKeyJoinColumn Annotation

The _PrimaryKeyJoinColumn_ annotation
specifies a primary key column that is used as a foreign key to join to
another table.

The _PrimaryKeyJoinColumn_ annotation is used
to join the primary table of an entity subclass in the JOINED mapping
strategy to the primary table of its superclass; it is used within a
_SecondaryTable_ annotation to join a secondary table to a primary
table; and it may be used in a _OneToOne_ mapping in which the primary
key of the referencing entity is used as a foreign
keylink:#a19657[121] to the referenced
entitylink:#a19658[122].

The _foreignKey_ element is used to specify
or control the generation of a foreign key constraint for the primary
key join column when table generation is in effect. If the _foreignKey_
element is not specified, the persistence provider’s default foreign key
strategy will apply.

link:Per.html#a15962[See
PrimaryKeyJoinColumn Annotation Elements] lists the annotation elements
that may be specified for the _PrimaryKeyJoinColumn_ annotation and
their default values.

If no _PrimaryKeyJoinColumn_ annotation is
specified for a subclass in the JOINED mapping strategy, the foreign key
columns are assumed to have the same names as the primary key columns of
the primary table of the superclass.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

@Repeatable(PrimaryKeyJoinColumns.class)

public @interface _PrimaryKeyJoinColumn_ \{

 String name() default "";

 String referencedColumnName() default "";

 String columnDefinition() default "";

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

}

===

image:Per-5.png[image]

[[a15962]]PrimaryKeyJoinColumn Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the primary key
column of the current table. |The same name
as the primary key column of the primary table of the superclass (JOINED
mapping strategy); the same name as the primary key column of the
primary table (SecondaryTable mapping); or the same name as the primary
key column for the table for the referencing entity (OneToOne mapping).

|String
|referencedColumnName
|(Optional) The name of the primary key
column of the table being joined to. |The
same name as the primary key column of the primary table of the
superclass (JOINED mapping strategy); the same name as the primary key
column of the primary table (SecondaryTable mapping); or the same name
as the primary key column of the table for the referenced entity
(OneToOne mapping).

|String
|columnDefinition
|(Optional) The SQL fragment that is used
when generating the DDL for the column. This should not be specified for
a OneToOne primary key association.
|Generated SQL to create a column of the
inferred type.

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint
specification for the join column. This is used only if table generation
is in effect. |Provider’s default
|===

 _Example:_ Customer and ValuedCustomer
subclass

@Entity

@Table(name="CUST")

@Inheritance(strategy=JOINED)

@DiscriminatorValue("CUST")

public class Customer \{ ... }



@Entity

@Table(name="VCUST")

@DiscriminatorValue("VCUST")

@ _PrimaryKeyJoinColumn_ (name="CUST_ID")

public class ValuedCustomer extends Customer
\{ ... }

==== PrimaryKeyJoinColumns Annotation

Composite foreign keys are supported by means
of the _PrimaryKeyJoinColumns_ annotation. The _PrimaryKeyJoinColumns_
annotation groups _PrimaryKeyJoinColumn_ annotations.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

public @interface _PrimaryKeyJoinColumns_ \{

 _PrimaryKeyJoinColumn_ [] value();

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

}



The _foreignKey_ element is used to specify
or control the generation of a foreign key constraint for the columns
corresponding to the _PrimaryKeyJoinColumn_ elements referenced by the
_value_ element when table generation is in effect. If both this element
and the _foreignKey_ element of any of the _PrimaryKeyJoinColumn_
elements are specified, the behavior is undefined. If no _foreignKey_
annotation element is specified in either location, the persistence
provider's default foreign key strategy will apply.

Table link:Per.html#a16004[See
PrimaryKeyJoinColumns Annotation Elements] lists the annotation elements
that may be specified for the _PrimaryKeyJoinColumns_ annotation.

===

image:Per-5.png[image]

[[a16004]]PrimaryKeyJoinColumns Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|PrimaryKeyJoinColumn[]
|value |(Required)
The primary key join columns. |

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint
specification for the join columns. This is used only if table
generation is in effect. |Provider’s default
|===

 _Example 1:_ ValuedCustomer subclass

@Entity

@Table(name="VCUST")

@DiscriminatorValue("VCUST")

@ _PrimaryKeyJoinColumns_ (\{

 @ _PrimaryKeyJoinColumn_ (name="CUST_ID",

 referencedColumnName="ID"),

 @ _PrimaryKeyJoinColumn_ (name="CUST_TYPE",

 referencedColumnName="TYPE")

})

public class ValuedCustomer extends Customer
\{ ... }

{empty} _Example 2:_ OneToOne relationship
between Employee and EmployeeInfo classes.link:#a19659[123]

public class EmpPK \{

 public Integer id;

 public String name;

}



@Entity

@IdClass(com.acme.EmpPK.class)

public class Employee \{



 @Id Integer id;

 @Id String name;



 @OneToOne

 @PrimaryKeyJoinColumns(\{

 @PrimaryKeyJoinColumn(name="ID",

 referencedColumnName="EMP_ID"),

 @PrimaryKeyJoinColumn(name="NAME",

 referencedColumnName="EMP_NAME")})

 EmployeeInfo info;



 ...

}



@Entity

@IdClass(com.acme.EmpPK.class)

public class EmployeeInfo \{



 @Id @Column(name="EMP_ID")

 Integer id;

 @Id @Column(name="EMP_NAME")

 String name;



 ...

}



==== [[a16062]]SecondaryTable Annotation

The _SecondaryTable_ annotation is used to
specify a secondary table for the annotated entity class.

If no _SecondaryTable_ annotation is
specified, it is assumed that all persistent fields or properties of the
entity are mapped to the primary table. Specifying one or more secondary
tables indicates that the data for the entity class is stored across
multiple tables.

link:Per.html#a16082[See
SecondaryTable Annotation Elements] lists the annotation elements that
may be specified for the _SecondaryTable_ annotation and their default
values.

If no primary key join columns are specified,
the join columns are assumed to reference the primary key columns of the
primary table, and have the same names and types as the referenced
primary key columns of the primary table.

The _foreignKey_ element is used to specify
or control the generation of a foreign key constraint for the columns
corresponding to the _pkJoinColumns_ element when table generation is in
effect. If both this element and the _foreignKey_ element of any of the
_pkJoinColumns_ elements are specified, the behavior is undefined. If no
_foreignKey_ annotation element is specified in either location, the
persistence provider's default foreign key strategy will apply.

@Target(\{TYPE}) @Retention(RUNTIME)

@Repeatable(SecondaryTables.class)

public @interface SecondaryTable \{

 String name();

 String catalog() default "";

 String schema() default "";

 PrimaryKeyJoinColumn[] pkJoinColumns()
default \{};

 ForeignKey foreignKey() default
@ForeignKey(PROVIDER_DEFAULT);

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

}





===

image:Per-5.png[image]

[[a16082]]SecondaryTable Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Required) The name of the table.
|

|String |catalog
|(Optional) The catalog of the table.
|Default catalog

|String |schema
|(Optional) The schema of the table.
|Default schema for user

|PrimaryKeyJoinColumn[]
|pkJoinColumns
|(Optional) The columns that are used to join
with the primary table. |Column(s) of the
same name(s) as the primary key column(s) in the primary table

|ForeignKey
|foreignKey
|(Optional) The foreign key constraint for
the join column. This is used only if table generation is in effect.
|Provider’s default

|UniqueConstraint[]
|uniqueConstraints
|(Optional) Unique constraints that are to be
placed on the table. These are typically only used if table generation
is in effect. These constraints apply in addition to any constraints
specified by the Column and JoinColumn annotations and constraints
entailed by primary key mappings. |No
additional constraints

|Index[] |indexes
|(Optional) Indexes for the table. These are
only used if table generation is in effect.
|No additional indexes
|===

 _Example 1:_ Single secondary table with a
single primary key column.

@Entity

@Table(name="CUSTOMER")

@SecondaryTable(

 name="CUST_DETAIL",


pkJoinColumns=@PrimaryKeyJoinColumn(name="CUST_ID")

)

public class Customer \{ ... }

 _Example 2:_ Single secondary table with
multiple primary key columns.

@Entity

@Table(name="CUSTOMER")

@SecondaryTable(

 name="CUST_DETAIL",

 pkJoinColumns=\{

 @PrimaryKeyJoinColumn(name="CUST_ID"),

 @PrimaryKeyJoinColumn(name="CUST_TYPE")

})

public class Customer \{ ... }

==== SecondaryTables Annotation

The _SecondaryTables_ annotation can be used
to specify multiple secondary tables for an entity.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface SecondaryTables \{

 SecondaryTable[] value();

}

Table link:Per.html#a16136[See
SecondaryTables Annotation Elements] lists the annotation elements that
may be specified for the _SecondaryTables_ annotation.

===

image:Per-5.png[image]

[[a16136]]SecondaryTables Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|SecondaryTable[]
|value |(Required)
The secondary tables that are used to map the entity class.
|
|===

 _Example 1:_ Multiple secondary tables
assuming primary key columns are named the same in all tables.

@Entity

@Table(name="EMPLOYEE")

@SecondaryTables(\{

 @SecondaryTable(name="EMP_DETAIL"),

 @SecondaryTable(name="EMP_HIST")

})

public class Employee \{ ... }



 _Example 2:_ Multiple secondary tables with
differently named primary key columns.

@Entity

@Table(name="EMPLOYEE")

@SecondaryTables(\{

 @SecondaryTable(

 name="EMP_DETAIL",


pkJoinColumns=@PrimaryKeyJoinColumn(name="EMPL_ID")),

 @SecondaryTable(

 name="EMP_HIST",


pkJoinColumns=@PrimaryKeyJoinColumn(name="EMPLOYEE_ID"))

})

public class Employee \{ ... }

==== [[a16164]]SequenceGenerator Annotation

The _SequenceGenerator_ annotation defines a
primary key generator that may be referenced by name when a generator
element is specified for the _GeneratedValue_ annotation. A sequence
generator may be specified on the entity class or on the primary key
field or property. The scope of the generator name is global to the
persistence unit (across all generator types).

link:Per.html#a16179[See
SequenceGenerator Annotation Elements] lists the annotation elements
that may be specified for the _SequenceGenerator_ annotation and their
default values.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

@Repeatable(SequenceGenerators.class)

public @interface SequenceGenerator \{

 String name();

 String sequenceName() default "";

 String catalog() default "";

 String schema() default "";

 int initialValue() default 1;

 int allocationSize() default 50;

}



===

image:Per-5.png[image]

[[a16179]]SequenceGenerator Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Required) A unique generator name that can
be referenced by one or more classes to be the generator for primary key
values. |

|String
|sequenceName
|(Optional) The name of the database sequence
object from which to obtain primary key values.
|A provider- chosen value

|String |catalog
|(Optional) The catalog of the sequence
generator. |Default catalog

|String |schema
|(Optional) The schema of the sequence
generator. |Default schema for user

|int |initialValue
|(Optional) The value from which the sequence
object is to start generating. |1

|int
|allocationSize
|(Optional) The amount to increment by when
allocating sequence numbers from the sequence.
|50
|===

 _Example:_

@SequenceGenerator(name="EMP_SEQ",
allocationSize=25)

==== [[a16205]]SequenceGenerators Annotation

The SequenceGenerators annotation can be used
to specify multiple sequence generators.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

public @interface SequenceGenerators \{

 SequenceGenerator[] value();

}

===

image:Per-5.png[image]

SequenceGenerators Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|SequenceGenerator[]
|value |(Required)
The sequence generator mappings |
|===

==== Table Annotation

{empty}The _Table_ annotation specifies the
primary table for the annotated entity. Additional tables may be
specified by using the _SecondaryTable_ or _SecondaryTables_
annotation.link:#a19660[124]

link:Per.html#a16232[See Table
Annotation Elements] lists the annotation elements that may be specified
for the _Table_ annotation and their default values.

If no _Table_ annotation is specified for an
entity class, the default values defined in
link:Per.html#a16232[See Table Annotation Elements] apply.

@Target(\{TYPE}) @Retention(RUNTIME)

public @interface Table \{

 String name() default "";

 String catalog() default "";

 String schema() default "";

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

}



===

image:Per-5.png[image]

[[a16232]]Table Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) The name of the table.
|Entity name

|String |catalog
|(Optional) The catalog of the table.
|Default catalog

|String |schema
|(Optional) The schema of the table.
|Default schema for user

|UniqueConstraint[]
|uniqueConstraints
|(Optional) Unique constraints that are to be
placed on the table. These are only used if table generation is in
effect. These constraints apply in addition to any constraints specified
by the Column and JoinColumn annotations and constraints entailed by
primary key mappings. |No additional
constraints

|Index[] |indexes
|(Optional) Indexes for the table. These are
only used if table generation is in effect.
|No additional indexes
|===

 _Example:_

@Entity

@Table(name="CUST", schema="RECORDS")

public class Customer \{ ... }

==== [[a16256]]TableGenerator Annotation

The _TableGenerator_ annotation defines a
primary key generator that may be referenced by name when a generator
element is specified for the _GeneratedValue_ annotation. A table
generator may be specified on the entity class or on the primary key
field or property. The scope of the generator name is global to the
persistence unit (across all generator types).

link:Per.html#a16277[See
TableGenerator Annotation Elements] lists the annotation elements that
may be specified for the _TableGenerator_ annotation and their default
values.

The _table_ element specifies the name of the
table that is used by the persistence provider to store generated
primary key values for entities. An entity type will typically use its
own row in the table for the generation of primary key values. The
primary key values are normally positive integers.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

@Repeatable(TableGenerators.class)

public @interface TableGenerator \{

 String name();

 String table() default "";

 String catalog() default "";

 String schema() default "";

 String pkColumnName() default "";

 String valueColumnName() default "";

 String pkColumnValue() default "";

 int initialValue() default 0;

 int allocationSize() default 50;

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

}



===

image:Per-5.png[image]

TableGenerator Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Required) A unique generator name that can
be referenced by one or more classes to be the generator for primary key
values. |

|String |table
|(Optional) Name of table that stores the
generated primary key values. |Name is chosen
by persistence provider

|String |catalog
|(Optional) The catalog of the table.
|Default catalog

|String |schema
|(Optional) The schema of the table.
|Default schema for user

|String
|pkColumnName
|(Optional) Name of the primary key column in
the table. |A provider-chosen name

|String
|valueColumnName
|(Optional) Name of the column that stores
the last value generated. |A provider-chosen
name

|String
|pkColumnValue
|(Optional) The primary key value in the
generator table that distinguishes this set of generated values from
others that may be stored in the table. |A
provider-chosen value to store in the primary key column of the
generator table

|int |initialValue
|(Optional) The value used to initialize the
column that stores the last value generated.
|0

|int
|allocationSize
|(Optional) The amount to increment by when
allocating numbers from the generator. |50

|UniqueConstraint[]
|uniqueConstraints
|(Optional) Unique constraints that are to be
placed on the table. These are only used if table generation is in
effect. These constraints apply in addition to primary key constraints .
|No additional constraints

|Index[] |indexes
|(Optional) Indexes for the table. These are
only used if table generation is in effect.
|No additional indexes
|===

 _Example 1:_

@Entity public class Employee \{

 ...

 @TableGenerator(

 name="empGen",

 table="ID_GEN",

 pkColumnName="GEN_KEY",

 valueColumnName="GEN_VALUE",

 pkColumnValue="EMP_ID",

 allocationSize=1)

 @Id

 @GeneratedValue(strategy=TABLE,
generator="empGen")

 int id;

 ...

}

 _Example 2:_

@Entity public class Address \{

 ...

 @TableGenerator(

 name="addressGen",

 table="ID_GEN",

 pkColumnName="GEN_KEY",

 valueColumnName="GEN_VALUE",

 pkColumnValue="ADDR_ID")

 @Id

 @GeneratedValue(strategy=TABLE,
generator="addressGen")

 int id;

 ...

}

==== TableGenerators Annotation

The TableGenerators annotation can be used to
specify multiple table generators.

@Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

public @interface TableGenerators \{

 TableGenerator[] value();

}

===

image:Per-5.png[image]

TableGenerators Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|TableGenerator[]
|value |(Required)
The table generator mappings |
|===

==== [[a16361]]Temporal Annotation

The _Temporal_ annotation must be specified
for persistent fields or properties of type _java.util.Date_ and
_java.util.Calendar_ unless a converter is being applied. It may only be
specified for fields or properties of these types.

The _Temporal_ annotation may be used in
conjunction with the _Basic_ annotation, the _Id_ annotation, or the
_ElementCollectionlink:#a19661[125]_ annotation (when the element
collection value is of such a temporal type).

The _TemporalType_ enum defines the mapping
for these temporal types.

public enum TemporalType \{

 DATE, //java.sql.Date

 TIME, //java.sql.Time

 TIMESTAMP //java.sql.Timestamp

}





@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Temporal \{

 TemporalType value();

}

link:Per.html#a16378[See Temporal
Annotation Elements] lists the annotation elements that may be specified
for the _Temporal_ annotation and their default values.

===

image:Per-5.png[image]

[[a16378]]Temporal Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|TemporalType
|value |(Required)
The type used in mapping java.util.Date or java.util.Calendar.
|
|===

 _Example:_

@Embeddable

public class EmploymentPeriod \{

 @Temporal(DATE) java.util.Date startDate;

 @Temporal(DATE) java.util.Date endDate;

 ...

}

==== Transient Annotation

The _Transient_ annotation is used to
annotate a property or field of an entity class, mapped superclass, or
embeddable class. It specifies that the property or field is not
persistent.

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Transient \{}

Example _:_

@Entity

public class Employee \{

 @Id int id;

 @Transient User currentUser;

...

}

==== [[a16403]]UniqueConstraint Annotation

The _UniqueConstraint_ annotation is used to
specify that a unique constraint is to be included in the generated DDL
for a primary or secondary table.

link:Per.html#a16413[See
UniqueConstraint Annotation Elements] lists the annotation elements that
may be specified for the _UniqueConstraint_ annotation.

@Target(\{}) @Retention(RUNTIME)

public @interface UniqueConstraint \{

 String name() default "";

 String[] columnNames();

}



===

image:Per-5.png[image]

[[a16413]]UniqueConstraint Annotation Elements

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Type |Name
|Description
|Default
|String |name
|(Optional) Constraint name.
|A provider-chosen name.

|String[]
|columnNames
|(Required) An array of the column names that
make up the constraint. |
|===

 _Example:_

@Entity

@Table(

 name="EMPLOYEE",

 uniqueConstraints=

 @UniqueConstraint(columnNames=\{"EMP_ID",
"EMP_NAME"})

)

public class Employee \{ ... }

==== [[a16432]]Version Annotation

The _Version_ annotation specifies the
version field or property of an entity class that serves as its
optimistic lock value. The version is used to ensure integrity when
performing the merge operation and for optimistic concurrency control.

Only a single _Version_ property or field
should be used per class; applications that use more than one _Version_
property or field will not be portable.

The _Version_ property should be mapped to
the primary table for the entity class; applications that map the
_Version_ property to a table other than the primary table will not be
portable.

{empty}In general, fields or properties that
are specified with the _Version_ annotation should not be updated by the
application.link:#a19662[126]

The following types are supported for version
properties: _int_ , _Integer_ , _short_ , _Short_ , _long_ , _Long_ ,
_Timestamp_ .

@Target(\{METHOD, FIELD}) @Retention(RUNTIME)

public @interface Version \{}

 _Example:_

@Version

@Column(name="OPTLOCK")

protected int getVersionNum() \{ return
versionNum; }

=== [[a16444]]Object/Relational Metadata Used in Schema Generation

image:Per-4.png[image]

The following annotations and XML elements
define or control the generation of database objects. If schema
generation is in effect, the persistence provider must observe the
mapping information specified by these annotations and their
corresponding XML elements. Unless otherwise specified, all elements of
these annotations are observed in the schema generation process.

 _CollectionTable_

 _Column_

 _DiscriminatorColumn_

 _EmbeddedId_

 _Enumerated, MapKeyEnumerated_

ForeignKey

 _GeneratedValue_

 _Id_

 _Index_

Inheritance

 _JoinColumn_

 _JoinTable_

 _Lob_

 _MapKeyColumn_

 _MapKeyJoinColumn_

 _OrderColumn_

 _PrimaryKeyJoinColumn_

 _SecondaryTable_

 _SequenceGenerator_

 _Table_

 _TableGenerator_

 _Temporal, MapKeyTemporal_

 _UniqueConstraint_

 _Version_



In some cases, these annotations and elements
may be specified explicitly, while in other cases they may be implied by
the default values of other annotations or elements. For example, by
default a table is generated corresponding to an entity and bears the
same name as that assigned to the entity (which in turn may have been
defaulted from the name of the entity class).

The naming of database objects is determined
by the defaulting rules and the explicit names used in annotations
and/or XML. The names of database objects must be treated in conformance
with the requirements of section link:Per.html#a988[See Naming
of Database Objects].

The metadata annotations and corresponding
XML elements that result in generated objects are as follows.

==== Table-level elements

The following annotations (and corresponding
XML elements) specify the creation of tables. The rules for their
naming, columns, and other properties are defined in the referenced
sections of this specification:

===== Table

By default, a table is created for every
top-level entity and, by default, includes columns corresponding to the
basic and embedded attributes of the entity and the foreign keys to the
tables of related entities. These columns include columns that result
from the use of mapped superclasses, if any. The _SecondaryTable_
annotation, in conjunction with the use of the _table_ element of the
_Column_ and _JoinColumn_ annotations, is used to override this mapping
to partition the state of an entity across multiple tables.

The mapping of the columns of a table is
controlled by the _Column_ and _JoinColumn_ annotations. When entity
state is inherited from a mapped superclass, the _AttributeOverride_ and
_AssociationOverride_ annotations may be used to further control the
column-level mapping of inherited state. The ordering of the columns is
not defined by this specification. When it is desirable to control the
ordering of columns, DDL scripts should be provided.

See section link:Per.html#a16205[See
SequenceGenerators Annotation] for additional rules that apply to the
generation of tables. For the treatment of column-level mappings, see
further below.

===== Inheritance

The _Inheritance_ annotation defines the
inheritance strategy for an entity hierarchy. The inheritance strategy
determines whether the table for a top-level entity includes columns for
entities that inherit from the entity and whether it includes a
discriminator column, or whether separate tables are created for each
entity type that inherits from the top-level entity. See sections
link:Per.html#a966[See Inheritance Mapping Strategies] and
link:Per.html#a14891[See Inheritance Annotation] for rules
pertaining to the treatment of entity inheritance.

===== SecondaryTable

A secondary table is created to partition the
mapping of entity state across multiple tables. See section
link:Per.html#a16062[See SecondaryTable Annotation] for the rules
that apply to the generation of secondary tables.

===== CollectionTable

A collection table is created for the mapping
of an element collection. See section link:Per.html#a14250[See
CollectionTable Annotation] for the rules that apply to the generation
of collection tables. The _Column_ , _AttributeOverride_ , and
_AssociationOverride_ annotations may be used to override
_CollectionTable_ mappings, as described in sections
link:Per.html#a14330[See Column Annotation],
link:Per.html#a14084[See AttributeOverride Annotation], and
link:Per.html#a13942[See AssociationOverride Annotation]
respectively.

===== JoinTable

By default, join tables are created for the
mapping of many-to-many relationships and unidirectional one-to-many
relationships. See sections link:Per.html#a708[See
Bidirectional ManyToMany Relationships], link:Per.html#a764[See
Unidirectional OneToMany Relationships], and
link:Per.html#a800[See Unidirectional ManyToMany Relationships]
for the defaults that apply in such cases. Join tables may also be used
to map bidirectional many-to-one/one-to-many associations,
unidirectional many-to-one relationships, and one-to-one relationships
(both bidirectional and unidirectional). See section
link:Per.html#a15022[See JoinTable Annotation] for the rules that
apply to the generation of join tables. The _AssociationOverride_
annotation may be used to override join table mappings.

===== TableGenerator

Table generator tables are used to store
generated primary key values. See section
link:Per.html#a16256[See TableGenerator Annotation] for the rules
pertaining to table generators.

==== Column-level elements

The following annotations and corresponding
XML elements control the mapping of columns in generated tables.

The exact mapping of Java language types to
database-specific types is not defined by this specification, as
databases vary in the specific types that they support. In general,
however, an implementation of this specification should conform to the
“Standard Mapping from Java Types to JDBC Types” as defined by the JDBC
specification link:Per.html#a19496[See JDBC 4.2 Specification.
http://jcp.org/en/jsr/detail?id=221.]. Unless otherwise explicitly
specified, however, VARCHAR and VARBINARY mappings should be used in
preference to CHAR and BINARY mappings. Applications that are sensitive
to the exact database mappings that are generated should use the
_columnDefinition_ element of the _Column_ annotation or include DDL
files that specify how the database schema is to be generated.

===== Column

The following elements of the _Column_
annotation are used in schema generation:

 _name_

 _unique_

 _nullable_

 _columnDefinition_

 _table_

 _length_ (string-valued columns only)

 _precision_ (exact numeric (decimal/numeric)
columns only)

 _scale_ (exact numeric (decimal/numeric)
columns only)

See section link:Per.html#a14330[See
Column Annotation] for the rules that apply to these elements and column
creation. The _AttributeOverride_ annotation may be used to override
column mappings.

===== MapKeyColumn

The _MapKeyColumn_ annotation specifies the
mapping for a key column of a map when the key is of basic type. The
following elements of the _MapKeyColumn_ annotation are used in schema
generation:

 _name_

 _unique_

 _nullable_

 _columnDefinition_

 _table_

 _length_ (string-valued columns only)

 _precision_ (exact numeric (decimal/numeric)
columns only)

 _scale_ (exact numeric (decimal/numeric)
columns only)

See section link:Per.html#a15367[See
MapKeyColumn Annotation] for the rules that apply to these elements and
map key column creation. The _AttributeOverride_ annotation may be used
to override map key column mappings.

===== Enumerated, MapKeyEnumerated

The _Enumerated_ and _MapKeyEnumerated_
annotations control whether string- or integer-valued columns are
generated for basic attributes of enumerated types and therefore impact
the default column mappings for these types. See sections
link:Per.html#a14719[See Enumerated Annotation] and
link:Per.html#a15433[See MapKeyEnumerated Annotation]. The
_Column_ and _MapKeyColumn_ annotations may be used to further control
the column mappings for attributes of enumerated types.

===== Temporal, MapKeyTemporal

The _Temporal_ and _MapKeyTemporal_
annotations control whether date-, time-, or timestamp-value columns are
generated for basic attributes of temporal types, and therefore impact
the default column mappings for these types. See sections
link:Per.html#a16361[See Temporal Annotation] and
link:Per.html#a15583[See MapKeyTemporal Annotation]. The _Column_
and _MapKeyColumn_ annotations may be used to further control the column
mappings for attributes of temporal types.

===== Lob

The _Lob_ annotation specifies that a
persistent attribute is to be persisted to a database large object type.
See section link:Per.html#a15087[See Lob Annotation]. In general,
however, the treatment of the _Lob_ annotation is provider-dependent.
Applications that are sensitive to the exact mapping that is used should
use the _columnDefinition_ element of the _Column_ annotation or include
DDL files that specify how the database schema is to be generated.

===== OrderColumn

The _OrderColumn_ annotation specifies the
generation of a column that is used to maintain the persistent ordering
of a list that is represented in an element collection, one-to-many, or
many-to-many relationship.

The following elements of the _OrderColumn_
annotation are used in schema generation:

 _name_

 _nullable_

 _columnDefinition_

See section link:Per.html#a15873[See
OrderColumn Annotation] for the rules that pertain to the generation of
order columns.

===== DiscriminatorColumn

A discriminator column is generated for the
SINGLE_TABLE mapping strategy and may optionally be generated by the
provider for use with the JOINED inheritance strategy. The
_DiscriminatorColumn_ annotation may be used to control the mapping of
the discriminator column. See section link:Per.html#a14530[See
DiscriminatorColumn Annotation] for the rules that pertain to
discriminator columns.

===== Version

The _Version_ annotation specifies the
generation of a column to serve as an entity's optimistic lock. See
section link:Per.html#a16432[See Version Annotation] for rules
that pertain to the version column. The _Column_ annotation may be used
to further control the column mapping for a version attribute.

==== Primary Key mappings

Primary keys may be represented by basic or
embedded attributes and/or may correspond to foreign key attributes. The
_Id_ and _EmbeddedId_ annotations define attributes whose corresponding
columns are the constituents of database primary keys.

===== Id

The _Id_ annotation (which may be used used
in conjunction with the _IdClass_ annotation) is used to specify
attributes whose database columns correspond to a primary key. Use of
the _Id_ annotation results in the creation of a primary key consisting
of the corresponding column or columns. Rules for the _Id_ annotation
are described in sections link:Per.html#a14827[See Id Annotation]
and link:Per.html#a132[See Primary Keys and Entity Identity].

The _Column_ annotation may be used to
further control the column mapping for an _Id_ attribute that is applied
to a basic type. If the _Id_ column was defined in a mapped superclass,
the _AttributeOverride_ annotation may be used to control the column
mapping.

The _JoinColumn_ annotation may be used to
further control the column mappings for an _Id_ attribute that is
applied to a relationship that corresponds to a foreign key. If the _Id_
attribute was defined in a mapped superclass, the _AssociationOverride_
annotation may be used to control the column mapping.

===== EmbeddedId

The _EmbeddedId_ annotation specifies an
embedded attribute whose corresponding columns correspond to a database
primary key. Use of the _EmbeddedId_ annotation results in the creation
of a primary key consisting of the corresponding columns. Rules for the
_EmbeddedId_ annotation are described in sections
link:Per.html#a14687[See EmbeddedId Annotation] and
link:Per.html#a132[See Primary Keys and Entity Identity].

The _Column_ annotation may be used to
control the column mapping for an embeddable class. If the _EmbeddedId_
attribute is defined in a mapped superclass, the _AttributeOverride_
annotation may be used to control the column mappings.

If an _EmbeddedId_ attribute corresponds to a
relationship attribute, the _MapsId_ annotation must be used, and the
column mapping is determined by the join column for the relationship.
See section link:Per.html#a149[See Primary Keys Corresponding
to Derived Identities].

===== GeneratedValue

The _GeneratedValue_ annotation indicates a
primary key whose value is to be generated by the provider. If a
strategy is indicated, the provider must use it if it is supported by
the target database. Note that specification of the AUTO strategy may
result in the provider creating a database object for Id generation
(e.g., a database sequence). Rules for the _GeneratedValue_ annotation
are described in link:Per.html#a14790[See GeneratedValue
Annotation]. The _GeneratedValue_ annotation may only be portably used
for simple (i.e., non-composite) primary keys.

==== Foreign Key Column Mappings

===== JoinColumn

The _JoinColumn_ annotation is typically used
in specifying a foreign key mapping. In general, the foreign key
definitions created will be provider-dependent and database-dependent.
Applications that are sensitive to the exact mapping that is used should
use the _foreignKey_ element of the _JoinColumn_ annotation or include
DDL files that specify how the database schemas are to be generated.

The following elements of the _JoinColumn_
annotation are used in schema generation:

 _name_

 _referencedColumnName_

 _unique_

 _nullable_

 _columnDefinition_

 _table_

 _foreignKey_

See section link:Per.html#a14922[See
JoinColumn Annotation] for rules that apply to these elements and join
column creation, and sections link:Per.html#a538[See
Relationship Mapping Defaults] and link:Per.html#a14250[See
CollectionTable Annotation] for the rules that apply for the default
mappings of foreign keys for relationships and element collections. The
_AssociationOverride_ annotation may be used to override relationship
mappings. The _PrimaryKeyJoinColumn_ annotation is used to join
secondary tables and may be used in the mapping of one-to-one
relationships. See section link:Per.html#a16567[See
PrimaryKeyJoinColumn] below.

===== MapKeyJoinColumn

The _MapKeyJoinColumn_ annotation is to
specify foreign key mappings to entities that are map keys in map-valued
element collections or relationships. In general, the foreign key
definitions created should be expected to be provider-dependent and
database-dependent. Applications that are sensitive to the exact mapping
that is used should use the _foreignKey_ element of the
_MapKeyJoinColumn_ annotation or include DDL files that specify how the
database schemas are to be generated.

The following elements of the
_MapKeyJoinColumn_ annotation are used in schema generation:

 _name_

 _referencedColumnName_

 _unique_

 _nullable_

 _columnDefinition_

 _table_

 _foreignKey_

See section link:Per.html#a15450[See
MapKeyJoinColumn Annotation] for rules that apply to these elements and
map key join column creation. The _AssociationOverride_ annotation may
be used to override such mappings.

===== [[a16567]]PrimaryKeyJoinColumn

The _PrimaryKeyJoinColumn_ annotation
specifies that a primary key column is to be used as a foreign key. This
annotation is used in the specification of the JOINED mapping strategy
and for joining a secondary table to a primary table in a OneToOne
relationship mapping. In general, the foreign key definitions created
should be expected to be provider-dependent and database-dependent.
Applications that are sensitive to the exact mapping that is used should
use the _foreignKey_ element of the _PrimaryKeyJoinColumn_ annotation or
include DDL files that specify how the database schemas are to be
generated. See sections link:Per.html#a15947[See
PrimaryKeyJoinColumn Annotation] for rules pertaining to the
_PrimaryKeyJoinColumn_ annotation.

===== ForeignKey

The _ForeignKey_ annotation may be used
within the _JoinColumn_ , _JoinColumns_ , _MapKeyJoinColumn_ ,
_MapKeyJoinColumns_ , _PrimaryKeyJoinColumn_ , _PrimaryKeyJoinColumns_ ,
_CollectionTable_ , _JoinTable_ , _SecondaryTable_ , and
_AssociationOverride_ annotations to specify or override a foreign key
constraint. See section link:Per.html#a14754[See ForeignKey
Annotation].

==== Other Elements

===== SequenceGenerator

The _SequenceGenerator_ annotation creates a
database sequence to be used for Id generation. The use of generators is
limited to those databases that support them. See section
link:Per.html#a16164[See SequenceGenerator Annotation].

===== Index

The _Index_ annotation generates an index
consisting of the specified columns. The ordering of the names in the
_columnList_ element specified in the _Index_ annotation must be
observed by the provider when creating the index. See section
link:Per.html#a14862[See Index Annotation].

===== UniqueConstraint

The _UniqueConstraint_ annotation generates a
unique constraint for the given table. Databases typically implement
unique constraints by creating unique indexes. The ordering of the
_columnNames_ specified in the _UniqueConstraint_ annotation must be
observed by the provider when creating the constraint. See section
link:Per.html#a16403[See UniqueConstraint Annotation]. The
_unique_ element of the _Column_ , _JoinColumn_ , _MapKeyColumn_ , and
_MapKeyJoinColumn_ annotations is equivalent to the use of the
_UniqueConstraint_ annotation when only one column is to be included in
the constraint.

=== Examples of the Application of Annotations for Object/Relational Mapping

image:Per-4.png[image]

==== Examples of Simple Mappings



@Entity

public class Customer \{



 @Id @GeneratedValue(strategy=AUTO) Long id;

 @Version protected int version;

 @ManyToOne Address address;

 @Basic String description;


@OneToMany(targetEntity=com.acme.Order.class,

 mappedBy="customer")

 Collection orders = new Vector();

 @ManyToMany(mappedBy="customers")

 Set<DeliveryService> serviceOptions = new
HashSet();



 public Long getId() \{ return id; }



 public Address getAddress() \{ return
address; }

 public void setAddress(Address addr) \{

 this.address = addr;

 }



 public String getDescription() \{ return
description; }

 public void setDescription(String desc) \{

 this.description = desc;

 }



 public Collection getOrders() \{ return
orders; }



 public Set<DeliveryService>
getServiceOptions() \{

 return serviceOptions;

 }

}





@Entity

public class Address \{



 private Long id;

 private int version;

 private String street;



 @Id @GeneratedValue(strategy=AUTO)

 public Long getId() \{ return id; }

 protected void setId(Long id) \{ this.id =
id; }



 @Version

 public int getVersion() \{ return version; }

 protected void setVersion(int version) \{

 this.version = version;

 }



 public String getStreet() \{ return street;
}

 public void setStreet(String street) \{

 this.street = street;

 }

}





@Entity

public class Order \{



 private Long id;

 private int version;

 private String itemName;

 private int quantity;

 private Customer cust;



 @Id @GeneratedValue(strategy=AUTO)

 public Long getId() \{ return id; }

 public void setId(Long id) \{ this.id = id;
}



 @Version

 protected int getVersion() \{ return
version; }

 protected void setVersion(int version) \{

 this.version = version;

 }



 public String getItemName() \{ return
itemName; }

 public void setItemName(String itemName) \{

 this.itemName = itemName;

 }



 public int getQuantity() \{ return quantity;
}

 public void setQuantity(int quantity) \{

 this.quantity = quantity;

 }



 @ManyToOne

 public Customer getCustomer() \{ return
cust; }

 public void setCustomer(Customer cust) \{

 this.cust = cust;

 }

}





@Entity

@Table(name="DLVY_SVC")

public class DeliveryService \{



 private String serviceName;

 private int priceCategory;

 private Collection customers;



 @Id

 public String getServiceName() \{ return
serviceName; }

 public void setServiceName(String
serviceName) \{

 this.serviceName = serviceName;

 }



 public int getPriceCategory() \{ return
priceCategory; }

 public void setPriceCategory(int
priceCategory) \{

 this.priceCategory = priceCategory;

 }




@ManyToMany(targetEntity=com.acme.Customer.class)

 @JoinTable(name="CUST_DLVRY")

 public Collection getCustomers() \{ return
customers; }

 public setCustomers(Collection customers) \{

 this.customers = customers;

 }

}

==== A More Complex Example



/***** Employee class *****/



@Entity

@Table(name="EMPL")

@SecondaryTable(name="EMP_SALARY",


pkJoinColumns=@PrimaryKeyJoinColumn(name="EMP_ID",

 referencedColumnName="ID"))

public class Employee implements Serializable
\{



 private Long id;

 private int version;

 private String name;

 private Address address;

 private Collection phoneNumbers;

 private Collection<Project> projects;

 private Long salary;

 private EmploymentPeriod period;



 @Id @GeneratedValue(strategy=TABLE)

 public Integer getId() \{ return id; }

 protected void setId(Integer id) \{ this.id
= id; }



 @Version

 @Column(name="EMP_VERSION", nullable=false)

 public int getVersion() \{ return version; }

 protected void setVersion(int version) \{

 this.version = version;

 }



 @Column(name="EMP_NAME", length=80)

 public String getName() \{ return name; }

 public void setName(String name) \{
this.name = name; }



 @ManyToOne(cascade=PERSIST, optional=false)

 @JoinColumn(name="ADDR_ID",

 referencedColumnName="ID", nullable=false)

 public Address getAddress() \{ return
address; }

 public void setAddress(Address address) \{

 this.address = address;

 }




@OneToMany(targetEntity=com.acme.PhoneNumber.class,

 cascade=ALL, mappedBy="employee")

 public Collection getPhoneNumbers() \{
return phoneNumbers; }

 public void setPhoneNumbers(Collection
phoneNumbers) \{

 this.phoneNumbers = phoneNumbers;

 }



 @ManyToMany(cascade=PERSIST,
mappedBy="employees")

 @JoinTable(

 name="EMP_PROJ",

 joinColumns=@JoinColumn(

 name="EMP_ID", referencedColumnName="ID"),

 inverseJoinColumns=@JoinColumn(

 name="PROJ_ID", referencedColumnName="ID"))

 public Collection<Project> getProjects() \{
return projects; }

 public void setProjects(Collection<Project>
projects) \{

 this.projects = projects;

 }



 @Column(name="EMP_SAL", table="EMP_SALARY")

 public Long getSalary() \{ return salary; }

 public void setSalary(Long salary) \{

 this.salary = salary;

 }



 @Embedded

 @AttributeOverrides(\{

 @AttributeOverride(name="startDate",

 column=@Column(name="EMP_START")),

 @AttributeOverride(name="endDate",

 column=@Column(name="EMP_END"))

 })

 public EmploymentPeriod
getEmploymentPeriod() \{

 return period;

 }

 public void
setEmploymentPeriod(EmploymentPeriod period) \{

 this.period = period;

 }

}





/***** Address class *****/



@Entity

public class Address implements Serializable
\{



 private Integer id;

 private int version;

 private String street;

 private String city;



 @Id @GeneratedValue(strategy=IDENTITY)

 public Integer getId() \{ return id; }

 protected void setId(Integer id) \{ this.id
= id; }



 @Version @Column(name="VERS",
nullable=false)

 public int getVersion() \{ return version; }

 protected void setVersion(int version) \{

 this.version = version;

 }



 @Column(name="RUE")

 public String getStreet() \{ return street;
}

 public void setStreet(String street) \{

 this.street = street;

 }



 @Column(name="VILLE")

 public String getCity() \{ return city; }

 public void setCity(String city) \{
this.city = city; }

}



/***** PhoneNumber class *****/



@Entity

@Table(name="PHONE")

public class PhoneNumber implements
Serializable \{



 private String number;

 private int phoneType;

 private Employee employee;



 @Id

 public String getNumber() \{ return number;
}

 public void setNumber(String number) \{

 this.number = number;

 }



 @Column(name="PTYPE")

 public int getPhonetype() \{ return
phonetype; }

 public void setPhoneType(int phoneType) \{

 this.phoneType = phoneType;

 }



 @ManyToOne(optional=false)

 @JoinColumn(name="EMP_ID", nullable=false)

 public Employee getEmployee() \{ return
employee; }

 public void setEmployee(Employee employee)
\{

 this.employee = employee;

 }

}





/***** Project class *****/



@Entity

@Inheritance(strategy=JOINED)

@DiscriminatorValue("Proj")

@DiscriminatorColumn(name="DISC")

public class Project implements Serializable
\{



 private Integer projId;

 private int version;

 private String name;

 private Set<Employee> employees;



 @Id @GeneratedValue(strategy=TABLE)

 public Integer getId() \{ return projId; }

 protected void setId(Integer id) \{
this.projId = id; }



 @Version

 public int getVersion() \{ return version; }

 protected void setVersion(int version) \{
this.version = version; }



 @Column(name="PROJ_NAME")

 public String getName() \{ return name; }

 public void setName(String name) \{
this.name = name; }



 @ManyToMany(mappedBy="projects")

 public Set<Employee> getEmployees() \{
return employees; }

 public void setEmployees(Set<Employee>
employees) \{

 this.employees = employees;

 }

}





/***** GovernmentProject subclass *****/



@Entity

@Table(name="GOVT_PROJECT")

@DiscriminatorValue("GovtProj")

@PrimaryKeyJoinColumn(name="GOV_PROJ_ID",

 referencedColumnName="ID")

public class GovernmentProject extends
Project \{



 private String fileInfo;



 @Column(name="INFO")

 public String getFileInfo() \{ return
fileInfo; }

 public void setFileInfo(String fileInfo) \{

 this.fileInfo = fileInfo;

 }

}





/***** CovertProject subclass *****/



@Entity

@Table(name="C_PROJECT")

@DiscriminatorValue("CovProj")

@PrimaryKeyJoinColumn(name="COV_PROJ_ID",

 referencedColumnName="ID")

public class CovertProject extends Project \{



 private String classified;



 public CovertProject() \{ super(); }



 public CovertProject(String classified) \{

 this();

 this.classified = classified;

 }



 @Column(updatable=false)

 public String getClassified() \{ return
classified; }

 protected void setClassified(String
classified) \{

 this.classified = classified;

 }

}





/***** EmploymentPeriod class *****/



@Embeddable

public class EmploymentPeriod implements
Serializable \{



 private Date start;

 private Date end;



 @Column(nullable=false)

 public Date getStartDate() \{ return start;
}

 public void setStartDate(Date start) \{

 this.start = start;

 }



 public Date getEndDate() \{ return end; }

 public void setEndDate(Date end) \{

 this.end = end;

 }

}

== [[a16944]]XML Object/Relational Mapping Descriptor

The XML object/relational mapping descriptor
serves as both an alternative to and an overriding mechanism for Java
language metadata annotations.

=== Use of the XML Descriptor

image:Per-4.png[image]

The XML schema for the object
relational/mapping descriptor is contained in Section
link:Per.html#a17175[See XML Schema]. The root element of this
schema is the _entity-mappings_ element. The absence or present of the
_xml-mapping-metadata-complete_ subelement contained in the
_persistence-unit-defaults_ subelement of the _entity-mappings_ element
controls whether the XML object/relational mapping descriptor is used to
selectively override annotation values or whether it serves as a
complete alternative to Java language metadata annotations.

If the _xml-mapping-metadata-complete_
subelement is specified, the complete set of mapping metadata for the
persistence unit is contained in the XML mapping files for the
persistence unit, and any persistence annotations on the classes are
ignored.

If _xml-mapping-metadata-complete_ is
specified and XML elements are omitted, the default values apply. These
default values are the same as the corresponding defaults when
annotations are used, except in the cases specified in Section
link:Per.html#a16953[See XML Overriding Rules] below. When the
_xml-mapping-metadata-complete_ element is specified, any
_metadata-complete_ attributes specified within the _entity_ ,
_mapped-superclass_ , and _embeddable_ elements are ignored.

If the _xml-mapping-metadata-complete_
subelement is not specified, the XML descriptor overrides the values set
or defaulted by the use of annotations, as described below.

The mapping files used by the application
developer must conform to the XML schema defined in Section
link:Per.html#a17175[See XML Schema] or to the object/relational
mapping schema defined in a previous version of this specification
link:Per.html#a19493[See JSR-220: Enterprise JavaBeans, v. 3.0.
Java Persistence API. http://jcp.org/en/jsr/detail?id=220.],
link:Per.html#a19501[See JSR-317: Java Persistence 2.0.
http://jcp.org/en/jsr/detail?id=317.].

The Java Persistence persistence provider
must support use of older versions of the object/relational mapping
schema as well as the object/relational mapping schema defined in
Section link:Per.html#a17175[See XML Schema], whether singly or
in combination when multiple mapping files are used.

=== [[a16953]]XML Overriding Rules

image:Per-4.png[image]

This section defines the rules that apply
when the XML descriptor is used to override annotations, and the rules
pertaining to the interaction of XML elements specified as subelements
of the _persistence-unit-defaults_ , _entity-mappings_ , _entity_ ,
_mapped-superclass_ , and _embeddable_ elements.

==== persistence-unit-defaults Subelements

===== schema

The _schema_ subelement applies to all
entities, tables, secondary tables, join tables, collection tables,
table generators, and sequence generators in the persistence unit.

The _schema_ subelement is overridden by any
_schema_ subelement of the _entity-mappings_ element; any _schema_
element explicitly specified in the _Table_ or _SecondaryTable_
annotation on an entity or any _schema_ attribute on any _table_ or
_secondary-table_ subelement defined within an _entity_ element; any
_schema_ element explicitly specified in a _TableGenerator_ annotation
or _table-generator_ subelement; any _schema_ element explicitly
specified in a _SequenceGenerator_ annotation or _sequence-generator_
subelement; any _schema_ element explicitly specified in a _JoinTable_
annotation or _join-table_ subelement; and any _schema_ element
explicitly specified in a _CollectionTable_ annotation or
_collection-table_ subelement.

===== catalog

The _catalog_ subelement applies to all
entities, tables, secondary tables, join tables, collection tables,
table generators, and sequence generators in the persistence unit.

The _catalog_ subelement is overridden by any
_catalog_ subelement of the _entity-mappings_ element; any _catalog_
element explicitly specified in the _Table_ or _SecondaryTable_
annotation on an entity or any _catalog_ attribute on any _table_ or
_secondary-table_ subelement defined within an _entity_ XML element; any
_catalog_ element explicitly specified in a _TableGenerator_ annotation
or _table-generator_ subelement; any _catalog_ element explicitly
specified in a _SequenceGenerator_ annotation or _sequence-generator_
subelement; any _catalog_ element explicitly specified in a _JoinTable_
annotation or _join-table_ subelement; and any _catalog_ element
explicitly specified in a _CollectionTable_ annotation or
_collection-table_ subelement.

===== delimited-identifiers

The _delimited-identifiers_ subelement
applies to the naming of database objects, as described in section
link:Per.html#a988[See Naming of Database Objects]. It
specifies that all database table-, schema-, and column-level
identifiers in use for the persistence unit be treated as delimited
identifiers.

The _delimited-identifiers_ subelement cannot
be overridden in this release.

===== access

The _access_ subelement applies to all
managed classes in the persistence unit.

The _access_ subelement is overridden by the
use of any annotations specifying mapping information on the fields or
properties of the entity class; by any _Access_ annotation on the entity
class, mapped superclass, or embeddable class; by any _access_
subelement of the _entity-mappings_ element; by any _Access_ annotation
on a field or property of an entity class, mapped superclass, or
embeddable class; by any _access_ attribute defined within an _entity_ ,
_mapped-superclass_ , or _embeddable_ XML element, or by any _access_
attribute defined within an _id_ , _embedded-id_ , _version_ , _basic_ ,
_embedded_ , _many-to-one_ , _one-to-one_ , _one-to-many_ ,
_many-to-many_ , or _element-collection_ element.

===== cascade-persist

The _cascade-persist_ subelement applies to
all relationships in the persistence unit.

Specifying this subelement adds the cascade
persist option to all relationships in addition to any settings
specified in annotations or XML.

The _cascade-persist_ subelement cannot be
overridden in this release.

The ability to override the _cascade-persist_
of the _persistence-unit-defaults_ element will be added in a future
release of this specification.

===== entity-listeners

The _entity-listeners_ subelement defines
default entity listeners for the persistence unit. These entity
listeners are called before any other entity listeners for an entity
unless the entity listener order is overridden within a
_mapped-superclass_ or _entity_ element, or the
_ExcludeDefaultListeners_ annotation is present on the entity or mapped
superclass or the _exclude-default-listeners_ subelement is specified
within the corresponding _entity_ or _mapped-superclass_ XML element.

==== Other Subelements of the entity-mappings element

===== package

The _package_ subelement specifies the
package of the classes listed within the subelements and attributes of
the same mapping file only. The _package_ subelement is overridden if
the fully qualified class name is specified for a class and the two
disagree.

===== schema

The _schema_ subelement applies only to the
entities, tables, secondary tables, join tables, collection tables,
table generators, and sequence generators listed within the same mapping
file.

The _schema_ subelement is overridden by any
_schema_ element explicitly specified in the _Table_ , _SecondaryTable_
, _JoinTable_ , or _CollectionTable_ annotation on an entity listed
within the mapping file or any _schema_ attribute on any _table_ or
_secondary-table_ subelement defined within the _entity_ element for
such an entity, or by any _schema_ attribute on any _join-table_ or
_collection-table_ subelement of an attribute defined within the
_attributes_ subelement of the _entity_ element for such an entity, or
by the _schema_ attribute of any _table-generator_ or
_sequence-generator_ element within the mapping file.

===== catalog

The _catalog_ subelement applies only to the
entities, tables, secondary tables, join tables, collection tables,
table generators, and sequence generators listed within the same mapping
file.

The _catalog_ subelement is overridden by any
_catalog_ element explicitly specified in the _Table_ , _SecondaryTable_
, _JoinTable_ , or _CollectionTable_ annotation on an entity listed
within the mapping file or any _catalog_ attribute on any _table_ or
_secondary-table_ subelement defined within the _entity_ element for
such an entity, or by any _catalog_ attribute on any _join-table_ or
_collection-table_ subelement of an attribute defined within the
_attributes_ subelement of the _entity_ element for such an entity, or
by the _catalog_ attribute of any _table-generator_ or
_sequence-generator_ element within the mapping file.

===== access

The _access_ subelement applies to the
managed classes listed within the same mapping file.

The _access_ subelement is overridden by the
use of any annotations specifying mapping information on the fields or
properties of the entity class; by any _Access_ annotation on the entity
class, mapped superclass, or embeddable class; by any _Access_
annotation on a field or property of an entity class, mapped superclass,
or embeddable class; by any _access_ attribute defined within an
_entity_ , _mapped-superclass_ , or _embeddable_ XML element, or by any
_access_ attribute defined within an _id_ , _embedded-id_ , _version_ ,
_basic_ , _embedded_ , _many-to-one_ , _one-to-one_ , _one-to-many_ ,
_many-to-many_ , or _element-collection_ element.

===== sequence-generator

The generator defined by the
_sequence-generator_ subelement applies to the persistence unit. It is
undefined if multiple mapping files for the persistence unit contain
generators of the same name.

The generator defined is added to any
generators defined in annotations. If a generator of the same name is
defined in annotations, the generator defined by this subelement
overrides that definition.

===== table-generator

The generator defined by the
_table-generator_ subelement applies to the persistence unit. It is
undefined if multiple mapping files for the persistence unit contain
generators of the same name.

The generator defined is added to any
generators defined in annotations. If a generator of the same name is
defined in annotations, the generator defined by this subelement
overrides that definition.

===== named-query

The named query defined by the _named-query_
subelement applies to the persistence unit. It is undefined if multiple
mapping files for the persistence unit contain named queries of the same
name.

The named query defined is added to the named
queries defined in annotations. If a named query of the same name is
defined in annotations, the named query defined by this subelement
overrides that definition.

===== named-native-query

The named native query defined by the
_named-native-query_ subelement applies to the persistence unit. It is
undefined if multiple mapping files for the persistence unit contain
named queries of the same name.

The named native query defined is added to
the named native queries defined in annotations. If a named query of the
same name is defined in annotations, the named query defined by this
subelement overrides that definition.

===== named-stored-procedure-query

The named stored procedure query defined by
the _named-stored-procedure-query_ subelement applies to the persistence
unit. It is undefined if multiple mapping files for the persistence unit
contain named stored procedure queries of the same name.

The named stored procedure query defined is
added to the named stored procedure queries defined in annotations. If a
named stored procedure query of the same name is defined in annotations,
the named stored procedure query defined by this subelement overrides
that definition.

===== sql-result-set-mapping

The SQL result set mapping defined by the
_sql-result-set-mapping_ subelement applies to the persistence unit. It
is undefined if multiple mapping files for the persistence unit contain
SQL result set mappings of the same name.

The SQL result set mapping defined is added
to the SQL result set mappings defined in annotations. If a SQL result
set mapping of the same name is defined in annotations, the SQL result
set mapping defined by this subelement overrides that definition.

===== entity

The _entity_ subelement defines an entity of
the persistence unit. It is undefined if multiple mapping files for the
persistence unit contain entries for the same entity.

The entity class may or may not have been
annotated as _Entity_ . The subelements and attributes of the _entity_
element override as specified in section link:Per.html#a17017[See
entity Subelements and Attributes].

===== mapped-superclass

The _mapped-superclass_ subelement defines a
mapped superclass of the persistence unit. It is undefined if multiple
mapping files for the persistence unit contain entries for the same
mapped superclass.

The mapped superclass may or may not have
been annotated as _MappedSuperclass_ . The subelements and attributes of
the _mapped-superclass_ element override as specified in section
link:Per.html#a17106[See mapped-superclass Subelements and
Attributes].

===== embeddable

The _embeddable_ subelement defines an
embeddable class of the persistence unit. It is undefined if multiple
mapping files for the persistence unit contain entries for the same
embeddable class.

The _embeddable_ class may or may not have
been annotated as _Embeddable_ . The subelements and attributes of the
_embeddable_ element override as specified in section
link:Per.html#a17150[See embeddable Subelements and Attributes].

===== converter

The converter defined by the _converter_
subelement applies to the persistence unit. It is undefined if multiple
mapping files for the persistence unit contain converters for the same
target type.

The converter defined is added to the
converters defined in annotations. If a converter for the same target
type is defined in annotations, the converter defined by this subelement
overrides that definition.

==== [[a17017]]entity Subelements and Attributes

These apply only to the entity for which they
are subelements or attributes, unless otherwise specified below.

===== metadata-complete

If the _metadata-complete_ attribute of the
_entity_ element is specified as _true_ , any annotations on the entity
class (and its fields and properties) are ignored. When
_metadata-complete_ is specified as _true_ and XML attributes or
sub-elements of the _entity_ element are omitted, the default values for
those attributes and elements are applied.

===== access

The _access_ attribute defines the access
type for the entity. The _access_ attribute overrides any access type
specified by the _persistence-unit-defaults_ element or
_entity-mappings_ element for the given entity. The access type for a
field or property of the entity may be overridden by specifying by
overriding the mapping for that field or property using the appropriate
XML subelement, as described in Section link:Per.html#a17082[See
attributes] below.

Caution must be exercised in overriding an
access type that was specified or defaulted using annotations, as doing
so may cause applications to break.

===== cacheable

The _cacheable_ attribute defines whether the
entity should be cached or must not be cached when the
_shared-cache-mode_ element of the _persistence.xml_ file is specified
as _ENABLE_SELECTIVE_ or _DISABLE_SELECTIVE_ . If the _Cacheable_
annotation was specified for the entity, its value is overridden by this
attribute. The value of the _cacheable_ attribute is inherited by
subclasses (unless otherwise overridden for a subclass by the
_Cacheable_ annotation or _cacheable_ XML attribute).

===== name

The name attribute defines the entity name.
The _name_ attribute overrides the value of the entity name defined by
the _name_ element of the _Entity_ annotation (whether explicitly
specified or defaulted). Caution must be exercised in overriding the
entity name, as doing so may cause applications to break.

===== table

The _table_ subelement overrides any _Table_
annotation (including defaulted _Table_ values) on the entity. If a
_table_ subelement is present, and attributes or subelements of that
_table_ subelement are not explicitly specified, their default values
are applied.

===== secondary-table

The _secondary-table_ subelement overrides
all _SecondaryTable_ and _SecondaryTables_ annotations (including
defaulted _SecondaryTable_ values) on the entity. If a _secondary-table_
subelement is present, and attributes or subelements of that _secondary_
- _table_ subelement are not explicitly specified, their default values
are applied.

===== primary-key-join-column

The _primary-key-join-column_ subelement of
the entity element specifies a primary key column that is used to join
the table of an entity subclass to the primary table for the entity when
the joined strategy is used. The _primary-key-join-column_ subelement
overrides all _PrimaryKeyJoinColumn_ and _PrimaryKeyJoinColumns_
annotations (including defaulted _PrimaryKeyJoinColumn_ values) on the
entity. If a _primary-key-join-column_ subelement is present, and
attributes or subelements of that _primary-key-join-column_ subelement
are not explicitly specified, their default values are applied.

===== id-class

The _id-class_ subelement overrides any
_IdClass_ annotation specified on the entity.

===== inheritance

The _inheritance_ subelement overrides any
_Inheritance_ annotation (including defaulted _Inheritance_ values) on
the entity. If an _inheritance_ subelement is present, and the
_strategy_ attribute is not explicitly specified, its default value is
applied.

This element applies to the entity and its
subclasses (unless otherwise overridden for a subclass by an annotation
or XML element).

Support for the combination of inheritance
strategies is not required by this specification. Portable applications
should use only a single inheritance strategy within an entity
hierarchy.

===== discriminator-value

The _discriminator-value_ subelement
overrides any _DiscriminatorValue_ annotations (including defaulted
_DiscriminatorValue_ values) on the entity.

===== discriminator-column

The _discriminator-column_ subelement
overrides any _DiscriminatorColumn_ annotation (including defaulted
_DiscriminatorColumn_ values) on the entity. If a _discriminator-column_
subelement is present, and attributes of that _discriminator-column_
subelement are not explicitly specified, their default values are
applied.

This element applies to the entity and its
subclasses (unless otherwise overridden for a subclass by an annotation
or XML element).

===== sequence-generator

The generator defined by the
_sequence-generator_ subelement is added to any generators defined in
annotations and any other generators defined in XML. If a generator of
the same name is defined in annotations, the generator defined by this
subelement overrides that definition. If a _sequence-generator_
subelement is present, and attributes or subelements of that
_sequence-generator_ subelement are not explicitly specified, their
default values are applied.

The generator defined by the
_sequence-generator_ subelement applies to the persistence unit. It is
undefined if multiple mapping files for the persistence unit contain
generators of the same name.

===== table-generator

The generator defined by the
_table-generator_ subelement is added to any generators defined in
annotations and any other generators defined in XML. If a generator of
the same name is defined in annotations, the generator defined by this
subelement overrides that definition. If a _table-generator_ subelement
is present, and attributes or subelements of that _table-generator_
subelement are not explicitly specified, their default values are
applied.

The generator defined by the
_table-generator_ subelement applies to the persistence unit. It is
undefined if multiple mapping files for the persistence unit contain
generators of the same name.

===== attribute-override

The _attribute-override_ subelement is
additive to any _AttributeOverride_ or _AttributeOverrides_ annotations
on the entity. It overrides any _AttributeOverride_ elements for the
same attribute name. If an _attribute-override_ subelement is present,
and attributes or subelements of that _attribute-override_ subelement
are not explicitly specified, their default values are applied.

===== association-override

The _association-override_ subelement is
additive to any _AssociationOverride_ or _AssociationOverrides a_
nnotations on the entity. It overrides any _AssociationOverride_
elements for the same attribute name. If an _association-override_
subelement is present, and attributes or subelements of that
_association-override_ subelement are not explicitly specified, their
default values are applied.

===== convert

The _convert_ subelement is additive to any
_Convert_ or _Converts_ annotations on the entity. It overrides any
_Convert_ annotation for the same attribute name. If a _convert_
subelement is present, and attributes or subelements of that _convert_
subelement are not explicitly specified, their default values are
applied.

===== named-entity-graph

The _named-entity-graph_ subelement is
additive to any _NamedEntityGraph_ annotations on the entity. It
overrides any _NamedEntityGraph_ annotation with the same name.

===== named-query

The named query defined by the _named-query_
subelement is added to any named queries defined in annotations, and any
other named queries defined in XML. If a named query of the same name is
defined in annotations, the named query defined by this subelement
overrides that definition. If a _named-query_ subelement is present, and
attributes or subelements of that _named-query_ subelement are not
explicitly specified, their default values are applied.

The named query defined by the _named-query_
subelement applies to the persistence unit. It is undefined if multiple
mapping files for the persistence unit contain named queries of the same
name.

===== named-native-query

The named query defined by the
_named-native-query_ subelement is added to any named queries defined in
annotations, and any other named queries defined in XML. If a named
query of the same name is defined in annotations, the named query
defined by this subelement overrides that definition. If a
_named-native-query_ subelement is present, and attributes or
subelements of that _named-native-query_ subelement are not explicitly
specified, their default values are applied.

The named native query defined by the
_named-native-query_ subelement applies to the persistence unit. It is
undefined if multiple mapping files for the persistence unit contain
named queries of the same name.

===== named-stored-procedure-query

The named stored procedure query defined by
the _named-stored-procedure-query_ subelement is added to any named
stored procedure queries defined in annotations, and any other named
stored procedure queries defined in XML. If a named stored procedure
query of the same name is defined in annotations, the named stored
procedure query defined by this subelement overrides that definition. If
a _named-stored-procedure-query_ subelement is present, and attributes
or subelements of that _named-stored-procedure-query_ subelement are not
explicitly specified, their default values are applied.

The named stored procedure query defined by
the _named-stored-procedure-query_ subelement applies to the persistence
unit. It is undefined if multiple mapping files for the persistence unit
contain named stored procedure queries of the same name.

===== sql-result-set-mapping

The SQL result set mapping defined by the
_sql-result-set-mapping_ is added to the SQL result set mappings defined
in annotations, and any other SQL result set mappings defined in XML. If
a SQL result set mapping of the same name is defined in annotations, the
SQL result set mapping defined by this subelement overrides that
definition. If a _sql-result-set-mapping_ subelement is present, and
attributes or subelements of that _sql-result-set-mapping_ subelement
are not explicitly specified, their default values are applied.

The SQL result set mapping defined by the
_sql-result-set-mapping_ subelement applies to the persistence unit. It
is undefined if multiple mapping files for the persistence unit contain
SQL result set mappings of the same name.

===== exclude-default-listeners

The _exclude-default-listeners_ subelement
applies whether or not the _ExcludeDefaultListeners_ annotation was
specified on the entity.

This element causes the default entity
listeners to be excluded for the entity and its subclasses.

===== exclude-superclass-listeners

The _exclude-superclass-listeners_ subelement
applies whether or not the _ExcludeSuperclassListeners_ annotation was
specified on the entity.

This element causes any superclass listeners
to be excluded for the entity and its subclasses.

===== entity-listeners

The _entity-listeners_ subelement overrides
any _EntityListeners_ annotation on the entity.

These listeners apply to the entity and its
subclasses unless otherwise excluded.

===== pre-persist, post-persist, pre-remove, post-remove, pre-update, post-update, post-load

These subelements override any lifecycle
callback methods defined by the corresponding annotations on the entity.

===== [[a17082]]attributes

The _attributes_ element groups the mapping
subelements for the fields and properties of the entity. It may be
sparsely populated to include only a subset of the fields and
properties. If the value of _metadata-complete_ is _true_ , the
remainder of the attributes will be defaulted according to the default
rules. If _metadata-complete_ is not specified, or is _false_ , the
mappings for only those properties and fields that are explicitly
specified will be overridden.

====== id

The _id_ subelement overrides the mapping for
the specified field or property. If an _id_ subelement is present, and
attributes or subelements of that _id_ subelement are not explicitly
specified, their default values are applied.

====== embedded-id

The _embedded-id_ subelement overrides the
mapping for the specified field or property. If an _embedded-id_
subelement is present, and attributes or subelements of that
_embedded-id_ subelement are not explicitly specified, their default
values are applied.

====== basic

The _basic_ subelement overrides the mapping
for the specified field or property. If a _basic_ subelement is present,
and attributes or subelements of that _basic_ subelement are not
explicitly specified, their default values are applied.

====== version

The _version_ subelement overrides the
mapping for the specified field or property. If a _version_ subelement
is present, and attributes or subelements of that _version_ subelement
are not explicitly specified, their default values are applied.

====== many-to-one

The _many-to-one_ subelement overrides the
mapping for the specified field or property. If a _many-to-one_
subelement is present, and attributes or subelements of that
_many-to-one_ subelement are not explicitly specified, their default
values are applied.

====== one-to-many

The _one-to-many_ subelement overrides the
mapping for the specified field or property. If a _one-to-many_
subelement is present, and attributes or subelements of that
_one-to-many_ subelement are not explicitly specified, their default
values are applied.

====== one-to-one

The _one-to-one_ subelement overrides the
mapping for the specified field or property. If a _one-to-one_
subelement is present, and attributes or subelements of that
_one-to-one_ subelement are not explicitly specified, their default
values are applied.

====== many-to-many

The _many-to-many_ subelement overrides the
mapping for the specified field or property. If a _many-to-many_
subelement is present, and attributes or subelements of that
_many-to-many_ subelement are not explicitly specified, their default
values are applied.

====== element-collection

The _element-collection_ subelement overrides
the mapping for the specified field or property. If an
_element-collection_ subelement is present, and attributes or
subelements of that _element-collection_ subelement are not explicitly
specified, their default values are applied.

====== embedded

The _embedded_ subelement overrides the
mapping for the specified field or property. If an _embedded_ subelement
is present, and attributes or subelements of that _embedded_ subelement
are not explicitly specified, their default values are applied.

====== transient

The _transient_ subelement overrides the
mapping for the specified field or property.

==== [[a17106]]mapped-superclass Subelements and Attributes

These apply only to the mapped-superclass for
which they are subelements or attributes, unless otherwise specified
below.

===== metadata-complete

If the _metadata-complete_ attribute of the
_mapped-superclass_ element is specified as _true_ , any annotations on
the mapped superclass (and its fields and properties) are ignored. When
_metadata-complete_ is specified as _true_ and attributes or
sub-elements of the _mapped-superclass_ element are omitted, the default
values for those attributes and elements are applied.

===== access

The _access_ attribute defines the access
type for the mapped superclass. The _access_ attribute overrides any
access type specified by the _persistence-unit-defaults_ element or
_entity-mappings_ element for the given mapped superclass. The access
type for a field or property of the mapped superclass may be overridden
by specifying by overriding the mapping for that field or property using
the appropriate XML subelement, as described in Section
link:Per.html#a17126[See attributes] below.

Caution must be exercised in overriding an
access type that was specified or defaulted using annotations, as doing
so may cause applications to break.

===== id-class

The _id-class_ subelement overrides any
_IdClass_ annotation specified on the mapped superclass.

===== exclude-default-listeners

The _exclude-default-listeners_ subelement
applies whether or not the _ExcludeDefaultListeners_ annotation was
specified on the mapped superclass.

This element causes the default entity
listeners to be excluded for the mapped superclass and its subclasses.

===== exclude-superclass-listeners

The _exclude-superclass-listeners_ subelement
applies whether or not the _ExcludeSuperclassListeners_ annotation was
specified on the mapped superclass.

This element causes any superclass listeners
to be excluded for the mapped superclass and its subclasses.

===== entity-listeners

The _entity-listeners_ subelement overrides
any _EntityListeners_ annotation on the mapped superclass.

These listeners apply to the mapped
superclass and its subclasses unless otherwise excluded.

===== pre-persist, post-persist, pre-remove, post-remove, pre-update, post-update, post-load

These subelements override any lifecycle
callback methods defined by the corresponding annotations on the mapped
superclass.

===== [[a17126]]attributes

The _attributes_ element groups the mapping
subelements for the fields and properties defined by the mapped
superclass. It may be sparsely populated to include only a subset of the
fields and properties. If the value of _metadata-complete_ is _true_ ,
the remainder of the attributes will be defaulted according to the
default rules. If _metadata-complete_ is not specified, or is _false_ ,
the mappings for only those properties and fields that are explicitly
specified will be overridden.

====== id

The _id_ subelement overrides the mapping for
the specified field or property. If an _id_ subelement is present, and
attributes or subelements of that _id_ subelement are not explicitly
specified, their default values are applied.

====== embedded-id

The _embedded-id_ subelement overrides the
mapping for the specified field or property. If an _embedded-id_
subelement is present, and attributes or subelements of that
_embedded-id_ subelement are not explicitly specified, their default
values are applied.

====== basic

The _basic_ subelement overrides the mapping
for the specified field or property. If a _basic_ subelement is present,
and attributes or subelements of that _basic_ subelement are not
explicitly specified, their default values are applied.

====== version

The _version_ subelement overrides the
mapping for the specified field or property. If a _version_ subelement
is present, and attributes or subelements of that _version_ subelement
are not explicitly specified, their default values are applied.

====== many-to-one

The _many-to-one_ subelement overrides the
mapping for the specified field or property. If a _many-to-one_
subelement is present, and attributes or subelements of that
_many-to-one_ subelement are not explicitly specified, their default
values are applied.

====== one-to-many

The _one-to-many_ subelement overrides the
mapping for the specified field or property. If a _one-to-many_
subelement is present, and attributes or subelements of that
_one-to-many_ subelement are not explicitly specified, their default
values are applied.

====== one-to-one

The _one-to-one_ subelement overrides the
mapping for the specified field or property. If a _one-to-one_
subelement is present, and attributes or subelements of that
_one-to-one_ subelement are not explicitly specified, their default
values are applied.

====== many-to-many

The _many-to-many_ subelement overrides the
mapping for the specified field or property. If a _many-to-many_
subelement is present, and attributes or subelements of that
_many-to-many_ subelement are not explicitly specified, their default
values are applied.

====== element-collection

The _element-collection_ subelement overrides
the mapping for the specified field or property. If an
_element-collection_ subelement is present, and attributes or
subelements of that _element-collection_ subelement are not explicitly
specified, their default values are applied.

====== embedded

The _embedded_ subelement overrides the
mapping for the specified field or property. If an _embedded_ subelement
is present, and attributes or subelements of that _embedded_ subelement
are not explicitly specified, their default values are applied.

====== transient

The _transient_ subelement overrides the
mapping for the specified field or property.

==== [[a17150]]embeddable Subelements and Attributes

These apply only to the embeddable for which
they are subelements or attributes.

===== metadata-complete

If the _metadata-complete_ attribute of the
_embeddable_ element is specified as _true_ , any annotations on the
embeddable class (and its fields and properties) are ignored. When
_metadata-complete_ is specified as _true_ and attributes and
sub-elements of the _embeddable_ element are omitted, the default values
for those attributes and elements are applied.

===== access

The _access_ attribute defines the access
type for the embeddable class. The _access_ attribute overrides any
access type specified by the _persistence-unit-defaults_ element or
_entity-mappings_ element for the given embeddable class. The access
type for a field or property of the embeddable class may be overridden
by specifying by overriding the mapping for that field or property using
the appropriate XML subelement, as described in Section
link:Per.html#a17157[See attributes] below.

Caution must be exercised in overriding an
access type that was specified or defaulted using annotations, as doing
so may cause applications to break.

===== [[a17157]]attributes

The _attributes_ element groups the mapping
subelements for the fields and properties defined by the embeddable
class. It may be sparsely populated to include only a subset of the
fields and properties. If the value of _metadata-complete_ is _true_ ,
the remainder of the attributes will be defaulted according to the
default rules. If _metadata-complete_ is not specified, or is _false_ ,
the mappings for only those properties and fields that are explicitly
specified will be overridden.

====== basic

The _basic_ subelement overrides the mapping
for the specified field or property. If a _basic_ subelement is present,
and attributes or subelements of that _basic_ subelement are not
explicitly specified, their default values are applied.

====== many-to-one

The _many-to-one_ subelement overrides the
mapping for the specified field or property. If a _many-to-one_
subelement is present, and attributes or subelements of that
_many-to-one_ subelement are not explicitly specified, their default
values are applied.

====== one-to-many

The _one-to-many_ subelement overrides the
mapping for the specified field or property. If a _one-to-many_
subelement is present, and attributes or subelements of that
_one-to-many_ subelement are not explicitly specified, their default
values are applied.

====== one-to-one

The _one-to-one_ subelement overrides the
mapping for the specified field or property. If a _one-to-one_
subelement is present, and attributes or subelements of that
_one-to-one_ subelement are not explicitly specified, their default
values are applied.

====== many-to-many

The _many-to-many_ subelement overrides the
mapping for the specified field or property. If a _many-to-many_
subelement is present, and attributes or subelements of that
_many-to-many_ subelement are not explicitly specified, their default
values are applied.

====== element-collection

The _element-collection_ subelement overrides
the mapping for the specified field or property. If an
_element-collection_ subelement is present, and attributes or
subelements of that _element-collection_ subelement are not explicitly
specified, their default values are applied.

====== embedded

The _embedded_ subelement overrides the
mapping for the specified field or property. If an _embedded_ subelement
is present, and attributes or subelements of that _embedded_ subelement
are not explicitly specified, their default values are applied.

====== transient

The _transient_ subelement overrides the
mapping for the specified field or property.

=== [[a17175]]XML Schema

image:Per-4.png[image]

This section provides the XML
object/relational mapping schema for use with the persistence API.

<?xml version="1.0" encoding="UTF-8"?>

<!-- Java Persistence API object/relational
mapping file schema -->

<xsd:schema
targetNamespace="http://xmlns.jcp.org/xml/ns/persistence/orm"


xmlns:orm="http://xmlns.jcp.org/xml/ns/persistence/orm"

 xmlns:xsd="http://www.w3.org/2001/XMLSchema"

 elementFormDefault="qualified"

 attributeFormDefault="unqualified"

 version="2.2">



 <xsd:annotation>

 <xsd:documentation>

 @(#)orm_2_2.xsd 2.2 July 7 2017

 </xsd:documentation>

 </xsd:annotation>



 <xsd:annotation>

 <xsd:documentation><![CDATA[



 This is the XML Schema for the persistence
object/relational

 mapping file.

 The file may be named "META-INF/orm.xml" in
the persistence

 archive or it may be named some other name
which would be

 used to locate the file as resource on the
classpath.



 Object/relational mapping files must
indicate the object/relational

 mapping file schema by using the persistence
namespace:



 http://xmlns.jcp.org/xml/ns/persistence/orm



 and indicate the version of the schema by

 using the version element as shown below:



 <entity-mappings
xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"


xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence/orm


http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd"

 version="2.2">

 ...

 </entity-mappings>



 ]]></xsd:documentation>

 </xsd:annotation>



 <xsd:complexType name="emptyType"/>



 <xsd:simpleType name="versionType">

 <xsd:restriction base="xsd:token">

 <xsd:pattern value="[0-9]+(\.[0-9]+)*"/>

 </xsd:restriction>

 </xsd:simpleType>



 <!--
**************************************************** -->



 <xsd:element name="entity-mappings">

 <xsd:complexType>

 <xsd:annotation>

 <xsd:documentation>



 The entity-mappings element is the root
element of a mapping

 file. It contains the following four types
of elements:



 1. The persistence-unit-metadata element
contains metadata

 for the entire persistence unit. It is
undefined if this element

 occurs in multiple mapping files within the
same persistence unit.



 2. The package, schema, catalog and access
elements apply to all of

 the entity, mapped-superclass and embeddable
elements defined in

 the same file in which they occur.



 3. The sequence-generator, table-generator,
converter, named-query,

 named-native-query,
named-stored-procedure-query, and

 sql-result-set-mapping elements are global
to the persistence

 unit. It is undefined to have more than one
sequence-generator

 or table-generator of the same name in the
same or different

 mapping files in a persistence unit. It is
undefined to have

 more than one named-query,
named-native-query, sql-result-set-mapping,

 or named-stored-procedure-query of the same
name in the same

 or different mapping files in a persistence
unit. It is also

 undefined to have more than one converter
for the same target

 type in the same or different mapping files
in a persistence unit.



 4. The entity, mapped-superclass and
embeddable elements each define

 the mapping information for a managed
persistent class. The mapping

 information contained in these elements may
be complete or it may

 be partial.



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string"

 minOccurs="0"/>

 <xsd:element
name="persistence-unit-metadata"

 type="orm:persistence-unit-metadata"

 minOccurs="0"/>

 <xsd:element name="package"
type="xsd:string"

 minOccurs="0"/>

 <xsd:element name="schema" type="xsd:string"

 minOccurs="0"/>

 <xsd:element name="catalog"
type="xsd:string"

 minOccurs="0"/>

 <xsd:element name="access"
type="orm:access-type"

 minOccurs="0"/>

 <xsd:element name="sequence-generator"
type="orm:sequence-generator"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="table-generator"
type="orm:table-generator"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="named-query"
type="orm:named-query"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="named-native-query"
type="orm:named-native-query"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element
name="named-stored-procedure-query"

 type="orm:named-stored-procedure-query"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="sql-result-set-mapping"

 type="orm:sql-result-set-mapping"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="mapped-superclass"
type="orm:mapped-superclass"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="entity" type="orm:entity"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="embeddable"
type="orm:embeddable"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="converter"
type="orm:converter"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="version"
type="orm:versionType"

 fixed="2.2" use="required"/>

 </xsd:complexType>

 </xsd:element>



 <!--
**************************************************** -->



 <xsd:complexType
name="persistence-unit-metadata">

 <xsd:annotation>

 <xsd:documentation>



 Metadata that applies to the persistence
unit and not just to

 the mapping file in which it is contained.



 If the xml-mapping-metadata-complete element
is specified,

 the complete set of mapping metadata for the
persistence unit

 is contained in the XML mapping files for
the persistence unit.



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element
name="xml-mapping-metadata-complete" type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element
name="persistence-unit-defaults"

 type="orm:persistence-unit-defaults"

 minOccurs="0"/>

 </xsd:sequence>

 </xsd:complexType>



 <!--
**************************************************** -->



 <xsd:complexType
name="persistence-unit-defaults">

 <xsd:annotation>

 <xsd:documentation>



 These defaults are applied to the
persistence unit as a whole

 unless they are overridden by local
annotation or XML

 element settings.



 schema - Used as the schema for all tables,
secondary tables, join

 tables, collection tables, sequence
generators, and table

 generators that apply to the persistence
unit

 catalog - Used as the catalog for all
tables, secondary tables, join

 tables, collection tables, sequence
generators, and table

 generators that apply to the persistence
unit

 delimited-identifiers - Used to treat
database identifiers as

 delimited identifiers.

 access - Used as the access type for all
managed classes in

 the persistence unit

 cascade-persist - Adds cascade-persist to
the set of cascade options

 in all entity relationships of the
persistence unit

 entity-listeners - List of default entity
listeners to be invoked

 on each entity in the persistence unit.

 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="schema" type="xsd:string"

 minOccurs="0"/>

 <xsd:element name="catalog"
type="xsd:string"

 minOccurs="0"/>

 <xsd:element name="delimited-identifiers"
type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="access"
type="orm:access-type"

 minOccurs="0"/>

 <xsd:element name="cascade-persist"
type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="entity-listeners"
type="orm:entity-listeners"

 minOccurs="0"/>

 </xsd:sequence>

 </xsd:complexType>



 <!--
**************************************************** -->



 <xsd:complexType name="entity">

 <xsd:annotation>

 <xsd:documentation>



 Defines the settings and mappings for an
entity. Is allowed to be

 sparsely populated and used in conjunction
with the annotations.

 Alternatively, the metadata-complete
attribute can be used to

 indicate that no annotations on the entity
class (and its fields

 or properties) are to be processed. If this
is the case then

 the defaulting rules for the entity and its
subelements will

 be recursively applied.



 @Target(TYPE) @Retention(RUNTIME)

 public @interface Entity \{

 String name() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="table" type="orm:table"

 minOccurs="0"/>

 <xsd:element name="secondary-table"
type="orm:secondary-table"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:sequence>

 <xsd:element name="primary-key-join-column"

 type="orm:primary-key-join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="primary-key-foreign-key"

 type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:element name="id-class"
type="orm:id-class" minOccurs="0"/>

 <xsd:element name="inheritance"
type="orm:inheritance" minOccurs="0"/>

 <xsd:element name="discriminator-value"
type="orm:discriminator-value"

 minOccurs="0"/>

 <xsd:element name="discriminator-column"

 type="orm:discriminator-column"

 minOccurs="0"/>

 <xsd:element name="sequence-generator"
type="orm:sequence-generator"

 minOccurs="0"/>

 <xsd:element name="table-generator"
type="orm:table-generator"

 minOccurs="0"/>

 <xsd:element name="named-query"
type="orm:named-query"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="named-native-query"
type="orm:named-native-query"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element
name="named-stored-procedure-query"

 type="orm:named-stored-procedure-query"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="sql-result-set-mapping"

 type="orm:sql-result-set-mapping"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element
name="exclude-default-listeners" type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element
name="exclude-superclass-listeners" type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="entity-listeners"
type="orm:entity-listeners"

 minOccurs="0"/>

 <xsd:element name="pre-persist"
type="orm:pre-persist" minOccurs="0"/>

 <xsd:element name="post-persist"
type="orm:post-persist"

 minOccurs="0"/>

 <xsd:element name="pre-remove"
type="orm:pre-remove" minOccurs="0"/>

 <xsd:element name="post-remove"
type="orm:post-remove" minOccurs="0"/>

 <xsd:element name="pre-update"
type="orm:pre-update" minOccurs="0"/>

 <xsd:element name="post-update"
type="orm:post-update" minOccurs="0"/>

 <xsd:element name="post-load"
type="orm:post-load" minOccurs="0"/>

 <xsd:element name="attribute-override"
type="orm:attribute-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="association-override"

 type="orm:association-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="convert"
type="orm:convert"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="named-entity-graph"
type="orm:named-entity-graph"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="attributes"
type="orm:attributes" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="class"
type="xsd:string" use="required"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 <xsd:attribute name="cacheable"
type="xsd:boolean"/>

 <xsd:attribute name="metadata-complete"
type="xsd:boolean"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="access-type">

 <xsd:annotation>

 <xsd:documentation>



 This element determines how the persistence
provider accesses the

 state of an entity or embedded object.



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="PROPERTY"/>

 <xsd:enumeration value="FIELD"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType
name="association-override">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

 public @interface AssociationOverride \{

 String name();

 JoinColumn[] joinColumns() default\{};

 JoinTable joinTable() default @JoinTable;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:choice>

 <xsd:sequence>

 <xsd:element name="join-column"
type="orm:join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="foreign-key"
type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:element name="join-table"
type="orm:join-table"

 minOccurs="0"/>

 </xsd:choice>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="attribute-override">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

 public @interface AttributeOverride \{

 String name();

 Column column();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="column"
type="orm:column"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="attributes">

 <xsd:annotation>

 <xsd:documentation>



 This element contains the entity field or
property mappings.

 It may be sparsely populated to include only
a subset of the

 fields or properties. If metadata-complete
for the entity is true

 then the remainder of the attributes will be
defaulted according

 to the default rules.



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:choice>

 <xsd:element name="id" type="orm:id"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="embedded-id"
type="orm:embedded-id"

 minOccurs="0"/>

 </xsd:choice>

 <xsd:element name="basic" type="orm:basic"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="version"
type="orm:version"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="many-to-one"
type="orm:many-to-one"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="one-to-many"
type="orm:one-to-many"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="one-to-one"
type="orm:one-to-one"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="many-to-many"
type="orm:many-to-many"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="element-collection"
type="orm:element-collection"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="embedded"
type="orm:embedded"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="transient"
type="orm:transient"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="basic">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Basic \{

 FetchType fetch() default EAGER;

 boolean optional() default true;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="column" type="orm:column"
minOccurs="0"/>

 <xsd:choice>

 <xsd:element name="lob" type="orm:lob"
minOccurs="0"/>

 <xsd:element name="temporal"
type="orm:temporal" minOccurs="0"/>

 <xsd:element name="enumerated"
type="orm:enumerated" minOccurs="0"/>

 <xsd:element name="convert"
type="orm:convert" minOccurs="0"/>

 </xsd:choice>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="fetch"
type="orm:fetch-type"/>

 <xsd:attribute name="optional"
type="xsd:boolean"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="cascade-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum CascadeType \{ ALL, PERSIST,
MERGE, REMOVE, REFRESH, DETACH};



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="cascade-all"
type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="cascade-persist"
type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="cascade-merge"
type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="cascade-remove"
type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="cascade-refresh"
type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="cascade-detach"
type="orm:emptyType"

 minOccurs="0"/>

 </xsd:sequence>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="collection-table">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface CollectionTable \{

 String name() default "";

 String catalog() default "";

 String schema() default "";

 JoinColumn[] joinColumns() default \{};

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:sequence>

 <xsd:element name="join-column"
type="orm:join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="foreign-key"
type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:element name="unique-constraint"
type="orm:unique-constraint"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="index" type="orm:index"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="catalog"
type="xsd:string"/>

 <xsd:attribute name="schema"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="column">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Column \{

 String name() default "";

 boolean unique() default false;

 boolean nullable() default true;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 String table() default "";

 int length() default 255;

 int precision() default 0; // decimal
precision

 int scale() default 0; // decimal scale

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="unique"
type="xsd:boolean"/>

 <xsd:attribute name="nullable"
type="xsd:boolean"/>

 <xsd:attribute name="insertable"
type="xsd:boolean"/>

 <xsd:attribute name="updatable"
type="xsd:boolean"/>

 <xsd:attribute name="column-definition"
type="xsd:string"/>

 <xsd:attribute name="table"
type="xsd:string"/>

 <xsd:attribute name="length"
type="xsd:int"/>

 <xsd:attribute name="precision"
type="xsd:int"/>

 <xsd:attribute name="scale" type="xsd:int"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="column-result">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface ColumnResult \{

 String name();

 Class type() default void.class;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="class"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="constraint-mode">

 <xsd:annotation>

 <xsd:documentation>



 public enum ConstraintMode \{CONSTRAINT,
NO_CONSTRAINT, PROVIDER_DEFAULT};



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="CONSTRAINT"/>

 <xsd:enumeration value="NO_CONSTRAINT"/>

 <xsd:enumeration value="PROVIDER_DEFAULT"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType name="constructor-result">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface ConstructorResult \{

 Class targetClass();

 ColumnResult[] columns();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="column"
type="orm:column-result"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="target-class"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="convert">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Convert \{

 Class converter() default void.class;

 String attributeName() default "";

 boolean disableConversion() default false;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="converter"
type="xsd:string"/>

 <xsd:attribute name="attribute-name"
type="xsd:string"/>

 <xsd:attribute name="disable-conversion"
type="xsd:boolean"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="converter">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Converter \{

 boolean autoApply() default false;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="class"
type="xsd:string" use="required"/>

 <xsd:attribute name="auto-apply"
type="xsd:boolean"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType
name="discriminator-column">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface DiscriminatorColumn \{

 String name() default "DTYPE";

 DiscriminatorType discriminatorType()
default STRING;

 String columnDefinition() default "";

 int length() default 31;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="discriminator-type"
type="orm:discriminator-type"/>

 <xsd:attribute name="column-definition"
type="xsd:string"/>

 <xsd:attribute name="length"
type="xsd:int"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="discriminator-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum DiscriminatorType \{ STRING,
CHAR, INTEGER };



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="STRING"/>

 <xsd:enumeration value="CHAR"/>

 <xsd:enumeration value="INTEGER"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:simpleType name="discriminator-value">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface DiscriminatorValue \{

 String value();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:string"/>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType name="element-collection">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface ElementCollection \{

 Class targetClass() default void.class;

 FetchType fetch() default LAZY;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:choice>

 <xsd:element name="order-by"
type="orm:order-by"

 minOccurs="0"/>

 <xsd:element name="order-column"
type="orm:order-column"

 minOccurs="0"/>

 </xsd:choice>

 <xsd:choice>

 <xsd:element name="map-key"
type="orm:map-key"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element name="map-key-class"
type="orm:map-key-class"

 minOccurs="0"/>

 <xsd:choice>

 <xsd:element name="map-key-temporal"

 type="orm:temporal"

 minOccurs="0"/>

 <xsd:element name="map-key-enumerated"

 type="orm:enumerated"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element
name="map-key-attribute-override"

 type="orm:attribute-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="map-key-convert"
type="orm:convert"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 </xsd:choice>

 <xsd:choice>

 <xsd:element name="map-key-column"

 type="orm:map-key-column"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element name="map-key-join-column"

 type="orm:map-key-join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="map-key-foreign-key"

 type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 </xsd:choice>

 </xsd:sequence>

 </xsd:choice>

 <xsd:choice>

 <xsd:sequence>

 <xsd:element name="column" type="orm:column"
minOccurs="0"/>

 <xsd:choice>

 <xsd:element name="temporal"

 type="orm:temporal"

 minOccurs="0"/>

 <xsd:element name="enumerated"

 type="orm:enumerated"

 minOccurs="0"/>

 <xsd:element name="lob"

 type="orm:lob"

 minOccurs="0"/>

 </xsd:choice>

 </xsd:sequence>

 <xsd:sequence>

 <xsd:element name="attribute-override"

 type="orm:attribute-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="association-override"

 type="orm:association-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="convert"
type="orm:convert"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 </xsd:choice>

 <xsd:element name="collection-table"
type="orm:collection-table"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="target-class"
type="xsd:string"/>

 <xsd:attribute name="fetch"
type="orm:fetch-type"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

</xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="embeddable">

 <xsd:annotation>

 <xsd:documentation>



 Defines the settings and mappings for
embeddable objects. Is

 allowed to be sparsely populated and used in
conjunction with

 the annotations. Alternatively, the
metadata-complete attribute

 can be used to indicate that no annotations
are to be processed

 in the class. If this is the case then the
defaulting rules will

 be recursively applied.



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface Embeddable \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="attributes"
type="orm:embeddable-attributes"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="class"
type="xsd:string" use="required"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 <xsd:attribute name="metadata-complete"
type="xsd:boolean"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType
name="embeddable-attributes">

 <xsd:sequence>

 <xsd:element name="basic" type="orm:basic"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="many-to-one"
type="orm:many-to-one"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="one-to-many"
type="orm:one-to-many"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="one-to-one"
type="orm:one-to-one"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="many-to-many"
type="orm:many-to-many"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="element-collection"
type="orm:element-collection"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="embedded"
type="orm:embedded"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="transient"
type="orm:transient"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 </xsd:complexType>



 <!--
**************************************************** -->



 <xsd:complexType name="embedded">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Embedded \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="attribute-override"
type="orm:attribute-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="association-override"

 type="orm:association-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="convert"
type="orm:convert"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="embedded-id">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface EmbeddedId \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="attribute-override"
type="orm:attribute-override"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="entity-listener">

 <xsd:annotation>

 <xsd:documentation>



 Defines an entity listener to be invoked at
lifecycle events

 for the entities that list this listener.



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="pre-persist"
type="orm:pre-persist" minOccurs="0"/>

 <xsd:element name="post-persist"
type="orm:post-persist"

 minOccurs="0"/>

 <xsd:element name="pre-remove"
type="orm:pre-remove" minOccurs="0"/>

 <xsd:element name="post-remove"
type="orm:post-remove" minOccurs="0"/>

 <xsd:element name="pre-update"
type="orm:pre-update" minOccurs="0"/>

 <xsd:element name="post-update"
type="orm:post-update" minOccurs="0"/>

 <xsd:element name="post-load"
type="orm:post-load" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="class"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="entity-listeners">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface EntityListeners \{

 Class[] value();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="entity-listener"
type="orm:entity-listener"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="entity-result">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface EntityResult \{

 Class entityClass();

 FieldResult[] fields() default \{};

 String discriminatorColumn() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="field-result"
type="orm:field-result"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="entity-class"
type="xsd:string" use="required"/>

 <xsd:attribute name="discriminator-column"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="enum-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum EnumType \{

 ORDINAL,

 STRING

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="ORDINAL"/>

 <xsd:enumeration value="STRING"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:simpleType name="enumerated">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Enumerated \{

 EnumType value() default ORDINAL;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="orm:enum-type"/>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:simpleType name="fetch-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum FetchType \{ LAZY, EAGER };



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="LAZY"/>

 <xsd:enumeration value="EAGER"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType name="field-result">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface FieldResult \{

 String name();

 String column();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="column"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="foreign-key">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface ForeignKey \{

 String name() default "";

 ConstraintMode value() default CONSTRAINT;

 String foreign-key-definition() default "";



 Note that the elements that embed the use of
the annotation

 default this use as
@ForeignKey(PROVIDER_DEFAULT).



 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="constraint-mode"
type="orm:constraint-mode"/>

 <xsd:attribute name="foreign-key-definition"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="generated-value">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface GeneratedValue \{

 GenerationType strategy() default AUTO;

 String generator() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="strategy"
type="orm:generation-type"/>

 <xsd:attribute name="generator"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="generation-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum GenerationType \{ TABLE,
SEQUENCE, IDENTITY, AUTO };



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="TABLE"/>

 <xsd:enumeration value="SEQUENCE"/>

 <xsd:enumeration value="IDENTITY"/>

 <xsd:enumeration value="AUTO"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType name="id">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Id \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="column" type="orm:column"

 minOccurs="0"/>

 <xsd:element name="generated-value"
type="orm:generated-value"

 minOccurs="0"/>

 <xsd:element name="temporal"
type="orm:temporal"

 minOccurs="0"/>

 <xsd:element name="table-generator"
type="orm:table-generator"

 minOccurs="0"/>

 <xsd:element name="sequence-generator"
type="orm:sequence-generator"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="id-class">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface IdClass \{

 Class value();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="class"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="index">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface Index \{

 String name() default "";

 String columnList();

 boolean unique() default false;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="column-list"
type="xsd:string" use="required"/>

 <xsd:attribute name="unique"
type="xsd:boolean"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="inheritance">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface Inheritance \{

 InheritanceType strategy() default
SINGLE_TABLE;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="strategy"
type="orm:inheritance-type"/>

 </xsd:complexType>



 <!--
**************************************************** -->



 <xsd:simpleType name="inheritance-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum InheritanceType

 \{ SINGLE_TABLE, JOINED, TABLE_PER_CLASS};



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="SINGLE_TABLE"/>

 <xsd:enumeration value="JOINED"/>

 <xsd:enumeration value="TABLE_PER_CLASS"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType name="join-column">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface JoinColumn \{

 String name() default "";

 String referencedColumnName() default "";

 boolean unique() default false;

 boolean nullable() default true;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 String table() default "";

 ForeignKey foreignKey() default
@ForeignKey();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="referenced-column-name"
type="xsd:string"/>

 <xsd:attribute name="unique"
type="xsd:boolean"/>

 <xsd:attribute name="nullable"
type="xsd:boolean"/>

 <xsd:attribute name="insertable"
type="xsd:boolean"/>

 <xsd:attribute name="updatable"
type="xsd:boolean"/>

 <xsd:attribute name="column-definition"
type="xsd:string"/>

 <xsd:attribute name="table"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="join-table">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface JoinTable \{

 String name() default "";

 String catalog() default "";

 String schema() default "";

 JoinColumn[] joinColumns() default \{};

 JoinColumn[] inverseJoinColumns() default
\{};

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:sequence>

 <xsd:element name="join-column"
type="orm:join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="foreign-key"
type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:sequence>

 <xsd:element name="inverse-join-column"
type="orm:join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="inverse-foreign-key"
type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:element name="unique-constraint"
type="orm:unique-constraint"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="index" type="orm:index"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="catalog"
type="xsd:string"/>

 <xsd:attribute name="schema"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="lob">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Lob \{}



 </xsd:documentation>

 </xsd:annotation>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="lock-mode-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum LockModeType \{ READ, WRITE,
OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ,
PESSIMISTIC_WRITE, PESSIMISTIC_FORCE_INCREMENT, NONE};



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="READ"/>

 <xsd:enumeration value="WRITE"/>

 <xsd:enumeration value="OPTIMISTIC"/>

 <xsd:enumeration
value="OPTIMISTIC_FORCE_INCREMENT"/>

 <xsd:enumeration value="PESSIMISTIC_READ"/>

 <xsd:enumeration value="PESSIMISTIC_WRITE"/>

 <xsd:enumeration
value="PESSIMISTIC_FORCE_INCREMENT"/>

 <xsd:enumeration value="NONE"/>



 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



<xsd:complexType name="many-to-many">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface ManyToMany \{

 Class targetEntity() default void.class;

 CascadeType[] cascade() default \{};

 FetchType fetch() default LAZY;

 String mappedBy() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:choice>

 <xsd:element name="order-by"
type="orm:order-by"

 minOccurs="0"/>

 <xsd:element name="order-column"
type="orm:order-column"

 minOccurs="0"/>

 </xsd:choice>

 <xsd:choice>

 <xsd:element name="map-key"
type="orm:map-key"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element name="map-key-class"
type="orm:map-key-class"

 minOccurs="0"/>

 <xsd:choice>

 <xsd:element name="map-key-temporal"

 type="orm:temporal"

 minOccurs="0"/>

 <xsd:element name="map-key-enumerated"

 type="orm:enumerated"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element
name="map-key-attribute-override"

 type="orm:attribute-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="map-key-convert"
type="orm:convert"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 </xsd:choice>

 <xsd:choice>

 <xsd:element name="map-key-column"
type="orm:map-key-column"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element name="map-key-join-column"

 type="orm:map-key-join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="map-key-foreign-key"

 type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 </xsd:choice>

 </xsd:sequence>

 </xsd:choice>

 <xsd:element name="join-table"
type="orm:join-table"

 minOccurs="0"/>

 <xsd:element name="cascade"
type="orm:cascade-type"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="target-entity"
type="xsd:string"/>

 <xsd:attribute name="fetch"
type="orm:fetch-type"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 <xsd:attribute name="mapped-by"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="many-to-one">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface ManyToOne \{

 Class targetEntity() default void.class;

 CascadeType[] cascade() default \{};

 FetchType fetch() default EAGER;

 boolean optional() default true;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:choice>

 <xsd:sequence>

 <xsd:element name="join-column"
type="orm:join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="foreign-key"
type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:element name="join-table"
type="orm:join-table"

 minOccurs="0"/>

 </xsd:choice>

 <xsd:element name="cascade"
type="orm:cascade-type"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="target-entity"
type="xsd:string"/>

 <xsd:attribute name="fetch"
type="orm:fetch-type"/>

 <xsd:attribute name="optional"
type="xsd:boolean"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 <xsd:attribute name="maps-id"
type="xsd:string"/>

 <xsd:attribute name="id"
type="xsd:boolean"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="map-key">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface MapKey \{

 String name() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="map-key-class">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface MapKeyClass \{

 Class value();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="class"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="map-key-column">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface MapKeyColumn \{

 String name() default "";

 boolean unique() default false;

 boolean nullable() default false;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 String table() default "";

 int length() default 255;

 int precision() default 0; // decimal
precision

 int scale() default 0; // decimal scale

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="unique"
type="xsd:boolean"/>

 <xsd:attribute name="nullable"
type="xsd:boolean"/>

 <xsd:attribute name="insertable"
type="xsd:boolean"/>

 <xsd:attribute name="updatable"
type="xsd:boolean"/>

 <xsd:attribute name="column-definition"
type="xsd:string"/>

 <xsd:attribute name="table"
type="xsd:string"/>

 <xsd:attribute name="length"
type="xsd:int"/>

 <xsd:attribute name="precision"
type="xsd:int"/>

 <xsd:attribute name="scale" type="xsd:int"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="map-key-join-column">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface MapKeyJoinColumn \{

 String name() default "";

 String referencedColumnName() default "";

 boolean unique() default false;

 boolean nullable() default false;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 String table() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="referenced-column-name"
type="xsd:string"/>

 <xsd:attribute name="unique"
type="xsd:boolean"/>

 <xsd:attribute name="nullable"
type="xsd:boolean"/>

 <xsd:attribute name="insertable"
type="xsd:boolean"/>

 <xsd:attribute name="updatable"
type="xsd:boolean"/>

 <xsd:attribute name="column-definition"
type="xsd:string"/>

 <xsd:attribute name="table"
type="xsd:string"/>

 </xsd:complexType>





<!--
**************************************************** -->



 <xsd:complexType name="mapped-superclass">

 <xsd:annotation>

 <xsd:documentation>



 Defines the settings and mappings for a
mapped superclass. Is

 allowed to be sparsely populated and used in
conjunction with

 the annotations. Alternatively, the
metadata-complete attribute

 can be used to indicate that no annotations
are to be processed

 If this is the case then the defaulting
rules will be recursively

 applied.



 @Target(TYPE) @Retention(RUNTIME)

 public @interface MappedSuperclass\{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="id-class"
type="orm:id-class" minOccurs="0"/>

 <xsd:element
name="exclude-default-listeners" type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element
name="exclude-superclass-listeners" type="orm:emptyType"

 minOccurs="0"/>

 <xsd:element name="entity-listeners"
type="orm:entity-listeners"

 minOccurs="0"/>

 <xsd:element name="pre-persist"
type="orm:pre-persist" minOccurs="0"/>

 <xsd:element name="post-persist"
type="orm:post-persist"

 minOccurs="0"/>

 <xsd:element name="pre-remove"
type="orm:pre-remove" minOccurs="0"/>

 <xsd:element name="post-remove"
type="orm:post-remove" minOccurs="0"/>

 <xsd:element name="pre-update"
type="orm:pre-update" minOccurs="0"/>

 <xsd:element name="post-update"
type="orm:post-update" minOccurs="0"/>

 <xsd:element name="post-load"
type="orm:post-load" minOccurs="0"/>

 <xsd:element name="attributes"
type="orm:attributes" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="class"
type="xsd:string" use="required"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 <xsd:attribute name="metadata-complete"
type="xsd:boolean"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType
name="named-attribute-node">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface NamedAttributeNode \{

 String value();

 String subgraph() default "";

 String keySubgraph() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="subgraph"
type="xsd:string"/>

 <xsd:attribute name="key-subgraph"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="named-entity-graph">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface NamedEntityGraph \{

 String name() default "";

 NamedAttributeNode[] attributeNodes()
default \{};

 boolean includeAllAttributes() default
false;

 NamedSubgraph[] subgraphs() default \{};

 NamedSubGraph[] subclassSubgraphs() default
\{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="named-attribute-node"

 type="orm:named-attribute-node"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="subgraph"

 type="orm:named-subgraph"

 minOccurs="0"

 maxOccurs="unbounded"/>

 <xsd:element name="subclass-subgraph"

 type="orm:named-subgraph"

 minOccurs="0"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="include-all-attributes"
type="xsd:boolean"/>

 </xsd:complexType>





<!--
**************************************************** -->



 <xsd:complexType name="named-native-query">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface NamedNativeQuery \{

 String name();

 String query();

 QueryHint[] hints() default \{};

 Class resultClass() default void.class;

 String resultSetMapping() default "";
//named SqlResultSetMapping

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="query"
type="xsd:string"/>

 <xsd:element name="hint"
type="orm:query-hint"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="result-class"
type="xsd:string"/>

 <xsd:attribute name="result-set-mapping"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="named-query">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface NamedQuery \{

 String name();

 String query();

 LockModeType lockMode() default NONE;

 QueryHint[] hints() default \{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="query"
type="xsd:string"/>

 <xsd:element name="lock-mode"
type="orm:lock-mode-type" minOccurs="0"/>

 <xsd:element name="hint"
type="orm:query-hint"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

</xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType
name="named-stored-procedure-query">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface NamedStoredProcedureQuery
\{

 String name();

 String procedureName();

 StoredProcedureParameter[] parameters()
default \{};

 Class[] resultClasses() default \{};

 String[] resultSetMappings() default\{};

 QueryHint[] hints() default \{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="parameter"

 type="orm:stored-procedure-parameter"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="result-class"
type="xsd:string"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="result-set-mapping"
type="xsd:string"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="hint"
type="orm:query-hint"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="procedure-name"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="named-subgraph">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface NamedSubgraph \{

 String name();

 Class type() default void.class;

 NamedAttributeNode[] attributeNodes();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="named-attribute-node"

 type="orm:named-attribute-node"

 minOccurs="0"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="class"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



<xsd:complexType name="one-to-many">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface OneToMany \{

 Class targetEntity() default void.class;

 CascadeType[] cascade() default \{};

 FetchType fetch() default LAZY;

 String mappedBy() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:choice>

 <xsd:element name="order-by"
type="orm:order-by"

 minOccurs="0"/>

 <xsd:element name="order-column"
type="orm:order-column"

 minOccurs="0"/>

 </xsd:choice>

 <xsd:choice>

 <xsd:element name="map-key"
type="orm:map-key"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element name="map-key-class"
type="orm:map-key-class"

 minOccurs="0"/>

 <xsd:choice>

 <xsd:element name="map-key-temporal"

 type="orm:temporal"

 minOccurs="0"/>

 <xsd:element name="map-key-enumerated"

 type="orm:enumerated"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element
name="map-key-attribute-override"

 type="orm:attribute-override"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="map-key-convert"
type="orm:convert"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 </xsd:choice>

 <xsd:choice>

 <xsd:element name="map-key-column"
type="orm:map-key-column"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element name="map-key-join-column"

 type="orm:map-key-join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="map-key-foreign-key"

 type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 </xsd:choice>

 </xsd:sequence>

 </xsd:choice>

 <xsd:choice>

 <xsd:element name="join-table"
type="orm:join-table"

 minOccurs="0"/>

 <xsd:sequence>

 <xsd:element name="join-column"
type="orm:join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="foreign-key"
type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 </xsd:choice>

 <xsd:element name="cascade"
type="orm:cascade-type"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="target-entity"
type="xsd:string"/>

 <xsd:attribute name="fetch"
type="orm:fetch-type"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 <xsd:attribute name="mapped-by"
type="xsd:string"/>

 <xsd:attribute name="orphan-removal"
type="xsd:boolean"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="one-to-one">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface OneToOne \{

 Class targetEntity() default void.class;

 CascadeType[] cascade() default \{};

 FetchType fetch() default EAGER;

 boolean optional() default true;

 String mappedBy() default "";

 boolean orphanRemoval() default false;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:choice>

 <xsd:sequence>

 <xsd:element name="primary-key-join-column"

 type="orm:primary-key-join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="primary-key-foreign-key"

 type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:sequence>

 <xsd:element name="join-column"
type="orm:join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="foreign-key"
type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:element name="join-table"
type="orm:join-table"

 minOccurs="0"/>

 </xsd:choice>

 <xsd:element name="cascade"
type="orm:cascade-type"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="target-entity"
type="xsd:string"/>

 <xsd:attribute name="fetch"
type="orm:fetch-type"/>

 <xsd:attribute name="optional"
type="xsd:boolean"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 <xsd:attribute name="mapped-by"
type="xsd:string"/>

 <xsd:attribute name="orphan-removal"
type="xsd:boolean"/>

 <xsd:attribute name="maps-id"
type="xsd:string"/>

 <xsd:attribute name="id"
type="xsd:boolean"/>

</xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="order-by">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface OrderBy \{

 String value() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:string"/>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType name="order-column">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface OrderColumn \{

 String name() default "";

 boolean nullable() default true;

 boolean insertable() default true;

 boolean updatable() default true;

 String columnDefinition() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="nullable"
type="xsd:boolean"/>

 <xsd:attribute name="insertable"
type="xsd:boolean"/>

 <xsd:attribute name="updatable"
type="xsd:boolean"/>

 <xsd:attribute name="column-definition"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="parameter-mode">

 <xsd:annotation>

 <xsd:documentation>



 public enum ParameterMode \{ IN, INOUT, OUT,
REF_CURSOR};



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="IN"/>

 <xsd:enumeration value="INOUT"/>

 <xsd:enumeration value="OUT"/>

 <xsd:enumeration value="REF_CURSOR"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType name="post-load">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD}) @Retention(RUNTIME)

 public @interface PostLoad \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="method-name"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="post-persist">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD}) @Retention(RUNTIME)

 public @interface PostPersist \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="method-name"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="post-remove">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD}) @Retention(RUNTIME)

 public @interface PostRemove \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="method-name"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="post-update">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD}) @Retention(RUNTIME)

 public @interface PostUpdate \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="method-name"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="pre-persist">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD}) @Retention(RUNTIME)

 public @interface PrePersist \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="method-name"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="pre-remove">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD}) @Retention(RUNTIME)

 public @interface PreRemove \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="method-name"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="pre-update">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD}) @Retention(RUNTIME)

 public @interface PreUpdate \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="method-name"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType
name="primary-key-join-column">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

 public @interface PrimaryKeyJoinColumn \{

 String name() default "";

 String referencedColumnName() default "";

 String columnDefinition() default "";

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="referenced-column-name"
type="xsd:string"/>

 <xsd:attribute name="column-definition"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="query-hint">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface QueryHint \{

 String name();

 String value();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="value"
type="xsd:string" use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="secondary-table">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface SecondaryTable \{

 String name();

 String catalog() default "";

 String schema() default "";

 PrimaryKeyJoinColumn[] pkJoinColumns()
default \{};

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:sequence>

 <xsd:element name="primary-key-join-column"

 type="orm:primary-key-join-column"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="primary-key-foreign-key"

 type="orm:foreign-key"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:element name="unique-constraint"
type="orm:unique-constraint"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="index" type="orm:index"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="catalog"
type="xsd:string"/>

 <xsd:attribute name="schema"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="sequence-generator">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

 public @interface SequenceGenerator \{

 String name();

 String sequenceName() default "";

 String catalog() default "";

 String schema() default "";

 int initialValue() default 1;

 int allocationSize() default 50;

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="sequence-name"
type="xsd:string"/>

 <xsd:attribute name="catalog"
type="xsd:string"/>

 <xsd:attribute name="schema"
type="xsd:string"/>

 <xsd:attribute name="initial-value"
type="xsd:int"/>

 <xsd:attribute name="allocation-size"
type="xsd:int"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType
name="sql-result-set-mapping">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface SqlResultSetMapping \{

 String name();

 EntityResult[] entities() default \{};

 ConstructorResult[] classes() default\{};

 ColumnResult[] columns() default \{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="entity-result"
type="orm:entity-result"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="constructor-result"
type="orm:constructor-result"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="column-result"
type="orm:column-result"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType
name="stored-procedure-parameter">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface StoredProcedureParameter
\{

 String name() default "";

 ParameterMode mode() default
ParameterMode.IN;

 Class type();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string"

 minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="class"
type="xsd:string" use="required"/>

 <xsd:attribute name="mode"
type="orm:parameter-mode"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="table">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE}) @Retention(RUNTIME)

 public @interface Table \{

 String name() default "";

 String catalog() default "";

 String schema() default "";

 UniqueConstraint[] uniqueConstraints()
default \{};

 Index[] indexes() default \{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="unique-constraint"
type="orm:unique-constraint"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="index" type="orm:index"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 <xsd:attribute name="catalog"
type="xsd:string"/>

 <xsd:attribute name="schema"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="table-generator">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{TYPE, METHOD, FIELD})
@Retention(RUNTIME)

 public @interface TableGenerator \{

 String name();

 String table() default "";

 String catalog() default "";

 String schema() default "";

 String pkColumnName() default "";

 String valueColumnName() default "";

 String pkColumnValue() default "";

 int initialValue() default 0;

 int allocationSize() default 50;

 UniqueConstraint[] uniqueConstraints()
default \{};

 Indexes[] indexes() default \{};

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="description"
type="xsd:string" minOccurs="0"/>

 <xsd:element name="unique-constraint"
type="orm:unique-constraint"

 minOccurs="0" maxOccurs="unbounded"/>

 <xsd:element name="index" type="orm:index"

 minOccurs="0" maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="table"
type="xsd:string"/>

 <xsd:attribute name="catalog"
type="xsd:string"/>

 <xsd:attribute name="schema"
type="xsd:string"/>

 <xsd:attribute name="pk-column-name"
type="xsd:string"/>

 <xsd:attribute name="value-column-name"
type="xsd:string"/>

 <xsd:attribute name="pk-column-value"
type="xsd:string"/>

 <xsd:attribute name="initial-value"
type="xsd:int"/>

 <xsd:attribute name="allocation-size"
type="xsd:int"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:simpleType name="temporal">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Temporal \{

 TemporalType value();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="orm:temporal-type"/>

 </xsd:simpleType>



 <!--
**************************************************** -->



 <xsd:simpleType name="temporal-type">

 <xsd:annotation>

 <xsd:documentation>



 public enum TemporalType \{

 DATE, // java.sql.Date

 TIME, // java.sql.Time

 TIMESTAMP // java.sql.Timestamp

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:restriction base="xsd:token">

 <xsd:enumeration value="DATE"/>

 <xsd:enumeration value="TIME"/>

 <xsd:enumeration value="TIMESTAMP"/>

 </xsd:restriction>

 </xsd:simpleType>



<!--
**************************************************** -->



 <xsd:complexType name="transient">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Transient \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="unique-constraint">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{}) @Retention(RUNTIME)

 public @interface UniqueConstraint \{

 String name() default "";

 String[] columnNames();

 }



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="column-name"
type="xsd:string"

 maxOccurs="unbounded"/>

 </xsd:sequence>

 <xsd:attribute name="name"
type="xsd:string"/>

 </xsd:complexType>



<!--
**************************************************** -->



 <xsd:complexType name="version">

 <xsd:annotation>

 <xsd:documentation>



 @Target(\{METHOD, FIELD})
@Retention(RUNTIME)

 public @interface Version \{}



 </xsd:documentation>

 </xsd:annotation>

 <xsd:sequence>

 <xsd:element name="column" type="orm:column"
minOccurs="0"/>

 <xsd:element name="temporal"
type="orm:temporal" minOccurs="0"/>

 </xsd:sequence>

 <xsd:attribute name="name" type="xsd:string"
use="required"/>

 <xsd:attribute name="access"
type="orm:access-type"/>

 </xsd:complexType>



</xsd:schema>



== Related Documents

[[a19493]]JSR-220:
Enterprise JavaBeans, v. 3.0. Java Persistence API.
_http://jcp.org/en/jsr/detail?id=220_ .

[[a19494]]SQL 2003, Part 2,
Foundation (SQL/Foundation). ISO/IEC 9075-2:2003.

http://jcp.org/en/jsr/detail?id=221[JDBC 4.2
Specification. http://jcp.org/en/jsr/detail?id=221.][[a19496]]

[[a19497]]Enterprise JavaBeans, v.
2.1. _http://jcp.org/en/jsr/detail?id=153_ .

[[a19498]]JSR-380: Bean Validation,
v. 2.0. _http://jcp.org/en/jsr/detail?id=380_ .

[[a19499]]JSR-366: Java Platform,
Enterprise Edition 8 (Java EE 8) Specification.
_http://jcp.org/en/jsr/detail?id=366[http://jcp.org/en/jsr/detail?id=366.]_

[[a19500]]JSR-365: Context and
Dependency Injection for Java EE, v 2.0.
_http://jcp.org/en/jsr/detail?id=365[http://jcp.org/en/jsr/detail?id=365.]_

[[a19501]]JSR-317: Java Persistence
2.0. _http://jcp.org/en/jsr/detail?id=317_ .

[discrete]
=== Revision History

This appendix lists the significant changes
that have been made during the development of the Java Persistence 2.2
specification.

[discrete]
=== Maintenance Release Draft

image:Per-4.png[image]

Created document from Java Persistence 2.1
Final Release specification.

The following annotations have been marked
_@Repeatable_ :

AssociationOverride

AttributeOverride

Convert

JoinColumn

MapKeyJoinColumn

NamedEntityGraph

NamedNativeQuery

NamedQuery

NamedStoredProcedureQuery

PersistenceContext

PersistenceUnit

PrimaryKeyJoinColumn

SecondaryTable

SqlResultSetMapping

SequenceGenerator

TableGenerator

Added SequenceGenerators and TableGenerators
annotations.

Added support for CDI injection into
AttributeConverter classes.

Added support for the mapping of the
following java.time types:

java.time.LocalDate

java.time.LocalTime

java.time.LocalDateTime

java.time.OffsetTime

java.time.OffsetDateTime



Added default Stream getResultStream() method
to Query interface.

Added default Stream<X> getResultStream()
method to TypedQuery interface.

Replaced reference to JAR file specification
in persistence provider bootstrapping section with more general
reference to Java SE service provider requirements.

Updated persistence.xml and orm.xml schemas
to 2.2 versions.

Updated Related Documents.

'''''

[.footnoteNumber]# 1.# [[a19537]]The term "persistence
provider runtime" refers to the runtime environment of the persistence
implementation. In Java EE environments, this may be the Java EE
container or a third-party persistence provider implementation
integrated with it.

[.footnoteNumber]# 2.# [[a19538]]Specifically, if get
_X_ is the name of the getter method and set _X_ is the name of the
setter method, where _X_ is a string, the name of the persistent
property is defined by the result of
java.beans.Introspector.decapitalize( _X_ ).

[.footnoteNumber]# 3.# [[a19539]]Portable applications
should not expect the order of a list to be maintained across
persistence contexts unless the _OrderColumn_ construct is used or
unless the _OrderBy_ construct is used and the modifications to the list
observe the specified ordering.

[.footnoteNumber]# 4.# [[a19540]]Lazy fetching is a
hint to the persistence provider and can be specified by means of the
_Basic_ , _OneToOne_ , _OneToMany_ , _ManyToOne_ , _ManyToMany_ , and
_ElementCollection_ annotations and their XML equivalents. See Chapter
link:Per.html#a13915[See Metadata for Object/Relational Mapping].

[.footnoteNumber]# 5.# [[a19541]]Note that an instance
of Calendar must be fully initialized for the type that it is mapped to.

[.footnoteNumber]# 6.# [[a19542]]The use of XML as an
alternative and the interaction between Java language annotations and
XML elements in defining default and explicit access types is described
in Chapter link:Per.html#a16944[See XML Object/Relational Mapping
Descriptor].

[.footnoteNumber]# 7.# [[a19543]]These annotations must
not be applied to the setter methods.

[.footnoteNumber]# 8.# [[a19544]]It is permitted (but
redundant) to place Access(FIELD) on a persistent field whose class has
field access type or Access(PROPERTY) on a persistent property whose
class has property access type. It is not permitted to specify a field
as Access(PROPERTY) or a property as Access(FIELD). Note that
Access(PROPERTY) must not be placed on the setter methods.

[.footnoteNumber]# 9.# [[a19545]]In general, however,
approximate numeric types (e.g., floating point types) should never be
used in primary keys.

[.footnoteNumber]# 10.# [[a19546]]This includes not
changing the value of a mutable type that is primary key or an attribute
of a composite primary key.

[.footnoteNumber]# 11.# [[a19547]]The implementation
may, but is not required to, throw an exception. Portable applications
must not rely on any such specific behavior.

[.footnoteNumber]# 12.# [[a19548]]If the application
does not set the primary key attribute corresponding to the
relationship, the value of that attribute may not be available until
after the entity has been flushed to the database.

[.footnoteNumber]# 13.# [[a19549]]Note that it is
correct to observe the first rule as an alternative in this case.

[.footnoteNumber]# 14.# [[a19550]]Note that the
parent’s primary key might be represented as either an embedded id or as
an id class.

[.footnoteNumber]# 15.# [[a19551]]Note that the use of
PrimaryKeyJoinColumn instead of MapsId would result in the same mapping
in this example. Use of MapsId is preferred for the mapping of derived
identities.

[.footnoteNumber]# 16.# [[a19552]]Direct or indirect
circular containment dependencies among embeddable classes are not
permitted.

[.footnoteNumber]# 17.# [[a19553]]An entity cannot have
a unidirectional relationship to the embeddable class of another entity
(or itself).

[.footnoteNumber]# 18.# [[a19554]]Note that when an
embeddable instance is used as a map key, these attributes represent its
identity. Changes to embeddable instances used as map keys have
undefined behaviour and should be avoided.

[.footnoteNumber]# 19.# [[a19555]]For associations of
type _java.util.Map_ , _target type_ refers to the type that is the Map
_value_ .

[.footnoteNumber]# 20.# [[a19556]]If the parent is
detached or new or was previously removed before the orphan was
associated with it, the remove operation is not applied to the entity
being orphaned.

[.footnoteNumber]# 21.# [[a19557]]When the relationship
is modeled as a _java.util.Map_ , “Entity B references a collection of
Entity A” means that Entity B references a map collection in which the
type of the Map _value_ is Entity A. The map key may be a basic type,
embeddable class, or an entity.

[.footnoteNumber]# 22.# [[a19558]]The superclass must
not be an embeddable class or id class.

[.footnoteNumber]# 23.# [[a19559]]If a
transaction-scoped persistence context is used, it is not required to be
retained across transactions.

[.footnoteNumber]# 24.# [[a19560]]This includes
instances of a non-entity class that extends an entity class.

[.footnoteNumber]# 25.# [[a19561]]If
<delimited-identifiers> is specified and individual annotations or XML
elements or attributes use escaped double quotes, the double-quotes
appear in the name of the database identifier.

[.footnoteNumber]# 26.# [[a19562]]The semantics of this
method may be extended in a future release of this specification to
support other result types. Applications that specify other result types
(e.g., Tuple.class) will not be portable.

[.footnoteNumber]# 27.# [[a19563]]The semantics of this
method may be extended in a future release of this specification to
support other result types. Applications that specify other result types
(e.g., Tuple.class) will not be portable.

[.footnoteNumber]# 28.# [[a19564]]This includes, for
example. modifications to persistent attributes of type char[] and
byte[].

[.footnoteNumber]# 29.# [[a19565]]This might be an
issue if unique constraints (such as those described for the default
mappings in sections link:Per.html#a640[See Unidirectional
OneToOne Relationships] and link:Per.html#a764[See
Unidirectional OneToMany Relationships]) were not applied in the
definition of the object/relational mapping.

[.footnoteNumber]# 30.# [[a19566]]Note that when a new
transaction is begun, the managed objects in an extended persistence
context are _not_ reloaded from the database.

[.footnoteNumber]# 31.# [[a19567]]These are instances
that were persistent in the database at the start of the transaction.

[.footnoteNumber]# 32.# [[a19568]] It is unspecified as
to whether instances that were not persistent in the database behave as
new instances or detached instances after rollback. This may be
implementation-dependent.

[.footnoteNumber]# 33.# [[a19569]]Applications may
require that database isolation levels higher than read-committed be in
effect. The configuration of the setting database isolation levels,
however, is outside the scope of this specification.

[.footnoteNumber]# 34.# [[a19570]]Bulk update
statements, however, are permitted to set the value of version
attributes. See section link:Per.html#a5636[See Bulk Update and
Delete Operations].

[.footnoteNumber]# 35.# [[a19571]]This includes owned
relationships maintained in join tables.

[.footnoteNumber]# 36.# [[a19572]]Such additional
mechanisms may be standardized by a future release of this
specification.

[.footnoteNumber]# 37.# [[a19573]]Implementations are
permitted to use database mechanisms other than locking to achieve the
semantic effects described here, for example, multiversion concurrency
control mechanisms.

[.footnoteNumber]# 38.# [[a19574]]This is achieved by
using a lock with LockModeType.PESSIMISTIC_WRITE or
LockModeType.PESSIMISTIC_FORCE_INCREMENT as described in section
link:Per.html#a2084[See Lock Modes].

[.footnoteNumber]# 39.# [[a19575]]For example, a
persistence provider may use an underlying database platform's SELECT
FOR UPDATE statements to implement pessimistic locking if that construct
provides appropriate semantics, or the provider may use an isolation
level of repeatable read.

[.footnoteNumber]# 40.# [[a19576]] The lock mode type
NONE may be specified as a value of lock mode arguments and also
provides a default value for annotations.

[.footnoteNumber]# 41.# [[a19577]]Databases concurrency
control mechanisms that provide comparable semantics, e.g., multiversion
concurrency control, can be used by the provider.

[.footnoteNumber]# 42.# [[a19578]]The persistence
provider is not required to flush the entity to the database
immediately.

[.footnoteNumber]# 43.# [[a19579]]CDI is enabled by
default in Java EE. See the Java EE specification
link:Per.html#a19499[See JSR-366: Java Platform, Enterprise
Edition 8 (Java EE 8) Specification.
http://jcp.org/en/jsr/detail?id=366.].

[.footnoteNumber]# 44.# [[a19580]]The persistence
provider may support CDI injection into entity listeners in other
environments in which the BeanManager is available.

[.footnoteNumber]# 45.# [[a19581]]For example, if a
transaction commit occurs as a result of the normal termination of a
session bean business method with transaction attribute _RequiresNew_ ,
the _PostPersist_ and _PostRemove_ callbacks are executed in the naming
context, the transaction context, and the security context of that
component.

[.footnoteNumber]# 46.# Note that this
caution applies also to the actions of objects that might be injected
into an entity listener.

[.footnoteNumber]# 47.# [[a19583]]The semantics of such
operations may be standardized in a future release of this
specification.

[.footnoteNumber]# 48.# [[a19584]]Excluded listeners
may be reintroduced on an entity class by listing them explicitly in the
_EntityListeners_ annotation or XML _entity-listeners_ element.

[.footnoteNumber]# 49.# [[a19585]]If a method overrides
an inherited callback method but specifies a different lifecycle event
or is not a lifecycle callback method, the overridden method will not be
invoked.

[.footnoteNumber]# 50.# [[a19586]]We plan to provide a
facility for more complex attribute conversions in a future release of
this specification.

[.footnoteNumber]# 51.# [[a19587]]CDI is enabled by
default in Java EE. See the Java EE specification
link:Per.html#a19499[See JSR-366: Java Platform, Enterprise
Edition 8 (Java EE 8) Specification.
http://jcp.org/en/jsr/detail?id=366.].

[.footnoteNumber]# 52.# [[a19588]]The persistence
provider may support CDI injection into attribute converters in other
environments in which the BeanManager is available.

[.footnoteNumber]# 53.# [[a19589]]A lock mode is
specified for a query by means of the _setLockMode_ method or by
specifying the lock mode in the _NamedQuery_ annotation.

[.footnoteNumber]# 54.# [[a19590]]Note that the
setLockMode method may be called more than once (with different values)
on a Query or TypedQuery object.

[.footnoteNumber]# 55.# [[a19591]]Note that locking
will not occur for data passed to aggregate functions. Further, queries
involving aggregates with pessimistic locking may not be supported on
all database platforms.

[.footnoteNumber]# 56.# [[a19592]]Support for joins is
currently limited to single-valued relationships that are mapped
directly—i.e., not via join tables.

[.footnoteNumber]# 57.# [[a19593]]Note that REF_CURSOR
parameters are used by some databases to return result sets from stored
procedures.

[.footnoteNumber]# 58.# [[a19594]]This chapter uses the
convention that reserved identifiers appear in upper case in the
examples and BNF for the language.

[.footnoteNumber]# 59.# [[a19595]]BIT_LENGTH,
CHAR_LENGTH, CHARACTER_LENGTH, POSITION, and UNKNOWN are not currently
used: they are reserved for future use.

[.footnoteNumber]# 60.# [[a19596]]A range variable must
not designate an embeddable class abstract schema type.

[.footnoteNumber]# 61.# [[a19597]]Note that use of
VALUE is optional, as an identification variable referring to an
association of type _java.util.Map_ is of the abstract schema type of
the map value. (See section link:Per.html#a4765[See
Identification Variables].)

[.footnoteNumber]# 62.# [[a19598]]The implementation is
not expected to perform such query operations involving such fields in
memory rather than in the database.

[.footnoteNumber]# 63.# [[a19599]]Note that queries
that contain subqueries on both sides of a comparison operation will not
be portable across all databases.

[.footnoteNumber]# 64.# [[a19600]]Refer to
link:Per.html#a19494[See SQL 2003, Part 2, Foundation
(SQL/Foundation). ISO/IEC 9075-2:2003.] for a more precise
characterization of these rules.

[.footnoteNumber]# 65.# [[a19601]]The use of the
reserved word OF is optional in this expression.

[.footnoteNumber]# 66.# [[a19602]]Subqueries are
restricted to the WHERE and HAVING clauses in this release. Support for
subqueries in the FROM clause will be considered in a later release of
this specification.

[.footnoteNumber]# 67.# [[a19603]]Note that expressions
involving aggregate operators must not be used in the WHERE clause.

[.footnoteNumber]# 68.# [[a19604]]Note that not all
databases support the use of a trim character other than the space
character; use of this argument may result in queries that are not
portable.

[.footnoteNumber]# 69.# [[a19605]]Note that not all
databases support the use of the third argument to LOCATE; use of this
argument may result in queries that are not portable.

[.footnoteNumber]# 70.# [[a19606]]Note that not all
databases support the use of SQL case expressions. The use of case
expressions may result in queries that are not portable to such
databases.

[.footnoteNumber]# 71.# [[a19607]]Note that the keyword
OBJECT is not required. It is preferred that it be omitted for new
queries.

[.footnoteNumber]# 72.# [[a19608]]This can be used, for
example, to refer to a select expression in the ORDER BY clause.

[.footnoteNumber]# 73.# [[a19609]]It is legal to
specify DISTINCT with MAX or MIN, but it does not affect the result.

[.footnoteNumber]# 74.# [[a19610]]In the case of a
general or simple case expression, these are the scalar expressions of
the THEN and ELSE clauses.

[.footnoteNumber]# 75.# [[a19611]]We expect that the
option of different packages will be provided in a future release of
this specification.

[.footnoteNumber]# 76.# [[a19612]]If the class was
generated, the _javax.annotation.Generated_ annotation should be used to
annotate the class. The use of any annotations other than
_StaticMetamodel_ and _Generated_ on static metamodel classes is
undefined.

[.footnoteNumber]# 77.# [[a19613]]The attributes of
these metamodel objects play a role analogous to that which would be
played by member literals.

[.footnoteNumber]# 78.# Metamodel objects are
used to specify typesafe nagivation through joins and through path
expressions. These metamodel objects capture both the source and target
types of the attribute through which navigation occurs, and are thus the
mechanism by which typesafe navigation is achieved.

[.footnoteNumber]# 79.# [[a19615]]Attribute names serve
this role for string-based queries. See section
link:Per.html#a11349[See Use of the Criteria API with Strings to
Reference Attributes].

[.footnoteNumber]# 80.# [[a19616]]Attribute names serve
this role for string-based queries. See section
link:Per.html#a11349[See Use of the Criteria API with Strings to
Reference Attributes].

[.footnoteNumber]# 81.# [[a19617]]Note that the use of
JTA is not required to be supported in application client containers.

[.footnoteNumber]# 82.# [[a19618]]It may also be used
internally by the Java EE container. See section
link:Per.html#a12100[See Runtime Contracts between the Container
and Persistence Provider].

[.footnoteNumber]# 83.# [[a19619]]This may be the case
when using multiple databases, since in a typical configuration a single
entity manager only communicates with a single database. There is only
one entity manager factory per persistence unit, however.

[.footnoteNumber]# 84.# [[a19620]]Specifically, when
one of the methods of the EntityManager interface is invoked.

[.footnoteNumber]# 85.# [[a19621]]Note that this
applies to a transaction-scoped persistence context of type
SynchronizationType.UNSYNCHRONIZED that has not been joined to the
transaction as well.

[.footnoteNumber]# 86.# [[a19622]]Entity manager
instances obtained from different entity manager factories never share
the same persistence context.

[.footnoteNumber]# 87.# [[a19623]]It is not required
that these contracts be used when a third-party persistence provider is
not used: the container might use these same APIs or its might use its
own internal APIs.

[.footnoteNumber]# 88.# [[a19624]]The container may
choose to pool EntityManagers: it instead of creating and closing in
each case, it may acquire one from its pool and call _clear()_ on it.

[.footnoteNumber]# 89.# [[a19625]]The root of the
persistence unit is the _WEB-INF/classes_ directory; the
_persistence.xml_ file is therefore contained in the
_WEB-INF/classes/META-INF_ directory.

[.footnoteNumber]# 90.# [[a19626]]Note that an
individual class may be used in more than one persistence unit.

[.footnoteNumber]# 91.# [[a19627]]This semantics
applies to persistence.xml files written to the persistence_2_0.xsd or
later schema. Due to ambiguity in the Java Persistence 1.0
specification, provider-specific interpretation of the relative
references used by this element may apply to earlier versions.

[.footnoteNumber]# 92.# [[a19628]]Persistence providers
are encouraged to support this syntax for use in Java SE environments.

[.footnoteNumber]# 93.# [[a19629]]Note that in this
example a META-INF/orm.xml file is assumed not to exist.

[.footnoteNumber]# 94.# [[a19630]]Use of these Java SE
bootstrapping APIs may be supported in Java EE containers; however,
support for such use is not required.

[.footnoteNumber]# 95.# [[a19631]]In dynamic
environments (e.g., OSGi-based environments, containers based on dynamic
kernels, etc.), the list of persistence providers may change.

[.footnoteNumber]# 96.# [[a19632]]If a custom
PersistenceProviderResolver is needed in a JavaSE environment, it must
be set before Persistence.createEntityManagerFactory is called. Note,
however, that the setPersistenceProviderResolver method is not intended
for general use, but rather is aimed at containers maintaining a dynamic
environment.

[.footnoteNumber]# 97.# [[a19633]]The determining of
the persistence providers that are available is discussed in section
link:Per.html#a12837[See Determining the Available Persistence
Providers].

[.footnoteNumber]# 98.# [[a19634]]A dependency on
ultiple persistence contexts may be needed, for example, when multiple
persistence units are used.

[.footnoteNumber]# 99.# [[a19635]]Multiple persistence
units may be needed, for example, when mapping to multiple databases.

[.footnoteNumber]# 100.# [[a19636]]The use of map keys
that contain embeddables that reference entities is not permitted.

[.footnoteNumber]# 101.# [[a19637]]Note that _either_
the _joinColumns_ element _or_ the _joinTable_ element of the
_AssociationOverride_ annotation is specified for overriding a given
relationship (but never both).

[.footnoteNumber]# 102.# [[a19638]]Mapping of
java.time.LocalDate, java.time.LocalTime, java.time.LocalDateTime,
java.time.OffsetTime, and java.time.OffsetDateTime types to columns
other than those supported by the mappings defined by Appendix B of the
JDBC 4.2 specification is not required to be supported by the
persistence provider beyond the support required for other serializable
types. See link:Per.html#a19496[See JDBC 4.2 Specification.
http://jcp.org/en/jsr/detail?id=221.].

[.footnoteNumber]# 103.# [[a19639]]The combination of
inheritance strategies within a single entity inheritance hierarchy is
not defined by this specification.

[.footnoteNumber]# 104.# [[a19640]]If it is not
specified, the rules of section link:Per.html#a511[See Mapping
Defaults for Non-Relationship Fields or Properties] apply.

[.footnoteNumber]# 105.# [[a19641]]If the embeddable
class is used as a primary key, the _EmbeddedId_ rather than the
_Embedded_ annotation is used.

[.footnoteNumber]# 106.# [[a19642]]Use of the
_Embedded_ annotation is not required. See section
link:Per.html#a511[See Mapping Defaults for Non-Relationship
Fields or Properties].

[.footnoteNumber]# 107.# [[a19643]]Note that the _Id_
annotation is not used in the embeddable class.

[.footnoteNumber]# 108.# [[a19644]]If the element
collection is a Map, this applies to the map value.

[.footnoteNumber]# 109.# [[a19645]]Mapping of enum
values that contain state is not supported.

[.footnoteNumber]# 110.# [[a19646]]Portable
applications should not use the _GeneratedValue_ annotation on other
persistent fields or properties.

[.footnoteNumber]# 111.# [[a19647]]Note that SEQUENCE
and IDENTITY are not portable across all databases.

[.footnoteNumber]# 112.# [[a19648]]Primary keys using
types other than these will not be portable. In general, floating point
types should never be used in primary keys.

[.footnoteNumber]# 113.# [[a19649]]If the element
collection is a Map, this applies to the map value.

[.footnoteNumber]# 114.# [[a19650]]The _ManyToMany_
annotation must not be used within an embeddable class used in an
element collection.

[.footnoteNumber]# 115.# [[a19651]]The _OneToMany_
annotation must not be used within an embeddable class used in an
element collection.

[.footnoteNumber]# 116.# [[a19652]]If the parent is
detached or new or was previously removed before the orphan was
associated with it, the remove operation is not applied to the entity
being orphaned.

[.footnoteNumber]# 117.# [[a19653]]If the parent is
detached or new or was previously removed before the orphan was
associated with it, the remove operation is not applied to the entity
being orphaned.

[.footnoteNumber]# 118.# [[a19654]]If the primary key
is a composite primary key, the precedence of ordering among the
attributes within the primary key is not futher defined. To assign such
a precedence within these attributes, each of the individual attributes
must be specified as an orderby_item.

[.footnoteNumber]# 119.# [[a19655]]In all other cases
when OrderBy is applied to an element collection, the
_property_or_field_name_ must be specified.

[.footnoteNumber]# 120.# [[a19656]]The _OrderBy_
annotation should be used for ordering that is visible as persistent
state and maintained by the application.

[.footnoteNumber]# 121.# [[a19657]]It is not expected
that a database foreign key be defined for the OneToOne mapping, as the
OneToOne relationship may be defined as “optional=true”.

[.footnoteNumber]# 122.# [[a19658]]The derived id
mechanisms described in section link:Per.html#a155[See
Specification of Derived Identities] are now to be preferred over
PrimaryKeyJoinColumn for the OneToOne mapping case.

[.footnoteNumber]# 123.# [[a19659]]Note that the
derived identity mechanisms decribed in section
link:Per.html#a155[See Specification of Derived Identities] is
now preferred to the use of PrimaryKeyJoinColumn for this case.

[.footnoteNumber]# 124.# [[a19660]]When a joined
inheritance strategy is used, the Table annotation is used to specify a
primary table for the subclass-specific state if the default is not
used.

[.footnoteNumber]# 125.# [[a19661]]If the element
collection is a Map, this applies to the map value.

[.footnoteNumber]# 126.# [[a19662]]See, however,
section link:Per.html#a5636[See Bulk Update and Delete
Operations].
